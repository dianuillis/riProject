<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:59:03[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Out-of-order execution</title>
<id>1002307</id>
<revision>
<id>237469454</id>
<timestamp>2008-09-10T10:05:16Z</timestamp>
<contributor>
<username>Ykhwong</username>
<id>5662528</id>
</contributor>
</revision>
<categories>
<category>Instruction processing</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../408/50408.xml">
computer engineering</link>, <b>out-of-order execution</b>, <b>OoOE</b>, is a paradigm used in most high-performance <link xlink:type="simple" xlink:href="../553/19553.xml">
microprocessor</link>s to make use of <link xlink:type="simple" xlink:href="../535/575535.xml">
cycles</link> that would otherwise be wasted by a certain type of costly delay. Most modern CPU designs include support for out of order execution.
<sec>
<st>
History</st>

<p>

Out-of-order execution is a restricted form of <link xlink:type="simple" xlink:href="../032/1325032.xml">
data flow</link> computation, which was a major research area in <link xlink:type="simple" xlink:href="../509/6509.xml">
computer architecture</link> in the 1970s and early 1980s. Important academic research in this subject was led by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../129/4388129.xml">
Yale Patt</link></associate>
</educator>
</professional>
</adult>
</academician>
</causal_agent>
</colleague>
</engineer>
</person>
</peer>
</physical_entity>
 and his <link>
HPSm</link> simulator. A paper by <link>
James E. Smith</link> and A.R. Pleszkun, published in 1985 completed the scheme by describing how the precise behavior of exceptions could be maintained in out-of-order machines. </p>
<p>

The first machine to use out-of-order execution was probably the <link xlink:type="simple" xlink:href="../661/58661.xml">
CDC 6600</link> (1964), which used a <link xlink:type="simple" xlink:href="../102/4543102.xml">
scoreboard</link> to resolve conflicts. About three years later, the IBM 360/91 (1966) introduced <link xlink:type="simple" xlink:href="../562/390562.xml">
Tomasulo's algorithm</link>. In 1990, IBM introduced the first out-of-order microprocessor, the <link xlink:type="simple" xlink:href="../734/1199734.xml">
POWER1</link>, although out-of-order execution was limited to floating point instructions only.</p>
<p>

Throughout the 1990s out-of-order execution became more common, and was featured in the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
/<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/20319.xml">
Motorola</link></company>
 <link xlink:type="simple" xlink:href="../281/24281.xml">
PowerPC</link> 601 (1992/1993), <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../222/58222.xml">
Fujitsu</link></company>
/<link xlink:type="simple" xlink:href="../551/267551.xml">
HAL</link> SPARC64 (1995), <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link> <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../232/165232.xml">
Pentium Pro</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 (1995), <link xlink:type="simple" xlink:href="../170/20170.xml">
MIPS R10000</link> (1996), the <link xlink:type="simple" xlink:href="../973/13973.xml">
HP</link> <link xlink:type="simple" xlink:href="../970/24970.xml">
PA-8000</link> (1996), <link xlink:type="simple" xlink:href="../085/886085.xml">
K5</link> (1996) and the <link xlink:type="simple" xlink:href="../971/8971.xml">
DEC Alpha</link> 21264 (1998). Notable exceptions to this trend include <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../980/26980.xml">
Sun's</link></institution>
</company>
 <link xlink:type="simple" xlink:href="../954/36954.xml">
UltraSPARC</link>, <link xlink:type="simple" xlink:href="../973/13973.xml">
HP</link>/<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel's</link> <link xlink:type="simple" xlink:href="../454/15454.xml">
IA-64</link>, <company wordnetid="108058098" confidence="0.8">
<electronics_company wordnetid="108003035" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../689/168689.xml">
Transmeta's</link></institution>
</electronics_company>
</company>
 <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../635/172635.xml">
Crusoe</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 and most recently, <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM's</link></company>
 <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../354/2159354.xml">
POWER6</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 and <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel's</link> <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link>
Atom</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
.</p>
<p>

The logical complexity of the out-of-order schemes was the reason that this technique did not reach mainstream machines until the mid-1990s. Many low-end processors meant for cost-sensitive markets still do not use this paradigm due to large silicon area that is required to build this class of machine.</p>

</sec>
<sec>
<st>
Basic concept</st>

<ss1>
<st>
In-order processors</st>
<p>

In earlier processors, the processing of instructions is normally done in these steps:
<list>
<entry level="1" type="number">

 <link xlink:type="simple" xlink:href="../801/3149801.xml">
Instruction</link> <link xlink:type="simple" xlink:href="../190/309190.xml">
fetch</link>.</entry>
<entry level="1" type="number">

 If input <link xlink:type="simple" xlink:href="../656/22656.xml">
operand</link>s are available (in registers for instance), the instruction is dispatched to the appropriate <link xlink:type="simple" xlink:href="../828/9828.xml">
functional unit</link>.  If one or more operands is unavailable during the current clock cycle (generally because they are being fetched from <link xlink:type="simple" xlink:href="../847/25847.xml">
memory</link>), however, the processor stalls until they are available.</entry>
<entry level="1" type="number">

 The instruction is executed by the appropriate functional unit.</entry>
<entry level="1" type="number">

 The functional unit writes the results back to the <link xlink:type="simple" xlink:href="../216/1680216.xml">
register file</link>.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Out-of-order processors</st>
<p>

This new paradigm breaks up the processing of instructions into these steps:
<list>
<entry level="1" type="number">

 Instruction fetch.</entry>
<entry level="1" type="number">

 Instruction dispatch to an instruction queue (also called instruction buffer or <link xlink:type="simple" xlink:href="../249/4543249.xml">
reservation stations</link>).</entry>
<entry level="1" type="number">

 The instruction waits in the queue until its input operands are available. The instruction is then allowed to leave the queue before earlier, older instructions.</entry>
<entry level="1" type="number">

 The instruction is issued to the appropriate functional unit and executed by that unit.</entry>
<entry level="1" type="number">

 The results are queued.</entry>
<entry level="1" type="number">

 Only after all older instructions have their results written back to the register file, then this result is written back to the register file. This is called the graduation or retire stage.</entry>
</list>
</p>
<p>

The key concept of OoO processing is to allow the processor to avoid a class of stalls that occur when the data needed to perform an operation are unavailable. In the outline above, the OoO processor avoids the stall that occurs in step (2) of the in-order processor when the instruction is not completely ready to be processed due to missing data.</p>
<p>

OoO processors fill these "slots" in time with other instructions that <it>are</it> ready, then re-order the results at the end to make it appear that the instructions were processed as normal. The way the instructions are ordered in the original computer code is known as <it>program order</it>, in the processor they are handled in <it>data order</it>, the order in which the data, operands, become available in the processor's registers. Fairly complex circuitry is needed to convert from one ordering to the other and maintain a logical ordering of the output; the processor itself runs the instructions in seemingly random order.</p>
<p>

The benefit of OoO processing grows as the <link xlink:type="simple" xlink:href="../314/220314.xml">
instruction pipeline</link> deepens and the speed difference between <link>
main memory</link> (or <link xlink:type="simple" xlink:href="../181/849181.xml">
cache memory</link>) and the processor widens. On modern machines, the processor runs many times faster than the memory, so during the time an in-order processor spends waiting for data to arrive, it could have processed a large number of instructions.</p>

</ss1>
</sec>
<sec>
<st>
Dispatch and issue decoupling allows out-of-order issue</st>
<p>

One of the differences created by the new paradigm is the creation of queues which allows the dispatch step to be decoupled from the issue step and the graduation stage to be decoupled from the execute stage. An early name for the paradigm was <it><link xlink:type="simple" xlink:href="../592/2078592.xml">
decoupled architecture</link></it>. In the earlier <it>in-order</it> processors, these stages operated in a fairly <link xlink:type="simple" xlink:href="../230/1676230.xml">
lock-step</link>, pipelined fashion. </p>
<p>

To avoid false operand dependencies, which would decrease the frequency when instructions could be issued out of order, a technique called <link xlink:type="simple" xlink:href="../852/435852.xml">
register renaming</link> is used. In this scheme, there are more physical registers than defined by the architecture. The physical registers are tagged so that multiple versions of the same architectural register can exist at the same time.</p>

</sec>
<sec>
<st>
Execute and writeback decoupling allows program restart</st>
<p>

The queue for results is necessary to resolve issues such as branch mispredictions and exceptions/traps. The results queue allows programs to be restarted after an exception, which requires the instructions to be completed in program order. The queue allows results to be discarded due to mispredictions on older branch instructions and exceptions taken on older instructions.</p>
<p>

The ability to issue instructions past branches which have yet to resolve is known as <link xlink:type="simple" xlink:href="../504/319504.xml">
speculative execution</link>.</p>

</sec>
<sec>
<st>
Micro-architectural choices</st>
<p>

<list>
<entry level="1" type="bullet">

 Are the instructions dispatched to a centralized queue or to multiple distributed queues? </entry>
</list>
</p>
<p>

<indent level="1">

<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 <link xlink:type="simple" xlink:href="../281/24281.xml">
PowerPC</link> processors use queues which are distributed among the different functional units while other Out-of-Order processors use a centralized queue. IBM uses the term <it>reservation stations</it> for their distributed queues.
</indent>

<list>
<entry level="1" type="bullet">

 Is there an actual results queue or are the results written directly into a register file? For the latter, the queueing function is handled by register maps which hold the register renaming information for each instruction in flight. </entry>
</list>
</p>
<p>

<indent level="1">

Early Intel out-of-order processors use a results queue called a <link xlink:type="simple" xlink:href="../468/390468.xml">
<it>re-order buffer''</it></link>, while most later Out-of-Order processors use register maps.
</indent>

</p>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../102/4543102.xml">
Scoreboarding</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../562/390562.xml">
Tomasulo algorithm</link></entry>
<entry level="1" type="bullet">

 <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../970/3206970.xml">
Replay system</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/327010.327125">
"Implementation of precise interrupts in pipelined processors"</weblink>, a paper by Smith and Pleszkun (1985).</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../218/5218.xml">
CPU technologies</link></header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../772/47772.xml">
Architecture</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../772/47772.xml">
ISA</link> : <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../622/7622.xml">
CISC</link></group>
</collection>
</class>
 &nbsp;·  <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../622/7622.xml#xpointer(//*[./st=%22CISC_and_RISC_processors%22])">
CISC-RISC (x86)</link></group>
</collection>
</class>
&nbsp;·  <link xlink:type="simple" xlink:href="../151/685151.xml">
EPIC</link>&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../713/151713.xml">
OISC</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
&nbsp;· <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../201/26201.xml">
RISC</link></group>
</collection>
</class>
&nbsp;·  <link xlink:type="simple" xlink:href="../706/51706.xml">
VLIW</link>&nbsp;·  <link xlink:type="simple" xlink:href="../509/1940509.xml">
ZISC</link>&nbsp;·  <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../091/478091.xml">
Von Neumann architecture</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
&nbsp;·  <link xlink:type="simple" xlink:href="../733/80733.xml">
32 bit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../285/148285.xml">
64 bit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../724/1800724.xml">
128 bit</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../162/145162.xml">
Parallelism</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Pipeline</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../314/220314.xml">
Instruction pipelining</link>&nbsp;·  <link xlink:type="simple" xlink:href="../307/1002307.xml">
In-Order &amp; Out-of-Order execution</link>&nbsp;·  <register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../852/435852.xml">
Register renaming</link></written_record>
</evidence>
</indication>
</record>
</register>
&nbsp;·  <link xlink:type="simple" xlink:href="../504/319504.xml">
Speculative execution</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Level</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../148/14229148.xml">
Bit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../960/245960.xml">
Instruction</link>&nbsp;·  <link xlink:type="simple" xlink:href="../702/51702.xml">
Superscalar</link>&nbsp;·  <link xlink:type="simple" xlink:href="../420/9467420.xml">
Data</link>&nbsp;·  <link xlink:type="simple" xlink:href="../070/9468070.xml">
Task</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Threads</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../679/10520679.xml">
Multithreading</link>&nbsp;·  <link xlink:type="simple" xlink:href="../021/315021.xml">
Simultaneous multithreading</link>&nbsp;·  <link xlink:type="simple" xlink:href="../443/151443.xml">
Hyperthreading</link>&nbsp;·  <link xlink:type="simple" xlink:href="../877/313877.xml">
Superthreading</link></col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Types</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../505/154505.xml">
Digital signal processor</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../017/21017.xml">
Microcontroller</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../205/58205.xml">
Vector processor</link>&nbsp;·  PLDs: (<arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../969/10969.xml">
FPGA</link></array>
</group>
</arrangement>
&nbsp;·  <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../845/147845.xml">
ASIC</link></array>
</group>
</arrangement>
&nbsp;·  <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../209/12751209.xml">
ASIP</link></array>
</group>
</arrangement>
)</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Components</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<electrical_device wordnetid="103269401" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<circuit wordnetid="103033362" confidence="0.8">
<link xlink:type="simple" xlink:href="../504/199504.xml">
Arithmetic logic unit (ALU)</link></circuit>
</device>
</electrical_device>
</instrumentality>
</artifact>
&nbsp;·  <link xlink:type="simple" xlink:href="../see/Linden=2C_T$ennessee.xml">
Floating point unit (FPU)</link>&nbsp;·  <link xlink:type="simple" xlink:href="../045/339045.xml">
Backside Bus</link>&nbsp;·  <register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../432/486432.xml">
Registers</link></written_record>
</evidence>
</indication>
</record>
</register>
 &nbsp;·  <link xlink:type="simple" xlink:href="../112/177112.xml">
Memory management unit (MMU)</link> &nbsp;·  <link xlink:type="simple" xlink:href="../352/528352.xml">
Translation lookaside buffer (TLB)</link> &nbsp;·  <link xlink:type="simple" xlink:href="../181/849181.xml">
Cache</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Programming</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../349/222349.xml">
Flynn's taxonomy</link></group>
</collection>
</class>
 (<link xlink:type="simple" xlink:href="../630/1103630.xml">
SISD</link>&nbsp;&amp;bull;  <link xlink:type="simple" xlink:href="../359/55359.xml">
SIMD</link>&nbsp;&amp;bull;  <link xlink:type="simple" xlink:href="../666/991666.xml">
MISD</link>&nbsp;&amp;bull;  <link xlink:type="simple" xlink:href="../139/157139.xml">
MIMD</link>)</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../703/273703.xml">
Power management</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../130/3130.xml">
APM</link>&nbsp;·  <link xlink:type="simple" xlink:href="../697/2432697.xml">
ACPI</link> <link xlink:type="simple" xlink:href="../697/2432697.xml#xpointer(//*[./st=%22States%22])">
(states)</link>&nbsp;·  <link xlink:type="simple" xlink:href="../512/13891512.xml">
Dynamic frequency scaling</link>&nbsp;·  <link xlink:type="simple" xlink:href="../711/13933711.xml">
Dynamic voltage scaling</link>&nbsp;·  <link xlink:type="simple" xlink:href="../754/2817754.xml">
Clock gating</link></col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</article>
