<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:57:06[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>A* search algorithm</title>
<id>100558</id>
<revision>
<id>244176371</id>
<timestamp>2008-10-09T17:37:39Z</timestamp>
<contributor>
<username>Bhadani</username>
<id>219828</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Routing algorithms</category>
<category>Combinatorial optimization</category>
<category>Articles with example code</category>
<category>Game artificial intelligence</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>A*</b> (pronounced "A star") is a <link xlink:type="simple" xlink:href="../271/148271.xml">
best-first</link>, <link xlink:type="simple" xlink:href="../731/6263731.xml">
graph search algorithm</link> that finds the least-cost path from a given initial <link xlink:type="simple" xlink:href="../899/638899.xml">
node</link> to one  <link xlink:type="simple" xlink:href="../687/7639687.xml">
goal node</link> (out of one or more possible goals). <p>

It uses a distance-plus-cost <link xlink:type="simple" xlink:href="../452/63452.xml">
heuristic</link> function (usually denoted <math>f(x)</math>) to determine the order in which the search visits nodes in the tree. The distance-plus-cost heuristic is a sum of two functions: the path-cost function (usually denoted <math>g(x)</math>, which may or may not be a heuristic) and an <link xlink:type="simple" xlink:href="../826/11338826.xml">
admissible</link> "heuristic estimate" of the distance to the goal (usually denoted <math>h(x)</math>). The path-cost function <math>g(x)</math> is the cost from the starting node to the current node.</p>
<p>

Since the <math>h(x)</math> part of the <math>f(x)</math> function must be an <link xlink:type="simple" xlink:href="../826/11338826.xml">
admissible heuristic</link>, it must not overestimate the distance to the goal. Thus for an application like <link xlink:type="simple" xlink:href="../750/25750.xml">
routing</link>, <math>h(x)</math> might represent the straight-line distance to the goal, since that is physically the smallest possible distance between any two points (or nodes for that matter).</p>
<p>

The algorithm was first described in 1968 by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../790/11897790.xml">
Peter Hart</link></scholar>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../113/8016113.xml">
Nils Nilsson</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../387/5589387.xml">
Bertram Raphael</link></research_worker>
</scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
. In their paper, it was called algorithm A. Since using this algorithm yields optimal behavior for a given heuristic, it has been called A*.</p>
<p>

This algorithm has been generalized into a bidirectional heuristic search algorithm;  see <link xlink:type="simple" xlink:href="../516/3157516.xml">
bidirectional search</link>.</p>

<sec>
<st>
Algorithm description</st>
<p>

<image width="150px" src="A+_Pathfinding_Algorithm.png" type="thumb">
<caption>

A single-step simulation
</caption>
</image>
</p>
<p>

A* incrementally searches all routes leading from the starting point until it finds the shortest path to a goal. Like all <link>
informed search algorithm</link>s, it searches first the routes that <it>appear</it> to be most likely to lead towards the goal. What sets A* apart from a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy</link> best-first search is that it also takes the distance already traveled into account (the <math>g(x)</math> part of the heuristic is the cost from the start, and not simply the local cost from the previously expanded node).</p>
<p>

The algorithm traverses various paths from start to goal. For each node <math>x</math> traversed, it maintains 3 values:
<list>
<entry level="1" type="bullet">

 g(x): the actual shortest distance traveled from initial node to current node</entry>
<entry level="1" type="bullet">

 h(x): the estimated (or "heuristic") distance from current node to goal</entry>
<entry level="1" type="bullet">

 f(x): the sum of g(x) and h(x)</entry>
</list>
</p>
<p>

Starting with the initial node, it maintains a <link xlink:type="simple" xlink:href="../485/24485.xml">
priority queue</link> of nodes to be traversed, known as the <it>open set</it> (not to be confused with <link xlink:type="simple" xlink:href="../358/39358.xml">
open set</link>s in <link xlink:type="simple" xlink:href="../954/29954.xml">
topology</link>). The lower <math>f(x)</math> for a given node <math>x</math>, the higher its priority. At each step of the algorithm, the node with the lowest <math>f(x)</math> value is removed from the queue, the <math>f</math> and <math>h</math> values of its neighbors are updated accordingly, and these neighbors are added to the queue. The algorithm continues until a goal node has a lower <math>f</math> value than any node in the queue (or until the queue is empty). (Goal nodes may be passed over multiple times if there remain other nodes with lower <math>f</math> values, as they may lead to a shorter path to a goal.) The <math>f</math> value of the goal is then the length of the shortest path, since <math>h</math> at the goal is zero in an admissible heuristic. If the actual shortest path is desired, the algorithm may also update each neighbor with its immediate predecessor in the best path found so far; this information can then be used to reconstruct the path by working backwards from the goal node. Additionally, if the heuristic is <it>monotonic</it> (see below), a <it>closed set</it> of nodes already traversed may be used to make the search more efficient.</p>

<p>

function A*(start,goal)
closedset := the empty set                 % The set of nodes already evaluated.
openset := set containing the initial node % The set of tentative nodes to be evaluated.
g_score[start] := 0                        % Distance from start along optimal path.
while openset is not empty
x := the node in openset having the lowest f_score value
if x = goal
return reconstruct_path(came_from,goal)
remove x from openset
add x to closedset
foreach y in neighbor_nodes(x)
if y in closedset
continue
tentative_g_score := g_score[x] + dist_between(x,y)
tentative_is_better := false
if y not in openset
add y to openset
h_score[y] := heuristic_estimate_of_distance_to_goal_from(y)
tentative_is_better := true
elseif tentative_g_score  g_score[y]
tentative_is_better := true
if tentative_is_better = true
came_from[y] := x
g_score[y] := tentative_g_score
f_score[y] := g_score[y] + h_score[y] % Estimated total distance from start to goal through y.
return failure
function reconstruct_path(came_from,current_node)
if came_from[current_node] is set
p = reconstruct_path(came_from,came_from[current_node])
return (p + current_node)
else
return the empty path</p>

<p>

The closed set can be omitted (yielding a tree search algorithm) if a solution is guaranteed to exist, or if the algorithm is adapted so that new nodes are added to the open set only if they have a lower <math>f</math> value than at any previous iteration.</p>

</sec>
<sec>
<st>
Properties</st>
<p>

Like <link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link>, A* is <it>complete</it> in the sense that it will always find a solution if there is one.</p>
<p>

If the heuristic function <math>h</math> is <it>admissible</it>, meaning that it never overestimates the actual minimal cost of reaching the goal, then A* is itself admissible (or <it>optimal</it>) if we do not use a closed set. If a closed set is used, then <math>h</math> must also be <it>monotonic</it> (or <it>consistent</it>) for A* to be optimal. This means that for any pair of adjacent nodes <math>x</math> and <math>y</math>, where <math>d(x,y)</math> denotes the length of the edge between them, we must have:</p>
<p>

<indent level="1">

<math>h(x) \le d(x,y) + h(y)</math>
</indent>

This ensures that for any path <math>X</math> from the initial node to <math>x</math>:</p>
<p>

<indent level="1">

<math>L(X) + h(x) \le L(X) + d(x,y) + h(y) = L(Y) + h(y)</math>
</indent>

where <math>L(\cdot)</math> denotes the length of a path, and <math>Y</math> is the path <math>X</math> extended to include <math>y</math>. In other words, it is impossible to decrease (total distance so far + estimated remaining distance) by extending a path to include a neighboring node. (This is analogous to the restriction to nonnegative edge weights in <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.) Monotonicity implies admissibility when the heuristic estimate at any goal node itself is zero, since (letting <math>P = (f,v_1,v_2,\ldots,v_n,g)</math> be a shortest path from any node <math>f</math> to the nearest goal <math>g</math>):</p>
<p>

<indent level="1">

<math>h(f) \le d(f,v_1) + h(v_1) \le d(f,v_1) + d(v_1,v_2) + h(v_2) \le \ldots \le L(P) + h(g) = L(P)</math>
</indent>

A* is also optimally efficient for any heuristic <math>h</math>, meaning that no algorithm employing the same heuristic will expand fewer nodes than A*, except when there are multiple partial solutions where <math>h</math> exactly predicts the cost of the optimal path. Even in this case, for each graph there exists some order of breaking ties in the priority queue such that A* examines the fewest possible nodes.</p>

<ss1>
<st>
Special cases</st>

<p>

Generally speaking, <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link> and <link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link> are two special cases of A* algorithm. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, as another example of a best-first search algorithm, is the special case of A* where <math>h(x) = 0</math> for all <math>x</math>. For depth-first search, we may consider that there is a global counter <it>C</it> initialized with a very big value. Every time we process a node we assign <it>C</it> to all of its newly discovered neighbors. After each single assignment, we decrease the counter <it>C</it> by one. Thus the earlier a node is discovered, the higher its <math>h(x)</math> value.</p>

</ss1>
<ss1>
<st>
Implementation Details</st>

<p>

There are a number of simple optimizations or implementation details that can significantly affect the performance of an A* implementation.  The first detail to note is that the way the priority queue handles ties can have a significant effect on performance in some situations.  If ties are broken so the queue behaves in a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../937/4690937.xml">
LIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 manner, A* will behave like <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
 among equal cost paths.  If ties are broken so the queue behaves in a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/11347.xml">
FIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 manner, A* will behave like <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
 among equal cost paths.</p>
<p>

When a path is required at the end of the search, it is common to keep with each node a reference to that node's parent.  At the end of the search these references can be used to recover the optimal path.  If these references are being kept then it can be important that the same node doesn't appear in the priority queue more than once (each entry corresponding to a different path to the node, and each with a different cost).  A standard approach here is to check if a node about to be added already appears in the priority queue.  If it does, then the priority and parent pointers are changed to correspond to the lower cost path.  When finding a node in a queue to perform this check, many standard implementations of a <link xlink:type="simple" xlink:href="../996/13996.xml">
min-heap</link> require <math>O(n)</math> time.  Augmenting the heap with a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../833/13833.xml">
Hash table</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 can reduce this to constant time.</p>

</ss1>
</sec>
<sec>
<st>
 Why A* is admissible and computationally optimal </st>
<p>

A* is both admissible and considers fewer nodes than any other admissible search algorithm with the same heuristic, because A* works from an “optimistic” estimate of the cost of a path through every node that it considers — optimistic in that the true cost of a path through that node to the goal will be at least as great as the estimate.  But, critically, as far as A* “knows”, that optimistic estimate might be achievable.</p>
<p>

When A* terminates its search, it has, by definition, found a path whose actual cost is lower than the estimated cost of any path through any open node.  But since those estimates are optimistic, A* can safely ignore those nodes.  In other words, A* will never overlook the possibility of a lower-cost path and so is admissible.</p>
<p>

Suppose now that some other search algorithm B terminates its search with a path whose actual cost is <b>not</b> less than the estimated cost of a path through some open node.  Algorithm B cannot rule out the possibility, based on the heuristic information it has, that a path through that node might have a lower cost.  So while B might consider fewer nodes than A*, it cannot be admissible. Accordingly, A* considers the fewest nodes of any admissible search  algorithm that uses a no more accurate heuristic estimate.</p>

</sec>
<sec>
<st>
Complexity</st>
<p>

The <link xlink:type="simple" xlink:href="../543/7543.xml">
time complexity</link> of A* depends on the heuristic. In the worst case, the number of nodes expanded is <link xlink:type="simple" xlink:href="../581/44581.xml">
exponential</link> in the length of the solution (the shortest path), but it is <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial</link> when the heuristic function <it>h</it> meets the following condition:</p>
<p>

<indent level="1">

<math>|h(x) - h^*(x)| \leq O(\log h^*(x))</math>
</indent>

where <math>h^*</math> is the optimal heuristic, i.e. the exact cost to get from <math>x</math> to the goal. In other words, the error of <it>h</it> should not grow faster than the <link xlink:type="simple" xlink:href="../860/17860.xml">
logarithm</link> of the “perfect heuristic” <math>h^*</math> that returns the true distance from <it>x</it> to the goal (Russell and Norvig 2003, p. 101).</p>
<p>

More problematic than its time complexity is A*’s memory usage. In the worst case, it must also remember an exponential number of nodes. Several variants of A* have been developed to cope with this, including iterative deepening A* (IDA*), memory-bounded A* (MA*) and simplified memory bounded A* (SMA*) and recursive best-first search (RBFS).</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Dechter, Rina; Judea Pearl&#32;(1985).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=3830&amp;coll=portal&amp;dl=ACM">
Generalized best-first search strategies and the optimality of A*</weblink>". <it><magazine wordnetid="106595351" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/2321845.xml">
Journal of the ACM</link></magazine>
</it>&#32;<b>32</b>&#32;(3): pp. 505–536. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F3828.3830">
10.1145/3828.3830</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Hart, P. E.; Nilsson, N. J.; Raphael, B.&#32;(1968).&#32;"A Formal Basis for the Heuristic Determination of Minimum Cost Paths". <it><link xlink:type="simple" xlink:href="../938/56938.xml">
IEEE</link> Transactions on Systems Science and Cybernetics SSC4</it>&#32;(2): pp. 100–107.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Hart, P. E.; Nilsson, N. J.; Raphael, B.&#32;(1972).&#32;"Correction to "A Formal Basis for the Heuristic Determination of Minimum Cost Paths"". <it><organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
SIGART</link></organization>
 Newsletter</it>&#32;<b>37</b>: pp. 28–29.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Nilsson-1980" style="font-style:normal" class="book">Nilsson, N. J.&#32;(1980). Principles of Artificial Intelligence.&#32;Palo Alto, California:&#32;Tioga Publishing Company. ISBN 0935382011.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Pearl-1984" style="font-style:normal" class="book">Pearl, Judea&#32;(1984). Heuristics: Intelligent Search Strategies for Computer Problem Solving.&#32;Addison-Wesley. ISBN 0-201-05594-5.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Russell-2003" style="font-style:normal" class="book">Russell, S. J.;&#32;Norvig, P.&#32;(2003). ,&#32;pp. 97-104. ISBN 0-13-790395-2.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 Tarik Attar's <weblink xlink:type="simple" xlink:href="http://www.tarikattar.com/napier/osmastermap/">
Implementation and visualisation of the A* algorithm</weblink> - Implementation in PHP and visualisation using Google Map API</entry>
<entry level="1" type="bullet">

 Justin Heyes-Jones' <weblink xlink:type="simple" xlink:href="http://www.geocities.com/jheyesjones/astar.html">
A* algorithm tutorial</weblink></entry>
<entry level="1" type="bullet">

 Herbert Glarner's <weblink xlink:type="simple" xlink:href="http://herbert.gandraxa.com/herbert/pfa.asp">
Interactive Single Step Simulation in VB 6.0</weblink>, implemented as a DLL, including a GUI allowing simulation in user-defined grids.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.policyalmanac.org/games/aStarTutorial.htm">
Another A* Pathfinding for Beginners</weblink> (note: incorrectly states that A* always needs a "closed set")</entry>
<entry level="1" type="bullet">

 Amit's <weblink xlink:type="simple" xlink:href="http://theory.stanford.edu/~amitp/GameProgramming/">
Thoughts on Path-Finding and A*</weblink></entry>
<entry level="1" type="bullet">

 Sven Koenig's <weblink xlink:type="simple" xlink:href="http://idm-lab.org/applet.html">
Demonstration of Lifelong Planning A* and A*</weblink></entry>
<entry level="1" type="bullet">

 Cuneyt Mertayak's <weblink xlink:type="simple" xlink:href="http://www.ceng.metu.edu.tr/~cuneyt/astar.tar.gz">
A Generic C++ A* Library</weblink></entry>
<entry level="1" type="bullet">

 Tony Stentz's <weblink xlink:type="simple" xlink:href="http://www.frc.ri.cmu.edu/~axs/">
Papers on D* (Dynamic A*) Path-Finding</weblink></entry>
<entry level="1" type="bullet">

  Remko Tronçon and Joost Vennekens's <weblink xlink:type="simple" xlink:href="http://el-tramo.be/software/jsearchdemo/">
JSearch demo</weblink>: demonstrates various search algorithms, including A*.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://lostsouls.org/grimoire_astar">
A* search algorithm module</weblink> in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../645/904645.xml">
LPC</link></programming_language>
</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.jamespoag.com/AStarPathfinder.html">
A* search algorithm module</weblink> in <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented</link> <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
 with Demo Written for the <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../114/7033114.xml">
PopCap Games Framework</link></room>
</library>
</area>
</artifact>
</structure>
</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/argorha/">
Open Source A*</weblink> in polygon soup ( 3D world ). </entry>
<entry level="1" type="bullet">

 Variation on A* called <weblink xlink:type="simple" xlink:href="http://www.cs.ualberta.ca/~mmueller/ps/hpastar.pdf">
Near Optimal Hierarchical Path-Finding</weblink> and associated <weblink xlink:type="simple" xlink:href="http://www.cs.ualberta.ca/~bulitko/F06/presentations/2006-09-29-ML.pdf">
presentation</weblink>.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
