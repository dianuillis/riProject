<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 00:10:51[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Difference map algorithm</title>
<id>10145406</id>
<revision>
<id>227926346</id>
<timestamp>2008-07-26T00:16:42Z</timestamp>
<contributor>
<username>Gnfnrf</username>
<id>1334976</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Constraint satisfaction</category>
</categories>
</header>
<bdy>

The <b>difference map algorithm</b> is a <link xlink:type="simple" xlink:href="../249/28249.xml">
search algorithm</link> for general <link xlink:type="simple" xlink:href="../966/949966.xml">
constraint satisfaction</link> problems. It is a <link xlink:type="simple" xlink:href="../458/774458.xml">
meta-algorithm</link> in the sense that it is built from more basic algorithms that perform <link xlink:type="simple" xlink:href="../182/519182.xml">
projections</link> onto <link xlink:type="simple" xlink:href="../540/7418540.xml">
constraint</link> sets. From a mathematical perspective, the difference map algorithm is a <link xlink:type="simple" xlink:href="../087/9087.xml">
dynamical system</link> based on a <mathematical_relation wordnetid="113783581" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/516931.xml">
mapping</link></function>
</concept>
</idea>
</mathematical_relation>
 of <link xlink:type="simple" xlink:href="../697/9697.xml">
Euclidean space</link>. Solutions are encoded as <link xlink:type="simple" xlink:href="../738/449738.xml">
fixed points</link> of the mapping.<p>

Although originally conceived as a general method for solving the <link xlink:type="simple" xlink:href="../369/1531369.xml">
phase problem</link>, the difference map algorithm has been used for the <link xlink:type="simple" xlink:href="../715/4715.xml">
boolean satisfiability problem</link>, <link xlink:type="simple" xlink:href="../769/306769.xml">
protein structure prediction</link>, <link>
Ramsey numbers</link>, <link xlink:type="simple" xlink:href="../109/9109.xml">
diophantine equations</link>, and <it><link xlink:type="simple" xlink:href="../807/1365807.xml">
Sudoku</link></it><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. Since these applications include <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 problems, the scope of the difference map is that of an <link>
incomplete algorithm</link>. Whereas incomplete algorithms can efficiently verify solutions (once a candidate is found), they cannot prove that a solution does not exist.</p>
<p>

The difference map algorithm is a generalization of two <link xlink:type="simple" xlink:href="../237/15237.xml">
iterative methods</link>: Fienup's <link>
hybrid input-output phase retrieval algorithm</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> and the <link>
Douglas-Rachford algorithm</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> for <link xlink:type="simple" xlink:href="../411/1674411.xml">
convex optimization</link>. Iterative methods, in general, have a long history in phase retrieval and convex optimization. The use of this style of algorithm for hard, non-convex problems is a more recent development.</p>

<sec>
<st>
Algorithm</st>
<p>

The problem to be solved must first be formulated as a <link xlink:type="simple" xlink:href="../157/48157.xml">
set intersection</link> problem in Euclidean space: find an <it>x</it> in the intersection of sets <it>A</it> and <it>B</it>. Another prerequisite is an implementation of the projections <it>PA</it> and <it>PB</it> that, given an arbitrary input point <it>x</it>, return a point in the constraint set <it>A</it> or <it>B</it> that is nearest to <it>x</it>. One iteration of the algorithm is given by the mapping:</p>
<p>

<indent level="1">

<it>x</it> &amp;rarr; <it>D</it>(<it>x</it>) = <it>x</it> + &amp;beta; [ ''P''''A''( ''f''''B''(''x'')) - ''P''''B''( ''f''''A''(''x'')) ] ,
</indent>

<indent level="2">

<it>fA</it>(<it>x</it>) = <it>PA</it>(<it>x</it>) - (<it>PA</it>(<it>x</it>)-<it>x</it>)/&amp;beta; ,
</indent>

<indent level="2">

<it>fB</it>(<it>x</it>) = <it>PB</it>(<it>x</it>) + (<it>PB</it>(<it>x</it>)-<it>x</it>)/&amp;beta; .
</indent>

The real parameter β can have either sign; optimal values depend on the application and are determined through experimentation. As a first guess, the choice β = 1 (or β = -1) is recommended because it reduces the number of projection computations per iteration:</p>
<p>

<indent level="1">

<it>D</it>(<it>x</it>) = <it>x</it> + <it>PA</it>(2 <it>PB</it>(<it>x</it>) - <it>x</it>) - <it>PB</it>(<it>x</it>) .
</indent>

The progress of the algorithm is monitored by inspecting the norm of the difference of the two projections:</p>
<p>

<indent level="1">

<it>&amp;Delta;</it> = | <it>PA</it>( <it>fB</it>(<it>x</it>)) - <it>PB</it>( <it>fA</it>(<it>x</it>)) | .
</indent>

When this vanishes, at fixed points of the map, a point common to both constraint sets has been found and the algorithm is terminated. The set of fixed points in a particular application will normally have a large <link xlink:type="simple" xlink:href="../398/8398.xml">
dimension</link>, even when the solution set is a single point.</p>

</sec>
<sec>
<st>
Example: logical satisfiability </st>
<p>

Incomplete algorithms, such as stochastic <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../942/313942.xml">
local search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, are widely used for finding satisfying truth assignments to boolean formulas. As an example of solving an instance of <link xlink:type="simple" xlink:href="../640/497640.xml">
2-SAT</link> with the difference map algorithm, consider the following formula (~ indicates NOT):
<indent level="1">

(<it>q</it>1 or <it>q</it>2) and (~<it>q</it>1 or <it>q</it>3) and (~<it>q</it>2 or ~<it>q</it>3) and (<it>q</it>1 or ~<it>q</it>2)
</indent>

To each of the eight <link xlink:type="simple" xlink:href="../761/7792761.xml">
literals</link> in this formula we assign one real variable in an eight dimensional Euclidean space. The structure of the 2-SAT formula can be recovered when these variables are arranged in a table:</p>
<p>

<indent level="1">

| class="wikitable"  style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|<it>x</it>11
|width="80pt"|<it>x</it>12
|width="80pt"|
|-
|(<it>x</it>21)
|
|<it>x</it>22
|-
|
|(<it>x</it>31)
|(<it>x</it>32)
|-
|<it>x</it>41
|(<it>x</it>42)
|
|}</p>
<p>

Rows are the clauses in the 2-SAT formula and literals corresponding to the same boolean variable are arranged in columns, with negation indicated by parentheses. For example, the real variables <it>x</it>11, <it>x</it>21 and <it>x</it>41 correspond to the same boolean variable (<it>q</it>1) or its negation, and are called <b>replicas</b>.
It is convenient to associate the values 1 and -1 with <it>TRUE</it> and <it>FALSE</it> rather than the traditional 1 and 0. With this convention, the compatibility between the replicas takes the form of the following linear equations:</p>
<p>

<indent level="1">

<it>x</it>11 = -<it>x</it>21 = <it>x</it>41
</indent>
:<it>x</it>12 = -<it>x</it>31 = -<it>x</it>42
<indent level="1">

<it>x</it>22 = -<it>x</it>32
</indent>

The linear subspace where these equations are satisfied is one of the constraint spaces, say <it>A</it>, used by the difference map. To project to this constraint we replace each replica by the signed replica average, or its negative:</p>
<p>

<indent level="1">

<it>a</it>1 = (<it>x</it>11 - <it>x</it>21 + <it>x</it>41) / 3
</indent>
:<it>x</it>11 &amp;rarr; <it>a</it>1 &nbsp; <it>x</it>21 &amp;rarr; -<it>a</it>1        &nbsp; <it>x</it>41 &amp;rarr; <it>a</it>1</p>
<p>

The second difference map constraint applies to the rows of the table, the clauses. In a satisfying assignment, the two variables in each row must be assigned the values (1, 1), (1, -1), or (-1, 1). The corresponding constraint set, <it>B</it>, is thus a set of 34 = 729 points. In projecting to this constraint the following operation is applied to each row. First, the two real values are rounded to 1 or -1; then, if the outcome is (-1, -1), the larger of the two original values is replaced by 1. Examples: </p>
<p>

<indent level="1">

(-.2, 1.2) &amp;rarr; (-1, 1)
</indent>
:(-.2, -.8) &amp;rarr; (1, -1)</p>
<p>

It is a straightforward exercise to check that both of the projection operations described minimize the Euclidean distance between input and output values. Moreover, if the algorithm succeeds in finding a point <it>x</it> that lies in both constraint sets we know (i) the clauses associated with <it>x</it> are all <it>TRUE</it> and (ii) the assignments to the replicas are consistent with a truth assignment to the original boolean variables.</p>
<p>

To run the algorithm one first generates an initial point <it>x</it>0, say</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|-0.5
|width="80pt"|-0.8
|width="80pt"|
|-
|(-0.4)
|
| -0.6
|-
|
|(0.3)
|(-0.8)
|-
|0.5
|(0.1)
|
|}</p>
<p>

Using β = 1, the next step is to compute <it>P</it>B(<it>x</it>0) :</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|1
|width="80pt"|-1
|width="80pt"|
|-
|(1)
|
| -1
|-
|
|(1)
|(-1)
|-
|1
|(1)
|
|}</p>
<p>

This is followed by 2<it>P</it>B(<it>x</it>0) - <it>x</it>0,</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|2.5
|width="80pt"|-1.2
|width="80pt"|
|-
|(2.4)
|
| -1.4
|-
|
|(1.7)
|(-1.2)
|-
|1.5
|(1.9)
|
|}</p>
<p>

and then projected onto the other constraint, <it>P</it>A(2<it>P</it>B(<it>x</it>0) - <it>x</it>0) :</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|0.53333
|width="80pt"|-1.6
|width="80pt"|
|-
|(-0.53333)
|
| -0.1
|-
|
|(1.6)
|(0.1)
|-
|0.53333
|(1.6)
|
|}</p>
<p>

Incrementing <it>x</it>0 by the difference of the two projections gives the first iteration of the difference map, <it>D</it>(<it>x</it>0) = <it>x</it>1 :</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|-0.96666
|width="80pt"|-1.4
|width="80pt"|
|-
|(-1.93333)
|
| 0.3
|-
|
|(0.9)
|(0.3)
|-
|0.03333
|(0.7)
|
|}</p>
<p>

Here is the second iteration, <it>D</it>(<it>x</it>1) = <it>x</it>2 :</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|-0.3
|width="80pt"|-1.4
|width="80pt"|
|-
|(-2.6)
|
| -0.7
|-
|
|(0.9)
|(-0.7)
|-
|0.7
|(0.7)
|
|}</p>
<p>

This is a fixed point: <it>D</it>(<it>x</it>2) = <it>x</it>2. The iterate is unchanged because the two projections agree. From <it>PB</it>(<it>x</it>2) ,</p>
<p>

<indent level="1">

| class="wikitable" style="background-color:white;text-align: center;"
</indent>
|-
|width="80pt"|1
|width="80pt"|-1
|width="80pt"|
|-
|(-1)
|
| 1
|-
|
|(1)
|(-1)
|-
|1
|(1)
|
|}</p>
<p>

we can read off the satisfying truth assignment: <it>q</it>1 = <it>TRUE</it>, <it>q</it>2 = <it>FALSE</it>, <it>q</it>3 = <it>TRUE</it>.</p>

</sec>
<sec>
<st>
 Chaotic dynamics </st>

<p>

<image location="right" width="150px" src="3SAT.png" type="thumb">
<caption>

Time series of the norm of the difference map increment <it>&amp;Delta;</it> in the course of solving a random 3-SAT instance with 1000 variables and 4200 clauses.
</caption>
</image>
</p>
<p>

In the simple 2-SAT example above, the norm of the difference map increment <it>Δ</it> decreased monotonically to zero in three iterations. This contrasts the behavior of <it>Δ</it> when the difference map is given a hard instance of <link xlink:type="simple" xlink:href="../715/4715.xml">
3-SAT</link>, where it fluctuates strongly prior to the discovery of the fixed point. As a dynamical system the difference map is believed to be <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../295/6295.xml">
chaotic</link></concept>
</idea>
, and that the space being searched is a <link>
strange attractor</link>.</p>

</sec>
<sec>
<st>
 Phase retrieval </st>

<p>

<image location="left" width="150px" src="Wiki_speckle.png" type="thumb">
<caption>

Fourier transform modulus (diffraction pattern) of the Wikipedia logo.
</caption>
</image>
</p>
<p>

In phase retrieval a signal or image is reconstructed from the <link xlink:type="simple" xlink:href="../991/991.xml">
modulus</link> (absolute value, magnitude) of its <link xlink:type="simple" xlink:href="../811/8811.xml">
discrete Fourier transform</link>. For example, the source of the modulus data may be the <link xlink:type="simple" xlink:href="../986/799986.xml">
Fraunhofer diffraction</link> pattern formed when an object is illuminated with <link xlink:type="simple" xlink:href="../011/240011.xml">
coherent light</link>. </p>
<p>

The projection to the Fourier modulus constraint, say <it>PA</it>, is accomplished by first computing the discrete Fourier transform of the signal or image, rescaling the moduli to agree with the data, and then inverse transforming the result. This is a projection, in the sense that the Euclidean distance to the constraint is minimized, because (i) the discrete Fourier transform, as a <link xlink:type="simple" xlink:href="../007/236007.xml">
unitary transformation</link>, preserves distance, and (ii) rescaling the modulus (without modifying the phase) is the smallest change that realizes the modulus constraint. </p>
<p>

To recover the unknown phases of the Fourier transform the difference map relies on the projection to another constraint, <it>PB</it>. This may take several forms, as the object being reconstructed may be known to be positive, have a bounded <link xlink:type="simple" xlink:href="../013/381013.xml">
support</link>, etc. In the reconstruction of the Wikipedia logo, for example, the effect of the projection <it>PB</it> was to zero all values outside a rectangular support and also to zero all negative values within the support.</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
V. Elser, I. Rankenburg, and P. Thibault, "Searching with iterated maps". <it><periodical wordnetid="106593296" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/224259.xml">
Proceedings of the National Academy of Sciences</link></periodical>
</it> USA. (2007). <b>104</b>:418-423. http://www.pnas.org/cgi/content/short/104/2/418</entry>
<entry id="2">
J.R. Fienup, "Phase retrieval algorithms: a comparison". <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../886/7059886.xml">
Applied Optics</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>. (1982). <b>21</b>:2758-2769.</entry>
<entry id="3">
H.H. Bauschke, P.L. Combettes, and D.R. Luke, "Phase retrieval, error reduction algorithm, and Fienup variants: a view from convex optimization". <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../419/9136419.xml">
Journal of the Optical Society of America A</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>. (2002). <b>19</b>:1334-1345.</entry>
</reflist>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
