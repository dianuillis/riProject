<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 00:03:36[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Hirschberg&apos;s algorithm</title>
<id>10171509</id>
<revision>
<id>207867565</id>
<timestamp>2008-04-24T14:41:56Z</timestamp>
<contributor>
<username>WP 1.0 bot</username>
<id>3455093</id>
</contributor>
</revision>
<categories>
<category>Bioinformatics algorithms</category>
<category>Algorithms on strings</category>
<category>Dynamic programming</category>
</categories>
</header>
<bdy>

<b>Hirschberg's algorithm</b>, named after its inventor, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../958/7816958.xml">
Dan Hirschberg</link></scientist>
</causal_agent>
</person>
</physical_entity>
, is a <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that finds the least cost sequence alignment between two
<link xlink:type="simple" xlink:href="../701/27701.xml">
string</link>s, where cost is measured as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../418/406418.xml">
Levenshtein edit distance</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, defined to be the sum
of the costs of insertions, replacements, deletions, and null actions needed to change
one string to the other.  Hirschberg's algorithm is simply described as a <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer</link> version of the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../679/1004679.xml">
Needleman-Wunsch algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.  Hirschberg's algorithm is commonly used in <link xlink:type="simple" xlink:href="../353/149353.xml">
computational biology</link> to find maximal global alignments of <link xlink:type="simple" xlink:href="../955/7955.xml">
DNA</link> and <link xlink:type="simple" xlink:href="../634/23634.xml">
protein</link> sequences.
<sec>
<st>
Algorithm information</st>
<p>

Hirschberg's algorithm is a generally applicable
algorithm for finding an optimal sequence alignment.  <link xlink:type="simple" xlink:href="../695/363695.xml">
BLAST</link> and <link xlink:type="simple" xlink:href="../996/1009996.xml">
FASTA</link> are suboptimal heuristics.  If <it>x</it> and <it>y</it> are strings, where |<it>x</it>| = <it>n</it> and |<it>y</it>| = <it>m</it>, the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../679/1004679.xml">
Needleman-Wunsch algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 finds an optimal alignment in <link xlink:type="simple" xlink:href="../578/44578.xml">
O(<it>nm</it>)</link> time, using O(<it>nm</it>) space.  Hirschberg's algorithm is a clever modification of the Needleman-Wunsch Algorithm which takes O(<it>nm</it>) time, but needs only O(min{<it>m</it>,<it>n</it>}) space.</p>
<p>

One application of the algorithm is finding sequence alignments of DNA or protein sequences.</p>

</sec>
<sec>
<st>
Computation of the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../418/406418.xml">
Levenshtein edit distance</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 in linear space</st>

<p>

The edit distance Edit(<it>x</it>,<it>y</it>) is the least cost of changing <it>x</it> into <it>y</it> by using the operations Insert, Substitute, and Delete, where the cost
of each kind of operation is given.  We write Ins(<it>a</it>) for the cost of
inserting a symbol <it>a</it> into a string, Sub(<it>a</it>,<it>b</it>) for the cost of substituting a symbol <it>b</it> for <it>a</it> in a string, and Del(<it>a</it>) for the cost of deleting a symbol <it>a</it> from a string.  The "standard" choice of those costs is Ins(<it>a</it>) = Del(<it>a</it>) = 1 for each symbol <it>a</it>, Sub(<it>a</it>,<it>a</it>) = 0, and Sub(<it>a</it>,<it>b</it>) = 1 if <it>a</it> is not equal to <it>b</it>.
The Needleman-Wunsch algorithm computes Edit(<it>x</it>,<it>y</it>) by computing
Edit(Pref[''x'',''i''],Pref[''y'',''j'']) for all <it>i</it> and <it>j</it> dynamically, where Pref[''x'',''i''] denotes the prefix of <it>x</it> of length <it>i</it>.  That algorithm requires O(<it>nm</it>) time and O(<it>nm</it>) space, where <it>n</it> = |<it>x</it>| and <it>m</it> = |<it>y</it>|.</p>

</sec>
<sec>
<st>
Algorithm organization</st>

<p>

To understand Hirschberg's algorithm, it is important to first understand
that edit distances can be computed using linear space.</p>
<p>

What we call the "forward subprogram" computes the values of
Edit(Pref[''x'',''i''],Pref[''y'',''j'']) for all <it>i</it> and <it>j</it>, just as the Needleman-Wunsch
and returns the array {Edit(<it>x</it>,Pref[''y'',''j''])}0 ≤ j ≤ m.  The
"backward subprogram" is similar, except that the dynamic program
is done in the opposite direction, i.e., starting from the right ends
of the strings. It returns the array {Edit(<it>x</it>,Suff[''y'',''j''])}0 ≤ j ≤ m,
where Suff[''y'',''j''] is the suffix of <it>y</it> of length <it>j</it>.</p>
<p>

The forward and backward subprograms compute values in the matrix by using
previously computed values, but save space by erasing values that will no
longer be needed during that execution of the subprogram.  Unfortunately,
the erased values will need to be recomputed later; thus, Hirschberg's
algorithm takes roughly twice as much time as Needleman-Wunsch.</p>

</sec>
<sec>
<st>
Pseudocode</st>

<p>

01 High-level description of the forwards subprogram
02
03 Forwards[x,y] is
04
05 1.  n = |x|;  m = |y|
06 2.  For all i from 1 to n:
07     Edit[Pref[x,i],Pref[y,0]] = 0
08 3.  For all j from 1 to m:
09        A.  Edit[Pref[x,0],Pref[y,j]] = Edit[Pref[[x,0],Pref[y,j-1]] + Ins(y_j)
10        B.  For all i from 1 to n, execute the following steps:
11                i.  Edit[Pref[x,i],Pref[y,j]] =
12                      min{Edit[Pref[x,i-1],Pref[y,j]] + Del(x_i),
13                          Edit[Pref[x,i-1],Pref[y,j-1] + Sub(x_i,y_j),
14                          Edit[Pref[x,i],Pref[y,j-1]] + Ins(y_j)}
15                ii.  Erase Edit[Pref[x,i-1],Pref[y,j-1]]
16        C.  Erase Edit[Pref[x,i-1],Pref[y,j]]
17 4.  Return {Edit[Pref[x,n],Pref[y,j]]}  %% an array of length m+1</p>
<p>

01 High-level description of the backwards subprogram
02
03 Backwards[x,y] is
04
05 1.  n = |x|;  m = |y|
06 2.  For all i from 1 to n:
07         Edit[Suff[x,i],Suff[y,0]] = 0
08 3.  For all j from 1 to m:
09       A.  Edit[Suff[x,0],Suff[y,j]] = Edit[Suff[[x,n],Suff[y,j-1]] + Ins(y_{m-j+1})
10       B.  For all i from 1 to n:
11                 i.  Edit[Suff[x,i],Suff[y,j]] =
12                      min{Edit[Suff[x,i-1],Suff[y,j]] + Del(x_{n-i-1}),
13                          Edit[Suff[x,i-1],Suff[y,j-1]] + Sub(x_{n-i-1},y_{m-j+1}),
14                          Edit[Suff[x,i],Suff[y,j-1]] + Ins(y_{m-j+1})}
15                ii.  Erase Edit[Suff[x,i-1],Suff[y,j-1]]
16       C.  Erase Edit[Suff[x,i-1],Suff[y,j]]
17 4.  RETURN {Edit[Pref[x,n],Pref[y,j]]} %% an array of length m+1</p>
<p>

01 High level description of Hirschberg's algorithm:
02
03 Hirschberg(x,y) is
04
05 1.  n = |x|;  m = |y|
06 2.  If n = 1 or m = 1:
07        OUTPUT Alignment(x,y) using Needleman-Wunsch.
08     Else:
09        A.  mid = floor(n/2)
10       B.  x^left = Pref[x,mid]
11       C.  x^right = Suff[x,n-mid]
12       D.  {Edit[x^left,Pref[y,j]]} = Forwards(x^left,y)  %% an array of length m+1
13       E.  {Edit[x^right,Suff[y,j]]} = Backwards(x^right,y) %% an array of length m+1
14       F.  cut = ArgMin{Edit[x^left,Pref[y,cut]] + Edit[x^right,Suff[y,n-cut]]}
15       G.  Hirschberg(x^left,Pref[y,cut])
16       H.  Hirschberg(x^right,Suff[y,n-cut])</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../679/1004679.xml">
Needleman-Wunsch algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../195/1606195.xml">
Smith Waterman algorithm</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../418/406418.xml">
Levenshtein distance</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Dynamic/Hirsch/">
Hirschberg's algorithm</weblink></entry>
</reflist>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
