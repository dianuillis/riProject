<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:00:03[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Cuthill–McKee algorithm</title>
<id>1019406</id>
<revision>
<id>205413976</id>
<timestamp>2008-04-13T21:29:06Z</timestamp>
<contributor>
<username>Andreas Kaufmann</username>
<id>72502</id>
</contributor>
</revision>
<categories>
<category>Graph algorithms</category>
<category>Matrix theory</category>
</categories>
</header>
<bdy>

In the <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematical</link> subfield of <link xlink:type="simple" xlink:href="../323/246323.xml">
matrix theory</link> the <b>Cuthill–McKee algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> to reduce the <link>
bandwidth</link> of <link xlink:type="simple" xlink:href="../015/341015.xml">
sparse</link> <link xlink:type="simple" xlink:href="../474/126474.xml">
symmetric matrices</link>. The <b>reverse Cuthill–McKee algorithm</b> (<b>RCM</b>) is the same algorithm but with the resulting index numbers reversed. In practice this is generally  a better solution.
<sec>
<st>
Algorithm</st>

<p>

Given a symmetric <it>n</it>&amp;times;<it>n</it> matrix we visualize the matrix as the <link xlink:type="simple" xlink:href="../463/244463.xml">
adjacency matrix</link> of a <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link>. The Cuthill-McKee algorithm is then a relabeling of the <link xlink:type="simple" xlink:href="../899/638899.xml">
vertices</link> of the graph to reduce the bandwidth of the adjacency matrix.</p>
<p>

The algorithm produces an ordered <link xlink:type="simple" xlink:href="../729/132729.xml">
n-tuple</link> <it>R</it> of vertices which is the new order of the vertices. </p>
<p>

First we choose a <link xlink:type="simple" xlink:href="../802/325802.xml">
peripheral vertex</link> <it>x</it> and set <it>R</it>:= ({<it>x</it>}).</p>
<p>

Then for i=1,2,... we iterate the following steps while |<it>R</it>|  <it>n</it> </p>
<p>

<list>
<entry level="1" type="bullet">

Construct the adjacency set <math>A_i</math> of <math>R_i</math> (with <math>R_i</math> the <it>i</it>-th component of <it>R</it>) and exclude the vertices we already have in <it>R''</it></entry>
<entry level="1" type="indent">

<math>A_i := \operatorname{Adj}(R_i) \setminus R</math></entry>
<entry level="1" type="bullet">

Sort <math>A_i</math> with ascending vertex order.</entry>
<entry level="1" type="bullet">

Append <math>A_i</math> to the Result set <it>R</it>.</entry>
</list>
</p>
<p>

In other words, number the vertices according to a particular <link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first traversal</link> where neighboring vertices are visited in order from lowest to highest vertex order.</p>

</sec>
<sec>
<st>
References</st>
<p>

E. Cuthill and J. McKee. <it>Reducing the bandwidth of sparse symmetric matrices</it> In Proc. 24th Nat. Conf. <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
ACM</link></organization>
, pages 157-172, 1969.</p>

</sec>
</bdy>
</algorithm>
</article>
