<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:25:11[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Exponentiation by squaring</title>
<id>10237</id>
<revision>
<id>239643679</id>
<timestamp>2008-09-19T20:19:58Z</timestamp>
<contributor>
<username>Salix alba</username>
<id>212526</id>
</contributor>
</revision>
<categories>
<category>Computer arithmetic</category>
<category>Arbitrary precision algorithms</category>
<category>Exponentials</category>
</categories>
</header>
<bdy>

<b>Exponentiating by squaring</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> used for the fast computation of large <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link> powers of a <link xlink:type="simple" xlink:href="../690/21690.xml">
number</link>. It is also known as the <b>square-and-multiply</b> algorithm or <b>binary exponentiation</b>. In <link xlink:type="simple" xlink:href="../229/332229.xml">
additive group</link>s the appropriate name is <b>double-and-add</b> algorithm. It implicitly uses the <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> expansion of the exponent. It is of quite general use, for example in <link xlink:type="simple" xlink:href="../087/20087.xml">
modular arithmetic</link>.
<sec>
<st>
Squaring algorithm</st>

<p>

The following <link xlink:type="simple" xlink:href="../407/25407.xml">
recursive algorithm</link> computes <it>xn</it> for a <link xlink:type="simple" xlink:href="../616/154616.xml">
non-negative</link> <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link> <it>n</it>:</p>
<p>

<indent level="1">

<math>
\mbox{Power}(x,\,n)=
  \begin{cases} 1, &amp; \mbox{if }n\mbox{ = 0} \\ 
                x\times\mbox{Power}(x,\,n-1), &amp; \mbox{if }n\mbox{ is odd} \\
                \mbox{Power}(x,\,n/2)^2, &amp; \mbox{if }n\mbox{ is even}
\end{cases}
</math>
</indent>

Compared to the ordinary method of multiplying <it>x</it> with itself <it>n</it> &amp;minus; 1 times, in this algorithm the "n is even" case is optimized, according to:
<indent level="1">

<math>
x^n=x^{n/2} \times x^{n/2}
</math>
</indent>
This way the algorithm uses only <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(log <it>n</it>) multiplications and therefore speeds up the computation of <it>xn</it> tremendously, in much the same way that the <link xlink:type="simple" xlink:href="../411/57411.xml">
long multiplication</link> algorithm speeds up multiplication over the slower method of repeated addition. The benefit is had for <it>n</it> greater than or equal to <it>4</it>. (Note: when measured in terms of the size of the problem data -instead of the value of the data, n- this algorithm is <link xlink:type="simple" xlink:href="../258/754258.xml">
linear time</link> since the size of an integer is also its logarithm.)</p>
<p>

xn can be calculated thus, if n is an integer:
<list>
<entry level="1" type="number">

 If n  0, {x = 1 / x; n = - n}</entry>
<entry level="1" type="number">

 i = n; y = 1; z = x</entry>
<entry level="1" type="number">

 If i is an <link xlink:type="simple" xlink:href="../135/143135.xml">
odd number</link>, y = y * z</entry>
<entry level="1" type="number">

 z = z2</entry>
<entry level="1" type="number">

 i = i / 2, throwing away the division remainder</entry>
<entry level="1" type="number">

 If i ≠ 0, go back to step 3</entry>
<entry level="1" type="number">

 The result is y</entry>
</list>

(This method works out 00 as 1.)</p>

</sec>
<sec>
<st>
Further applications</st>

<p>

The same idea allows fast computation of large <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/903032.xml">
exponents modulo</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 a number. Especially in <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>, it is useful to compute powers in a <link xlink:type="simple" xlink:href="../404/48404.xml">
ring</link> of <link xlink:type="simple" xlink:href="../087/20087.xml">
integers modulo <it>q''</it></link>. It can also be used to compute integer powers in a <link xlink:type="simple" xlink:href="../447/19447.xml">
group</link>, using the rule </p>
<p>

<indent level="1">

Power(<it>x</it>, -<it>n</it>) = (Power(<it>x</it>, <it>n</it>))-1. 
</indent>

The method works in every <link xlink:type="simple" xlink:href="../799/27799.xml">
semigroup</link> and is often used to compute powers of <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrices</link>, </p>
<p>

For example, the evaluation of</p>
<p>

<indent level="1">

13789722341 (mod 2345) 
</indent>

would take a very long time and lots of storage space if the naïve method is used: compute 13789722341 then take the <link xlink:type="simple" xlink:href="../897/502897.xml">
remainder</link> when divided by 2345. Even using a more effective method will take a long time: square 13789, take the remainder when divided by 2345, multiply the <link xlink:type="simple" xlink:href="../710/1948710.xml">
result</link> by 13789, and so on. This will take 722340 modular multiplications. The square-and-multiply algorithm is based on the observation that 13789722341 = 13789(137892)361170. So, if we computed 137892, then the full computation would only take 361170 modular multiplications. This is a gain of a factor of two. But since the new problem is of the same type, we can apply the same observation <it>again</it>, once more approximately halving the size.</p>
<p>

The repeated application of this algorithm is equivalent to decomposing the exponent (by a base conversion to binary) into a sequence of squares and products: for example
<indent level="1">

<it>x</it>13 = <it>x</it>1101bin
</indent>
: = <it>x</it>(1*2^3 + 1*2^2 + 0*2^1 + 1*2^0)
<indent level="1">

 = <it>x</it>1*2^3 * <it>x</it>1*2^2 * <it>x</it>0*2^1 * <it>x</it>1*2^0
</indent>
: = <it>x</it>2^3 * <it>x</it>2^2 * 1 * <it>x</it>2^0
<indent level="1">

 = <it>x</it>8 * <it>x</it>4 * <it>x</it>1
</indent>
: = (<it>x</it>4)2 * (<it>x</it>2)2 * <it>x</it>
<indent level="1">

 = (<it>x</it>4 * <it>x</it>2)2 * <it>x</it>
</indent>
: = ((<it>x</it>2)2 * <it>x</it>2)2 * <it>x</it>
<indent level="1">

 = ((<it>x</it>2 * <it>x</it>)2)2 * <it>x</it> &nbsp; &nbsp; &nbsp; → algorithm needs only 5 multiplications instead of 12 (13-1)
</indent>

Some more examples:
<list>
<entry level="1" type="bullet">

 <it>x</it>10 = ((<it>x</it>2)2*<it>x</it>)2 because 10 = (1,010)2 = 23+21, algorithm needs 4 multiplications instead of 9</entry>
<entry level="1" type="bullet">

 <it>x</it>100 = (((((<it>x</it>2*<it>x</it>)2)2)2*<it>x</it>)2)2 because 100 = (1,100,100)2 = 26+25+22, algorithm needs 8 multiplications instead of 99</entry>
<entry level="1" type="bullet">

 <it>x</it>1,000 = ((((((((<it>x</it>2*<it>x</it>)2*<it>x</it>)2*<it>x</it>)2*<it>x</it>)2)2*<it>x</it>)2)2)2 because 103 = (1,111,101,000)2, algorithm needs 14 multiplications instead of 999</entry>
<entry level="1" type="bullet">

 <it>x</it>1,000,000 = ((((((((((((((((((<it>x</it>2*<it>x</it>)2*<it>x</it>)2*<it>x</it>)2)2*<it>x</it>)2)2)2)2)2*<it>x</it>)2)2)2*<it>x</it>)2)2)2)2)2)2 because 106 = (11,110,100,001,001,000,000)2, algorithm needs 25 multiplications instead of 999,999</entry>
<entry level="1" type="bullet">

 <it>x</it>1,000,000,000 = ((((((((((((((((((((((((((((<it>x</it>2*<it>x</it>)2*<it>x</it>)2)2*<it>x</it>)2*<it>x</it>)2*<it>x</it>)2)2)2*<it>x</it>)2*<it>x</it>)2)2*<it>x</it>)2)2*<it>x</it>)2*<it>x</it>)2)2)2*<it>x</it>)2)2*<it>x</it>)2)2)2)2)2)2)2)2)2 because 109 = (111,011,100,110,101,100,101,000,000,000)2, algorithm needs 41 multiplications instead of 999,999,999</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.princeton.edu/courses/archive/spr05/cos126/lectures/22.pdf">
Worked example (with modulo) for the RSA algorithm.</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 Example implementations </st>

<ss1>
<st>
 Computation by powers of 2 </st>
<p>

This is a non-recursive implementation of the above algorithm in the <link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby programming language</link>.</p>
<p>

In most <link>
statically typed</link> languages, result=1 must be replaced with code assigning an <link xlink:type="simple" xlink:href="../718/59718.xml">
identity matrix</link> of the same size as x to result to get a matrix exponentiating algorithm. In Ruby, thanks to coercion, result is automatically upgraded to the appropriate type, so this function works with matrices as well as with integers and floats.  Note that n=n-1 is redundant when n=n/2 implicitly rounds towards zero, as lower level languages would do.</p>

<p>

def power(x,n)
result = 1
while n.nonzero?
if n[0].nonzero?
result = result * x
n = n-1
end
x = x*x
n = n/2
end
return result
end</p>

<p>

The following is the <link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link> equivalent program. </p>

<p>

long pow(long x, long n)
{
long result = 1;
while ( n ) {
if ( n &amp; 1 ) {
result *= x;
}
x *= x;
n /= 2;
}
return result;
}</p>


<ss2>
<st>
 Runtime example: Compute 310 </st>
<p>

parameter x =  3
parameter n = 10
result := 1</p>
<p>

<b>Iteration 1</b>
n = 10 -&amp;gt; n is even
x := x2 = 32 = 9
n := n / 2 = 5</p>
<p>

<b>Iteration 2</b>
n = 5 -&amp;gt; n is odd
-&amp;gt; result := result * x = 1 * x = 1 * 32 = 9
n := n - 1 = 4
x := x2 = 92 = 34 = 81
n := n / 2 = 2</p>
<p>

<b>Iteration 3</b>
n = 2 -&amp;gt; n is even
x := x2 = 812 = 38 = 6561
n := n / 2 = 1</p>
<p>

<b>Iteration 4</b>
n = 1 -&amp;gt; n is odd
-&amp;gt; result := result * x = 32 * 38 = 310 = 9 * 6561 = 59049
n := n - 1 = 0</p>
<p>

return result</p>

</ss2>
<ss2>
<st>
 Runtime example: Compute 310 </st>
<p>

result := 3
bin := "1010"</p>
<p>

<b>Iteration for digit 2:</b>
result := result2 = 32 = 9
1<b>0</b>10bin - Digit equals "0"</p>
<p>

<b>Iteration for digit 3:</b>
result := result2 = (32)2 = 34  = 81
10<b>1</b>0bin - Digit equals "1" --&amp;gt;&nbsp;result := result*3 = (32)2*3 = 35  = 243</p>
<p>

<b>Iteration for digit 4:</b>
result := result2 = ((32)2*3)2 = 310  = 59049
101<b>0</b>bin - Digit equals "0"</p>
<p>

return result</p>
<p>

JavaScript-Demonstration: http://home.arcor.de/wzwz.de/wiki/ebs/en.htm</p>

</ss2>
</ss1>
<ss1>
<st>
 Generalization with example </st>

<ss2>
<st>
 Generalization </st>
<p>

Let the pair ( <b>S</b>, <b>*</b> ) be a <link xlink:type="simple" xlink:href="../799/27799.xml">
Semigroup</link>, that means <b>S</b> is an arbitrary <link xlink:type="simple" xlink:href="../691/26691.xml">
set</link>
and <b>*</b> is an <link xlink:type="simple" xlink:href="../335/1335.xml">
associative</link> <link xlink:type="simple" xlink:href="../948/3948.xml">
binary operation</link> on <b>S</b>:
<list>
<entry level="1" type="bullet">

 For all elements a and b of <b>S</b> is <b>a*b</b> also an element of <b>S</b></entry>
<entry level="1" type="bullet">

 For all elements a, b and c of <b>S</b> is valid: <b>(a*b)*c</b> equals <b>a*(b*c)</b></entry>
</list>
</p>
<p>

We may call <b>*</b> a "multiplication" and define an "exponentiation" <b>E</b> in the following way:
For all elements a of <b>S</b>:
<list>
<entry level="1" type="bullet">

 <b>E</b> ( a, 1 ) := a</entry>
<entry level="1" type="bullet">

 For all <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s n &amp;gt; 0 is defined: <b>E</b> ( a, n+1 ) := <b>E</b> ( a, n ) <b>*</b> a</entry>
</list>
</p>
<p>

Now the algorithm exponentiation by squaring may be used for fast computing of <b>E</b>-values.</p>

</ss2>
<ss2>
<st>
Text application</st>
<p>

Because the concatenation <b>+</b> is an associative operation on the set of all finite <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link> over a fixed alphabet
( with the empty string "" as its <link xlink:type="simple" xlink:href="../962/14962.xml">
identity element</link> ) exponentiation by squaring may be used for fast repeating of strings.</p>
<p>

Example using javascript:</p>

<p>

function repeat ( s, n ) {
if ( s == "" || n  1 ) return ""
var res = s
var bin = n.toString ( 2 )
for ( var i = 1 ; i  bin.length ; i++ ) {
res = res + res
if ( bin.charAt ( i ) == '1' ) res = res + s
}
return res
}</p>

<p>

The call <b>repeat ( 'Abc', 6 )</b> returns the string <b>AbcAbcAbcAbcAbcAbc</b></p>

</ss2>
</ss1>
<ss1>
<st>
Calculation of products of powers</st>
<p>

Exponentiation by squaring may also be used to calculate the product of 2 or more powers.
If the underlying group or semigroup is <link xlink:type="simple" xlink:href="../390/294390.xml">
commutative</link> then it is often possible to reduce the
number of multiplication by computing the product simultaneously.</p>

<ss2>
<st>
Example</st>
<p>

The formula a7×b5 may by calculated within 3 steps:
<indent level="1">

((a)2×a)2×a   (four multiplications for calculating a7)
</indent>
:((b)2)2×b     (three multiplications for calculating b5)
<indent level="1">

 (a7)×(b5) (one multiplication to calculate the product of the two)
</indent>
so one gets eight multiplications in total.</p>
<p>

A faster solution is to calculate both powers simultaneously:
<indent level="1">

((a×b)2×a)2×a×b
</indent>
which needs only 6 multiplications in total. Note that a×b is calculated twice, the result could be stored after the first calculation which reduces the count of multiplication to 5.</p>
<p>

Example with numbers:
<indent level="1">

27×35&nbsp;=&nbsp;((2×3)2×2)2×2×3&nbsp;=&nbsp;(62×2)2×6&nbsp;=&nbsp;722×6&nbsp;=&nbsp;31,104
</indent>

Calculating the powers simultaneously instead of calculating them separately always reduces the
count of multiplications if at least two of the exponents are greater than 1.</p>

</ss2>
<ss2>
<st>
 Using transformation </st>
<p>

The example above a7×b5 may also be calculated with only 5
multiplications if the expression is transformed before calculation:</p>
<p>

a7×b5 = a2×(ab)5 with ab := a×b</p>
<p>

ab := a×b (one multiplication)
a2×(ab)5 = ((ab)2×a)2×ab (four multiplications)</p>

<p>

Generalization of transformation shows the following scheme:
For calculating aA×bB×...×mM×nN
1st: define ab := a×b, abc = ab×c, ...
2nd: calculate the transformed expression aA-B×abB-C×...×abc..mM-N×abc..mnN</p>
<p>

Transformation before calculation often reduces the count of multiplications
but in some cases it also increases the count (see the last one of the examples below),
so it may be a good idea to check the count of multiplications before using the transformed expression for calculation.</p>

</ss2>
<ss2>
<st>
 Examples </st>
<p>

For the following expressions the count of multiplications is shown for calculating each power separately,
calculating them simultaneously without transformation and calculating them simultaneously after transformation.</p>
<p>

Example: a7×b5×c3
separate: [((a)2×a)2×a] × [((b)2)2×b] × [(c)2×c] ( <b>11</b> multiplications )
simultaneous: ((a×b)2×a×c)2×a×b×c ( <b>8</b> multiplications )
transformation: a := 2 &nbsp; ab := a×b &nbsp; abc := ab×c ( 2 multiplications )
calculation after that: (a×ab×abc)2×abc ( 4 multiplications ⇒ <b>6</b> in total )</p>
<p>

Example: a5×b5×c3
separate: [((a)2)2×a] × [((b)2)2×b] × [(c)2×c] ( <b>10</b> multiplications )
simultaneous: ((a×b)2×c)2×a×b×c ( <b>7</b> multiplications )
transformation: a := 2 &nbsp; ab := a×b &nbsp; abc := ab×c ( 2 multiplications )
calculation after that: (ab×abc)2×abc ( 3 multiplications ⇒ <b>5</b> in total )</p>
<p>

Example: a7×b4×c1
separate: [((a)2×a)2×a] × [((b)2)2] × [c] ( <b>8</b> multiplications )
simultaneous: ((a×b)2×a)2×a×c ( <b>6</b> multiplications )
transformation: a := 2 &nbsp; ab := a×b &nbsp; abc := ab×c ( 2 multiplications )
calculation after that: (a×ab)2×a×ab×abc ( 5 multiplications ⇒ <b>7</b> in total )</p>

</ss2>
<ss2>
<st>
 Implementation </st>


<p>

// the following javascript function calculates
// Bas [0] ^ Exp [0] x Bas [1] ^ Exp [1] x ...
<b>function productOfPowers_simpleVersion ( Bas , Exp )</b> {
var str // temporary string
// make binary representations:
var maxLen = 0
var bin = new Array ()
for ( var i = 0 ; i  Exp.length ; i++ ) {
str = Exp [i] . toString ( 2 )
bin [i] = str
if ( maxLen  str.length ) maxLen = str.length
}
// make all binaries the same length:
for ( var i = 0 ; i  bin.length ; i++ ) {
while ( bin [i] . length  maxLen ) bin [i] = '0' + bin [i]
}
// calculate:
var result = 1
// . use first binary digits:
for ( var y = 0 ; y  bin.length ; y++ ) {
str = bin [y]
if ( str.charAt ( 0 ) == '1' ) {
if ( result == 1 ) result = Bas [y] ; else result = result * Bas [y]
}
}
// . use remaining digits:
for ( var x = 1 ; x  maxLen ; x++ ) { // x : all digits except first one
result = result * result
for ( var y = 0 ; y  bin.length ; y++ ) { // y : all factors
str = bin [y]
if ( str.charAt ( x ) == '1' ) result = result * Bas [y]
}
}
// ready:
return result
}
//
// for the following function input has to be sorted:
// Exp [0] &amp;gt;= Exp [1] &amp;gt;= ...
<b>function productOfPowers_withTransformation ( Bas , Exp )</b> {
// new bases:
var tempBas = new Array ()
tempBas [0] = Bas [0]
for ( var i = 1 ; i  Bas.length ; i++ ) tempBas [i] = Bas [i] * tempBas [i-1]
// new exponents:
var tempExp = new Array ()
for ( var i = 0 ; i  Exp.length - 1 ; i++ ) tempExp [i] = Exp [i] - Exp [i+1]
tempExp [Exp.length-1] = Exp [Exp.length-1]
// now compress:
var basTrans = new Array ()
var expTrans = new Array ()
for ( var i = 0 ; i  tempExp.length ; i++ ) if ( tempExp [i] &amp;gt; 0 ) {
basTrans.push ( tempBas [i] )
expTrans.push ( tempExp [i] )
}
// ready:
return productOfPowers_simpleVersion ( basTrans , expTrans )
}
// <b>now let's test it:</b>
alert ( 'S1: ' + productOfPowers_simpleVersion      ( [ 2 , 3 ] , [ 7 , 5 ] ) ) // should be 31,104
alert ( 'T1: ' + productOfPowers_withTransformation ( [ 2 , 3 ] , [ 7 , 5 ] ) ) // once again: 31,104
alert ( 'T2: ' + productOfPowers_withTransformation ( [ 2 , 5 , 3 ] , [ 4 , 3 , 2 ] ) ) // 18,000
alert ( 'T3: ' + productOfPowers_withTransformation ( [ 2 , 5 , 3 ] , [ 3 , 3 , 2 ] ) ) //  9,000
alert ( 'T4: ' + productOfPowers_withTransformation ( [ 2 , 5 , 3 ] , [ 4 , 3 , 3 ] ) ) // 54,000
alert ( 'T5: ' + productOfPowers_withTransformation ( [ 2 , 5 , 3 ] , [ 3 , 3 , 3 ] ) ) // 27,000</p>


</ss2>
</ss1>
</sec>
<sec>
<st>
Variation</st>
<p>

From practical standpoint the following modification is also useful:</p>
<p>

<math>
\mbox{Power}(x,\,n)=
  \begin{cases} 1, &amp; \mbox{if }n\mbox{ = 0} \\ 
                x\times \left(\mbox{Power}(x,\,\frac{n-1}{2})\right)^2, &amp; \mbox{if }n\mbox{ is odd} \\
                \left(\mbox{Power}(x,\,\frac{n}{2})\right)^2, &amp; \mbox{if }n\mbox{ is even}
\end{cases}
</math></p>
<p>

It is very similar in properties to aforementioned approach. While recursion is a natural way for calculation, it can be easily translated to iterative form. It also might provide some computational advantage (e.g., in case of small <it>x</it> and <it>n</it> = 3*2<it>m</it>) as well as memory consumption reduction.</p>

</sec>
<sec>
<st>
Alternatives and generalizations</st>

<p>

<indent level="1">

<it>Main article: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../356/856356.xml">
Addition-chain exponentiation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it>
</indent>
Exponentiation by squaring can be viewed as a suboptimal <link xlink:type="simple" xlink:href="../356/856356.xml">
addition-chain exponentiation</link> algorithm: it computes the exponent via an <link xlink:type="simple" xlink:href="../656/578656.xml">
addition chain</link> consisting of repeated exponent doublings (squarings) and/or incrementing exponents by <it>one</it> (multiplying by <it>x</it>) only.  More generally, if one allows <it>any</it> previously computed exponents to be summed (by multiplying those powers of <it>x</it>), one can sometimes perform the exponentiation using fewer multiplications (but typically using more memory).  The smallest power where this occurs is for <it>n</it>=15:</p>
<p>

<indent level="1">

<math>a^{15} = x \times (x \times [x \times x^2]^2)^2  \!</math>  (squaring, 6 multiplies)
</indent>
:<math>a^{15} = x^3 \times ([x^3]^2)^2  \!</math> (optimal addition chain, 5 multiplies if <it>x</it>3 is re-used)</p>
<p>

In general, finding the <it>optimal</it> addition chain for a given exponent is a hard problem, for which no efficient algorithms are known, so optimal chains are typically only used for small exponents (e.g. in <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>s where the chains for small powers have been pre-tabulated).  However, there are a number of <link xlink:type="simple" xlink:href="../452/63452.xml">
heuristic</link> algorithms that, while not being optimal, have fewer multiplications than exponentiation by squaring at the cost of additional bookkeeping work and memory usage.  Regardless, the number of multiplications never grows more slowly than <link xlink:type="simple" xlink:href="../578/44578.xml">
&amp;Theta;</link>(log <it>n</it>), so these algorithms only improve asymptotically upon exponentiation by squaring by a constant factor at best.</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
