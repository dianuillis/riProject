<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:20:46[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Algorithms for calculating variance</title>
<id>1063</id>
<revision>
<id>238551525</id>
<timestamp>2008-09-15T10:12:53Z</timestamp>
<contributor>
<username>Lese</username>
<id>206932</id>
</contributor>
</revision>
<categories>
<category>Statistical algorithms</category>
<category>Statistical deviation and dispersion</category>
<category>Articles with example pseudocode</category>
</categories>
</header>
<bdy>

<b><link xlink:type="simple" xlink:href="../775/775.xml">
Algorithm</link>s for calculating <link xlink:type="simple" xlink:href="../344/32344.xml">
variance</link></b> play a major role in <link xlink:type="simple" xlink:href="../685/26685.xml">
statistical</link> computing. A key problem in the design of good algorithms for this problem is that formulas for the variance may involve sums of squares, which can lead to <link xlink:type="simple" xlink:href="../807/233807.xml">
numerical instability</link> as well as to <link xlink:type="simple" xlink:href="../724/40724.xml">
arithmetic overflow</link> when dealing with large values.
<sec>
<st>
 I. Naïve algorithm </st>
<p>

The <link xlink:type="simple" xlink:href="../040/164040.xml">
formula</link> for calculating the variance of an entire <link xlink:type="simple" xlink:href="../585/27585.xml">
population</link> of size <it>n</it> is:</p>
<p>

<indent level="1">

<math>\sigma^2 = \displaystyle\frac {\sum_{i=1}^{n} x_i^2 - (\sum_{i=1}^{n} x_i)^2/n}{n}. \!</math>
</indent>

The formula for calculating an <link xlink:type="simple" xlink:href="../479/8450479.xml">
unbiased</link> estimate of the population variance from a finite <link xlink:type="simple" xlink:href="../586/27586.xml">
sample</link> of <it>n</it> observations is:</p>
<p>

<indent level="1">

<math>s^2 = \displaystyle\frac {\sum_{i=1}^{n} x_i^2 - (\sum_{i=1}^{n} x_i)^2/n}{n-1}. \!</math>
</indent>

Therefore a naive algorithm to calculate the estimated variance is given by the following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>: </p>
<p>

n = 0
sum = 0
sum_sqr = 0</p>
<p>

foreach x in data:
n = n + 1
sum = sum + x
sum_sqr = sum_sqr + x*x
end for</p>
<p>

mean = sum/n
variance = (sum_sqr - sum*mean)/(n - 1)</p>
<p>

This algorithm can easily be adapted to compute the variance of a finite population: simply divide by <it>n</it> instead of <it>n</it> &amp;minus; 1 on the last line.</p>
<p>

Because sum_sqr and sum * mean can be very similar numbers, the <link xlink:type="simple" xlink:href="../110/552110.xml">
precision</link> of the result can be much less than the inherent precision of the <link xlink:type="simple" xlink:href="../376/11376.xml">
floating-point</link> arithmetic used to perform the computation.  This is particularly bad if the variance is small relative to the sum of the numbers.</p>

</sec>
<sec>
<st>
 II. Two-pass algorithm </st>
<p>

An alternate approach, using a different formula for the variance, is given by the following pseudocode:</p>
<p>

n = 0
sum1 = 0
foreach x in data:
n = n + 1
sum1 = sum1 + x
end for
mean = sum1/n</p>
<p>

sum2 = 0
foreach x in data:
sum2 = sum2 + (x - mean)^2
end for
variance = sum2/(n - 1)</p>
<p>

This algorithm is often more numerically reliable than the naïve <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22I.+Na=C3=AFve+algorithm%22])">
algorithm I</link> for large sets of data, although it can be worse if much of the data is very close to but not precisely equal to the mean and some are quite far away from it.</p>
<p>

The results of both of these simple algorithms (I and II) can depend inordinately on the ordering of the data and can give poor results for very large data sets due to repeated roundoff error in the accumulation of the sums. Techniques such as <link xlink:type="simple" xlink:href="../216/373216.xml">
compensated summation</link> can be used to combat this error to a degree.</p>

<ss1>
<st>
 IIa. Compensated variant </st>
<p>

The compensated-summation version of the algorithm above reads:</p>
<p>

n = 0
sum1 = 0
foreach x in data:
n = n + 1
sum1 = sum1 + x
end for
mean = sum1/n</p>
<p>

sum2 = 0
sumc = 0
foreach x in data:
sum2 = sum2 + (x - mean)^2
sumc = sumc + (x - mean)
end for
variance = (sum2 - sumc^2/n)/(n - 1)</p>

</ss1>
</sec>
<sec>
<st>
 III. On-line algorithm </st>
<p>

It is often useful to be able to compute the variance in a single pass, inspecting each value <math>x_i</math> only once; for example, when the data are being collected without enough storage to keep all the values, or when costs of memory access dominate those of computation.  For such an <link xlink:type="simple" xlink:href="../716/22716.xml">
online algorithm</link>, a <link xlink:type="simple" xlink:href="../806/146806.xml">
recurrence relation</link> is required between quantities from which the required statistics can be calculated in a numerically stable fashion.</p>
<p>

The following formulas can be used to update the <link xlink:type="simple" xlink:href="../192/19192.xml">
mean</link> and (estimated) variance of the sequence, for an additional element <math>x_{\mathrm{new}}</math>. Here, <it>m</it> denotes the estimate of the population mean(using the sample mean), <it>s</it>2n-1 the estimate of the population variance, <it>s</it>2n the estimate of the sample variance, and <it>n</it> the number of elements in the sequence before the addition.</p>
<p>

<indent level="1">

<math>m_{\mathrm{new}} = \frac{n \; m_{\mathrm{old}} + x_{\mathrm{new}}}{n+1} = m_{\mathrm{old}} + \frac{x_{\mathrm{new}} - m_{\mathrm{old}}}{n+1} \!</math>
</indent>

<indent level="1">

<math>s^2_{\mathrm{n-1, new}} = \frac{(n-1) \; s^2_{\mathrm{n-1, old}} + (x_{\mathrm{new}} - m_{\mathrm{new}}) \, (x_{\mathrm{new}} - m_{\mathrm{old}})}{n} \; \; \, \,  \; \,     \mathrm{n&amp;gt;0} \!</math>
</indent>

<indent level="1">

<math>s^2_{\mathrm{n, new}} = \frac{n \; s^2_{\mathrm{n, old}} + (x_{\mathrm{new}} - m_{\mathrm{new}}) \, (x_{\mathrm{new}} - m_{\mathrm{old}})}{n+1}.</math>
</indent>

It turns out that a more suitable quantity for updating is the sum of squares of differences from the (current) mean, <math>\sum_{i=1}^n (x_i - m)^2</math>, here denoted <math>M_2</math>:</p>
<p>

<indent level="1">

<math>M_\mathrm{2,new}\! = M_\mathrm{2,old} + (x_\mathrm{new} - m_\mathrm{old})(x_\mathrm{new} - m_\mathrm{new})</math>
</indent>
:<math>s^2_\mathrm{n} = \frac{M_2}{n}</math>
<indent level="1">

<math>s^2_\mathrm{n-1} = \frac{M_2}{n-1}</math>
</indent>

A numerically stable algorithm is given below.  It also computes the mean.
This algorithm is due to Knuth,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
who cites Welford.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

n = 0
mean = 0
M2 = 0</p>
<p>

foreach x in data:
n = n + 1
delta = x - mean
mean = mean + delta/n
M2 = M2 + delta*(x - mean)      // This expression uses the new value of mean
end for</p>
<p>

variance_n = M2/n
variance = M2/(n - 1)</p>
<p>

This algorithm is much less prone to loss of precision due to massive cancellation, but might not be as efficient because of the division operation inside the loop.  For a particularly robust two-pass algorithm for computing the variance, first compute and subtract an estimate of the mean, and then use this algorithm on the residuals.</p>
<p>

A slightly more convenient form allows one to calculate the standard deviation without having to explicitly calculate the new mean. If <math>n</math> is the number of elements in the sequence after the addition of the new element, then one has</p>
<p>

<math>s^2_{\mathrm{n-1, new}} = \frac{(n-2)s^2_{\mathrm{n-1, old}}+\frac{n-1}{n}\left(x_\text{new}-m_\text{old}\right)^2}{n-1}</math></p>

</sec>
<sec>
<st>
 IV. Weighted incremental algorithm </st>
<p>

When the observations are weighted, West (1979) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> suggests this incremental algorithm:</p>
<p>

n = 0
foreach x in the data:
if n=0 then 
n = 1
mean = x
S = 0
sumweight = weight
else
n = n + 1
temp = weight + sumweight
S = S + sumweight*weight*(x-mean)^2 / temp
mean = mean + (x-mean)*weight / temp
sumweight = temp
end if
end for
Variance = S * n / ((n-1) * sumweight)  // if sample is the population, omit n/(n-1)</p>

</sec>
<sec>
<st>
 V. Parallel algorithm </st>
<p>

Chan et al.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> note that the above on-line algorithm III is a special case of an algorithm that works for any partition of the sample <math>X</math> into sets <math>X^A</math>, <math>X^B</math>:
<indent level="1">

<math>\delta\! = m^B - m^A</math>
</indent>
:<math>m^X = m^A + \delta\cdot\frac{N^B}{N^X}</math>
<indent level="1">

<math>M_2^X = M_2^A + M_2^B + \delta^2\cdot\frac{N^A N^B}{N^X}</math>.
</indent>
This may be useful when, for example, multiple processing units may be assigned to discrete parts of the input.</p>

<ss1>
<st>
 Higher-order statistics </st>
<p>

Terriberry<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> extends Chan's formulae to calculating the third and fourth <link xlink:type="simple" xlink:href="../983/19983.xml">
central moment</link>s, needed for example when estimating <link xlink:type="simple" xlink:href="../212/28212.xml">
skewness</link> and <link xlink:type="simple" xlink:href="../848/16848.xml">
kurtosis</link>:
<indent level="1">

<math>M_3^X = M_3^A + M_3^B + \delta^3\frac{N^A N^B (N^A - N^B)}{(N^X)^2} + 3\delta\frac{N^AM_2^B - N^BM_2^A}{N^X}</math>
</indent>
:<math>\begin{align}
M_4^X = M_4^A + M_4^B &amp; + \delta^4\frac{N^A N^B \left((N^A)^2 - N^A N^B + (N^B)^2\right)}{(N^X)^3} \\
                    &amp; + 6\delta^2\frac{(N^A)^2 M_2^B + (N^B)^2 M_2^A}{(N^X)^2} + 4\delta\frac{N^AM_3^B - N^BM_3^A}{N^X} \\
\end{align}</math></p>
<p>

Here the <math>M_k</math> are again the sums of powers of differences from the mean <math>\Sigma(x - \overline{x})^k</math>, giving
<indent level="1">

skewness: <math>g_1 = \frac{\sqrt{n} M_3}{M_2^{3/2}},</math>
</indent>
:kurtosis: <math>g_2 = \frac{n M_4}{M_2^2}.</math></p>
<p>

For the incremental case (i.e., <math>B = \{x\}</math>), this simplifies to:
<indent level="1">

<math>\delta\! = x - m</math>
</indent>
:<math>m' = m + \frac{\delta}{n}</math>
<indent level="1">

<math>M_2' = M_2 + \delta^2 \frac{ n-1}{n}</math>
</indent>
:<math>M_3' = M_3 + \delta^3 \frac{ (n - 1) (n - 2)}{n^2} - \frac{3\delta M_2}{n}</math>
<indent level="1">

<math>M_4' = M_4 + \frac{\delta^4 (n - 1) (n^2 - 3n + 3)}{n^3} + \frac{6\delta^2 M_2}{n^2} - \frac{4\delta M_3}{n}</math>
</indent>

It should be noted that by preserving the value <math>\delta / n</math>, only one division operation is needed and thus that the higher-order statistics can be calculated for little incremental cost.</p>

</ss1>
</sec>
<sec>
<st>
 Example </st>
<p>

Assume that all floating point operations use the standard <link xlink:type="simple" xlink:href="../039/405039.xml#xpointer(//*[./st=%22Double-precision+64+bit%22])">
IEEE 754 double-precision</link> arithmetic. Consider the sample (4, 7, 13, 16) from an infinite population. Based on this sample, the estimated population mean is 10, and the unbiased estimate of population variance is 30.  Both Algorithm I and Algorithm II compute these values correctly.  Next consider the sample (108&nbsp;+&nbsp;4, 108&nbsp;+&nbsp;7, 108&nbsp;+&nbsp;13, 108&nbsp;+&nbsp;16), which gives rise to the same estimated variance as the first sample.  Algorithm II computes this variance estimate correctly, but Algorithm I returns 29.333333333333332 instead of 30.  While this loss of precision may be tolerable and viewed as a minor flaw of Algorithm I, it is easy to find data that reveal a major flaw in the naive algorithm: Take the sample to be (109&nbsp;+&nbsp;4, 109&nbsp;+&nbsp;7, 109&nbsp;+&nbsp;13, 109&nbsp;+&nbsp;16).  Again the estimated population variance of 30 is computed correctly by Algorithm II, but the naive algorithm now computes it as &amp;minus;170.66666666666666.  This is a serious problem with Algorithm I, since the variance can, by definition, never be negative.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../934/12456934.xml">
Computational formula for the variance</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald E. Knuth</link> (1998). <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, volume 2: <it>Seminumerical Algorithms</it>, 3rd edn., p. 232. Boston: Addison-Wesley.</entry>
<entry id="2">
B. P. Welford (1962).<weblink xlink:type="simple" xlink:href="http://www.jstor.org/view/00401706/ap040015/04a00090/0">
"Note on a method for calculating corrected sums of squares and products"</weblink>. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../084/5854084.xml">
Technometrics</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it> 4(3):419–420.</entry>
<entry id="3">
D. H. D. West (1979). <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>, 22, 9, 532-535: <it>Updating Mean and Variance Estimates: An Improved Method''</it></entry>
<entry id="4">
 <cite id="CITEREFChanGolubLeVeque1979" style="font-style:normal">Chan, Tony F.; <link>
Golub, Gene H.</link>&#32;&amp;&#32;LeVeque, Randall J.&#32;(1979),&#32;<weblink xlink:type="simple" xlink:href="ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf">
"Updating Formulae and a Pairwise Algorithm for Computing Sample Variances."</weblink>,&#32;<it>Technical Report STAN-CS-79-773</it>, Department of Computer Science, Stanford University</cite>&nbsp;.</entry>
<entry id="5">
 <cite id="CITEREFTerriberry2007" style="font-style:normal">Terriberry, Timothy B.&#32;(2007),&#32;<it><weblink xlink:type="simple" xlink:href="http://people.xiph.org/~tterribe/notes/homs.html">
Computing Higher-Order Moments Online</weblink></it>, </cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Mathworld-Sample Variance Computation"><physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<encyclopedist wordnetid="110055566" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../189/836189.xml">
Eric W. Weisstein</link></scholar>
</mathematician>
</writer>
</scientist>
</causal_agent>
</alumnus>
</compiler>
</encyclopedist>
</intellectual>
</person>
</communicator>
</physical_entity>
, <it><weblink xlink:type="simple" xlink:href="http://mathworld.wolfram.com/SampleVarianceComputation.html">
Sample Variance Computation</weblink></it> at <computer wordnetid="103082979" confidence="0.8">
<work wordnetid="104599396" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<encyclopedia wordnetid="106427387" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../235/374235.xml">
MathWorld</link></web_site>
</device>
</book>
</instrumentality>
</artifact>
</product>
</encyclopedia>
</publication>
</reference_book>
</machine>
</creation>
</work>
</computer>
.</cite></entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
