<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:25:34[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<model  confidence="0.9511911446218017" wordnetid="110324560">
<know-how  confidence="0.8" wordnetid="105616786">
<method  confidence="0.8" wordnetid="105660268">
<header>
<title>Finite state machine</title>
<id>10931</id>
<revision>
<id>242413824</id>
<timestamp>2008-10-02T03:37:08Z</timestamp>
<contributor>
<username>PseudoBot</username>
<id>6290400</id>
</contributor>
</revision>
<categories>
<category>Digital electronics</category>
<category>Automata</category>
<category>Computational models</category>
<category>Formal methods</category>
</categories>
</header>
<bdy>

"State machine" redirects here. For infinite state machines, see <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../417/396417.xml">
State transition system</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
.<p>

<image location="right" width="225px" src="Finite_state_machine_example_with_comments.svg" type="thumb">
<caption>

Fig.1 Example of a Finite State Machine
</caption>
</image>
</p>
<p>

A <b>finite state machine (FSM)</b> or <b>finite state automaton</b> (plural: <it>automata</it>) or simply a <b>state machine</b>, is a model of behavior composed of a finite number of <link xlink:type="simple" xlink:href="../512/285512.xml">
state</link>s, transitions between those states, and actions. A finite state machine is an abstract model of a machine with a primitive internal memory.</p>

<sec>
<st>
Concepts and vocabulary</st>
<p>

A current <it>state</it> is determined by past states of the system. As such, it can be said to record information about the past, i.e. it reflects the input changes from the system start to the present moment. A <it>transition</it> indicates a state change and is described by a condition that would need to be fulfilled to enable the transition. An <it>action</it> is a description of an activity that is to be performed at a given moment. There are several action types:
<list>
<entry level="1" type="definition">

Entry action: which is performed <it>when entering</it> the state</entry>
<entry level="1" type="definition">

Exit action: which is performed <it>when exiting</it> the state</entry>
<entry level="1" type="definition">

Input action: which is performed depending on present state and input conditions</entry>
<entry level="1" type="definition">

Transition action: which is performed when performing a certain transition</entry>
</list>
</p>
<p>

An FSM can be represented using a <link xlink:type="simple" xlink:href="../337/187337.xml">
state diagram</link> (or state transition diagram) as in figure 1 above. Besides this, several <link xlink:type="simple" xlink:href="../857/548857.xml">
state transition table</link> types are used. The most common representation is shown below: the combination of current state (B) and condition (Y) shows the next state (C). The complete actions information can be added only using footnotes. An FSM definition including the full actions information is possible using <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../085/1296085.xml#xpointer(//*[./st=%22State+Table%22])">
state tables</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 (see also <link>
VFSM</link>). </p>
<p>

<table align="center" cellpadding="5" border="1" cellspacing="0">
<caption >
State transition table</caption>
<row>
<col valign="top">
&nbsp;&nbsp;&nbsp;Current State →Condition</col>
<col>
State A</col>
<col>
State B</col>
<col>
State C</col>
</row>
<row>
<col>
Condition X</col>
<col>
...</col>
<col>
...</col>
<col>
...</col>
</row>
<row>
<col>
Condition Y</col>
<col>
...</col>
<col>
State C</col>
<col>
...</col>
</row>
<row>
<col>
Condition Z</col>
<col>
...</col>
<col>
...</col>
<col>
...</col>
</row>
</table>
</p>
<p>

In addition to their use in modeling reactive systems presented here, finite state automata are significant in many different areas, including <link xlink:type="simple" xlink:href="../531/9531.xml">
electrical engineering</link>, <link xlink:type="simple" xlink:href="../526/17526.xml">
linguistics</link>, <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <link xlink:type="simple" xlink:href="../155/13692155.xml">
philosophy</link>, <link xlink:type="simple" xlink:href="../632/9127632.xml">
biology</link>, <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematic</link>s, and <link xlink:type="simple" xlink:href="../225/3729225.xml">
logic</link>.  A complete survey of their applications is outside the scope of this article.  Finite state machines are a class of automata studied in <link xlink:type="simple" xlink:href="../356/103356.xml">
automata theory</link> and the <link xlink:type="simple" xlink:href="../402/30402.xml">
theory of computation</link>.
In computer science, finite state machines are widely used in modeling of application behavior, design of hardware digital systems, software engineering, compilers, network protocols, and the study of computation and languages.</p>

</sec>
<sec>
<st>
Classification</st>
<p>

There are two different groups: Acceptors/Recognizers and Transducers.</p>

<ss1>
<st>
Acceptors and recognizers</st>
<p>

<image location="right" width="400px" src="Fsm_parsing_word_nice.svg" type="thumb">
<caption>

Fig. 2 Acceptor FSM: parsing the word "nice"
</caption>
</image>
</p>
<p>

<b>Acceptors</b> and <b>recognizers</b> (also <b>sequence detectors</b>) produce a binary output, saying either <it>yes</it> or <it>no</it> to answer whether the input is accepted by the machine or not. All states of the FSM are said to be either accepting or not accepting.  At the time when all input is processed, if the current state is an accepting state, the input is accepted; otherwise it is rejected. As a rule the input are symbols (characters); actions are not used. The example in figure 2 shows a finite state machine which accepts the word "nice". In this FSM the only accepting state is number 7.</p>
<p>

The machine can also be described as defining a language, which would contain every word accepted by the machine but none of the rejected ones; we say then that the language is <it>accepted</it> by the machine. By definition, the languages accepted by FSMs are the <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>s - that is, a language is regular if there is some FSM that accepts it.</p>

<ss2>
<st>
 Start state </st>
<p>

The start state is usually shown drawn with an arrow "pointing at it from nowhere" (Sipser (2006) p.34).</p>

</ss2>
<ss2>
<st>
Accept state</st>
<p>

<image location="right" width="220px" src="DFAexample.svg" type="thumb">
<caption>

Fig. 3: A finite state machine that determines if a binary number has an odd or even number of 0s.
</caption>
</image>

An <b>accept state</b> (sometimes referred to as an <b>accepting state</b>) is a state at which the machine has successfully performed its procedure. It is usually represented by a double circle.</p>
<p>

An example of an accepting state appears on the left in this diagram of a <link xlink:type="simple" xlink:href="../404/653404.xml">
deterministic finite automaton</link> (DFA) which determines if the <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link></instrumentality>
</artifact>
</system>
 input contains an even number of 0s.  </p>
<p>

<it>S</it>1 (which is also the start state) indicates the state at which an even number of 0s has been input and is therefore defined as an accepting state.  This machine will give a correct end state if the binary number contains an even number of zeros including a string with no zeros.  Examples of strings accepted by this DFA are epsilon (the empty string), 1, 11, 11..., 00, 010, 1010, 10110 and so on.</p>

</ss2>
</ss1>
<ss1>
<st>
Transducers</st>
<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../289/1071289.xml">
Transducers</link></language>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 generate output based on a given input and/or a state using actions. They are used for control applications and in the field of <link xlink:type="simple" xlink:href="../561/5561.xml">
computational linguistics</link>. Here two types are distinguished:</p>
<p>

<list>
<entry level="1" type="definition">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../020/353020.xml">
Moore machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
: The FSM uses only entry actions, i.e. output depends only on the state. The advantage of the Moore model is a simplification of the behaviour. The example in figure 1 shows a Moore FSM of an elevator door. The state machine recognizes two commands: "command_open" and "command_close" which trigger state changes. The entry action (E:) in state "Opening" starts a motor opening the door, the entry action in state "Closing" starts a motor in the other direction closing the door. States "Opened" and "Closed" don't perform any actions. They signal to the outside world (e.g. to other state machines) the situation: "door is open" or "door is closed".</entry>
</list>
</p>
<p>

<image location="right" width="350px" src="Fsm_mealy_model_door_control.jpg" type="thumb">
<caption>

Fig. 4 Transducer FSM: Mealy model example
</caption>
</image>

<list>
<entry level="1" type="definition">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/331512.xml">
Mealy machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
: The FSM uses only input actions, i.e. output depends on input and state. The use of a Mealy FSM leads often to a reduction of the number of states. The example in figure 4 shows a Mealy FSM implementing the same behaviour as in the Moore example (the behaviour depends on the implemented FSM execution model and will work e.g. for <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../085/1296085.xml">
virtual FSM</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 but not for <link xlink:type="simple" xlink:href="../752/1295752.xml">
event driven FSM</link>). There are two input actions (I:): "start motor to close the door if command_close arrives" and "start motor in the other direction to open the door if command_open arrives".</entry>
</list>
</p>
<p>

In practice mixed models are often used.</p>
<p>

More details about the differences and usage of Moore and Mealy models, including an executable example, can be found in the external technical note <weblink xlink:type="simple" xlink:href="http://www.stateworks.com/active/content/en/technology/technical_notes.php#tn10">
"Moore or Mealy model?"</weblink></p>
<p>

A further distinction is between <b>deterministic</b> (<link xlink:type="simple" xlink:href="../404/653404.xml">
DFA</link>) and <b>non-deterministic</b> (<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
NDFA</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
, <link xlink:type="simple" xlink:href="../415/653415.xml">
GNFA</link>) automata. In deterministic automata, for each state there is exactly one transition for each possible input. In non-deterministic automata, there can be none, one, or more than one transition from a given state for a given possible input.  This distinction is relevant in practice, but not in theory, as there exists an algorithm which can transform any NDFA into an equivalent DFA, although this transformation typically significantly increases the complexity of the automaton.</p>
<p>

The FSM with only one state is called a combinatorial FSM and uses only input actions. This concept is useful in cases where a number of FSM are required to work together, and where it is convenient to consider a purely combinatorial part as a form of FSM to suit the design tools.</p>

</ss1>
</sec>
<sec>
<st>
FSM logic</st>
<p>

<image location="right" width="200px" src="Finite_State_Machine_Logic.svg" type="thumb">
<caption>

Fig. 5 FSM Logic (Mealy)
</caption>
</image>
</p>
<p>

The next state and output of an FSM is a function of the input and of the current state. The FSM logic is shown in Figure 5.</p>

</sec>
<sec>
<st>
Mathematical model</st>
<p>

Depending on the type there are several definitions. An <b>acceptor</b> finite-state machine is a <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
quintuple</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
 <math>(\Sigma, S, s_0, \delta, F)</math>, where:
<list>
<entry level="1" type="bullet">

<math>\Sigma</math> is the input <link xlink:type="simple" xlink:href="../269/4292269.xml">
alphabet</link> (a finite, non-empty set of symbols).</entry>
<entry level="1" type="bullet">

<math>S</math> is a finite, non-empty set of states.</entry>
<entry level="1" type="bullet">

<math>s_0</math> is an initial state, an element of <math>S</math>. In a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
Nondeterministic finite state machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
, <math>s_0</math> is a set of initial states.</entry>
<entry level="1" type="bullet">

<math>\delta</math> is the state-transition function: <math>\delta: S \times \Sigma \rightarrow S</math>.</entry>
<entry level="1" type="bullet">

<math>F</math> is the set of final states, a (possibly empty) subset of <math>S</math>.</entry>
</list>
</p>
<p>

A <link xlink:type="simple" xlink:href="../289/1071289.xml">
finite state transducer</link> is a sextuple <math>(\Sigma, \Gamma, S, s_0, \delta, \omega)</math>, where:
<list>
<entry level="1" type="bullet">

<math>\Sigma</math> is the input <link xlink:type="simple" xlink:href="../269/4292269.xml">
alphabet</link> (a finite non empty set of symbols).</entry>
<entry level="1" type="bullet">

<math>\Gamma</math> is the output alphabet (a finite, non-empty set of symbols).</entry>
<entry level="1" type="bullet">

<math>S</math> is a finite, non-empty set of states.</entry>
<entry level="1" type="bullet">

<math>s_0</math> is the initial state, an element of <math>S</math>. In a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
Nondeterministic finite state machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
, <math>s_0</math> is a set of initial states.</entry>
<entry level="1" type="bullet">

<math>\delta</math> is the state-transition function: <math>\delta: S \times \Sigma \rightarrow S</math>.</entry>
<entry level="1" type="bullet">

<math>\omega</math> is the output function.</entry>
</list>
</p>
<p>

If the output function is a function of a state and input alphabet (<math>\omega: S \times \Sigma \rightarrow \Gamma</math>) that definition corresponds to the <b>Mealy model</b>, and can be modelled as a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/331512.xml">
Mealy machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
. If the output function depends only on a state (<math>\omega: S \rightarrow \Gamma</math>) that definition corresponds to the <b>Moore model</b>, and can be modelled as a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../020/353020.xml">
Moore machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
. A finite-state machine with no output function at all is known as a <link xlink:type="simple" xlink:href="../937/10766937.xml">
semiautomaton</link> or <link xlink:type="simple" xlink:href="../417/396417.xml">
transition system</link>.</p>

</sec>
<sec>
<st>
Optimization</st>
<p>

Optimizing an FSM means finding the machine with the minimum number of states that performs the same function. The fastest known algorithm doing this is the Hopcroft minimization algorithm.<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Finite_state_machine#endnote_hopcroft1">
http://localhost:18088/wiki/index.php/Finite_state_machine#endnote_hopcroft1</weblink><weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Finite_state_machine#endnote_AlmeidaEtAl">
http://localhost:18088/wiki/index.php/Finite_state_machine#endnote_AlmeidaEtAl</weblink>. Other techniques include using an <link xlink:type="simple" xlink:href="../376/8426376.xml">
Implication table</link>, or the <link xlink:type="simple" xlink:href="../215/8433215.xml">
Moore reduction procedure</link>. Additionally, acyclic FSAs can be optimized using a simple bottom up algorithm<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Finite_state_machine#endnote_minimization1">
http://localhost:18088/wiki/index.php/Finite_state_machine#endnote_minimization1</weblink>.</p>

</sec>
<sec>
<st>
Implementation</st>

<ss1>
<st>
Hardware applications</st>
<p>

<image location="right" width="500px" src="4_bit_counter.png" type="thumbnail">
<caption>

Fig. 6 The <link xlink:type="simple" xlink:href="../339/587339.xml">
circuit diagram</link> for a 4 bit <link xlink:type="simple" xlink:href="../769/47769.xml">
TTL</link> counter, a type of state machine
</caption>
</image>
In a <link xlink:type="simple" xlink:href="../068/39068.xml">
digital circuit</link>, an FSM may be built using a <link xlink:type="simple" xlink:href="../215/73215.xml">
programmable logic device</link>, a <link xlink:type="simple" xlink:href="../992/24992.xml">
programmable logic controller</link>, <link xlink:type="simple" xlink:href="../168/18168.xml">
logic gate</link>s and <link xlink:type="simple" xlink:href="../777/11777.xml">
flip flop</link>s or <link xlink:type="simple" xlink:href="../590/26590.xml">
relay</link>s. More specifically, a hardware implementation requires a <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link> to store state variables, a block of combinational logic which determines the state transition, and a second block of combinational logic that determines the output of an FSM.  One of the classic hardware implementations is the <link xlink:type="simple" xlink:href="../961/7706961.xml">
Richard's Controller</link>.</p>

</ss1>
<ss1>
<st>
 Software applications </st>
<p>

The following concepts are commonly used to build software applications with finite state machines:
<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../752/1295752.xml">
event driven FSM</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../085/1296085.xml">
virtual FSM (VFSM)</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../755/3377755.xml">
Automata-Based Programming</link></entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../836/2575836.xml">
Abstract state machine</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../572/433572.xml">
Decision tables</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../259/6965259.xml">
Extended finite state machine</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../109/11693109.xml">
Finite state machine with datapath</link></entry>
<entry level="1" type="bullet">

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../192/225192.xml">
Petri net</link></language>
</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../510/24510.xml">
Pushdown automaton</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../008/7926008.xml">
Quantum finite automata</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../374/89374.xml">
Sequential logic</link></entry>
<entry level="1" type="bullet">

<link>
Statechart</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../417/396417.xml">
Transition system</link></entry>
<entry level="1" type="bullet">

<invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 </entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../770/98770.xml">
Hidden Markov model</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../987/2997987.xml">
Ant Wars</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../769/1654769.xml">
Game AI</link></entry>
<entry level="1" type="bullet">

<format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../592/5171592.xml">
SCXML</link></format>
</entry>
</list>
</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?query=finite+state+machine">
Description from the Free On-Line Dictionary of Computing</weblink></entry>
<entry level="1" type="bullet">

NIST Dictionary of Algorithms and Data Structures <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/finiteStateMachine.html">
entry</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.eventhelix.com/RealtimeMantra/HierarchicalStateMachine.htm">
Hierarchical State Machines</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.troyworks.com/cogs/">
COGs</weblink> - Cogs is a open source, small FSM and HSM ( hierarchical state machine) library for use with Flash / Flex Actionscript 3.0 projects.  An introductory talk <weblink xlink:type="simple" xlink:href="http://link.brightcove.com/services/player/bcpid1733261879?bclid=1729365228&amp;bctid=1743215121">
here</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/fsmgenerator/">
FSM Generator</weblink> - FSMGenerator is a turn-key solution for FSM (Finite State Machine) automatic generation and integration within user's software</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/fsmdesigner/">
FSM Designer</weblink> - An open-source tool for the graphical development of FSMs and automatic Verilog code generation</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.intelliwizard.com">
Round-trip Engineering State Machines</weblink> 	</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.sccs.swarthmore.edu/users/06/adem/engin/e15/lab4/">
Using state machines in practical applications</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://leotools.atwebpages.com/">
Tool for design and visualization of Finite State Machines</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.sinelabore.com">
sinelaboreRT</weblink> - generates human readable c-code from state-charts especially targeting embedded real-time systems</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.augeas.net/libfa/index.html">
libfa</weblink> - An open-source C library for automata computations</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://smc.sourceforge.net/">
The State Machine Compiler</weblink> - A tool to model and compile statemachines for a number of languages; java, C# etc. As well as display them as graphically.</entry>
<entry level="1" type="bullet">

  <cite id="endnote_minimziation1" style="font-style: normal;">
<b>^</b></cite>&nbsp; <weblink xlink:type="simple" xlink:href="http://www.cs.jhu.edu/~hajic/courses/cs226/alg.html">
bottom-up algorithm for Acyclic FSAs</weblink> - FSM minimization algorithms.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.state-machine.com">
Quantum Leaps</weblink> - Provider of open source, state machine-based frameworks. Includes several examples and C/C++ code.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://gfsm.sourceforge.net">
gFSM</weblink> - An open source implementation of FSM (Finite State Machine) programming framework in C.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://vaucanson.lrde.epita.fr">
Vaucanson</weblink> - An open source C++ finite state machine manipulation platform, consisting of a library and tools implemented on top of it.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://unimod.sf.net">
UniMod</weblink> - An open source plugin for Eclipse for automata-based programming.</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>


<ss1>
<st>
General</st>
<p>

<list>
<entry level="1" type="bullet">

Wagner, F., "Modeling Software with Finite State Machines: A Practical Approach", Auerbach Publications, 2006, ISBN 0-8493-8086-3.</entry>
<entry level="1" type="bullet">

Samek, M., <weblink xlink:type="simple" xlink:href="http://www.state-machine.com/psicc1/">
<it>Practical Statecharts in C/C++''</it></weblink>, CMP Books, 2002, ISBN 1-57820-110-1.</entry>
<entry level="1" type="bullet">

Samek, M., <weblink xlink:type="simple" xlink:href="http://www.state-machine.com/psicc2/">
<it>Practical UML Statecharts in C/C++, 2nd Edition''</it></weblink>, Newnes, 2008, ISBN 0-75068-706-1.</entry>
<entry level="1" type="bullet">

Gardner, T., <weblink xlink:type="simple" xlink:href="http://www.troyworks.com/cogs/">
<it>Advanced State Management''</it></weblink>, 2007  <weblink xlink:type="simple" xlink:href="http://link.brightcove.com/services/player/bcpid1733261879?bclid=1729365228&amp;bctid=1743215121">
<it>(video at 360Flex 2008)''</it></weblink></entry>
<entry level="1" type="bullet">

Cassandras, C., Lafortune, S., "Introduction to Discrete Event Systems". Kluwer, 1999, ISBN 0-7923-8609-4.</entry>
<entry level="1" type="bullet">

Timothy Kam, <it>Synthesis of Finite State Machines: Functional Optimization</it>. Kluwer Academic Publishers, Boston 1997, ISBN 0-7923-9842-4</entry>
<entry level="1" type="bullet">

Tiziano Villa, <it>Synthesis of Finite State Machines: Logic Optimization</it>. Kluwer Academic Publishers, Boston 1997, ISBN 0-7923-9892-0</entry>
<entry level="1" type="bullet">

Carroll, J., Long, D. , <it>Theory of Finite Automata with an Introduction to Formal Languages</it>. Prentice Hall, Englewood Cliffs, 1989.</entry>
<entry level="1" type="bullet">

Kohavi, Z., <it>Switching and Finite Automata Theory</it>. McGraw-Hill, 1978.</entry>
<entry level="1" type="bullet">

Gill, A., <it>Introduction to the Theory of Finite-state Machines</it>. McGraw-Hill, 1962.</entry>
<entry level="1" type="bullet">

Ginsburg, S., <it>An Introduction to Mathematical Machine Theory</it>. Addison-Wesley, 1962.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Finite state machines (automata theory) in theoretical computer science</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Arbib-1969" style="font-style:normal" class="book">Arbib, Michael A.&#32;(1969). Theories of Abstract Automata, 1st ed.,&#32;Englewood Cliffs, N.J.:&#32;Prentice-Hall, Inc..</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Bobrow-1974" style="font-style:normal" class="book">Bobrow, Leonard S.;&#32;Michael A. Arbib&#32;(1974). Discrete Mathematics: Applied Algebra for Computer and Information Science, 1st ed.,&#32;Philadelphia:&#32;W. B. Saunders Company, Inc..</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Booth-1967" style="font-style:normal" class="book">Booth, Taylor L.&#32;(1967). Sequential Machines and Automata Theory, 1st,&#32;New York:&#32;John Wiley and Sons, Inc.. Library of Congress Card Catalog Number 67-25924.</cite>&nbsp; Extensive, wide-ranging book meant for specialists, written for both theoretical computer scientists as well as electrical engineers. With detailed explanations of state minimization techniques, FSMs, Turing machines, Markov processes, and undecidability. Excellent treatment of Markov processes.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Boolos-1989, 1999" style="font-style:normal" class="book">Boolos, George;&#32;Richard Jeffrey&#32;(1989, 1999). Computability and Logic, 3rd ed.,&#32;Cambridge, England:&#32;Cambridge University Press. ISBN 0-521-20402-X.</cite>&nbsp; Excellent. Has been in print in various editions and reprints since 1974 (1974, 1980, 1989, 1999).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Brookshear-1989" style="font-style:normal" class="book">Brookshear, J. Glenn&#32;(1989). Theory of Computation: Formal Languages, Automata, and Complexity.&#32;Redwood City, California:&#32;Benjamin/Cummings Publish Company, Inc.. ISBN 0-8053-0143-7.</cite>&nbsp; Approaches <link xlink:type="simple" xlink:href="../854/6854.xml">
Church-Turing thesis</link> from three angles: levels of finite automata as acceptors of formal languages, primitive and partial recursive theory, and power of bare-bones programming languages to implement algorithms, all in one slim volume.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Davis-1994" style="font-style:normal" class="book">Davis, Martin;&#32;Ron Sigal, Elaine J. Weyuker&#32;(1994). Second Edition: Computability, Complexity, and Languages and Logic: Fundamentals of Theoretical Computer Science, 2nd ed.,&#32;San Diego:&#32;Academic Press, Harcourt, Brace &amp; Company.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="endnote_hopcroft1" style="font-style: normal;">
<b>^</b></cite>&nbsp; Hopcroft, John E (1971). An n log n algorithm for minimizing states in a finite automaton <weblink xlink:type="simple" xlink:href="ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/71/190/CS-TR-71-190.pdf">
ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/71/190/CS-TR-71-190.pdf</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Hopcroft-1979" style="font-style:normal" class="book">Hopcroft, John;&#32;Jeffrey Ullman&#32;(1979). Introduction to Automata Theory, Languages and Computation, 1st ed.,&#32;Reading Mass:&#32;Addison-Wesley. ISBN 0-201-02988-X.</cite>&nbsp; A difficult book centered around the issues of machine-interpretation of "languages", NP-Completeness, etc.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Hopcroft-2001" style="font-style:normal" class="book">Hopcroft, John E.;&#32;Rajeev Motwani, Jeffrey D. Ullman&#32;(2001). Introduction to Automata Theory, Languages, and Computation, 2nd ed.,&#32;Reading Mass:&#32;Addison-Wesley.</cite>&nbsp; Distinctly different and less intimidating than the first edition.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Hopkin-1976" style="font-style:normal" class="book">Hopkin, David;&#32;Barbara Moss&#32;(1976). Automata.&#32;New York:&#32;Elsevier North-Holland. ISBN 0-444-00249-9.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Kozen-1997" style="font-style:normal" class="book">Kozen, Dexter C.&#32;(1997). Automata and Computability, 1st ed.,&#32;New York:&#32;Springer-Verlag. ISBN 0-387-94907-0.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Lewis-1998" style="font-style:normal" class="book">Lewis, Harry R.;&#32;Christos H. Papadimitriou&#32;(1998). Elements of the Theory of Computation, 2nd,&#32;Upper Saddle River, New Jersey:&#32;Prentice-Hall. ISBN 0-13-262478-8.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Linz-2006" style="font-style:normal" class="book">Linz, Peter&#32;(2006). Formal Languages and Automata, 4th,&#32;Sudbury, MA:&#32;Jones and Bartlett. ISBN-13: 978-0-7637-3798-6.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Minsky-1967" style="font-style:normal" class="book">Minsky, Marvin&#32;(1967). Computation: Finite and Infinite Machines, 1st,&#32;New Jersey:&#32;Prentice-Hall.</cite>&nbsp; Minsky spends pages 11-20 defining what a “state” is in context of FSMs. His state diagram convention is unconventional. Excellent, i.e. relatively readable, sometimes funny.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../428/3509428.xml">
Christos Papadimitriou</link></scholar>
</writer>
</causal_agent>
</academician>
</alumnus>
</laureate>
</communicator>
</associate>
</educator>
</recipient>
</professional>
</adult>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</peer>
</physical_entity>
&#32;(1993). Computational Complexity, 1st edition,&#32;Addison Wesley. ISBN 0-201-53082-1.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Pippenger-1997" style="font-style:normal" class="book">Pippenger, Nicholas&#32;(1997). Theories of Computability, 1st,&#32;Cambridge, England:&#32;Cambridge University Press. 0-521-55380-6 (hc).</cite>&nbsp; Abstract algebra is at the core of the book, rendering it advanced and less accessible than other texts.  </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Rodger-2006" style="font-style:normal" class="book">Rodger, Susan;&#32;Thomas Finley&#32;(2006). JFLAP: An Interactive Formal Languages and Automata Package, 1st,&#32;Sudbury, MA:&#32;Jones and Bartlett. ISBN-10: 0763738344.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Sipser-2006" style="font-style:normal" class="book">Sipser, Michael&#32;(2006). Introduction to the Theory of Computation, Second Edition, 2nd,&#32;Boston Mass:&#32;Thomson Course Technology. ISBN-10: 0-534-95097-3.</cite>&nbsp; cf Finite state machines (finite automata) in chapter 29.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Wood-1987" style="font-style:normal" class="book">Wood, Derick&#32;(1987). Theory of Computation, 1st,&#32;New York:&#32;Harper &amp; Row, Publishers, Inc.. ISBN-10: 0-06-047208-1.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="endnote_AlmeidaEtAl" style="font-style: normal;">
<b>^</b></cite>&nbsp; Almeida, Marco; Moreira, Nelma; Reis, Rogerio (2007). On the performance of automata minimization algrotims. <weblink xlink:type="simple" xlink:href="http://www.dcc.fc.up.pt/dcc/Pubs/TReports/TR07/dcc-2007-03.pdf">
http://www.dcc.fc.up.pt/dcc/Pubs/TReports/TR07/dcc-2007-03.pdf</weblink></entry>
</list>
</p>

</ss1>
<ss1>
<st>
Abstract state machines in theoretical computer science</st>

<p>

<list>
<entry level="1" type="bullet">

Yuri Gurevich (2000), <it>Sequential Abstract State Machines Capture Sequential Algorithms</it>, ACM Transactions on Computational Logic, vl. 1, no. 1 (July 2000), pages 77-111. http://research.microsoft.com/~gurevich/Opera/141.pdf</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Machine learning using finite-state algorithms</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Mitchell-1997" style="font-style:normal" class="book">Mitchell, Tom M.&#32;(1997). Machine Learning, 1st,&#32;New York:&#32;WCB/McGraw-Hill Corporation. ISBN 0-07-042807-7.</cite>&nbsp; A broad brush but quite thorough and sometimes difficult, meant for computer scientists and engineers. Chapter 13 <it>Reinforcement Learning</it> deals with robot-learning involving state-machine-like algorithms.  </entry>
</list>
</p>

</ss1>
<ss1>
<st>
Hardware engineering: state minimization and synthesis of sequential circuits</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Booth-1967" style="font-style:normal" class="book">Booth, Taylor L.&#32;(1967). Sequential Machines and Automata Theory, 1st,&#32;New York:&#32;John Wiley and Sons, Inc.. Library of Congress Card Catalog Number 67-25924.</cite>&nbsp; Extensive, wide-ranging book meant for specialists, written for both theoretical computer scientists as well as electrical engineers. With detailed explanations of state minimization techniques, FSMs, Turing machines, Markov processes, and undecidability. Excellent treatment of Markov processes.</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Booth-1971" style="font-style:normal" class="book">Booth, Taylor L.&#32;(1971). Digital Networks and Computer Systems, 1st,&#32;New York:&#32;John Wiley and Sons, Inc.. ISBN 0-471-08840-4.</cite>&nbsp; Meant for electrical engineers. More focused, less demanding than his earlier book. His treatment of computers is out-dated. Interesting take on definition of ‘algorithm’.</entry>
<entry level="1" type="bullet">

 <cite id="Reference-McCluskey-1965" style="font-style:normal" class="book">McCluskey, E. J.&#32;(1965). Introduction to the Theory of Switching Circuits, 1st,&#32;New York:&#32;McGraw-Hill Book Company, Inc.. Library of Congress Card Catalog Number 65-17394.</cite>&nbsp; Meant for hardware electrical engineers. With detailed explanations of state minimization techniques and synthesis techniques for design of combinatory logic circuits.</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Hill-1965" style="font-style:normal" class="book">Hill, Fredrick J.;&#32;Gerald R. Peterson&#32;(1965). Introduction to the Theory of Switching Circuits, 1st,&#32;New York:&#32;McGraw-Hill Book Company. Library of Congress Card Catalog Number 65-17394.</cite>&nbsp; Meant for hardware electrical engineers. Excellent explanations of state minimization techniques and synthesis techniques for design of combinatory and sequential logic circuits.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Finite Markov chain processes</st>
<p>

<indent level="2">

"We may think of a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../876/60876.xml">
Markov chain</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 as a process that moves successively through a set of states s1, s2, ..., sr. ... if it is in state si it moves on to the next stop to state sj with probability pij. These probabilities can be exhibited in the form of a transition matrix" (Kemeny (1959), p. 384)
</indent>
Finite Markov-chain processes are also known as <link xlink:type="simple" xlink:href="../265/1986265.xml">
subshifts of finite type</link>.</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Booth-1967" style="font-style:normal" class="book">Booth, Taylor L.&#32;(1967). Sequential Machines and Automata Theory, 1st,&#32;New York:&#32;John Wiley and Sons, Inc.. Library of Congress Card Catalog Number 67-25924.</cite>&nbsp; Extensive, wide-ranging book meant for specialists, written for both theoretical computer scientists as well as electrical engineers. With detailed explanations of state minimization techniques, FSMs, Turing machines, Markov processes, and undecidability. Excellent treatment of Markov processes.</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Kemeny-1959" style="font-style:normal" class="book">Kemeny, John G.;&#32;Hazleton Mirkil, J. Laurie Snell, Gerald L. Thompson&#32;(1959). Finite Mathematical Structures, 1st,&#32;Englewood Cliffs, N.J.:&#32;Prentice-Hall, Inc.. Library of Congress Card Catalog Number 59-12841.</cite>&nbsp; Classical text . cf Chapter 6 ‘’Finite Markov Chains”.</entry>
</list>
</p>


<p>

<table style=";width:auto;" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../356/103356.xml">
Automata theory</link>: <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>s and <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;background:transparent;color:inherit;" class="navbox-list navbox-odd">
<table style="text-align:left;width:100%;" class="navbox-columns-table" cellspacing="0">
<row>
<col colspan="1" style="" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky
hierarchy</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../716/18020716.xml">
Grammars</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><link xlink:type="simple" xlink:href="../939/10939.xml">
Languages</link></b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b>Minimal
<link xlink:type="simple" xlink:href="../931/10931.xml">
automaton</link></b></col>
</row>
<row style="height:2px;">

</row>
<row style="vertical-align:top;">
<col style="padding:0px;text-align: center;;;;width:10em;">
Type-0 n/a Type-1 n/a n/a Type-2 n/a Type-3 n/a</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../174/4906174.xml">
Unrestricted</link></language>
(no common name) <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../211/6211.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/12656637.xml">
Indexed</link></language>
<model wordnetid="105890249" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<hypothesis wordnetid="105888929" confidence="0.8">
<link xlink:type="simple" xlink:href="../555/567555.xml">
Tree-adjoining</link></hypothesis>
</concept>
</idea>
</model>
 etc.<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../759/6759.xml">
Context-free</link></language>
</subject>
</message>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/10609024.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../855/25855.xml">
Regular</link></language>
n/a</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../789/54789.xml">
Recursively enumerable</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../874/53874.xml">
Recursive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/6212.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../284/7324284.xml">
Indexed</link></language>
(<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/13026226.xml">
Mildly context-sensitive</link></language>
)<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/6867.xml">
Context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../589/7962589.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../723/25723.xml">
Regular</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../792/4922792.xml">
Star-free</link></language>
</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/1352564.xml">
Decider</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../962/1811962.xml">
Linear-bounded</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../447/9791447.xml">
Nested stack</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../961/14345961.xml">
Embedded pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../510/24510.xml">
Nondeterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../656/3972656.xml">
Deterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<link xlink:type="simple" xlink:href="../931/10931.xml">
Finite</link><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../149/17995149.xml">
Aperiodic finite</link></language>
</p>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
Each category of languages or grammars is a <link xlink:type="simple" xlink:href="../631/27631.xml">
proper subset</link>of the category directly above it; and any automaton in each category has an equivalent automaton in the category directly above it.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</ss1>
</sec>
</bdy>
</method>
</know-how>
</model>
</article>
