<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:25:40[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<header>
<title>First-order logic</title>
<id>10983</id>
<revision>
<id>243841853</id>
<timestamp>2008-10-08T08:02:56Z</timestamp>
<contributor>
<username>JAnDbot</username>
<id>1725149</id>
</contributor>
</revision>
<categories>
<category>Discrete mathematics</category>
<category>Mathematical logic</category>
<category>Systems of formal logic</category>
<category>Model theory</category>
<category>Predicate logic</category>
</categories>
</header>
<bdy>

<b>First-order logic (FOL)</b> is a formal <link xlink:type="simple" xlink:href="../822/15285822.xml">
deductive system</link> used in mathematics, philosophy, linguistics, and computer science. It goes by many names, including: <b>first-order predicate calculus</b> (<b>FOPC</b>), <b>the lower predicate calculus</b>, <b>the language of first-order logic</b> or <b>predicate logic</b>. Unlike natural languages such as <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../916/8569916.xml">
English</link></language>
, FOL uses a wholly unambiguous <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link> interpreted by mathematical structures. FOL is a system of <link xlink:type="simple" xlink:href="../278/8278.xml">
deduction</link> that extends <link xlink:type="simple" xlink:href="../335/5597335.xml">
propositional logic</link> by allowing <link xlink:type="simple" xlink:href="../806/228806.xml">
quantification</link> over individuals of a given <link xlink:type="simple" xlink:href="../180/229180.xml">
domain of discourse</link>. For example, it can be stated in FOL "Every individual has the property P".<p>

While propositional logic deals with simple declarative propositions, first-order logic additionally covers <link xlink:type="simple" xlink:href="../336/7178336.xml">
predicate</link>s and quantification. Take for example the following sentences: "Socrates is a man", "Plato is a man". In propositional logic these will be two unrelated propositions, denoted for example by <it>p</it> and <it>q</it>. In first-order logic however, both sentences would be connected by the same property: Man(x), where Man(x) means that x is a man. When x=Socrates we get the first proposition, <it>p</it>, and when x=Plato we get the second proposition, <it>q</it>. Such a construction allows for a much more powerful logic when quantifiers are introduced, such as "for every x...", for example, "for every x, if Man(x), then...". Without quantifiers, every valid argument in FOL is valid in propositional logic, and vice versa.</p>
<p>

A <link xlink:type="simple" xlink:href="../103/3512103.xml">
first-order theory</link> consists of a set of <link xlink:type="simple" xlink:href="../928/928.xml">
axiom</link>s (usually finite or <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable</link>) and the statements deducible from them given the underlying deducibility relation. Usually what is meant by 'first-order theory' is some set of axioms <it>together with those of a complete (and sound) axiomatization of first-order logic</it>, closed under the rules of FOL. (Any such system FOL will give rise to the same abstract deducibility relation, so we needn't have a fixed axiomatic system in mind.) A first-order language has sufficient expressive power to formalize two important mathematical theories: <link>
ZFC</link> set theory and (first-order) <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link>. A first-order language cannot, however, categorically express the notion of <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../026/6026.xml">
 countability</link></concept>
</idea>
 even though it is expressible in the first-order theory ZFC under the <link xlink:type="simple" xlink:href="../171/13691171.xml">
intended interpretation</link> of the symbolism of ZFC. Such ideas can be expressed categorically with <link xlink:type="simple" xlink:href="../428/341428.xml">
second-order logic</link>.</p>

<sec>
<st>
Why is first-order logic needed?</st>

<p>

<link xlink:type="simple" xlink:href="../335/5597335.xml">
Propositional logic</link> is not adequate for formalizing valid arguments that rely on the internal structure of the propositions involved.  To see this, consider the valid  <link xlink:type="simple" xlink:href="../046/48046.xml">
syllogistic</link> argument:
<list>
<entry level="1" type="bullet">

 All men are mortal</entry>
<entry level="1" type="bullet">

 Socrates is a man</entry>
<entry level="1" type="bullet">

 Therefore, Socrates is mortal</entry>
</list>
</p>
<p>

which upon translation into <link xlink:type="simple" xlink:href="../335/5597335.xml">
propositional logic</link> yields:
<list>
<entry level="1" type="bullet">

 A</entry>
<entry level="1" type="bullet">

 B</entry>
<entry level="1" type="bullet">

 <math>\therefore</math> C</entry>
</list>

(taking <math>\therefore</math> to mean "therefore").</p>
<p>

According to propositional logic, this translation is invalid: Propositional logic validates arguments according to their <it>structure</it>, and nothing in the structure of this translated argument (C follows from A and B, for arbitrary A, B, C) suggests that it is valid. A translation that preserves the intuitive (and formal) validity of the argument must take into consideration the deeper structure of propositions, such as the essential notions of predication and quantification. Propositional logic deals only with truth-functional validity: any assignment of truth-values to the variables of the argument should make either the conclusion true or at least one of the premises false. Clearly we may (uniformly) assign truth values to the variables of the above argument such that A, B are both true but C is false. Hence the argument is truth-functionally invalid. On the other hand, it is impossible to (uniformly) assign truth values to the argument "A follows from (A and B)" such that (A and B) is true (hence A is true and B is true) and A false.</p>
<p>

In contrast, this argument can be easily translated into first-order logic:
<list>
<entry level="1" type="bullet">

 <math>\forall x (\mathit{Man}(x) \rightarrow \mathit{Mortal}(x))</math></entry>
<entry level="1" type="bullet">

 <math>\,\mathit{Man}(\mathit{Socrates})</math></entry>
<entry level="1" type="bullet">

 <math>\therefore \mathit{Mortal}(\mathit{Socrates})</math></entry>
</list>

(Where "<math>\forall x</math>" means "for all x", "<math>\rightarrow</math>" means "implies", <math>\mathit{Man}(\mathit{Socrates})</math> means "Socrates is a man", and <math>\mathit{Mortal}(\mathit{Socrates})</math> means "Socrates is mortal".)  In plain English, this states that
<list>
<entry level="1" type="bullet">

 for all <it>x</it>, if <it>x</it> is a man then <it>x</it> is mortal</entry>
<entry level="1" type="bullet">

 <it>Socrates</it> is a man</entry>
<entry level="1" type="bullet">

 therefore <it>Socrates</it> is mortal</entry>
</list>
</p>
<p>

FOL can also express the existence of something (<math>\exists</math>), as well as predicates ("functions" that are true or false) with more than one parameter. For example, "there is someone who can be fooled every time" can be expressed as:
<indent level="1">

<math>\exists x (\mathit{Person}(x) \and \forall y (\mathit{time}(y) \rightarrow \mathit{Canfool}(x,y)))</math>
</indent>
Where "<math>\exists x</math>" means "there exists (an) x", "<math>\and</math>" means "and", and <math>\mathit{Canfool}(x,y)</math> means "(person) x can be fooled (at time) y".</p>

<ss1>
<st>
Variables in first-order logic and in propositional logic</st>

<p>

Every propositional formula can be translated into an essentially equivalent first-order formula by replacing each propositional variable with a zero-arity predicate. For example, the formula:
<math>x \vee (y \wedge \neg z)</math> can be translated into <math>P() \vee (Q() \wedge \neg R())</math>, where <it>P</it>, <it>Q</it> and <it>R</it> are predicates of arity zero.
And where <math>\vee</math> means 'or' and <math>\neg</math> means 'negation'.</p>
<p>

While variables in the propositional logics are used to represent propositions that can be true or false, variables in first-order logic represent objects the formula is referring to. In the example above, the variable <it>x</it> in <math>\forall x (\mathit{Man}(x) \rightarrow \mathit{Mortal}(x))</math> is intended to indicate an arbitrary element of the human race, not a proposition that can be true or false.</p>

</ss1>
</sec>
<sec>
<st>
Defining first-order logic</st>

<p>

A predicate calculus consists of 
<list>
<entry level="1" type="bullet">

 formation rules (i.e. <link xlink:type="simple" xlink:href="../407/25407.xml">
 recursive</link> definitions for forming <link xlink:type="simple" xlink:href="../582/404582.xml">
well-formed formula</link>s).</entry>
<entry level="1" type="bullet">

 a proof theory, made of:</entry>
<entry level="2" type="bullet">

 transformation rules (i.e. <link xlink:type="simple" xlink:href="../311/252311.xml">
inference rule</link>s for deriving theorems).</entry>
<entry level="2" type="bullet">

 axioms (possibly <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../026/6026.xml">
countably infinite</link></concept>
</idea>
 many) or axiom schemata.</entry>
<entry level="1" type="bullet">

 a semantics, telling which interpretation of the symbol makes the formula true.</entry>
</list>
</p>
<p>

The axioms considered here are <link>
<it>logical</it> axioms</link> which are part of classical <b>FOL</b>.
It is important to note that <b>FOL</b> can be formalized in many equivalent ways; there is nothing canonical about the axioms and rules of inference given in this article. There are infinitely many equivalent formalizations all of which yield the same theorems and non-theorems, and all of which have equal right to the title <b>'FOL</b>'.</p>
<p>

FOL is used as the basic "building block" for many mathematical theories.
FOL provides several built-in rules, such as the axiom <math>\forall x P(x)\rightarrow \forall x P(x)</math> (if P(x) is true for every x then P(x) is true for every x).
Additional <it>non-logical</it> axioms are added to produce specific first-order theories based on the axioms of classical <b>FOL</b>; these theories built on FOL are called <it>classical first-order theories</it>. One example of a classical first-order theory is <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link>, which adds the axiom <math>\forall x \exists y Q(x,y)</math> (i.e. for every x there exists y such that y=x+1, where Q(x,y) is interpreted as "y=x+1").  This additional axiom is a non-logical axiom; it is not part of FOL, but instead is an axiom of the theory (an axiom of arithmetic rather than of logic). Axioms of the latter kind are also called axioms of first-order <it>theories</it>.
The axioms of first-order theories are not regarded as truths of logic <it>per se</it>, but rather as truths of the particular theory that usually has associated with it an intended interpretation of its non-logical symbols. (See an analogous idea at logical versus <link xlink:type="simple" xlink:href="../994/7791994.xml">
non-logical symbol</link>s.) Thus, the proposition <math>\forall x \exists y Q(x,y)</math> is an axiom (hence is true) in the theory of <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link>, with the interpretation of the relation Q(x,y) as "y=x+1", and may be false in other theories or with another interpretation of the relation Q(x,y).
Classical <b>FOL</b> does not have associated with it an intended interpretation of its non-logical vocabulary (except arguably a symbol denoting identity, depending on whether one regards such a symbol as logical).
<it><link xlink:type="simple" xlink:href="../553/27553.xml">
Classical set-theory</link></it> is another example of a first-order theory (a theory built on FOL).</p>

</sec>
<sec>
<st>
Syntax of first-order logic</st>

<ss1>
<st>
Symbols</st>
<p>

The terms and formulas of first-order logic are strings of <b>symbols</b>. As for all <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>s, the nature of the symbols themselves is outside the scope of formal logic; it is best to think of them as letters and punctuation symbols. The <b>alphabet</b> (set of all symbols of the language) is divided into the non-logical symbols and the logical symbols. The latter are the same, and have the same meaning, for all applications.</p>

<ss2>
<st>
Non-logical symbols</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../994/7791994.xml">
non-logical symbols</link></it>
</indent>
The <b>non-logical symbols</b> represent predicates (relations), functions and constants on the domain. For a long time it was standard practice to use a fixed, infinite set of non-logical symbols for all purposes. A more recent practice is to use different non-logical symbols according to the application one has in mind. Therefore it has become necessary to name the set of all non-logical symbols used in a particular application. It is now known as the <b>signature</b>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

<list>
<entry level="1" type="definition">

Traditional approach</entry>
</list>

The traditional approach is to have only one, infinite, set of non-logical symbols (one signature) for all applications. Consequently, under the traditional approach there is only one language of first-order logic.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> This approach is still common, especially in philosophically oriented books.</p>
<p>

<list>
<entry level="1" type="number">

 For every integer <it>n</it>&nbsp;≥&nbsp;0 we have the <link xlink:type="simple" xlink:href="../301/42301.xml">
<it>n</it>-<b>ary</b></link>, or <it>n</it>-<b>place</b>, <b>predicate symbols</b>. Because they represent <link xlink:type="simple" xlink:href="../509/19509.xml">
relations</link> between <it>n</it> elements, they are also called <b>relation symbols</b>. For each arity <it>n</it> we have an infinite supply of them:</entry>
<entry level="2" type="indent">

<it>Pn</it>0, <it>Pn</it>1, <it>Pn</it>2, <it>Pn</it>3, …</entry>
<entry level="1" type="number">

 For every integer <it>n</it>&nbsp;≥&nbsp;0 infinitely many <it>n</it>-ary <b>function symbols</b>:</entry>
<entry level="2" type="indent">

<it>fn</it>0, <it>fn</it>1, <it>fn</it>2, <it>fn</it>3, …</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

Application-specific signatures</entry>
</list>

In modern mathematical treatments of first-order logic, the signature varies with the applications. Typical signatures in mathematics are {1, &amp;times;} or just {&amp;times;} for <link xlink:type="simple" xlink:href="../074/44074.xml">
group</link>s, or {0, 1, +, &amp;times;, } for <link xlink:type="simple" xlink:href="../430/22430.xml">
ordered field</link>s. There are no restrictions on the number of non-logical symbols. The signature can be <link xlink:type="simple" xlink:href="../566/9566.xml">
empty</link>, finite, or infinite, even <link xlink:type="simple" xlink:href="../248/32248.xml">
uncountable</link>. Uncountable signatures occur for example in modern proofs of (the upward part of) the <link>
Löwenheim-Skolem theorem</link>.</p>
<p>

Every non-logical symbol is of one of the following types.
<list>
<entry level="1" type="number">

 A set of <b>predicate symbols</b> (or <b>relation symbols</b>) each with some <b>valence</b> (or <b><link xlink:type="simple" xlink:href="../301/42301.xml">
arity</link></b>, number of its arguments) ≥ 0, which are often denoted by uppercase letters <it>P</it>, <it>Q</it>, <it>R</it>,... .</entry>
<entry level="2" type="bullet">

 Relations of valence 0 can be identified with <link xlink:type="simple" xlink:href="../562/1557562.xml">
propositional variable</link>s. For example, <it>P</it>, which can stand for any statement.</entry>
<entry level="2" type="bullet">

 For example, <it>P(x)</it> is a predicate variable of valence 1. It can stand for "x is a man", for example.</entry>
<entry level="2" type="bullet">

 <it>Q(x,y)</it> is a predicate variable of valence 2. It can stand for "x is greater than y" in arithmetic or "x is the father of y", for example.</entry>
<entry level="2" type="bullet">

 By using functions (see below), it is possible to dispense with all predicate variables with valence larger than one. For example, "<it>x&amp;gt;y</it>" (a predicate of valence 2, of the type <it>Q(x,y)</it>) can be replaced by a predicate of valence 1 about the <link xlink:type="simple" xlink:href="../362/22362.xml">
ordered pair</link> (x,y).</entry>
<entry level="1" type="number">

 A set of <b>function symbols</b>, each of some valence ≥ 0, which are often denoted by lowercase letters <it>f</it>, <it>g</it>, <it>h</it>,... .</entry>
<entry level="2" type="bullet">

 Function symbols of valence 0 are called <b>constant symbols</b>, and are often denoted by lowercase letters at the beginning of the alphabet <it>a</it>, <it>b</it>, <it>c</it>,... .</entry>
<entry level="2" type="bullet">

 Examples: <it>f(x)</it> may stand for "the father of x". In <link xlink:type="simple" xlink:href="../118/3118.xml">
arithmetic</link>, it may stand for "-x". In <link xlink:type="simple" xlink:href="../553/27553.xml">
set theory</link>, it may stand for "the <link xlink:type="simple" xlink:href="../799/23799.xml">
power set</link> of x". In <link xlink:type="simple" xlink:href="../118/3118.xml">
arithmetic</link>, <it>f(x,y)</it> may stand for "x+y". In <link xlink:type="simple" xlink:href="../553/27553.xml">
set theory</link>, it may stand for "the union of x and y". The symbol <it>a</it> may stand for Socrates. In <link xlink:type="simple" xlink:href="../118/3118.xml">
arithmetic</link>, it may stand for 0. In <link xlink:type="simple" xlink:href="../553/27553.xml">
set theory</link>, such a constant may stand for the <link xlink:type="simple" xlink:href="../566/9566.xml">
empty set</link>.</entry>
<entry level="2" type="bullet">

 One can in principle dispense entirely with functions of arity &amp;gt; 2 and predicates of arity &amp;gt; 1 if there is a function symbol of arity 2 representing an <link xlink:type="simple" xlink:href="../362/22362.xml">
ordered pair</link> (or predicate symbols of arity 2 representing the projection relations of an ordered pair). The pair or projections need to satisfy the natural axioms.</entry>
<entry level="2" type="bullet">

 One can in principle dispense entirely with functions and constants. For example, instead of using a constant <math> \; 0 </math>  one may use a predicate  <math> \; 0(x) </math>  (interpreted as  <math> \; x=0 </math> ), and replace every predicate such as  <math>\; P(0,y) </math> with <math> \forall x \;\; 0(x) \rightarrow P(x,y) </math>. A function such as <math> f\;(x_1,x_2,...,x_n) </math> will similarly be replaced by a predicate  <math> F\;(x_1,x_2,...,x_n,y) </math> (interpreted as <math> y = f\;(x_1,x_2,...,x_n) </math> ).</entry>
</list>
</p>
<p>

We can recover the traditional approach by considering the following signature:
<indent level="1">

{<it>P0</it>0, <it>P0</it>1, <it>P0</it>2, <it>P0</it>3, …, <it>P1</it>0, <it>P1</it>1, <it>P1</it>2, <it>P1</it>3, …, <it>P2</it>0, <it>P2</it>1, <it>P2</it>2, <it>P2</it>3, …, …,
</indent>
:<it>f</it>00, <it>f</it>01, <it>f</it>02, <it>f</it>03, …, <it>f1</it>0, <it>f1</it>1, <it>f1</it>2, <it>f1</it>3, …, <it>f2</it>0, <it>f2</it>1, <it>f2</it>2, <it>f2</it>3, …, <it>f3</it>0, <it>f3</it>1, <it>f3</it>2, <it>f3</it>3, …, …}</p>

</ss2>
<ss2>
<st>
Logical symbols</st>
<p>

Besides <link xlink:type="simple" xlink:href="../153/18153.xml">
logical connective</link>s such as <math>\and</math>, <math>\or</math>, <math>\rightarrow</math>, <math>\leftrightarrow</math> and <math>\neg</math>, the <b>logical symbols</b> include <link xlink:type="simple" xlink:href="../806/228806.xml">
quantifier</link>s, and <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s. 
<list>
<entry level="1" type="number">

 An infinite set of <b>variables</b>, often denoted by lowercase letters at the end of the alphabet <it>x</it>, <it>y</it>, <it>z</it>,... .</entry>
<entry level="1" type="number">

 Symbols denoting <b>logical operators</b> (or <b>connectives</b>):</entry>
<entry level="2" type="bullet">

The unary operator <math>\neg</math> (<link xlink:type="simple" xlink:href="../019/161019.xml">
logical not</link>).</entry>
<entry level="2" type="bullet">

Binary operators <math>\wedge</math> (<link>
logical and</link>) and <math>\vee</math> (<link xlink:type="simple" xlink:href="../962/7962.xml">
logical or</link>).</entry>
<entry level="2" type="bullet">

Binary operators <math>\rightarrow</math> (<link xlink:type="simple" xlink:href="../808/658808.xml">
logical conditional</link>) and <math>\leftrightarrow</math> (<link xlink:type="simple" xlink:href="../783/228783.xml">
logical biconditional</link>).</entry>
<entry level="1" type="number">

 Symbols denoting <b>quantifiers</b>: <math>\forall</math> (<link xlink:type="simple" xlink:href="../174/76174.xml">
universal quantification</link>, typically read as "for all") and <math>\exists</math> (<link xlink:type="simple" xlink:href="../420/91420.xml">
existential quantification</link>, typically read as "there exists").</entry>
<entry level="1" type="number">

 Left and right parenthesis: ( and ). There are many different conventions about where to put parentheses; for example, one might write <math>\forall </math><it>x</it> or (<math>\forall</math><it>x</it>). Sometimes one uses colons or full stops instead of parentheses to make formulas unambiguous. One interesting but rather unusual convention is "<notation wordnetid="106808493" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../056/25056.xml">
Polish notation</link></notation>
", where one omits all parentheses, and writes <math>\rightarrow</math>, <math>\wedge</math>, and so on in front of their arguments rather than between them. Polish notation is compact and elegant, but rare because it is hard for humans to read it. </entry>
<entry level="1" type="number">

 An <b>identity symbol</b> (or equality symbol) =. Syntactically it behaves like a binary predicate.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

Variations</entry>
</list>

First-order logic as described here is often called <b>first-order logic with identity</b>, because of the presence of an identity symbol = with special semantics. In <b>first-order logic without identity</b> this symbol is omitted. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

There are numerous minor variations that may define additional logical symbols: 
<list>
<entry level="1" type="bullet">

 Sometimes the truth constants T for "true" and F for "false" are included. Without any such logical operators of valence 0 it is not possible to express these two constants otherwise without using quantifiers.</entry>
<entry level="1" type="bullet">

 Sometimes the <link xlink:type="simple" xlink:href="../388/29388.xml">
Sheffer stroke</link> (<it>P</it> | <it>Q</it>, aka NAND) is included as a logical symbol.</entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../979/105979.xml">
exclusive-or</link> operator "xor" is another logical connective that can occur as a logical symbol.</entry>
<entry level="1" type="bullet">

 Sometimes it is useful to say that "<it>P(x)</it> holds for exactly one <it>x</it>", which can be expressed as <math>\exists!</math><it>x</it> <it>P</it>(<it>x</it>).  This notation, called <link xlink:type="simple" xlink:href="../894/276894.xml">
uniqueness quantification</link>, may be taken to abbreviate a formula such as <math>\exists</math><it>x</it> (<it>P</it>(<it>x</it>)  <math>\wedge\forall</math><it>y</it> (<it>P</it>(<it>y</it>) <math>\rightarrow</math> (<it>x</it> = <it>y</it>))).</entry>
</list>
</p>
<p>

Not all logical symbols as defined above need occur. For example:
<list>
<entry level="1" type="bullet">

 Since (<math>\exists</math> <it>x</it>)φ can be expressed as <math>\neg</math>((<math>\forall</math> x)(<math>\neg</math> φ)), and (<math>\forall</math> <it>x</it>)φ can be expressed as <math>\neg</math>((<math>\exists</math> x)(<math>\neg</math> φ)), one of the two quantifiers <math>\exists</math> and <math>\forall</math> can be dropped.</entry>
<entry level="1" type="bullet">

 Since φ<math>\vee</math>ψ can be expressed as <math>\neg</math>((<math>\neg</math> φ)<math>\wedge</math> (<math>\neg</math> ψ)), and φ<math>\wedge</math>ψ can be expressed as <math>\neg</math>((<math>\neg</math> φ)<math>\vee</math> (<math>\neg</math> ψ)), either <math>\vee</math> or <math>\wedge</math> can be dropped. In other words, it is sufficient to have <math>\neg,\vee</math> or <math>\neg,\wedge</math> as the only logical connectives among the logical symbols.</entry>
<entry level="1" type="bullet">

 Similarly, it is sufficient to have <math>\neg,\rightarrow</math> or just the Sheffer stroke as the only logical connectives.</entry>
</list>
</p>
<p>

There are also some frequently used variants of notation:
<list>
<entry level="1" type="bullet">

 Some books and papers use the notation φ <math>\Rightarrow</math> ψ for φ <math>\rightarrow</math> ψ. This is especially common in proof theory where <math>\rightarrow</math> is easily confused with the sequent arrow. </entry>
<entry level="1" type="bullet">

 ~φ is sometimes used for <math>\neg</math>φ, φ &amp; ψ for φ <math>\wedge</math> ψ.</entry>
<entry level="1" type="bullet">

 There is a wealth of alternative notations for <link xlink:type="simple" xlink:href="../806/228806.xml">
quantifier</link>s; e.g., <math>\forall</math><it>x</it> φ may be written as (<it>x</it>)φ. This latter notation is common in texts on recursion theory.</entry>
</list>
</p>

</ss2>
</ss1>
<ss1>
<st>
Formation rules</st>

<p>

The <b>formation rules</b> define the terms and formulas of first order logic. When terms and formulas are represented as strings of symbols, these rules can be used to write a <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link> for terms and formulas. The concept of free variable is used to define the sentences as a subset of the formulas. </p>

<ss2>
<st>
 Terms </st>
<p>

The set of <b><link xlink:type="simple" xlink:href="../665/668665.xml">
terms</link></b>  is recursively defined by the following rules:
<list>
<entry level="1" type="number">

 Any variable is a term.</entry>
<entry level="1" type="number">

 Any expression <it>f</it>(<it>t</it>1,...,<it>tn</it>) of <it>n</it> arguments (where each argument <it>ti</it> is a term and <it>f</it> is a function symbol of valence <it>n</it>) is a term.</entry>
<entry level="1" type="number">

 <b>Closure clause:</b> Nothing else is a term.  For example, predicates are not terms.</entry>
</list>
</p>

</ss2>
<ss2>
<st>
 Formulas </st>
<p>

The set of <link xlink:type="simple" xlink:href="../582/404582.xml">
well-formed formula</link>s (usually called <b>wff</b>s or just <b><link xlink:type="simple" xlink:href="../382/4230382.xml">
formulas</link></b>) is recursively defined by the following rules:
<list>
<entry level="1" type="number">

 <b>Simple and complex predicates</b> If <it>P</it> is a relation of valence <it>n</it> and <it>a1</it>, ..., <it>an</it> are terms  then <it>P</it>(<it>a</it>1,...,<it>a</it>n) is a well-formed formula. If equality is considered part of logic, then (<it>a</it>1 = <it>a</it>2) is a well-formed formula. All such formulas are said to be <link xlink:type="simple" xlink:href="../066/4472066.xml">
<it>atomic''</it></link>.</entry>
<entry level="1" type="number">

 <b>Inductive Clause I:</b> If φ is a <it>wff</it>, then <math>\neg</math>φ is a <it>wff</it>.</entry>
<entry level="1" type="number">

 <b>Inductive Clause II:</b> If φ and ψ are <it>wff</it>s, then (φ <math>\rightarrow</math> ψ) is a <it>wff</it>.</entry>
<entry level="1" type="number">

 <b>Inductive Clause III:</b> If φ is a <it>wff</it> and x is a variable, then <math>\forall</math>x  φ is a <it>wff</it>.</entry>
<entry level="1" type="number">

 <b>Closure Clause:</b> Nothing else is a <it>wff</it>.</entry>
</list>
</p>
<p>

For example, <math>\forall</math> x <math>\forall</math> y (P(f(x)) <math>\rightarrow\neg</math> (P(x)<math>\rightarrow</math> Q(f(y),x,z))) is a well-formed formula, if f is a function of valence 1, P a predicate of valence 1 and Q a predicate of valence 3. <math>\forall</math> x x<math>\rightarrow</math>  is not a well-formed formula.</p>
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
Computer science</link> terminology, a formula implements a built-in "boolean" type, while a term implements all other types.</p>

</ss2>
</ss1>
<ss1>
<st>
Example</st>
<p>

In mathematics the language of ordered abelian groups has one constant 0, one unary function &amp;minus;, one binary function +, and one binary relation ≤. So:
<list>
<entry level="1" type="bullet">

<it>x</it>, <it>y</it> are <b>atomic terms</b></entry>
<entry level="1" type="bullet">

+(<it>x</it>, <it>y</it>), +(<it>x</it>, +(<it>y</it>, &amp;minus;(<it>z</it>))) are <b>terms</b>, usually written as <it>x</it> + <it>y</it>, <it>x</it> + <it>y</it> &amp;minus; <it>z''</it></entry>
<entry level="1" type="bullet">

=(+(<it>x</it>, <it>y</it>), 0), ≤(+(<it>x</it>, +(<it>y</it>, &amp;minus;(<it>z</it>))), +(<it>x</it>, <it>y</it>)) are <b>atomic formulas</b>, usually written as <it>x</it> + <it>y</it> = 0, <it>x</it> + <it>y</it> − <it>z</it> ≤ <it>x</it> + <it>y</it>,</entry>
<entry level="1" type="bullet">

(<math>\forall</math><it>x</it> <math>\forall</math><it>y</it> ≤( +(<it>x</it>, <it>y</it>), <it>z</it>)) <math>\rightarrow</math> (<math>\forall</math><it>x</it> =(+(<it>x</it>, <it>y</it>), 0)) is a <b>formula</b>, usually written as (<math>\forall</math><it>x</it> <math>\forall</math><it>y</it> <it>x</it> + <it>y</it> ≤ <it>z</it>)  <math>\rightarrow</math> (<math>\forall</math><it>x</it> <it>x</it> + <it>y</it> = 0).</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Additional syntactic concepts</st>

<ss1>
<st>
 Free and Bound Variables </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../460/147460.xml">
Free variables and bound variables</link></it>
</indent>

In a formula, a variable may occur free or bound. Intuitively, a variable is free in a formula if it is not quantified: in <math>\forall y. P(x,y)</math>, variable <it>x</it> is free while <it>y</it> is bound.</p>
<p>

<list>
<entry level="1" type="number">

 <b>Atomic formulas</b> If φ is an atomic formula then x is <link xlink:type="simple" xlink:href="../460/147460.xml">
free</link> in φ if and only if x occurs in φ.</entry>
<entry level="1" type="number">

 <b>Inductive Clause I:</b> x is free in <math>\neg</math>φ if and only if x is free in φ.</entry>
<entry level="1" type="number">

 <b>Inductive Clause II:</b> x is free in (φ <math>\rightarrow</math> ψ) if and only if x is free in either φ or ψ.</entry>
<entry level="1" type="number">

 <b>Inductive Clause III:</b> x is free in <math>\forall</math>y  φ if and only if x is free in φ and x is a different symbol than y.</entry>
<entry level="1" type="number">

 <b>Closure Clause:</b> x is bound in φ if and only if x occurs in φ and x is not free in φ.</entry>
</list>
</p>
<p>

For example, in <math>\forall</math> x <math>\forall</math> y (P(x)<math>\rightarrow</math> Q(x,f(x),z)), x and y are bound variables, z is a free variable, and w is neither because it does not occur in the formula.</p>
<p>

Freeness and boundness can be also specialized to specific occurrences of variables in a formula. For example, in <math>P(x) \rightarrow \forall x. Q(x)</math>, the first occurrence of <it>x</it> is free while the second is bound. In other words, the <it>x</it> in <math>P(x)</math> is free while the <math>x</math> in <math>\forall x. Q(x)</math> is bound.</p>

</ss1>
<ss1>
<st>
Substitution</st>

<p>

If <it>t</it> is a term and φ is a formula possibly containing the variable <it>x</it>, then φ[''t/x''] is the result of replacing all free instances of <it>x</it> by <it>t</it> in φ.</p>
<p>

This replacement results in a formula that logically follows the original one <b>provided that no free variable of <it>t</it></b><b> becomes bound in this process</b>. If some free variable of <it>t</it> becomes bound, then to substitute <it>t</it> for <it>x</it> it is first necessary to change the names of bound variables of φ to something other than the free variables of <it>t</it>.</p>
<p>

To see why this condition is necessary, consider the formula φ given by <math>\forall</math><it>y</it> <it>y</it> ≤ <it>x</it> ("<it>x</it> is maximal"). If <it>t</it> is a term without <it>y</it> as a free variable, then φ[''t''/''x''] just means <it>t</it> is maximal. However if <it>t</it> is <it>y</it>, the formula φ[''y''/''x''] is <math>\forall</math><it>y</it> <it>y</it> ≤ <it>y</it> which does <b>not</b> say that <it>y</it> is maximal. The problem is that the free variable <it>y</it> of <it>t</it> (=<it>y</it>) became bound when we substituted <it>y</it> for <it>x</it> in φ[''y''/''x'']. The intended replacement can be obtained by renaming the bound variable <it>y</it> of φ to something else, say <it>z</it>, so that the formula is then <math>\forall</math><it>z</it> <it>z</it> ≤ <it>y</it>. Forgetting this condition is a notorious cause of errors.</p>

</ss1>
</sec>
<sec>
<st>
Proof theory</st>

<ss1>
<st>
 Inference rules </st>

<p>

An <link xlink:type="simple" xlink:href="../311/252311.xml">
inference rule</link> is a function from sets of (well-formed) formulas, called <link xlink:type="simple" xlink:href="../337/7993337.xml">
premise</link>s, to sets of formulas called conclusions. In most well-known deductive systems, inference rules take a set of formulas to a single conclusion. (Notice this is true even in the case of most <link xlink:type="simple" xlink:href="../329/252329.xml">
sequent calculi</link>.)</p>
<p>

Inference rules are used to prove <link xlink:type="simple" xlink:href="../977/30977.xml">
theorem</link>s, which are formulas provable in or members of a theory. If the <link xlink:type="simple" xlink:href="../337/7993337.xml">
premise</link>s of an inference rule are theorems, then its conclusion is a theorem as well. In other words, inference rules are used to generate "new" theorems from "old" ones--they are theoremhood preserving. Systems for generating theories are often called <it>predicate calculi</it>. These are described in a section below.</p>
<p>

An important inference rule, <link xlink:type="simple" xlink:href="../900/18900.xml">
modus ponens</link>, states that if φ and φ <math>\rightarrow</math> ψ are both theorems, then ψ is a theorem. This can be written as following;
<indent level="1">

if <math>T \vdash \varphi</math> and <math>T \vdash \varphi\rightarrow\psi</math>, then <math>T \vdash \psi</math>
</indent>
where <math>T \vdash \varphi</math> indicates <math>\varphi</math> is provable in theory <it>T</it>.
There are deductive systems (known as <link xlink:type="simple" xlink:href="../655/8529655.xml">
Hilbert-style deductive system</link>s) in which modus ponens is the sole rule of inference; in such systems, the lack of other inference rules is offset with an abundance of logical axiom schemes. </p>
<p>

A second important inference rule is <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link xlink:type="simple" xlink:href="../333/939333.xml">
Universal Generalization</link></rule>
</concept>
</idea>
. It can be stated as
<indent level="1">

if <math>T \vdash \varphi</math>, then <math>T \vdash \forall x \, \varphi</math>
</indent>
Which reads: if φ is a theorem, then "for every x, φ" is a theorem as well.
The similar-looking schema <math>\varphi\rightarrow\forall x \, \varphi</math> is not sound, in general, although it does however have valid instances, such as when x does not occur free in φ (see <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link xlink:type="simple" xlink:href="../333/939333.xml">
Generalization (logic)</link></rule>
</concept>
</idea>
).</p>

</ss1>
<ss1>
<st>
Axioms</st>

<p>

Here follows a description of the axioms of first-order logic. As explained above, a given first-order theory has further, non-logical axioms. The following logical axioms characterize a predicate calculus for this article's example of first-order logic<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>.</p>
<p>

For any theory, it is of interest to know whether the set of axioms can be generated by an algorithm, or if there is an algorithm which determines whether a well-formed formula is an axiom.</p>
<p>

If there is an algorithm to generate all axioms, then the set of axioms is said to be <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable</link>.</p>
<p>

If there is an algorithm which determines after a finite number of steps whether a formula is an axiom or not, then the set of axioms is said to be <link xlink:type="simple" xlink:href="../264/332264.xml">
recursive</link> or <it>decidable</it>. In that case, one may also construct an algorithm to generate all axioms: this algorithm simply builds all possible formulas one by one (with growing length), and for each formula the algorithm determines whether it is an axiom.</p>
<p>

Axioms of first-order logic are always decidable. However, in a first-order theory non-logical axioms are not necessarily such.</p>

<ss2>
<st>
Quantifier axioms</st>

<p>

Quantifier axioms change according to how the vocabulary is defined, how the substitution procedure works, what the formation rules are and which inference rules are used. Here follows a specific example of these axioms</p>
<p>

<list>
<entry level="1" type="bullet">

 PRED-1: <math>(\forall x Z(x)) \rightarrow Z(t)</math></entry>
<entry level="1" type="bullet">

 PRED-2: <math>Z(t) \rightarrow (\exists x Z(x))</math></entry>
<entry level="1" type="bullet">

 PRED-3: <math>(\forall x (W \rightarrow  Z(x))) \rightarrow  (W \rightarrow \forall x Z(x))</math></entry>
<entry level="1" type="bullet">

 PRED-4: <math>(\forall x (Z(x) \rightarrow W)) \rightarrow (\exists x Z(x) \rightarrow W)</math></entry>
</list>

These are actually <link xlink:type="simple" xlink:href="../613/764613.xml">
axiom schema</link>ta: the expression <it>W</it> stands for any wff in which <it>x</it> is not free, and
the expression <it>Z</it>(<it>x</it>) stands for any wff with the additional convention that <it>Z</it>(<it>t</it>) stands for the result of substitution of the term <it>t</it> for <it>x</it> in <it>Z</it>(<it>x</it>). Thus this is a <link xlink:type="simple" xlink:href="../264/332264.xml">
recursive set</link> of axioms.</p>
<p>

Another axiom, <math>Z \rightarrow \forall x Z</math>, for Z in which x does not occur free, is sometimes added.</p>

</ss2>
<ss2>
<st>
Equality and its axioms</st>

<p>

There are several different conventions for using equality (or identity) in first-order logic. This section summarizes the main ones. The various conventions all give essentially the same results with about the same amount of work, and differ mainly in terminology.</p>
<p>

<list>
<entry level="1" type="bullet">

The most common convention for equality is to include the equality symbol as a primitive logical symbol, and add the axioms for equality to the axioms for first-order logic. The equality axioms are</entry>
<entry level="2" type="indent">

<it>x</it> = <it>x''</it></entry>
<entry level="2" type="indent">

<it>x</it> = <it>y</it> → <it>f</it>(...,<it>x</it>,...) = <it>f</it>(...,<it>y</it>,...) for any function <it>f''</it></entry>
<entry level="2" type="indent">

<it>x</it> = <it>y</it> → (<it>P</it>(...,<it>x</it>,...) → <it>P</it>(...,<it>y</it>,...)) for any relation <it>P</it> (including the equality relation itself)</entry>
<entry level="1" type="indent">

These are, too, <link xlink:type="simple" xlink:href="../613/764613.xml">
axiom schema</link>ta: they define an algorithm which decides whether a given formula is an axiom.  Thus this is a <link xlink:type="simple" xlink:href="../264/332264.xml">
recursive set</link> of axioms.</entry>
<entry level="1" type="bullet">

The next most common convention is to include the equality symbol as one of the relations of a theory, and add the equality axioms to the axioms of the theory. In practice this is almost indistinguishable from the previous convention, except in the unusual case of theories with no notion of equality. The axioms are the same, and the only difference is whether one calls some of them logical axioms or axioms of the theory. </entry>
<entry level="1" type="bullet">

In theories with no functions and a finite number of relations, it is possible to define equality in terms of the relations, by defining the two terms <it>s</it> and <it>t</it> to be  equal if any relation is unchanged by changing <it>s</it> to <it>t</it> in any argument.</entry>
<entry level="2" type="indent">

For example, in set theory with one relation <math>\in</math>, we may define <it>s</it> = <it>t</it> to be an abbreviation for <math>\forall</math><it>x</it> (<it>s</it> <math>\in</math> <it>x</it> <math>\leftrightarrow</math> <it>t</it> <math>\in</math> <it>x</it>) <math>\wedge</math> <math>\forall</math><it>x</it> (<it>x</it> <math>\in</math> <it>s</it> <math>\leftrightarrow</math> <it>x</it> <math>\in</math>  <it>t</it>). This definition of equality then automatically satisfies the axioms for equality. In this case, one should replace the usual <link xlink:type="simple" xlink:href="../376/52376.xml">
axiom of extensionality</link>, <math>\forall x \forall y [ \forall z (z \in x \Leftrightarrow z \in y) \Rightarrow x = y]</math>, by <math>\forall x \forall y [ \forall z (z \in x \Leftrightarrow z \in y) \Rightarrow \forall z (x \in z \Leftrightarrow y \in z) ]</math>, i.e. if  <it>x</it> and <it>y</it> have the same elements, then they belong to the same sets.</entry>
<entry level="1" type="bullet">

In some theories it is possible to give <it>ad hoc</it> definitions of equality. For example, in a theory of partial orders with one relation ≤ we could define <it>s</it> = <it>t</it> to be an abbreviation for <it>s</it> ≤ <it>t</it> <math>\wedge</math> <it>t</it> ≤ <it>s</it>.</entry>
</list>
</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
Semantics</st>

<ss1>
<st>
Interpretations</st>

<p>

<indent level="1">

<it>Main article: <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../671/14511671.xml">
Interpretation (logic)</link></language>
</it>
</indent>
In logic and mathematics, an  <it>interpretation</it> (also mathematical interpretation, logico-mathematical interpretation, or commonly a model) gives meaning to an artificial or formal language by assigning a denotation to all non-logical constants in that language or in a sentence of that language.</p>
<p>

For a given formal language L, or a sentence Φ of L, an interpretation assigns a denotation to each non-logical constant occurring in L or Φ. To individual constants it assigns individuals (from some universe of discourse); to predicates of degree 1 it assigns properties (more precisely sets) ; to predicates of degree 2 it assigns binary relations of individuals; to predicates of degree 3 it assigns ternary relations of individuals, and so on; and to sentential letters it assigns truth-values.</p>
<p>

More precisely, an interpretation of a formal language L or of a sentence Φ of L, consists of a non-empty domain D (i.e. a non-empty set) as the universe of discourse together with an assignment that associates with each n-ary operation or function symbol of L or of Φ an n-ary operation with respect to D (i.e. a function from <math>D^n</math> into <math>D</math>); with each n-ary predicate of L or of Φ an n-ary relation among elements of D and (optionally) with some binary predicate I of L, the identity relation among elements of D.</p>
<p>

In this way an interpretation provides meaning or semantic values to the terms or formulae of the language. The study of the interpretations of formal languages is called formal semantics. In mathematical logic an interpretation is a mathematical object that contains the necessary information for an interpretation in the former sense.</p>
<p>

The symbols used in a formal language include variables, logical-constants, quantifiers and punctuation symbols as well as the non-logical constants. The interpretation of a sentence or language therefore depends on which non-logical constants it contains. Languages of the sentential (or propositional) calculus are allowed sentential symbols as non-logical constants. Languages of the first order predicate calculus allow in addition predicate symbols and operation or function symbols.</p>

</ss1>
<ss1>
<st>
Models</st>

<p>

A <it>model</it> is a pair <math>\langle D,I \rangle</math>, where <it>D</it> is a set of elements called the domain while <it>I</it> is an interpretation of the elements of a signature (functions, and predicates).</p>
<p>

<list>
<entry level="1" type="bullet">

 the domain <it>D</it> is a set of elements;</entry>
<entry level="1" type="bullet">

 the interpretation <it>I</it> is a function that assigns something to constants, functions and predicates:</entry>
<entry level="2" type="bullet">

 each function symbol <it>f</it> of arity <it>n</it> is assigned a function <it>I(f)</it> from <math>D^n</math> to <math>D</math></entry>
<entry level="2" type="bullet">

 each predicate symbol <it>P</it> of arity <it>n</it> is assigned a relation <it>I(P)</it> over <math>D^n</math> or, equivalently, a function from <math>D^n</math> to <math>\{true, false\}</math></entry>
</list>
</p>
<p>

The following is an intuitive explanation of these elements.</p>
<p>

The domain <it>D</it> is a set of "objects" of some kind. Intuitively, a first-order formula is a statement about objects; for example, <math>\exists x . P(x)</math> states the existence of an object <it>x</it> such that the predicate <it>P</it> is true where referred to it. The domain is the set of considered objects. As an example, one can take <math>D</math> to be the set of integer numbers.</p>
<p>

The model also includes an interpretation of the signature. Since the elements of the signature are function symbols and predicate symbols, the interpretation gives the "value" of functions and predicates.</p>
<p>

The interpretation of a function symbol is a function. For example, the function symbol <math>f(\_,\_)</math> of arity 2 can be interpreted as the function that gives the sum of its arguments. In other words, the symbol <math>f</math> is associated the function <it>I(f)</it> of addition in this interpretation. In particular, the interpretation of a constant is a function from the one-element set <it>D</it>0 to <it>D</it>, which can be simply identified with an object in <it>D</it>. For example, an interpretation may assign the value <math>I(c)=10</math> to the constant <math>c</math>.</p>
<p>

The interpretation of a predicate of arity <it>n</it> is a set of n-tuples of elements of the domain. This means that, given an interpretation, a predicate, and n elements of the domain, one can tell whether the predicate is true over those elements and according to the given interpretation. As an example, an interpretation <it>I(P)</it> of a predicate <it>P</it> of arity two may be the set of pairs of integers such that the first one is less than the second. According to this interpretation, the predicate <it>P</it> would be true if its first argument is less than the second.</p>

</ss1>
<ss1>
<st>
Evaluation</st>

<p>

A formula evaluates to true or false given a model and an interpretation of the value of the variables. Such an interpretation <math>\mu</math> associates every variable to a value of the domain.</p>
<p>

The evaluation of a formula under a model <math>M=\langle D,I \rangle</math> and an interpretation <math>\mu</math> of the variables is defined from the evaluation of a term under the same pair. Note that the model itself contains an interpretation (which evaluates functions, and predicates); we additionally have, separated from the model, an interpretation</p>
<p>

<list>
<entry level="1" type="bullet">

 every variable is associated its value according to <math>\mu</math>;</entry>
<entry level="1" type="bullet">

 a term <math>f(t_1,\ldots,t_n)</math> is associated the value given by the interpretation of the function and the interpretation of the terms: if <math>v_1,\ldots,v_n</math> are the values associated to <math>t_1,\ldots,t_n</math>, the term is associated the value <math>I(f)(v_1,\ldots,v_n)</math>; recall that <math>I(f)</math> is the interpretation of <it>f</it>, and so is a function from <math>D^n</math> to <it>D</it>.</entry>
</list>
</p>
<p>

The interpretation of a formula is given as follows.</p>
<p>

<list>
<entry level="1" type="bullet">

 a formula <math>P(t_1,\ldots,t_n)</math> is associated the value true or false depending on whether <math>v_1,\ldots,v_n \in I(D)</math>, where <math>v_1,\ldots,v_n</math> are the evaluation of the terms <math>t_1,\ldots,t_n</math> and <math>I(P)</math> is the interpretation of <math>P</math>, which by assumption is a subset of <math>D^n</math></entry>
<entry level="1" type="bullet">

 a formula in the form <math>\neg A</math> or <math>A \rightarrow 
B</math> is evaluated in the obvious way</entry>
<entry level="1" type="bullet">

 a formula <math>\exists x . A</math> is true according to <it>M</it> and <math>\mu</math> if there exists an evaluation <math>\mu'</math> of the variables that only differs from <math>\mu</math> regarding the evaluation of <it>x</it> and such that <it>A</it> is true according to the model <it>M</it> and the interpretation <math>\mu'</math></entry>
<entry level="1" type="bullet">

 a formula <math>\forall x . A</math> is true according to <it>M</it> and <math>\mu</math> if <it>A</it> is true for every pair composed by the model <it>M</it> and an interpretation <math>\mu'</math> that differs from <math>\mu</math> only on the value of <it>x''</it></entry>
</list>
</p>
<p>

If a formula does not contain free variables, then the evaluation of the variables does not affects its truth. In other words, in this case <it>F</it> is true according to <it>M</it> and <math>\mu</math> if and only if is true according to <it>M</it> and a different interpretation of the variables <math>\mu'</math>.</p>

</ss1>
<ss1>
<st>
Validity and satisfiability</st>

<p>

A model <it>M</it> satisfies a formula <it>F</it> if this formula is true according to <it>M</it> and every possible evaluation of its variables. 
A formula is valid if it is true in every possible model and interpretation of the variables.</p>
<p>

A formula is satisfiable if there exists a model and an interpretation of the variables that satisfy the formula.</p>

</ss1>
</sec>
<sec>
<st>
 Predicate calculus </st>
<p>

The predicate calculus is a proper extension of the <link xlink:type="simple" xlink:href="../335/5597335.xml">
propositional calculus</link> that defines which statements of first-order logic are provable. Many (but not all) <link xlink:type="simple" xlink:href="../746/30746.xml">
mathematical theories</link> can be formulated in the predicate calculus. If the propositional calculus is defined with a suitable set of axioms and the single rule of inference <link xlink:type="simple" xlink:href="../900/18900.xml">
modus ponens</link> (this can be done in many ways), then the predicate calculus can be defined by appending to the propositional calculus several axioms and the inference rule called "universal generalization". As axioms for the predicate calculus we take:
<list>
<entry level="1" type="bullet">

All tautologies of the propositional calculus, taken schematically so that the uniform replacement of a schematic letter by a formula is allowed.</entry>
<entry level="1" type="bullet">

The quantifier axioms, given above.</entry>
<entry level="1" type="bullet">

The above axioms for equality, if equality is regarded as a logical concept.</entry>
</list>

A sentence is defined to be <b>provable in first-order logic</b> if it can be derived from the axioms of the predicate calculus, by repeatedly applying the inference rules "modus ponens" and "universal generalization". In other words:
<list>
<entry level="1" type="bullet">

 An axiom of the predicate calculus is provable in first-order logic by definition.</entry>
<entry level="1" type="bullet">

 If the <link xlink:type="simple" xlink:href="../337/7993337.xml">
premise</link>s of an inference rule are provable in first-order logic, then so is its <link xlink:type="simple" xlink:href="../907/307907.xml">
conclusion</link>.</entry>
</list>
</p>
<p>

If we have a theory <it>T</it> (a set of statements, called axioms, in some language) then a sentence φ is defined to be <b>provable in the theory <it>T</it></b> if </p>
<p>

<indent level="1">

<math> a_1 \wedge a_2 \wedge \ldots \wedge a_n \rightarrow \varphi</math>
</indent>

is provable in first-order logic, for some finite set of axioms <math>a_1, a_2,\ldots,a_n</math> of the theory <it>T</it>. In other words, if one can prove in first-order logic that φ follows from the axioms of <it>T</it>. This also means, that we replace the above procedure for finding provable sentences by the following one:
<list>
<entry level="1" type="bullet">

 An axiom of <it>T</it> is provable in <it>T</it>.</entry>
<entry level="1" type="bullet">

 An axiom of the predicate calculus is provable in <it>T</it>.</entry>
<entry level="1" type="bullet">

 If the <link xlink:type="simple" xlink:href="../337/7993337.xml">
premise</link>s of an inference rule are provable in <it>T</it>, then so is its <link xlink:type="simple" xlink:href="../907/307907.xml">
conclusion</link>.</entry>
</list>
</p>
<p>

One apparent problem with this definition of provability is that it seems rather ad hoc: we have taken some apparently random collection of axioms and rules of inference, and it is unclear that we have not accidentally missed out some vital axiom or rule. <link>
Gödel's completeness theorem</link> assures us that this is not really a problem: any statement true in all models (semantically true) is provable in first-order logic (syntactically true). In particular, any reasonable definition of "provable" in first-order logic must be equivalent to the one above (though it is possible for the lengths of proofs to differ vastly for different definitions of provability).  </p>
<p>

There are many different (but equivalent) ways to define provability. The above definition is typical for a "Hilbert style" calculus, which has many axioms but very few rules of inference. By contrast, a <link xlink:type="simple" xlink:href="../329/252329.xml">
"Gentzen style" predicate calculus</link> has few axioms but many rules of inference.</p>

<ss1>
<st>
 Provable identities </st>
<p>

The following sentences can be called "identities" because the main connective in each is the <link xlink:type="simple" xlink:href="../783/228783.xml">
biconditional</link>. They are all provable in FOL, and are useful when manipulating the quantifiers:
<indent level="1">

<math>\lnot \forall x \, P(x) \Leftrightarrow \exists x \, \lnot P(x)</math>
</indent>
:<math>\lnot \exists x \, P(x) \Leftrightarrow \forall x \, \lnot P(x)</math>
<indent level="1">

<math>\forall x \, \forall y \, P(x,y) \Leftrightarrow \forall y \, \forall x \, P(x,y)</math>
</indent>
:<math>\exists x \, \exists y \, P(x,y) \Leftrightarrow \exists y \, \exists x \, P(x,y)</math>
<indent level="1">

<math>\forall x \, P(x) \land \forall x \, Q(x) \Leftrightarrow \forall x \, (P(x) \land Q(x)) </math>
</indent>
:<math>\exists x \, P(x) \lor \exists x \, Q(x) \Leftrightarrow \exists x \, (P(x) \lor Q(x)) </math>
<indent level="1">

<math>P \land \exists x \, Q(x) \Leftrightarrow \exists x \, (P \land Q(x)) </math> (where <math>x</math> must not occur free in <math>P</math>)
</indent>
:<math>P \lor \forall x \, Q(x) \Leftrightarrow \forall x \, (P \lor Q(x)) </math> (where <math>x</math> must not occur free in <math>P</math>)</p>

</ss1>
<ss1>
<st>
 Provable inference rules </st>
<p>

The main connective in the following sentences, also provable in FOL, is the <link xlink:type="simple" xlink:href="../808/658808.xml">
conditional</link>. These sentences can be seen as the justification for inference rules in addition to <link xlink:type="simple" xlink:href="../900/18900.xml">
modus ponens</link> and universal generalization discussed above and assumed valid:
<indent level="1">

<math>\exists x \, \forall y \, P(x,y) \Rightarrow \forall y \, \exists x \, P(x,y)</math>
</indent>
:<math>\forall x \, P(x) \lor \forall x \, Q(x) \Rightarrow \forall x \, (P(x) \lor Q(x)) </math>
<indent level="1">

<math>\exists x \, (P(x) \land Q(x)) \Rightarrow \exists x \, P(x) \land \exists x \, Q(x)</math>
</indent>
:<math>\exists x \, P(x) \land \forall x \, Q(x) \Rightarrow \exists x \, (P(x) \land Q(x)) </math>
<indent level="1">

<math>\forall x \, P(x) \Rightarrow P(c)</math> (If <it>c</it> is a variable, then it must not be previously quantified in <it>P</it>(<it>x</it>))
</indent>
:<math>P(c) \Rightarrow \exists x \, P(x)</math> (there must be no free instance of <it>x</it> in <it>P</it>(<it>c</it>))</p>

</ss1>
</sec>
<sec>
<st>
Metalogical theorems of first-order logic</st>

<p>

Some important metalogical theorems are listed below in bulleted form. What they roughly mean is that a sentence is valid if and only if it is provable. Furthermore, one can construct a program which works as follows: if a sentence is provable, the program will always answer "provable" after some unknown, possibly very large, amount of time. If a sentence is not provable, the program may run forever. In the latter case, we will not know whether the sentence is provable or not, since we cannot tell whether the program is about to answer or not. In other words, the validity of sentences is <link xlink:type="simple" xlink:href="../118/913118.xml#xpointer(//*[./st=%22Semidecidability%22])">
semidecidable</link>.</p>
<p>

One may construct an algorithm which will determine in finite number of steps whether a sentence is provable (a <link xlink:type="simple" xlink:href="../118/913118.xml">
decidable</link> algorithm) only for simple classes of first-order logic.</p>
<p>

<list>
<entry level="1" type="number">

 The decision problem for validity is <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable</link>; in other words, there is a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 that when given any sentence as input, will halt if and only if the sentence is valid (true in all models).</entry>
<entry level="2" type="bullet">

 As <link>
Gödel's completeness theorem</link> shows, any valid formula is provable. Conversely, assuming consistency of the logic, any provable formula is valid.</entry>
<entry level="2" type="bullet">

 The Turing machine can be one which generates all provable formulas in the following manner: for a finite or <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable set</link> of axioms, such a machine can be one that generates an axiom, then generates a new provable formula by application of axioms and inference rules already generated, then generate another axiom, and so on. Given a sentence as input, the Turing machine simply go on and generates all provable formulas one by one, and will halt if it generates the sentence.</entry>
<entry level="1" type="number">

 Unlike <link xlink:type="simple" xlink:href="../335/5597335.xml">
propositional logic</link>, first-order logic is <link xlink:type="simple" xlink:href="../118/913118.xml">
undecidable</link> (although semidecidable), provided that the language has at least one predicate of valence at least 2 other than equality. This means that there is no <link xlink:type="simple" xlink:href="../336/8336.xml">
decision procedure</link> that determines whether an arbitrary formula is valid or not. Because there is a Turing machine as described above, the undecidability is related to the unsolvability of the <link xlink:type="simple" xlink:href="../668/13668.xml">
Halting problem</link>: there is no algorithm which determines after a finite number of steps whether the Turing machine will ever halt for a given sentence as its input, hence whether the sentence is provable. This result was established independently by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Church</link></scientist>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Turing</link></scientist>
</person>
. </entry>
<entry level="1" type="number">

 <link xlink:type="simple" xlink:href="../680/8015680.xml">
Monadic predicate logic</link> (i.e., predicate logic with only predicates of one argument and no functions) is decidable.</entry>
<entry level="1" type="number">

 The <link>
Bernays–Schönfinkel class</link> of first-order formulas is also decidable.</entry>
</list>
</p>

</sec>
<sec>
<st>
Translating natural language to first-order logic</st>
<p>

Concepts expressed in natural language must be "translated" to first-order logic (FOL) before FOL can be used to address them, and there are a number of potential
pitfalls in this translation.
In FOL, <math>p \or q</math> means "p, or q, or both", that is, it is
<it>inclusive</it>.  In English, the word "or" is sometimes inclusive (e.g,
"cream or sugar?"), but sometimes it is exclusive (e.g., "coffee or tea?"
is usually intended to mean one or the other, not both).
Similarly, the English word "some" may mean "at least one, possibly all", but
other times it may mean "not all, possibly none".
The English word "and" should sometimes be translated as "or" (e.g.,
"men and women may apply").
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>

</sec>
<sec>
<st>
Limitations of first-order logic</st>

<p>

All mathematical notations have their strengths and weaknesses; here are a few such issues with first-order logic.</p>

<ss1>
<st>
 Difficulty in characterizing finiteness or countability </st>

<p>

It follows from the <link>
Löwenheim–Skolem theorem</link> that it is not possible to define finiteness or countability in a first-order language. That is, there is no first-order formula φ(<it>x</it>) such that for any model M, M is a model of φ iff the extension of φ in M is finite (or in the other case, countable). In first-order logic without identity the situation is even worse, since no first-order formula φ(<it>x</it>) can define "there exist <it>n</it> elements satisfying φ" for some fixed finite cardinal <it>n</it>. A number of properties not definable in first-order languages are definable in stronger languages. For example, in first-order logic one cannot assert the <link xlink:type="simple" xlink:href="../692/42692.xml">
least-upper-bound</link> property for sets of <link xlink:type="simple" xlink:href="../491/19725491.xml">
real number</link>s, which states that every bounded, nonempty set of real numbers has a <link xlink:type="simple" xlink:href="../692/42692.xml">
supremum</link>; A <link xlink:type="simple" xlink:href="../428/341428.xml">
second-order logic</link> is needed for that.</p>

</ss1>
<ss1>
<st>
 Difficulty representing if-then-else </st>

<p>

Oddly enough, FOL with equality (as typically defined) does not include or permit defining an if-then-else predicate or function if(c,a,b), where "c" is a condition expressed as a formula, while a and b are either both terms or both formulas, and its result would be "a" if c is true, and "b" if it is false.  The problem is that in FOL, both predicates and functions can only accept terms ("non-booleans") as parameters, but the "obvious" representation of the condition is a formula ("boolean").  This is unfortunate, since many mathematical functions are conveniently expressed in terms of if-then-else, and if-then-else is fundamental for describing most computer programs.</p>
<p>

Mathematically, it is possible to redefine a complete set of new functions that match the formula operators, but this is quite clumsy.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
A predicate if(c,a,b) can be expressed in FOL if rewritten as <math>(c \wedge a) \or (\neg c \wedge b)</math> (or, equivalently, <math>(c \rightarrow a) \wedge (\neg c \rightarrow b)</math>), but this is clumsy if the condition c is complex.  Many extend FOL to add a special-case predicate named "if(condition, a, b)" (where a and b are formulas) and/or function "ite(condition, a, b)" (where a and b are terms), both of which accept a formula as the condition, and are equal to "a" if condition is true and "b" if it is false.  These extensions make FOL easier to use for some problems, and make some kinds of automatic theorem-proving easier.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>
Others extend FOL further so that functions and predicates can accept both terms and formulas at any position.</p>

</ss1>
<ss1>
<st>
 Typing (Sorts) </st>

<p>

FOL does not include types (sorts) into the notation itself, other than the
difference between formulas ("booleans") and terms ("non-booleans").
Some argue that this lack of types is a great advantage
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref>, but many others find advantages in defining and using types (sorts), such as helping reject some erroneous or undesirable specifications<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref>.
Those who wish to indicate types must provide such information using the notation available in FOL.  Doing so can make such expressions more complex, and can also be easy to get wrong.</p>
<p>

Single-parameter predicates can be used to implement the notion of types where appropriate. For example, in:
<math>\forall x (\mathit{Man}(x) \rightarrow \mathit{Mortal}(x) )</math>,
the predicate <math>\mathit{Man}(x)</math> could be considered a kind of "type assertion" (that is, that <math>x</math> must be a man).
Predicates can also be used with the "exists" quantifier to identify types,
but this should usually be done with the "and" operator instead, e.g.:
<math>\exists x (\mathit{Man}(x) \wedge \mathit{Mortal}(x) )</math> ("there exists something that is both a man and is mortal").
It is easy to write
<math>\exists x (\mathit{Man}(x) \rightarrow \mathit{Mortal}(x) )</math>, but this would be equivalent to
<math>(\exists x \neg \mathit{Man}(x)) \or \exists x \mathit{Mortal}(x)</math> ("there is something that is not a man, and/or there exists something that is mortal"), which is usually
not what was intended.
Similarly, assertions can be made that one type is a subtype of another type, e.g.:
<math>\forall x (\mathit{Man}(x) \rightarrow \mathit{Mammal}(x) )</math>  ("for all <math>x</math>, if <math>x</math> is a man, then <math>x</math> is a mammal").</p>

</ss1>
<ss1>
<st>
 Graph reachability cannot be expressed </st>

<p>

Many situations can be modeled as a <link xlink:type="simple" xlink:href="../986/19721986.xml">
graph</link> of nodes and directed connections (edges).  For example, validating many systems requires showing that a "bad" state cannot be reached from a "good" state, and these interconnections of states can often be modelled as a graph.
However, it can be proved that connectedness cannot be fully expressed in predicate logic.  In other words, there is no predicate-logic formula <math>\phi</math> and <math>R</math> as its only predicate symbol (of arity 2) such that <math>\phi</math> holds in a interpretation <math>I</math> if and only if the extension of <math>R</math> in <math>I</math> describes a connected graph: that is, 
connected graphs cannot be axiomatized.</p>
<p>

Note that given a binary relation <math>R</math> encoding a graph, one can describe <math>R</math> in terms of 
a conjunction of first order formulas, and write a formula <math>\phi_{R}</math> which is satisfiable if and only if <math>R</math> is connected.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></p>

</ss1>
</sec>
<sec>
<st>
Comparison with other logics</st>

<p>

<list>
<entry level="1" type="bullet">

<b>Typed first-order logic</b> allows variables and terms to have various <b>types</b> (or <b>sorts</b>). If there are only a finite number of types, this does not really differ much from first-order logic, because one can describe the types with a finite number of unary predicates and a few axioms. Sometimes there is a special type Ω of truth values, in which case formulas are just terms of type Ω.</entry>
<entry level="1" type="bullet">

<b>First-order logic with domain conditions</b> adds domain conditions (DCs) to classical first-order logic, enabling the handling of partial functions; these conditions can be proven "on the side" in a manner similar to <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../947/1848947.xml">
PVS</link></language>
's type correctness conditions.  It also adds if-then-else to keep definitions and proofs manageable (they became too complex without them).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></entry>
<entry level="1" type="bullet">

The <b>SMT-LIB Standard</b> defines a language used by many research groups for satisfiability modulo theories; the full logic is based on FOL with equality, but adds sorts (types), if-then-else for terms and formulas (ite() and if.. then.. else..), a let construct for terms and formulas (let and flet), and a <it>distinct</it> construct declaring a set of listed values as distinct.  Its connectives are <it>not</it>, <it>implies</it>, <it>and</it>, <it>or</it>, <it>xor</it>, and <it>iff</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></entry>
<entry level="1" type="bullet">

<b>Weak second-order logic</b> allows quantification over finite subsets.</entry>
<entry level="1" type="bullet">

<b>Monadic second-order logic</b> allows quantification over subsets, that is, over <it>unary</it> predicates.</entry>
<entry level="1" type="bullet">

<b><system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../428/341428.xml">
Second-order logic</link></instrumentality>
</artifact>
</system>
</b> allows quantification over subsets and relations, that is, over all predicates. For example, the <link xlink:type="simple" xlink:href="../376/52376.xml">
axiom of extensionality</link> can be stated in second-order logic as <it>x</it> = <it>y</it> ≡def <math>\forall</math><it>P</it> (<it>P</it>(<it>x</it>) ↔ <it>P</it>(<it>y</it>)).  The strong semantics of second-order logic give such sentences a much stronger meaning than first-order semantics. </entry>
<entry level="1" type="bullet">

<b><system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../883/562883.xml">
Higher-order logic</link></instrumentality>
</artifact>
</system>
s</b> allows quantification over higher types than second-order logic permits. These higher types include relations between relations, functions from relations to relations between relations, etc. </entry>
<entry level="1" type="bullet">

<b><link xlink:type="simple" xlink:href="../262/169262.xml">
Intuitionistic first-order logic</link></b> uses intuitionistic rather than classical propositional calculus; for example, ¬¬φ need not be equivalent to φ. Similarly, <b><link xlink:type="simple" xlink:href="../501/13727501.xml">
first-order fuzzy logics</link></b> are first-order extensions of propositional fuzzy logics rather than classical logic.</entry>
<entry level="1" type="bullet">

<b><link xlink:type="simple" xlink:href="../365/333365.xml">
Modal logic</link></b> has extra <it>modal operators</it> with meanings which can be characterised informally as, for example  "it is necessary that φ" and "it is possible that φ".</entry>
<entry level="1" type="bullet">

In <b><link xlink:type="simple" xlink:href="../680/8015680.xml">
monadic predicate calculus</link></b> predicates are restricted to having only one argument. </entry>
<entry level="1" type="bullet">

<b><system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../478/630478.xml">
Infinitary logic</link></instrumentality>
</artifact>
</system>
</b> allows infinitely long sentences. For example, one may allow a conjunction or disjunction of infinitely many formulas, or quantification over infinitely many variables. Infinitely long sentences arise in areas of mathematics including  <link xlink:type="simple" xlink:href="../954/29954.xml">
topology</link> and <link xlink:type="simple" xlink:href="../858/19858.xml">
model theory</link>.</entry>
<entry level="1" type="bullet">

<b>First-order logic with extra quantifiers</b> has new quantifiers <it>Qx</it>,..., with meanings such as "there are many <it>x</it> such that ...". Also see <link xlink:type="simple" xlink:href="../834/3573834.xml">
branching quantifier</link>s and the <link xlink:type="simple" xlink:href="../789/444789.xml">
plural quantifier</link>s of <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../621/340621.xml">
George Boolos</link></person>
 and others.</entry>
<entry level="1" type="bullet">

<b>Predicate Logic with Definitions</b> (PLD, or D-logic) modifies FOL by formally adding syntactic definitions as a type of value (in addition to formulas and terms); these definitions can be used inside terms and formulas<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref>.</entry>
<entry level="1" type="bullet">

<b><system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../007/1974007.xml">
Independence-friendly logic</link></instrumentality>
</artifact>
</system>
</b>  is characterized by <link xlink:type="simple" xlink:href="../834/3573834.xml">
branching quantifier</link>s, which allow one to express independence between quantified variables.</entry>
</list>
</p>
<p>

Most of these logics are in some sense extensions of FOL: they include all the quantifiers and logical operators of FOL with the same meanings. Lindström showed that FOL has no extensions (other than itself) that satisfy both the <link xlink:type="simple" xlink:href="../207/152207.xml">
compactness theorem</link> and the downward <link>
Löwenheim–Skolem theorem</link>. A precise statement of <link>
Lindström's theorem</link> requires a few technical conditions that the logic is assumed to satisfy; for example, changing the symbols of a language should make no essential difference to which sentences are true.</p>

<ss1>
<st>
Algebraizations</st>
<p>

Three ways of eliminating quantified variables from FOL, and that do not involve replacing quantifiers with other variable binding term operators, are known:
<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../887/7852887.xml">
Cylindric algebra</link>, by <citizen wordnetid="109923673" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<disbeliever wordnetid="110015897" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<national wordnetid="109625401" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<atheist wordnetid="109820044" confidence="0.8">
<nonreligious_person wordnetid="109625789" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/59920.xml">
Alfred Tarski</link></scholar>
</mathematician>
</logician>
</nonreligious_person>
</atheist>
</causal_agent>
</scientist>
</intellectual>
</national>
</philosopher>
</person>
</disbeliever>
</physical_entity>
</expert>
</citizen>
 and his coworkers;</entry>
<entry level="1" type="bullet">

<link>
Polyadic algebra</link>, by <analyst wordnetid="109790482" confidence="0.8">
<citizen wordnetid="109923673" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<national wordnetid="109625401" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<statistician wordnetid="110653238" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../598/318598.xml">
Paul Halmos</link></mathematician>
</causal_agent>
</statistician>
</associate>
</scientist>
</colleague>
</national>
</person>
</physical_entity>
</peer>
</expert>
</citizen>
</analyst>
;</entry>
<entry level="1" type="bullet">

<maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<link xlink:type="simple" xlink:href="../871/15282871.xml">
Predicate functor logic</link></auditory_communication>
</saying>
</speech>
</maxim>
, mainly due to <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../833/33833.xml">
Willard Quine</link></philosopher>
</person>
.</entry>
</list>

These <link xlink:type="simple" xlink:href="../923/18716923.xml">
algebra</link>s:
<list>
<entry level="1" type="bullet">

Are all proper extensions of the <link xlink:type="simple" xlink:href="../449/2584449.xml">
two-element Boolean algebra</link>, and thus are <link xlink:type="simple" xlink:href="../304/469304.xml">
lattices</link>;</entry>
<entry level="1" type="bullet">

Do for FOL what <link xlink:type="simple" xlink:href="../343/990343.xml">
Lindenbaum-Tarski algebra</link> does for <link xlink:type="simple" xlink:href="../154/18154.xml">
sentential logic</link>;</entry>
<entry level="1" type="bullet">

Allow results from <link xlink:type="simple" xlink:href="../384/19616384.xml">
abstract algebra</link>, <link xlink:type="simple" xlink:href="../200/45200.xml">
universal algebra</link>, and <link xlink:type="simple" xlink:href="../924/361924.xml">
order theory</link> to be brought to bear on FOL. </entry>
</list>
</p>
<p>

Tarski and Givant (1987) show that the fragment of FOL that has no <link xlink:type="simple" xlink:href="../457/943457.xml">
atomic sentence</link> lying in the scope of more than three quantifiers, has the same expressive power as <link xlink:type="simple" xlink:href="../670/4363670.xml">
relation algebra</link>. This fragment is of great interest because it suffices for <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link> and most <link xlink:type="simple" xlink:href="../553/27553.xml">
axiomatic set theory</link>, including the canonical <link>
ZFC</link>. They also prove that FOL with a primitive <link xlink:type="simple" xlink:href="../362/22362.xml">
ordered pair</link> is equivalent to a relation algebra with two ordered pair <link>
projection function</link>s.</p>

</ss1>
</sec>
<sec>
<st>
Automation</st>
<p>

Theorem proving for first-order logic is one of the most mature subfields of <link xlink:type="simple" xlink:href="../546/2546.xml">
automated theorem proving</link>. The logic is expressive enough to allow the specification of arbitrary problems, often in a reasonably natural and intuitive way. On the other hand, it is still <link xlink:type="simple" xlink:href="../090/332090.xml">
semidecidable</link>, and a number of sound and complete calculi have been developed, enabling fully automated systems.
In 1965 <skilled_worker wordnetid="110605985" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<exile wordnetid="110071332" confidence="0.8">
<absentee wordnetid="109757653" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../114/8895114.xml">
J. Alan Robinson</link></scholar>
</mathematician>
</causal_agent>
</alumnus>
</worker>
</editor>
</associate>
</absentee>
</exile>
</scientist>
</colleague>
</traveler>
</intellectual>
</person>
</physical_entity>
</peer>
</skilled_worker>
 achieved an important breakthrough with his <link xlink:type="simple" xlink:href="../082/2724082.xml">
resolution</link> approach; to prove a theorem it tries to refute the negated theorem, in a goal-directed way, resulting in a much more efficient method to automatically prove theorems in FOL.
More expressive logics, such as higher-order and modal logics, allow the convenient expression of a wider range of problems than first-order logic, but theorem proving for these logics is less well developed.</p>
<p>

A modern and particularly disruptive new technology is that of <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../563/5138563.xml">
SMT solvers</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
, which add arithmetic and propositional support to the powerful classes of <link>
SAT solver</link>s.</p>


</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../546/2546.xml">
Automated theorem proving</link></method>
</know-how>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../887/7852887.xml">
Cylindric algebra</link></entry>
<entry level="1" type="bullet">

<link>
Gödel's completeness theorem</link></entry>
<entry level="1" type="bullet">

<link>
Gödel's incompleteness theorems</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../584/3690584.xml">
List of first-order theories</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../285/354285.xml">
List of rules of inference</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../636/19636.xml">
Mathematical logic</link></entry>
<entry level="1" type="bullet">

<maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<link xlink:type="simple" xlink:href="../871/15282871.xml">
Predicate functor logic</link></auditory_communication>
</saying>
</speech>
</maxim>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../388/2498388.xml">
Table of logic symbols</link></entry>
<entry level="1" type="bullet">

<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../805/961805.xml">
Algebra of sets</link></concept>
</idea>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
The word <it>language</it> is sometimes used as a synonym for signature, but this can be confusing because "language" can also refer to the set of formulas.</entry>
<entry id="2">
More precisely, there is only one language of each variant of one-sorted first-order logic: with or without equality, with or without functions, with or without propositional variables, ….</entry>
<entry id="3">
When working with first-order logic without identity it may be useful to include a binary predicate symbol = in the signature. The difference between first-order logic with identity and first-order logic without identity, but with = as a non-logical symbol, is that in the latter case there are no special restrictions on the semantics of =. For example there may be two (different) elements between which the relation = holds.</entry>
<entry id="4">
For another well-worked example, see <weblink xlink:type="simple" xlink:href="http://us.metamath.org/mpegif/mmset.html">
Metamath proof explorer</weblink></entry>
<entry id="5">
 <cite id="CITEREFSuber" style="font-style:normal">Suber, Peter,&#32;<it><weblink xlink:type="simple" xlink:href="http://www.earlham.edu/~peters/courses/log/transtip.htm">
Translation Tips</weblink></it>, .&#32;Retrieved on 19 September 2007</cite>&nbsp;
</entry>
<entry id="6">
 <cite id="CITEREF" style="font-style:normal"><it><weblink xlink:type="simple" xlink:href="http://www-unix.mcs.anl.gov/AR/otter/examples33/fringe/if.in">
Otter Example if.in</weblink></it>, .&#32;Retrieved on 20 September 2007</cite>&nbsp;
</entry>
<entry id="7">
 <cite id="CITEREFManna1974" style="font-style:normal">Manna, Zohar&#32;(1974),&#32;<it>Mathematical Theory of Computation</it>, McGraw-Hill Computer Science Series, New York, New York: McGraw-Hill Book Company, pp. 77-147, ISBN 0-07-039910-7</cite>&nbsp;
</entry>
<entry id="8">
Leslie Lamport, Lawrence C. Paulson.
Should Your Specification Language Be Typed?
ACM Transactions on Programming Languages and Systems.
1998.
http://citeseer.ist.psu.edu/71125.html
</entry>
<entry id="9">
Rushby, John. Subtypes for Specification. 1997. Proceedings of the Sixth European Software Engineering Conference (ESEC/FSE 97). http://citeseer.ist.psu.edu/328947.html</entry>
<entry id="10"><p>

 <cite id="CITEREFHuthRyan2004" style="font-style:normal">Huth, Michael&#32;&amp;&#32;Ryan, Mark&#32;(2004),&#32;<it>Logic in Computer Science, 2nd edition</it>, pp. 138-139, ISBN 0-521-54310-X</cite>&nbsp;
</p>
</entry>
<entry id="11">
Freek Wiedijk and Jan Zwanenburg.  "First Order Logic with Domain Conditions" In Theorem Proving in Higher Order Logics. Book Series "Lecture Notes in Computer Science". Springer Berlin / Heidelberg. ISSN	0302-9743 (Print) 1611-3349 (Online), Volume 2758/2003. ISBN 978-3-540-40664-8. http://www.springerlink.com/content/8uh32tu7uf04yeex/</entry>
<entry id="12">
Ranise, Silvio and Cesare Tinelli.  <it>The SMT-LIB Standard: Version 1.2</it>  Aug 30, 2006. http://smt-lib.org/</entry>
<entry id="13">
Makarov, Victor.  "Predicate Logic with Definitions". http://arxiv.org/pdf/cs/9906010</entry>
</reflist>

<list>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../858/912858.xml">
Jon Barwise</link></logician>
</causal_agent>
</person>
</expert>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../538/5503538.xml">
John Etchemendy</link></scholar>
</logician>
</causal_agent>
</intellectual>
</person>
</philosopher>
</expert>
</physical_entity>
, 2000. <it>Language Proof and Logic</it>. CSLI (University of Chicago Press) and New York: Seven Bridges Press.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../302/8302.xml">
David Hilbert</link></scientist>
</person>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../727/62727.xml">
Wilhelm Ackermann</link></person>
 1950. <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../047/2134047.xml">
Principles of Theoretical Logic</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
 (English translation). Chelsea. The 1928 first German edition was titled <it>Grundzüge der theoretischen Logik</it>.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../771/1789771.xml">
Wilfrid Hodges</link></educator>
</mathematician>
</professional>
</adult>
</scientist>
</academician>
</causal_agent>
</person>
</physical_entity>
, 2001, "Classical Logic I: First Order Logic," in Lou Goble, ed., <it>The Blackwell Guide to Philosophical Logic</it>. Blackwell.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<encyclopedia wordnetid="106427387" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../356/357356.xml">
Stanford Encyclopedia of Philosophy</link></publication>
</reference_book>
</book>
</artifact>
</creation>
</encyclopedia>
</product>
</work>
: "<weblink xlink:type="simple" xlink:href="http://plato.stanford.edu/entries/logic-classical/">
Classical Logic</weblink> -- by Stewart Shapiro. Covers syntax, model theory, and metatheory for first-order logic in the natural deduction style. </entry>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://www.fecundity.com/logic/">
forall x: an introduction to formal logic</weblink></it>, by P.D. Magnus, covers formal semantics and proof theory for first-order logic.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://us.metamath.org/index.html">
Metamath</weblink>: an ongoing online project to reconstruct mathematics as a huge first-order theory, using first-order logic and the <link xlink:type="simple" xlink:href="../553/27553.xml">
axiomatic set theory</link> <link>
ZFC</link>. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../133/24133.xml">
Principia Mathematica</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it> modernized and done right.</entry>
<entry level="1" type="bullet">

 Podnieks, Karl. <it><weblink xlink:type="simple" xlink:href="http://www.ltn.lv/~podnieks/">
Introduction to mathematical logic.</weblink>''</it></entry>
<entry level="1" type="bullet">

 <link>
Cambridge Mathematics Tripos Notes</link> : "<weblink xlink:type="simple" xlink:href="http://john.fremlin.de/schoolwork/logic/index.html">
http://john.fremlin.de/schoolwork/logic/index.html</weblink> -- Notes typeset by John Fremlin.  The notes cover part of a past Cambridge Mathematics Tripos course taught to undergraduates students (usually) within their third year.  The course is entitled "Logic, Computation and Set Theory" and covers Ordinals and cardinals, Posets and zorn’s Lemma, Propositional logic, Predicate logic, Set theory and Consistency issues related to ZFC and other set theories.  </entry>
</list>
</p>

<p>

<table style="background:#f9f9f9; font-size:85%; line-height:110%; ">
<row>
<col>
 <image width="32x28px" src="Portal.svg">
</image>
</col>
<col style="padding:0 0.2em;">
 <b><it>
Logic&#32;portal</it></b></col>
</row>
</table>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible collapsed " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../225/3729225.xml">
Logic</link></header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<table style="width:100%;;;;" class="nowraplinks collapsible collapsed navbox-subgroup" cellspacing="0">
<row>
<header colspan="2" style=";;" class="navbox-title">
&nbsp;History and core topics</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;padding:0;;;" class="navbox-list navbox-odd">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em;  width:8.0em;;" class="navbox-group">
History</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;  width:auto;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../945/59945.xml">
General</link>&nbsp;·  <link xlink:type="simple" xlink:href="../752/1978752.xml">
Chinese</link>&nbsp;·  <link xlink:type="simple" xlink:href="../019/499019.xml">
Greek</link>&nbsp;·  <link xlink:type="simple" xlink:href="../980/2015980.xml">
Indian</link>&nbsp;·  <link xlink:type="simple" xlink:href="../133/1978133.xml">
Islamic</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em;  width:8.0em;;" class="navbox-group">
Core topics</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;  width:auto;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../446/42446.xml">
Reason</link>&nbsp;·  <link xlink:type="simple" xlink:href="../939/304939.xml">
Philosophical logic</link>&nbsp;·  <division wordnetid="108220714" confidence="0.8">
<administrative_unit wordnetid="108077292" confidence="0.8">
<branch wordnetid="108401248" confidence="0.8">
<link xlink:type="simple" xlink:href="../317/1251317.xml">
Philosophy of logic</link></branch>
</administrative_unit>
</division>
&nbsp;·  <link xlink:type="simple" xlink:href="../636/19636.xml">
Mathematical logic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../934/387934.xml">
Metalogic</link>&nbsp;·  <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../991/1151991.xml">
Logic in computer science</link></method>
</know-how>
</col>
</row>
</table>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-even">
<table style="width:100%;;;;" class="nowraplinks collapsible collapsed navbox-subgroup" cellspacing="0">
<row>
<header colspan="2" style=";;" class="navbox-title">
&nbsp;Key concepts and logics</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;padding:0;;;" class="navbox-list navbox-odd">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<link xlink:type="simple" xlink:href="../755/89755.xml">
Reasoning</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../093/61093.xml">
Deduction</link>&nbsp;·  <link xlink:type="simple" xlink:href="../736/393736.xml">
Induction</link>&nbsp;·  <link xlink:type="simple" xlink:href="../459/60459.xml">
Abduction</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<link xlink:type="simple" xlink:href="../398/14122398.xml">
Informal</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../094/81094.xml">
Proposition</link>&nbsp;·  <link xlink:type="simple" xlink:href="../465/317465.xml">
Inference</link>&nbsp;·  <link xlink:type="simple" xlink:href="../310/13018310.xml">
Argument</link>&nbsp;·  <link xlink:type="simple" xlink:href="../366/32366.xml">
Validity</link>&nbsp;·  <link xlink:type="simple" xlink:href="../296/5296.xml">
Cogency</link>&nbsp;·  <link xlink:type="simple" xlink:href="../652/321652.xml">
Term logic</link>&nbsp;·  <qualification wordnetid="104717139" confidence="0.8">
<fitness wordnetid="104716864" confidence="0.8">
<suitability wordnetid="104715487" confidence="0.8">
<link xlink:type="simple" xlink:href="../872/276872.xml">
Critical thinking</link></suitability>
</fitness>
</qualification>
&nbsp;·  <link xlink:type="simple" xlink:href="../986/53986.xml">
Fallacies</link>&nbsp;·  <link xlink:type="simple" xlink:href="../046/48046.xml">
Syllogism</link>&nbsp;·  <link xlink:type="simple" xlink:href="../383/1317383.xml">
Argumentation theory</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<division wordnetid="108220714" confidence="0.8">
<administrative_unit wordnetid="108077292" confidence="0.8">
<branch wordnetid="108401248" confidence="0.8">
<link xlink:type="simple" xlink:href="../317/1251317.xml">
Philosophy
of logic</link></branch>
</administrative_unit>
</division>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-odd">
<event wordnetid="100029378" confidence="0.8">
<change wordnetid="100191142" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<motion wordnetid="100331950" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../513/24513.xml">
Platonic realism</link></psychological_feature>
</act>
</motion>
</action>
</change>
</event>
&nbsp;·  <link xlink:type="simple" xlink:href="../529/622529.xml">
Logical atomism</link>&nbsp;·  <link xlink:type="simple" xlink:href="../672/350672.xml">
Logicism</link>&nbsp;·  <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../863/324863.xml">
Formalism</link></concept>
</idea>
&nbsp;·  <link xlink:type="simple" xlink:href="../176/21176.xml">
Nominalism</link> 
&nbsp;·  <link xlink:type="simple" xlink:href="../731/1535731.xml">
Fictionalism</link>&nbsp;·  <link xlink:type="simple" xlink:href="../121/1271121.xml">
Realism</link>&nbsp;·   <link xlink:type="simple" xlink:href="../513/19513.xml">
Intuitionism</link>&nbsp;·  <link xlink:type="simple" xlink:href="../059/21059.xml">
Constructivism</link>&nbsp;·  <link xlink:type="simple" xlink:href="../900/152900.xml">
Finitism</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<link xlink:type="simple" xlink:href="../636/19636.xml">
Mathematical</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../939/10939.xml">
Formal language</link>&nbsp;·  <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../716/18020716.xml">
Formal grammar</link></language>
&nbsp;·  <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../102/396102.xml">
Formal system</link></language>
</method>
</know-how>
&nbsp;·  <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../822/15285822.xml">
Deductive system</link></language>
&nbsp;·  <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../184/1197184.xml">
Formal proof</link></language>
&nbsp;·  <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../968/693968.xml">
Formal interpretation</link></language>
&nbsp;·  <link xlink:type="simple" xlink:href="../888/909888.xml">
Formal semantics</link>&nbsp;·  <link xlink:type="simple" xlink:href="../382/4230382.xml">
Formula</link>&nbsp;·  <link xlink:type="simple" xlink:href="../582/404582.xml">
Wff</link>&nbsp;·  <link xlink:type="simple" xlink:href="../691/26691.xml">
Set</link>&nbsp;·  <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../629/682629.xml">
Element</link></concept>
</idea>
&nbsp;·  <link xlink:type="simple" xlink:href="../696/20696.xml">
Class</link>&nbsp;·  <link xlink:type="simple" xlink:href="../928/928.xml">
Axiom</link>&nbsp;·  <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/252311.xml">
Rule of inference</link></rule>
</concept>
</idea>
&nbsp;·  <link xlink:type="simple" xlink:href="../509/19509.xml">
Relation</link>&nbsp;·  <link xlink:type="simple" xlink:href="../977/30977.xml">
Theorem</link>&nbsp;·  <link xlink:type="simple" xlink:href="../361/3674361.xml">
Logical consequence</link>&nbsp;·  <link xlink:type="simple" xlink:href="../802/75802.xml">
Consistency</link>&nbsp;·  <link xlink:type="simple" xlink:href="../819/26819.xml">
Soundness</link>&nbsp;·  <link xlink:type="simple" xlink:href="../054/56054.xml">
Completeness</link>&nbsp;·  <link xlink:type="simple" xlink:href="../118/913118.xml">
Decidability</link>&nbsp;·  <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Satisfiability</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
&nbsp;·  <link xlink:type="simple" xlink:href="../208/1141208.xml">
Independence</link>&nbsp;·  <link xlink:type="simple" xlink:href="../553/27553.xml">
Set theory</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../401/188401.xml">
Axiomatic system</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../478/183478.xml">
Proof theory</link>&nbsp;·  <link xlink:type="simple" xlink:href="../858/19858.xml">
Model theory</link>&nbsp;·  <link xlink:type="simple" xlink:href="../414/155414.xml">
Recursion theory</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../282/40282.xml">
Type theory</link></instrumentality>
</artifact>
</system>
&nbsp;·  <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../039/546039.xml">
Syntax</link></language>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<link xlink:type="simple" xlink:href="../335/5597335.xml">
Propositional</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../349/753349.xml">
Boolean function</link>s&nbsp;·  <link xlink:type="simple" xlink:href="../680/8015680.xml">
Monadic predicate calculus</link>&nbsp;·  <link xlink:type="simple" xlink:href="../154/18154.xml">
Propositional calculus</link>&nbsp;·  <link xlink:type="simple" xlink:href="../153/18153.xml">
Logical connective</link>s&nbsp;·  <link xlink:type="simple" xlink:href="../806/228806.xml">
Quantifiers</link>&nbsp;·  <arrangement wordnetid="107938773" confidence="0.8">
<table wordnetid="108266235" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../362/30362.xml">
Truth table</link></array>
</group>
</table>
</arrangement>
s</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../970/74970.xml">
Predicate</link></instrumentality>
</artifact>
</system>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-even">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../983/10983.xml">
First-order</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../806/228806.xml">
Quantifiers</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../428/341428.xml">
Second-order</link></instrumentality>
</artifact>
</system>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
<link xlink:type="simple" xlink:href="../365/333365.xml">
Modal</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../365/333365.xml#xpointer(//*[./st=%22Alethic+modalities%22])">
Alethic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../714/3832714.xml#xpointer(//*[./st=%22Axiological%22])">
Axiologic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../980/1343980.xml">
Deontic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../590/12065590.xml">
Doxastic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../197/3827197.xml">
Epistemic</link>&nbsp;·  <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../481/321481.xml">
Temporal</link></method>
</know-how>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
Other non
<link xlink:type="simple" xlink:href="../868/55868.xml">
classical</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-even">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/616985.xml">
Computability</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../180/49180.xml">
Fuzzy</link>&nbsp;·  <link xlink:type="simple" xlink:href="../675/579675.xml">
Linear</link>&nbsp;·  <link xlink:type="simple" xlink:href="../076/185076.xml">
Relevance</link>&nbsp;·  <link xlink:type="simple" xlink:href="../086/341086.xml">
Non-monotonic</link></col>
</row>
</table>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<table style="width:100%;;;;" class="nowraplinks collapsible collapsed navbox-subgroup" cellspacing="0">
<row>
<header colspan="2" style=";;" class="navbox-title">
&nbsp;Controversies</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;;;" class="navbox-list navbox-odd">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../085/421085.xml">
Paraconsistent logic</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../359/591359.xml">
Dialetheism</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../262/169262.xml">
Intuitionistic logic</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../390/24390.xml">
Paradox</link>es&nbsp;·  <link xlink:type="simple" xlink:href="../175/3175.xml">
Antinomies</link>&nbsp;·  <link xlink:type="simple" xlink:href="../402/1166402.xml">
Is logic empirical?</link></col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-even">
<table style="width:100%;;;;" class="nowraplinks collapsible collapsed navbox-subgroup" cellspacing="0">
<row>
<header colspan="2" style=";;" class="navbox-title">
&nbsp;Key figures</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;;;" class="navbox-list navbox-odd">
<scholar wordnetid="110557854" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../040/175040.xml">
Alfarabi</link></scholar>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../607/146607.xml">
Algazel</link></philosopher>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../065/272065.xml">
Alkindus</link></philosopher>
&nbsp;·  <scholar wordnetid="110557854" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../595/326595.xml">
Al-Razi</link></scholar>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../308/308.xml">
Aristotle</link></philosopher>
</person>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../836/47836.xml">
Averroes</link></philosopher>
&nbsp;·  <scholar wordnetid="110557854" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../130/1130.xml">
Avicenna</link></scholar>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../298/38298.xml">
Boole</link></philosopher>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../216/12216.xml">
Cantor</link></scientist>
</person>
&nbsp;·  <citizen wordnetid="109923673" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<disbeliever wordnetid="110015897" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<immigrant wordnetid="110199489" confidence="0.8">
<national wordnetid="109625401" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<migrant wordnetid="110314952" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<atheist wordnetid="109820044" confidence="0.8">
<nonreligious_person wordnetid="109625789" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../987/57987.xml">
Carnap</link></scholar>
</nonreligious_person>
</atheist>
</causal_agent>
</traveler>
</migrant>
</intellectual>
</national>
</immigrant>
</philosopher>
</person>
</disbeliever>
</physical_entity>
</citizen>
&nbsp;·  <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Church</link></scientist>
&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../748/1893748.xml">
Dharmakirti</link></scholar>
</logician>
</writer>
</causal_agent>
</intellectual>
</person>
</philosopher>
</communicator>
</expert>
</physical_entity>
&nbsp;·  <link>
Dignāga</link>&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../416/48416.xml">
Frege</link></philosopher>
</person>
&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../027/46027.xml">
Gentzen</link></educator>
</logician>
</mathematician>
</professional>
</adult>
</scientist>
</academician>
</causal_agent>
</person>
</expert>
</physical_entity>
&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<mentor wordnetid="110309496" confidence="0.8">
<sage wordnetid="110546202" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<capitalist wordnetid="109609232" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<materialist wordnetid="110300963" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../941/561941.xml">
Kanada</link></scholar>
</materialist>
</causal_agent>
</capitalist>
</intellectual>
</person>
</philosopher>
</sage>
</mentor>
</physical_entity>
&nbsp;·  <link>
Gödel</link>&nbsp;·  <link>
Gotama</link>&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../302/8302.xml">
Hilbert</link></scientist>
</person>
&nbsp;·  <scholar wordnetid="110557854" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../527/2426527.xml">
Ibn al-Nafis</link></scholar>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../830/1467830.xml">
Ibn Hazm</link></philosopher>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../074/272074.xml">
Ibn Taymiyyah</link></philosopher>
&nbsp;·  <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../039/48039.xml">
Kripke</link></philosopher>
&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<physicist wordnetid="110428004" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../578/196578.xml">
Mozi</link></scholar>
</scientist>
</causal_agent>
</intellectual>
</person>
</philosopher>
</physicist>
</physical_entity>
&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<leader wordnetid="109623038" confidence="0.8">
<spiritual_leader wordnetid="109505153" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<patriarch wordnetid="110406905" confidence="0.8">
<teacher wordnetid="110694258" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../149/22149.xml">
Nagarjuna</link></scholar>
</teacher>
</patriarch>
</causal_agent>
</spiritual_leader>
</leader>
</educator>
</professional>
</adult>
</intellectual>
</philosopher>
</person>
</physical_entity>
&nbsp;·  <link>
Pāṇini</link>&nbsp;·  <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../043/13043.xml">
Peano</link></scientist>
&nbsp;·  <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../117/6117.xml">
Peirce</link></scientist>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../233/75233.xml">
Putnam</link></philosopher>
</person>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../833/33833.xml">
Quine</link></philosopher>
</person>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../163/4163.xml">
Russell</link></philosopher>
</person>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../765/453765.xml">
Skolem</link></scientist>
</person>
&nbsp;·  <physical_entity wordnetid="100001930" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../443/971443.xml">
Suhrawardi</link></scholar>
</scientist>
</causal_agent>
</intellectual>
</person>
</philosopher>
</physical_entity>
&nbsp;·  <citizen wordnetid="109923673" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<disbeliever wordnetid="110015897" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<national wordnetid="109625401" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<atheist wordnetid="109820044" confidence="0.8">
<nonreligious_person wordnetid="109625789" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/59920.xml">
Tarski</link></scholar>
</mathematician>
</logician>
</nonreligious_person>
</atheist>
</causal_agent>
</scientist>
</intellectual>
</national>
</philosopher>
</person>
</disbeliever>
</physical_entity>
</expert>
</citizen>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Turing</link></scientist>
</person>
&nbsp;·  <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../395/43395.xml">
Whitehead</link></philosopher>
</person>
&nbsp;·  <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../155/201155.xml">
Zadeh</link></scientist>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<table style="width:100%;;;;" class="nowraplinks collapsible collapsed navbox-subgroup" cellspacing="0">
<row>
<header colspan="2" style=";;" class="navbox-title">
&nbsp;Lists</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;padding:0.25em 0; line-height:1.4em;padding:0;;;" class="navbox-list navbox-odd">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
Topics</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../178/302178.xml">
General</link>&nbsp;·  <link xlink:type="simple" xlink:href="../271/6306271.xml">
Basic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../167/346167.xml">
Mathematical logic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../872/794872.xml">
Boolean algebra</link>&nbsp;·  <link xlink:type="simple" xlink:href="../448/2059448.xml">
Set theory</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding:0.35em 1.0em; line-height:1.1em; width:8.0em;;" class="navbox-group">
Other</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;padding:0.25em 0; line-height:1.4em; width:auto;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../213/356213.xml">
Logicians</link>&nbsp;·  <link xlink:type="simple" xlink:href="../285/354285.xml">
Rules of inference</link>&nbsp;·  <link xlink:type="simple" xlink:href="../201/3575201.xml">
Paradoxes</link>&nbsp;·  <link xlink:type="simple" xlink:href="../940/8042940.xml">
Fallacies</link>&nbsp;·  <link xlink:type="simple" xlink:href="../388/2498388.xml">
Logic symbols</link></col>
</row>
</table>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">

Portal&nbsp;·  
Logic|Category&nbsp;·  &nbsp;·  
Logic stubs|Logic stubs&nbsp;·  
Mathematical logic stubs|Mathlogic stubs&nbsp;·  &nbsp;·  </col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</instrumentality>
</artifact>
</system>
</article>
