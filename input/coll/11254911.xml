<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 00:42:42[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Page (computing)</title>
<id>11254911</id>
<revision>
<id>239385995</id>
<timestamp>2008-09-18T21:52:16Z</timestamp>
<contributor>
<username>Phe-bot</username>
<id>4114706</id>
</contributor>
</revision>
<categories>
<category>Central processing unit</category>
<category>Memory management</category>
</categories>
</header>
<bdy>

In a context of <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link>, a <b>page</b>, <b>memory page</b>, or <b>virtual page</b> is a fixed-length block of <link>
main memory</link>, that is contiguous in both physical memory addressing and virtual memory addressing. A page is usually a smallest unit of data for:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../117/547117.xml">
memory allocation</link> performed by the operating system for a program,</entry>
<entry level="1" type="bullet">

 transfer between main memory and any other auxiliary store, such as <link xlink:type="simple" xlink:href="../777/13777.xml">
hard disk drive</link>.</entry>
</list>
<p>

<link xlink:type="simple" xlink:href="../354/32354.xml">
Virtual memory</link> abstraction allows a page that does not currently reside in main memory to be addressed and used. If a program tries to access a location in such page, it generates an exception called <link xlink:type="simple" xlink:href="../143/1157143.xml">
page fault</link>. The hardware or operating system is notified and loads the required page from auxiliary store automatically. A program addressing the memory has no knowledge of a page fault or a process following it. In consequence a program may be easily allowed to address more RAM than actually exists in the computer.</p>
<p>

A transfer of pages between main memory and an auxiliary store, such as <link xlink:type="simple" xlink:href="../777/13777.xml">
hard disk drive</link>, is referred to as <link xlink:type="simple" xlink:href="../193/311193.xml">
paging</link> or swapping.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

<sec>
<st>
 Page size trade-off </st>
<p>

Page size is usually determined by a processor architecture. Traditionally, pages in a system had uniform size, for example 4096 bytes. However, processor designs often allow two or more, sometimes simultaneous, page sizes due to the benefits and penalties. There are several points that can factor into choosing the best page size.</p>

<ss1>
<st>
 Page size versus page table size </st>
<p>

A system with a smaller page size uses more pages, requiring a <link xlink:type="simple" xlink:href="../962/674962.xml">
page table</link> that occupies more space. For example, if a 232 virtual address space is mapped to 4KB (212 bytes) pages, the number of virtual pages is 220 (20 = 32 - 12). However, if the page size is increased to 32KB (215 bytes), only 217 pages are required.</p>

</ss1>
<ss1>
<st>
 Page size versus TLB usage </st>
<p>

Processors need to maintain a <link xlink:type="simple" xlink:href="../352/528352.xml">
Translation Lookaside Buffer</link> (TLB), mapping virtual to physical addresses, which are checked on every memory access. The TLB is typically of limited size, and when it cannot satisfy a given request (a <b>TLB miss</b>) the <link xlink:type="simple" xlink:href="../962/674962.xml">
page tables</link> must be searched manually (either in hardware or software, depending on the architecture) for the correct mapping, a time-consuming process. Larger page sizes mean that a TLB cache of the same size can keep track of larger amounts of memory, which avoids the costly TLB misses.</p>

</ss1>
<ss1>
<st>
 Internal fragmentation of pages </st>
<p>

Rarely do processes require the use of an exact number of pages. As a result, the last page will likely only be partially full, wasting some amount of memory. Larger page sizes clearly increase the potential for wasted memory this way, as more potentially unused portions of memory are loaded into main memory. Smaller page sizes ensure a closer match to the actual amount of memory required in an allocation.</p>
<p>

As an example, assume the page size is 1MB. If a process allocates 1025KB, two pages must be used, resulting in 1023KB of unused space.</p>

</ss1>
<ss1>
<st>
 Page size versus disk access </st>
<p>

When transferring from disk, much of the delay is caused by the seek time. Because of this, large, sequential transfers are more efficient than several smaller transfers. Transferring larger pages from disk to memory therefore, does not require much more time than smaller pages.</p>

</ss1>
</sec>
<sec>
<st>
 Determining the page size in a program </st>
<p>

Most operating systems allow programs to determine the page size at run time. This allows programs to use memory more efficiently by aligning allocations to this size and reducing overall internal fragmentation of pages.</p>

<ss1>
<st>
 UNIX and POSIX-based Operating Systems </st>
<p>

<link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> and <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../305/23305.xml">
POSIX</link></system_of_measurement>
</standard>
-based systems use the system function sysconf(), as illustrated in the following example written in the <link>
 C</link> programming language.</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include     // sysconf(3)</entry>
</list>
</p>
<p>

int main()
{
printf("The page size for this system is %ld bytes\n", sysconf(_SC_PAGESIZE)); //_SC_PAGE_SIZE is OK too.
return 0;
}</p>


</ss1>
<ss1>
<st>
 Windows-based operating systems </st>
<p>

<link xlink:type="simple" xlink:href="../601/81601.xml">
Win32</link>-based operating system, such as Windows 9x, NT, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../889/360889.xml">
ReactOS</link></O>
, use the system function GetSystemInfo() from kernel32.dll.</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

int main()
{
SYSTEM_INFO si;</p>
<p>

GetSystemInfo(&amp;si);
printf("The page size for this system is %u bytes\n", si.dwPageSize);</p>
<p>

return 0;
}</p>


</ss1>
</sec>
<sec>
<st>
 Huge pages </st>
<p>

<link xlink:type="simple" xlink:href="../198/34198.xml">
Intel x86</link> supports 4MB pages (2MB pages if using <link xlink:type="simple" xlink:href="../793/416793.xml">
PAE</link>) in addition to its standard 4kB pages, and other architectures may often have similar features. <link xlink:type="simple" xlink:href="../454/15454.xml">
IA-64</link> supports as many as eight different page sizes, from 4kB up to 256MB. This support for <it>huge pages</it> (or, in <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> terminology, <it>large pages</it>) allows for "the best of both worlds", reducing the pressure on the TLB cache (sometimes increasing speed by as much as 15%, depending on the application and the allocation size) for large allocations while still keeping memory usage at a reasonable level for small allocations.</p>
<p>

Huge pages, despite being implemented in most contemporary <link xlink:type="simple" xlink:href="../137/18457137.xml">
personal computer</link>s, are not in common use except in large servers and <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../527/832527.xml">
computational clusters</link></difficulty>
</problem>
</state>
</condition>
. Commonly, their use requires elevated privileges, cooperation from the application making the large allocation (usually setting a flag to ask the operating system for huge pages), or manual administrator configuration; operating systems commonly, sometimes by design, cannot <link xlink:type="simple" xlink:href="../193/311193.xml">
page them out</link> to disk.</p>
<p>

<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 has supported huge pages on several architectures since the 2.6 series. <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../068/208068.xml">
Windows Server 2003</link></version>
 (SP1 and newer), <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../648/2289648.xml">
Windows Vista</link></version>
 and <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../042/2361042.xml">
Windows Server 2008</link></version>
 support huge pages under the name of <it>large</it> pages. <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<window wordnetid="104587648" confidence="0.8">
<supporting_structure wordnetid="104361095" confidence="0.8">
<framework wordnetid="103391770" confidence="0.8">
<link xlink:type="simple" xlink:href="../892/491892.xml">
Windows Server 2000</link></framework>
</supporting_structure>
</window>
</artifact>
</structure>
 and <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/33879.xml">
Windows XP</link></version>
 support <weblink xlink:type="simple" xlink:href="http://support.microsoft.com/kb/270715">
large pages internally</weblink>, but are not exposed to applications. <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/46145.xml">
Solaris</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 beginning with version 9 supports large pages on <link xlink:type="simple" xlink:href="../954/36954.xml">
SPARC</link> and x86. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite id="CITEREFBelzerHolzmanKent1981" style="font-style:normal">Belzer, Jack; Holzman, Albert G.&#32;&amp; Kent, Allen, eds.&#32;(1981),&#32;<weblink xlink:type="simple" xlink:href="http://books.google.com/books?id=KUgNGCJB4agC&amp;printsec=frontcover">
"Virtual memory systems"</weblink>,&#32;<it>Encyclopedia of computer science and technology</it>, <b>14</b>, CRC Press, pp. 32, ISBN 0824722140, </cite>&nbsp;
</entry>
<entry id="2">
"<weblink xlink:type="simple" xlink:href="http://www.sun.com/blueprints/0304/817-5917.pdf">
Supporting Multiple Page Sizes in the Solaris Operating System</weblink>".&#32;<it>Sun BluePrints Online</it>.&#32;  Sun Microsystems.&#32;Retrieved on <link>
2008-01-19</link>.</entry>
<entry id="3">
"<weblink xlink:type="simple" xlink:href="http://www.sun.com/blueprints/0304/817-6242.pdf">
Supporting Multiple Page Sizes in the Solaris Operating System Appendix</weblink>".&#32;<it>Sun BluePrints Online</it>.&#32;  Sun Microsystems.&#32;Retrieved on <link>
2008-01-19</link>.</entry>
</reflist>

<cite style="font-style:normal" class="book">Dandamudi, Sivarama P.&#32;(2003). Fundamentals of Computer Organization and Design.&#32;<link xlink:type="simple" xlink:href="../367/1098367.xml">
Springer</link>,&#32;740-741. ISBN 038795211X.</cite>&nbsp;</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../354/32354.xml">
Virtual memory</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../962/674962.xml">
Page table</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../525/4353525.xml">
Swapping</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
