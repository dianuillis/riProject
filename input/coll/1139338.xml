<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:12:01[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Computable function</title>
<id>1139338</id>
<revision>
<id>241279425</id>
<timestamp>2008-09-27T06:37:21Z</timestamp>
<contributor>
<username>Ling.Nut</username>
<id>1929579</id>
</contributor>
</revision>
<categories>
<category>Theory of computation</category>
<category>Recursion theory</category>
</categories>
</header>
<bdy>

<b>Computable functions</b> are the basic objects of study in <link xlink:type="simple" xlink:href="../414/155414.xml">
computability theory</link>. They are also called <b>Turing-computable functions</b> and (<b>total</b>) <b>recursive functions</b>. Computable functions are the formalized analogue of the intuitive notion of <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>. They are used to discuss computability without referring to any concrete <link xlink:type="simple" xlink:href="../278/1773278.xml">
model of computation</link> such as <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s or <link xlink:type="simple" xlink:href="../218/505218.xml">
register machine</link>s. Their definition, however, must make reference to some specific model of computation.  <p>

Before the precise definition of computable function, <link xlink:type="simple" xlink:href="../902/18902.xml">
mathematician</link>s often used the informal term <it>effectively computable</it>.   This term has since come to be identified with the computable functions. Note that the effective computability of these functions does not imply that they can be <it>efficiently</it> computed (i.e. computed within a reasonable amount of time). In fact, for some effectively computable functions it can be shown that any algorithm that computes them will be very inefficient in the sense that the running time of the algorithm increases <link xlink:type="simple" xlink:href="../191/58191.xml">
exponentially</link> (or even <link xlink:type="simple" xlink:href="../379/482379.xml">
superexponentially</link>) with the length of the input. The fields of <link xlink:type="simple" xlink:href="../543/7543.xml">
feasible computability</link> and <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link> study functions that can be computed efficiently.</p>
<p>

According to the <link xlink:type="simple" xlink:href="../854/6854.xml">
Church-Turing thesis</link>, computable functions are exactly the functions that can be calculated using a mechanical calculation device given unlimited amounts of time and storage space. Equivalently, this thesis states that any function which has an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is computable.</p>
<p>

The <maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/2392005.xml">
Blum axioms</link></auditory_communication>
</saying>
</speech>
</maxim>
 can be used to define an abstract <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link> on the set of computable functions. In computational complexity theory, the problem of determining the complexity of a computable function is known as a <link xlink:type="simple" xlink:href="../345/663345.xml">
function problem</link>.</p>

<sec>
<st>
Definition</st>

<p>

There are many equivalent ways to define the class of computable functions.  For concreteness, the remainder of this article will assume that <b>computable functions</b> have been defined as those <link xlink:type="simple" xlink:href="../456/404456.xml">
finitary</link> <link xlink:type="simple" xlink:href="../577/23577.xml">
partial functions</link> on the <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s that can be calculated by a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
.  There are many equivalent models of computation that define the same class of computable functions.  These <link xlink:type="simple" xlink:href="../278/1773278.xml">
models of computation</link> include
<list>
<entry level="1" type="bullet">

 <b><invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s</b></entry>
<entry level="1" type="bullet">

 <b><link xlink:type="simple" xlink:href="../469/26469.xml">
μ-recursive function</link>s</b></entry>
<entry level="1" type="bullet">

 <b><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../203/18203.xml">
Lambda calculus</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
</b></entry>
<entry level="1" type="bullet">

 <b>Post machines</b> (<b><link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link>s</b> and <b><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../891/308891.xml">
tag machines</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</b>).</entry>
<entry level="1" type="bullet">

 <b><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../218/505218.xml">
Register machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
s</b></entry>
</list>

and others.</p>
<p>

Each computable function <math>f</math> takes a fixed number of natural numbers as arguments.  Because the functions are partial, they may not be defined for every possible choice of input.  If a computable function is defined then it returns a single natural number as output (this output can be interpreted as a list of numbers using a <link xlink:type="simple" xlink:href="../848/1145848.xml">
pairing function</link>). These functions are also called <b>partial recursive functions</b>. In computability theory, the <b><link xlink:type="simple" xlink:href="../263/50263.xml">
domain</link></b> of a function is taken to be the set of all inputs for which the function is defined.</p>
<p>

A function which is defined for all arguments is called <b><link xlink:type="simple" xlink:href="../577/23577.xml">
total</link></b>. If a computable function is total, it is called a <b>total computable function</b> or <b>total recursive function</b>.</p>
<p>

The notation <math> f(x_1,\ldots,x_k) \downarrow </math> indicates that the partial function <math> f </math> is defined on arguments <math>x_1,\ldots,x_k</math>, and the notation <math>f(x_1,\ldots,x_k) \downarrow = y</math> indicates that <math>f</math> is defined on the arguments <math>x_1,\ldots,x_k</math> and the value returned is <math>y</math>.</p>

</sec>
<sec>
<st>
 Characteristics of computable functions </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../775/775.xml">
Algorithm</link></it>
</indent>

The basic characteristic of a computable function is that there must be a finite procedure (an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>) telling how to compute the function.  The models of computation listed above give different interpretations of what a procedure is and how it is used, but these interpretations share many properties.  The fact that these models give equivalent classes of computable functions stems from the fact that each model is capable of reading and mimicking a procedure for any of the other models, much as a <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> is able to read instructions in one computer language and emit instructions in another language.</p>
<p>

Enderton [1977] gives the following characteristics of a procedure for computing a computable function; similar characterizations have been given by Turing [1936], Rogers [1967], and others.
<list>
<entry level="1" type="bullet">

 “There must be exact instructions (i.e. a program), finite in length, for the procedure.” </entry>
</list>

Thus every computable function must have a finite program that completely describes how the function is to be computed.  It is possible to compute the function by just following the instructions; no guessing or special insight is required.
<list>
<entry level="1" type="bullet">

 “If the procedure is given a <it>k</it>-tuple <b>x</b> in the domain of <it>f</it>, then after a finite number of discrete steps the procedure must terminate and produce <it>f(</it>'x<b>)<it>.”</it></b></entry>
</list>

Intuitively, the procedure proceeds step by step, with a specific rule to cover what to do at each step of the calculation.  Only finitely many steps can be carried out before the value of the function is returned.
<list>
<entry level="1" type="bullet">

 “If the procedure is given a <it>k</it>-tuple <b>x</b> which is not in the domain of <it>f</it>, then the procedure might go on forever, never halting.  Or it might get stuck at some point, but it must not pretend to produce a value for <it>f</it> at <b>x</b>.” </entry>
</list>

Thus if a value for <it>f(</it>'x<b>)<it> is ever found, it must be the correct value. It is not necessary for the computing agent to distinguish correct outcomes from incorrect ones because the procedure is always correct when it produces an outcome.</it></b></p>
<p>

Enderton goes on to list several clarifications of these requirements of the procedure for a computable function:
<list>
<entry level="1" type="bullet">

 The procedure must theoretically work for arbitrarily large arguments. It is not assumed that the arguments are smaller than the number of atoms in the Earth, for example.</entry>
<entry level="1" type="bullet">

 The procedure is required to halt after finitely many steps in order to produce an output, but it may take arbitrarily many steps before halting. No time limitation is assumed.</entry>
<entry level="1" type="bullet">

 Although the procedure may use only a finite amount of storage space during a successful computation, there is no bound on the amount of space that is used.  It is assumed that additional storage space can be given to the procedure whenever the procedure asks for it.</entry>
</list>
</p>
<p>

The field of <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link> studies functions with prescribed bounds on the time and/or space allowed in a successful computation.</p>

</sec>
<sec>
<st>
 Computable sets and relations </st>

<p>

A set <it>A</it> of natural numbers is called <b>computable</b> (synonyms: <b>recursive</b>, <b>decidable</b>) if there is a computable function <it>f</it> such that for each number <it>n</it>, <math>f(n) \downarrow = 1</math> if <it>n</it> is in <it>A</it> and <math>f(n) \downarrow = 0</math> if <it>n</it> is not in <it>A</it>.</p>
<p>

A set of natural numbers is called <b>computably enumerable</b> (synonyms: <b>recursively enumerable</b>, <b>semidecidable</b>) if there is a computable function <it>f</it> such that for each number <it>n</it>, <it>f(n)</it> is defined <link xlink:type="simple" xlink:href="../922/14922.xml">
if and only if</link> <it>n</it> is in the set.  Thus a set is computably enumerable if and only if it is the domain of some computable function.  The word <it>enumerable</it> is used because the following are equivalent for a nonempty subset <it>B</it> of the natural numbers: 
<list>
<entry level="1" type="bullet">

 <it>B</it> is the domain of a computable function.  </entry>
<entry level="1" type="bullet">

 <it>B</it> is the range of a total computable function.  If <it>B</it> is infinite then the function can be assumed to be <link xlink:type="simple" xlink:href="../196/45196.xml">
injective</link>.  </entry>
</list>

If a set <it>B</it> is the range of a function <it>f</it> then the function can be viewed as an
enumeration of <it>B</it>, because the list <it>f(0)</it>, <it>f(1)</it>, ... will include every element of <it>B</it>.</p>
<p>

Because each <link xlink:type="simple" xlink:href="../509/19509.xml">
finitary relation</link> on the natural numbers can be identified with a corresponding set of finite sequences of natural numbers, the notions of <b>computable relation</b> and <b>computably enumerable relation</b> can be defined from their analogues for sets.</p>

</sec>
<sec>
<st>
  Formal languages </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../939/10939.xml">
Formal language</link>
</it></indent>

In <link xlink:type="simple" xlink:href="../136/442136.xml">
computability theory in computer science</link>, it is common to consider <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>s.   An <b>alphabet</b> is an arbitrary set.  A <b>word</b> on an alphabet is a finite sequence of symbols from the alphabet; the same symbol may be used more than once.  For example, binary strings are exactly the words on the alphabet <math>\{0,1\}</math>.    A <b>language</b> is a subset of the collection of all words on a fixed alphabet. For example, the collection of all binary strings that contain exactly 3 ones is a language over the binary alphabet.</p>
<p>

A key property of a formal language is the level of difficulty required to decide whether a given word is in the language.  Some coding system must be developed to allow a computable function to take an arbitrary word in the language as input; this is usually considered routine.  A language is called <b>computable</b> (synonyms: <b>recursive</b>, <b>decidable</b>) if there is a computable function <math>f</math> such that for each word <it>w</it> over the alphabet, <math>f(w) \downarrow = 1</math> if the word is in the language and <math>f(w)\downarrow = 0</math> if the word is not in the language. Thus a language is computable just in case there is a procedure that is able to correctly tell whether arbitrary words are in the language.</p>
<p>

A language is <b>computably enumerable</b> (synonyms: <b>recursively enumerable</b>, <b>semidecidable</b>) if there is a computable function <it>f</it> such that <math>f(w)</math> is defined if and only if the word <it>w</it> is in the language.  The term <it>enumerable</it> has the same etymology as in computably enumerable sets of natural numbers.</p>

</sec>
<sec>
<st>
Examples</st>

<p>

The following functions are computable:</p>
<p>

<list>
<entry level="1" type="bullet">

 Each function with a finite <mathematical_relation wordnetid="113783581" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../263/50263.xml">
domain</link></function>
</concept>
</idea>
</mathematical_relation>
; e.g., any finite sequence of natural numbers.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Each <link xlink:type="simple" xlink:href="../861/320861.xml">
constant function</link> <it>f</it> : <b>N</b><it>k</it> → <b>N</b>,  <it>f</it>(<it>n</it>1,...<it>nk</it>) := <it>n</it>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../338/61338.xml">
Addition</link> <it>f</it> : <b>N</b>²→ <b>N</b>, <it>f</it>(<it>n</it>1,<it>n2</it>) := <it>n</it>1 + <it>n</it>2</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 The function which gives the list of prime factors of a number.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../354/12354.xml">
greatest common divisor</link> of two numbers is a computable function.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Bézout's identity</link>, a linear <link xlink:type="simple" xlink:href="../109/9109.xml">
Diophantine equation</link></entry>
</list>
</p>
<p>

If <it>f</it> and <it>g</it> are computable, then so are: <it>f + g</it>, <it>f * g</it>, <math>f \circ g</math> if
<it>f</it> is unary, max(<it>f</it>,<it>g</it>), min(<it>f</it>,<it>g</it>), argmin{<it>y</it>≤<it>f(x)</it>}  and many more combinations.</p>
<p>

The following examples illustrate that a function may be computable though it is not known which algorithm computes it.</p>
<p>

<list>
<entry level="1" type="bullet">

 The function <it>f</it> such that <it>f(n) = 1</it> if there is a sequence of <it>n</it> consecutive fives in the decimal expansion of π, and <it>f(n) = 0</it> otherwise, is computable. (The function <it>f</it> is either the constant 1 function, which is computable, or else there is a <it>k</it> such that <it>f(n) = 1</it> if <it>n  k</it> and <it>f(n) = 0</it> if <it>n ≥ k</it>.  Every such function is computable.  It is not known whether there are arbitrarily long runs of fives in the decimal expansion of π, so we don't know <it>which</it> of those functions is <it>f</it>.  Nevertheless, we know that the function <it>f</it> must be computable.)</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Each finite segment of an <it>in</it>computable sequence of natural numbers (such as the <link>
Busy Beaver function</link> <it>Σ</it>) is computable.  E.g., for each natural number <it>n</it>, there exists an algorithm that computes the finite sequence <it>Σ(0), Σ(1), Σ(2), ..., Σ(n)</it> &mdash; in contrast to the fact that there is no algorithm that computes the <it>entire</it> Σ-sequence, i.e. <it>Σ(n)</it> for all <it>n</it>.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Church-Turing thesis </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../854/6854.xml">
Church-Turing thesis</link></it>
</indent>

The <b>Church-Turing thesis</b> states that any function computable from a procedure possessing the three properties listed above is a computable function.  Because these three properties are not formally stated, the Church-Turing thesis cannot be proved.  The following facts are often taken as evidence for the thesis:
<list>
<entry level="1" type="bullet">

  Many equivalent models of computation are known, and they all give the same definition of computable function (or a weaker version, in some instances).</entry>
<entry level="1" type="bullet">

 No stronger model of computation which is generally considered to be effectively calculable has been proposed.</entry>
</list>
</p>
<p>

The Church-Turing thesis is sometimes used in proofs to justify that a particular function is computable by giving a concrete description of a procedure for the computation.  This is permitted because it is believed that all such uses of the thesis can be removed by the tedious process of writing a formal procedure for the function in some model of computation.</p>

</sec>
<sec>
<st>
 Incomputable functions and unsolvable problems </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../090/1188090.xml">
List of undecidable problems</link></it>
</indent>

Because every computable function has a finite procedure telling how to compute it, there are only countably many computable functions.  There are uncountably many finitary functions on the natural numbers, so most such functions are not computable.
The <link xlink:type="simple" xlink:href="../911/67911.xml">
Busy beaver</link> function is a concrete example of such a function. </p>
<p>

Similarly, most subsets of the natural numbers are not computable. The <link xlink:type="simple" xlink:href="../668/13668.xml">
Halting problem</link> was the first such set to be constructed.    The <link xlink:type="simple" xlink:href="../672/9672.xml">
Entscheidungsproblem</link>, proposed by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../302/8302.xml">
David Hilbert</link></scientist>
</person>
, asked whether there is an effective procedure to determine which mathematical statements (coded as natural numbers) are true.  Turing and Church independently showed in the 1930s that this set of natural numbers is not computable.  According to the Church-Turing thesis, there is no effective procedure (with an algorithm) which can perform these computations.</p>

</sec>
<sec>
<st>
Extensions of computability</st>

<p>

The notion of computability of a function can be <link xlink:type="simple" xlink:href="../375/1188375.xml">
relativized</link> to an arbitrary <link xlink:type="simple" xlink:href="../691/26691.xml">
set</link> of <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s <it>A</it>, or equivalently to an arbitrary function <it>f</it> from the naturals to the naturals, by using <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s (or any other model of computation) extended by an <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle</link> for <it>A</it> or <it>f</it>. Such functions may be called <b><it>A-computable</it></b> or <b><it>f-computable</it></b> respectively. </p>
<p>

Although the Church-Turing thesis states that the computable functions include all functions with algorithms, it is possible to consider broader classes of functions that relax the requirements that algorithms must possess.  The field of <link xlink:type="simple" xlink:href="../613/175613.xml">
Hypercomputation</link> studies a computability notion in which it is possible to perform infinitely many steps before producing a successful answer.  <link xlink:type="simple" xlink:href="../591/12383591.xml">
Hyperarithmetical theory</link> studies a different extension of standard computability.  Even more general recursion theories have been studied, such as <b>E-recursion theory</b> in which any set can be used as an argument to an E-recursive function.</p>

</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../206/6206.xml">
Computable number</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../890/12979890.xml">
Effective method</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../402/30402.xml">
Theory of computation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../414/155414.xml">
Recursion theory</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../405/764405.xml">
Turing degree</link></entry>
<entry level="1" type="bullet">

 <series wordnetid="108457976" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<hierarchy wordnetid="108377806" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../475/186475.xml">
Arithmetical hierarchy</link></group>
</hierarchy>
</ordering>
</arrangement>
</series>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../067/15641067.xml">
Super-recursive algorithm</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

Enderton, H.B. Elements of recursion theory.  <it>Handbook of Mathematical Logic</it> (North-Holland 1977) pp. 527&ndash;566.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Rogers, H.  <it>Theory of recursive functions and effective computation</it> (McGraw-Hill 1967).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Turing, A. (1936), On Computable Numbers, With an Application to the Entscheidungsproblem. <it>Proceedings of the London Mathematical Society</it>, Series 2, Volume 42 (1936). Reprinted in M. Davis (ed.), <it>The Undecidable</it>, Raven Press, Hewlett, NY, 1965.</entry>
</list>
</p>


</sec>
</bdy>
</article>
