<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:25:58[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Fast Fourier transform</title>
<id>11512</id>
<revision>
<id>244496234</id>
<timestamp>2008-10-11T02:24:45Z</timestamp>
<contributor>
<username>Stevenj</username>
<id>7918</id>
</contributor>
</revision>
<categories>
<category>Transforms</category>
<category>FFT algorithms</category>
<category>Digital signal processing</category>
</categories>
</header>
<bdy>

"FFT" redirects here. For other uses, see <link xlink:type="simple" xlink:href="../437/3927437.xml">
FFT (disambiguation)</link>.
A <b>fast Fourier transform</b> (<b>FFT</b>) is an efficient <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> to compute the <link xlink:type="simple" xlink:href="../811/8811.xml">
discrete Fourier transform</link> (DFT) and its inverse. There are many distinct FFT algorithms involving a wide range of mathematics, from simple <link xlink:type="simple" xlink:href="../826/5826.xml">
complex-number arithmetic</link> to <link xlink:type="simple" xlink:href="../890/41890.xml">
group theory</link> and <link xlink:type="simple" xlink:href="../527/21527.xml">
number theory</link>; this article gives an overview of the available techniques and some of their general properties, while the specific algorithms are described in subsidiary articles linked below.<p>

A DFT decomposes a <link xlink:type="simple" xlink:href="../838/27838.xml">
sequence</link> of values into components of different frequencies.  This operation is useful in many fields (see <link xlink:type="simple" xlink:href="../811/8811.xml">
discrete Fourier transform</link> for properties and applications of the transform) but computing it directly from the definition is often too slow to be practical.  An FFT is a way to compute the same result more quickly: computing a DFT of <it>N</it> points in the obvious way, using the definition, takes <link xlink:type="simple" xlink:href="../578/44578.xml">
O(<it>N</it> 2)</link> arithmetical operations, while an FFT  can compute the same result in only O(<it>N</it> log <it>N</it>) operations.  The difference in speed can be substantial, especially for long data sets where <it>N</it> may be in the thousands or millions&mdash;in practice, the computation time can be reduced by several <link xlink:type="simple" xlink:href="../657/22657.xml">
orders of magnitude</link> in such cases, and the improvement is roughly <link xlink:type="simple" xlink:href="../863/81863.xml">
proportional to</link> <it>N</it>/log(<it>N</it>).  This huge improvement made many DFT-based algorithms practical; FFTs are of great importance to a wide variety of applications, from <link xlink:type="simple" xlink:href="../TN$$/HT$C$_T$yT$N$.xml">
digital signal processing</link> and solving <link xlink:type="simple" xlink:href="../564/52564.xml">
partial differential equation</link>s to algorithms for quick <link xlink:type="simple" xlink:href="../411/57411.xml">
multiplication of large integers</link>.  </p>
<p>

Let <it>x</it>0, ...., <it>xN</it>-1 be <link xlink:type="simple" xlink:href="../826/5826.xml">
complex number</link>s. The DFT is defined by the formula</p>
<p>

<indent level="1">

<math> X_k =  \sum_{n=0}^{N-1} x_n e^{-{2\pi i \over N} nk }
\qquad
k = 0,\dots,N-1. </math>
</indent>

An FFT is any method to compute the same results in O(<it>N</it> log <it>N</it>) operations.</p>
<p>

To illustrate the savings of an FFT, consider the count of complex multiplications and additions.  Evaluating the DFT's sums directly involves <it>N</it>2 complex multiplies and <it>N</it>2 complex additions [of which ''O''(''N'') operations can be saved by eliminating trivial operations such as multiplications by 1].  The well-known radix-2 Cooley-Tukey FFT algorithm, for <it>N</it> a power of 2, can compute the same result with only (<it>N</it>/2)&nbsp;log2&nbsp;<it>N</it> complex multiplies (again, ignoring simplifications of multiplications by 1 and similar) and <it>N</it>&nbsp;log2<it>N</it> complex additions.   In practice, actual performance on modern computers is usually dominated by factors other than arithmetic and is a complicated subject (see, e.g., Johnson &amp; Frigo, 2007), but the overall improvement from &amp;Theta;(<it>N</it>2) to &amp;Theta;(<it>N</it> log <it>N</it>) remains.</p>
<p>

In general, FFT algorithms depend upon the <link xlink:type="simple" xlink:href="../341/82341.xml">
factorization</link> of <it>N</it>, but (contrary to popular misconception) there are FFTs with O(<it>N</it> log <it>N</it>) <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity</link> for all <it>N</it>, even for <link xlink:type="simple" xlink:href="../666/23666.xml">
prime</link> <it>N</it>.  Many FFT algorithms only depend on the fact that <math>e^{-{2\pi i \over N}}</math> is an <math>N</math>th  <link xlink:type="simple" xlink:href="../950/171950.xml">
primitive root of unity</link>, and thus can be applied to analogous transforms over any <link xlink:type="simple" xlink:href="../615/11615.xml">
finite field</link>, such as <link xlink:type="simple" xlink:href="../396/421396.xml">
number-theoretic transform</link>s.</p>
<p>

Since the inverse DFT is the same as the DFT, but with the opposite sign in the exponent and a 1/<it>N</it> factor, any FFT algorithm can easily be adapted for it.</p>

<sec>
<st>
 Cooley-Tukey algorithm </st>

<p>

<indent level="1">

<it>Main article: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/352702.xml">
Cooley-Tukey FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it>
</indent>

By far the most common FFT is the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/352702.xml">
Cooley-Tukey</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 algorithm.  This is a <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer algorithm</link> that <link xlink:type="simple" xlink:href="../407/25407.xml">
recursively</link> breaks down a DFT of any <link xlink:type="simple" xlink:href="../289/82289.xml">
composite</link> size <it>N</it> = <it>N</it>1<it>N</it>2 into many smaller DFTs of sizes <it>N</it>1 and <it>N</it>2, along with O(<it>N</it>) multiplications by complex <link xlink:type="simple" xlink:href="../950/171950.xml">
roots of unity</link>, traditionally called <link xlink:type="simple" xlink:href="../398/2707398.xml">
twiddle factor</link>s (after Gentleman and Sande, 1966).  </p>
<p>

This method (and the general idea of an FFT) was popularized by a publication of <link xlink:type="simple" xlink:href="../795/1565795.xml">
J. W. Cooley</link> and <link xlink:type="simple" xlink:href="../974/415974.xml">
J. W. Tukey</link> in <link xlink:type="simple" xlink:href="../750/34750.xml">
1965</link>, but it was later discovered (Heideman, 1984) that those two authors had independently re-invented an algorithm known to  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../125/6125.xml">
Carl Friedrich Gauss</link></scientist>
</person>
 around <link xlink:type="simple" xlink:href="../074/35074.xml">
1805</link> (and subsequently rediscovered several times in limited forms).</p>
<p>

The most well-known use of the Cooley-Tukey algorithm is to divide the transform into two pieces of size <math> N / 2</math> at each step, and is therefore limited to power-of-two sizes, but any factorization can be used in general (as was known to both Gauss and Cooley/Tukey).  These are called the <b>radix-2</b> and <b>mixed-radix</b> cases, respectively (and other variants such as the <link xlink:type="simple" xlink:href="../890/5283890.xml">
split-radix FFT</link> have their own names as well).  Although the basic idea is recursive, most traditional implementations rearrange the algorithm to avoid explicit recursion. Also, because the Cooley-Tukey algorithm breaks the DFT into smaller DFTs, it can be combined arbitrarily with any other algorithm for the DFT, such as those described below.</p>

</sec>
<sec>
<st>
 Other FFT algorithms </st>

<p>

<indent level="1">

<it>Main articles: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../490/241490.xml">
Prime-factor FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
,&#32;<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../020/272020.xml">
Bruun's FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
,&#32;<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../408/241408.xml">
Rader's FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
,&#32;and&#32;<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/241431.xml">
Bluestein's FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it>
</indent>

There are other FFT algorithms distinct from Cooley-Tukey.  For <math>N = N_1 N_2</math> with <link xlink:type="simple" xlink:href="../556/6556.xml">
coprime</link> <math>N_1</math> and <math>N_2</math>, one can use the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../490/241490.xml">
Prime-Factor</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (Good-Thomas) algorithm (PFA), based on the <link>
Chinese Remainder Theorem</link>, to factorize the DFT similarly to Cooley-Tukey but without the twiddle factors. The <link>
Rader-Brenner algorithm</link> (1976) is a Cooley-Tukey-like factorization but with purely imaginary twiddle factors, reducing multiplications at the cost of increased additions and reduced numerical stability; it was later superseded by the <link xlink:type="simple" xlink:href="../890/5283890.xml">
split-radix</link> variant of Cooley-Tukey (which achieves the same multiplication count but with fewer additions and without sacrificing accuracy). Algorithms that recursively factorize the DFT into smaller operations other than DFTs include the Bruun and <link>
QFT</link> algorithms. (The Rader-Brenner and QFT algorithms were proposed for power-of-two sizes, but it is possible that they could be adapted to general composite <math>n</math>.  Bruun's algorithm applies to arbitrary even composite sizes.)  <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../020/272020.xml">
Bruun's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, in particular, is based on interpreting the FFT as a recursive factorization of the <link xlink:type="simple" xlink:href="../000/23000.xml">
polynomial</link> <math>z^N-1</math>, here into real-coefficient polynomials of the form <math>z^M-1</math> and 
<math>z^{2M} + az^M + 1</math>.</p>
<p>

Another polynomial viewpoint is  exploited by the <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../155/1744155.xml#xpointer(//*[./st=%22Winograd+FFT+algorithm%22])">
Winograd</link></associate>
</employee>
</causal_agent>
</colleague>
</worker>
</person>
</peer>
</physical_entity>
 algorithm, which factorizes <math>z^N-1</math> into <link>
cyclotomic polynomial</link>s&mdash;these often have coefficients of 1, 0, or &amp;minus;1, and therefore require few (if any) multiplications, so Winograd can be used to obtain minimal-multiplication FFTs and is often used to find efficient algorithms for small factors.  Indeed, Winograd showed that the DFT can be computed with only <math>O(N)</math> irrational multiplications, leading to a proven achievable lower bound on the number of multiplications for power-of-two sizes; unfortunately, this comes at the cost of many more additions, a tradeoff no longer favorable on modern <link xlink:type="simple" xlink:href="../218/5218.xml">
processor</link>s with <link xlink:type="simple" xlink:href="../see/Linden=2C_T$ennessee.xml">
hardware multipliers</link>. In particular, Winograd also makes use of the PFA as well as an algorithm by Rader for FFTs of <it>prime</it> sizes.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../408/241408.xml">
Rader's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, exploiting the existence of a <link xlink:type="simple" xlink:href="../945/99945.xml">
generator</link> for the multiplicative <link xlink:type="simple" xlink:href="../447/19447.xml">
group</link> modulo prime <math>N</math>, expresses a DFT of prime size <math>n</math> as a cyclic <link xlink:type="simple" xlink:href="../519/7519.xml">
convolution</link> of (composite) size <math>N-1</math>, which can then be computed by a pair of ordinary FFTs via the <link xlink:type="simple" xlink:href="../268/53268.xml">
convolution theorem</link>  (although Winograd uses other convolution methods).  Another prime-size FFT is due to L. I. Bluestein, and is sometimes called the <link xlink:type="simple" xlink:href="../431/241431.xml">
chirp-z algorithm</link>; it also re-expresses a DFT as a convolution, but this time of the <it>same</it> size (which can be zero-padded to a <link xlink:type="simple" xlink:href="../948/376948.xml">
power of two</link> and evaluated by radix-2 Cooley-Tukey FFTs, for example), via the identity  <math>nk = -(k-n)^2/2 + n^2/2 + k^2/2</math>.</p>

<ss1>
<st>
 FFT algorithms specialized for real and/or symmetric data </st>

<p>

In many applications, the input data for the DFT are purely real, in which case the outputs satisfy the symmetry 
<indent level="1">

<math>X_{N-k} = X_k^*,</math>
</indent>
and efficient FFT algorithms have been designed for this situation (see e.g. Sorensen, 1987).  One approach consists of taking an ordinary algorithm (e.g. Cooley-Tukey) and removing the redundant parts of the computation, saving roughly a factor of two in time and memory.  Alternatively, it is possible to express an <it>even</it>-length real-input DFT as a complex DFT of half the length (whose real and imaginary parts are the even/odd elements of the original real data), followed by O(<it>N</it>) post-processing operations.</p>
<p>

It was once believed that real-input DFTs could be more efficiently computed by means of the <link xlink:type="simple" xlink:href="../210/206210.xml">
discrete Hartley transform</link> (DHT), but it was subsequently argued that a specialized real-input DFT algorithm (FFT) can typically be found that requires fewer operations than the corresponding DHT algorithm (FHT) for the same number of inputs. Bruun's algorithm (above) is another method that was initially proposed to take advantage of real inputs, but it has not proved popular.</p>
<p>

There are further FFT specializations for the cases of real data that have <link xlink:type="simple" xlink:href="../151/592151.xml">
even/odd </link> symmetry, in which case one can gain another factor of (roughly) two in time and memory and the DFT becomes the discrete cosine/sine transform(s) (<link xlink:type="simple" xlink:href="../962/59962.xml">
DCT</link>/<link xlink:type="simple" xlink:href="../095/196095.xml">
DST</link>).  Instead of directly modifying an FFT algorithm for these cases, DCTs/DSTs can also be computed via FFTs of real data combined with O(<it>N</it>) pre/post processing.</p>

</ss1>
</sec>
<sec>
<st>
 Bounds on complexity and operation counts </st>

<p>

A fundamental question of longstanding theoretical interest is to prove lower bounds on the <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity</link> and exact operation counts of fast Fourier transforms, and many open problems remain.  It is not even rigorously proved whether DFTs truly require <math>\Omega(N log N)</math> (i.e., order <math>N log N</math> or greater) operations, even for the simple case of <link xlink:type="simple" xlink:href="../948/376948.xml">
power of two</link> sizes, although no algorithms with lower complexity are known.  In particular, the count of arithmetic operations is usually the focus of such questions, although actual performance on modern-day computers is determined by many other factors such as <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link> or <link xlink:type="simple" xlink:href="../187/1236187.xml">
CPU pipeline</link> optimization.</p>
<p>

Following pioneering work by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../155/1744155.xml">
Winograd</link></associate>
</employee>
</causal_agent>
</colleague>
</worker>
</person>
</peer>
</physical_entity>
 (1978), a tight <math>\Theta(N)</math> lower bound <it>is</it> known for the <link xlink:type="simple" xlink:href="../730/8528730.xml">
number of real multiplications required by an FFT</link>.  It can be shown that only <math>4N-2\log_2^{2}N-2\log_2 N-4</math> irrational real multiplications are required to compute a DFT of power-of-two length <math>N=2^m</math>.  Moreover, explicit algorithms that achieve this count are known (Heideman &amp; Burrus, 1986; Duhamel, 1990).  Unfortunately, these algorithms require too many additions to be practical, at least on modern computers with hardware multipliers.</p>
<p>

A tight lower bound is <it>not</it> known on the number of required additions, although lower bounds have been proved under some restrictive assumptions on the algorithms.  In 1973, Morgenstern proved an <math>\Omega(N log N)</math> lower bound on the addition count for algorithms where the multiplicative constants have bounded magnitudes (which is true for most but not all FFT algorithms).  Pan (1986) proved an <math>\Omega(N log N)</math> lower bound assuming a bound on a measure of the FFT algorithm's "asynchronicity", but the generality of this assumption is unclear.  For the case of power-of-two <math>N</math>, Papadimitriou (1979) argued that the number <math>N \log_2 N</math> of complex-number additions achieved by Cooley-Tukey algorithms is <it>optimal</it> under certain assumptions on the <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link> of the algorithm (his assumptions imply, among other things, that no additive identities in the roots of unity are exploited).  (This argument would imply that at least <math>2 N \log_2 N</math> real additions are required, although this is not a tight bound because extra additions are required as part of complex-number multiplications.) Thus far, no published FFT algorithm has achieved fewer than <math>N \log_2 N</math> complex-number additions (or their equivalent) for power-of-two <math>N</math>.</p>
<p>

A third problem is to minimize the <it>total</it> number of real multiplications and additions, sometimes called the "arithmetic complexity" (although in this context it is the exact count and not the asymptotic complexity that is being considered).  Again, no tight lower bound has been proven.  Since 1968, however, the lowest published count for power-of-two <math>N</math> was long achieved by the <link xlink:type="simple" xlink:href="../890/5283890.xml">
split-radix FFT algorithm</link>, which requires <math>4N\log_2 N-6N+8</math> real multiplications and additions for <math>N &amp;gt; 1</math>.  This was recently reduced to <math>\sim \frac{34}{9} N \log_2 N</math> (Johnson and Frigo, 2007; Lundy and Van Buskirk, 2007).</p>
<p>

Most of the attempts to lower or prove the complexity of FFT algorithms have focused on the ordinary complex-data case, because it is the simplest.  However, complex-data FFTs are so closely related to algorithms for related problems such as real-data FFTs, <link xlink:type="simple" xlink:href="../962/59962.xml">
discrete cosine transform</link>s, <link xlink:type="simple" xlink:href="../210/206210.xml">
discrete Hartley transform</link>s, and so on, that any improvement in one of these would immediately lead to improvements in the others (Duhamel &amp; Vetterli, 1990).</p>

</sec>
<sec>
<st>
 Accuracy and approximations </st>

<p>

All of the FFT algorithms discussed so far compute the DFT exactly (in exact arithmetic, i.e. neglecting <link xlink:type="simple" xlink:href="../376/11376.xml">
floating-point</link> errors).  A few "FFT" algorithms have been proposed, however, that compute the DFT <it>approximately</it>, with an error that can be made arbitrarily small at the expense of increased computations.  Such algorithms trade the approximation error for increased speed or other properties.  For example, an approximate FFT algorithm by Edelman et al. (1999) achieves lower communication requirements for <link xlink:type="simple" xlink:href="../162/145162.xml">
parallel computing</link> with the help of a <link xlink:type="simple" xlink:href="../771/8280771.xml">
fast multipole method</link>.  A <link xlink:type="simple" xlink:href="../903/50903.xml">
wavelet</link>-based approximate FFT by Guo and Burrus (1996) takes sparse inputs/outputs (time/frequency localization) into account more efficiently than is possible with an exact FFT.  Another algorithm for approximate computation of a subset of the DFT outputs is due to Shentov et al. (1995).  Only the Edelman algorithm works equally well for sparse and non-sparse data, however, since it is based on the compressibility (rank deficiency) of the Fourier matrix itself rather than the compressibility (sparsity) of the data.</p>
<p>

Even the "exact" FFT algorithms have errors when finite-precision floating-point arithmetic is used, but these errors are typically quite small; most FFT algorithms, e.g. Cooley-Tukey, have excellent numerical properties.  The upper bound on the <link xlink:type="simple" xlink:href="../422/640422.xml">
relative error</link> for the Cooley-Tukey algorithm is O(ε log <it>N</it>), compared to O(ε <it>N</it>3/2) for the naïve DFT formula (Gentleman and Sande, 1966), where ε is the machine floating-point relative precision.  In fact, the <link xlink:type="simple" xlink:href="../819/66819.xml">
root mean square</link> (rms) errors are much better than these upper bounds, being only O(ε √log <it>N</it>) for Cooley-Tukey and O(ε √<it>N</it>) for the naïve DFT (Schatzman, 1996).  These results, however, are very sensitive to the accuracy of the twiddle factors used in the FFT (i.e. the <link xlink:type="simple" xlink:href="../367/30367.xml">
trigonometric function</link> values), and it is not unusual for incautious FFT implementations to have much worse accuracy, e.g. if they use inaccurate <link xlink:type="simple" xlink:href="../170/150170.xml">
trigonometric recurrence</link> formulas.  Some FFTs other than Cooley-Tukey, such as the Rader-Brenner algorithm, are intrinsically less stable.</p>
<p>

In <link xlink:type="simple" xlink:href="../736/449736.xml">
fixed-point arithmetic</link>, the finite-precision errors accumulated by FFT algorithms are worse, with rms errors growing as O(√<it>N</it>) for the Cooley-Tukey algorithm (Welch, 1969).  Moreover, even achieving this accuracy requires careful attention to scaling in order to minimize the loss of precision, and <link>
fixed-point FFT algorithms</link> involve rescaling at each intermediate stage of decompositions like Cooley-Tukey.</p>
<p>

To verify the correctness of an FFT implementation, rigorous guarantees can be obtained in O(<it>N</it> log <it>N</it>) time by a simple procedure checking the linearity, impulse-response, and time-shift properties of the transform on random inputs (Ergün, 1995).</p>

</sec>
<sec>
<st>
Multidimensional FFTs</st>

<p>

As defined in the <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml#xpointer(//*[./st=%22Multidimensional+DFT%22])">
multidimensional DFT</link></function>
</operator>
</mathematical_relation>
 article, the multidimensional DFT</p>
<p>

<indent level="1">

<math>X_\mathbf{k} = \sum_{\mathbf{n}=0}^{\mathbf{N}-1} e^{-2\pi i \mathbf{k} \cdot (\mathbf{n} / \mathbf{N})} x_\mathbf{n}</math>
</indent>

transforms an array <math>x_\mathbf{n}</math> with a <math>d</math>-dimensional <link xlink:type="simple" xlink:href="../358/879358.xml">
vector</link> of indices <math>\mathbf{n}=(n_1, n_2, \ldots, n_d)</math> by a set of <math>d</math> nested summations (over <math>n_j = 0 \ldots N_j-1</math> for each <math>j</math>), where the division <math>\mathbf{n} / \mathbf{N}</math>, defined as <math>\mathbf{n} / \mathbf{N} = (n_1/N_1, \cdots, n_d/N_d)</math>, is performed element-wise.  Equivalently, it is simply the composition of a sequence of <math>d</math> sets of one-dimensional DFTs, performed along one dimension at a time (in any order).</p>
<p>

This compositional viewpoint immediately provides the simplest and most common multidimensional DFT algorithm, known as the <b>row-column</b> algorithm (after the two-dimensional case, below).  That is, one simply performs a sequence of <math>d</math> one-dimensional FFTs (by any of the above algorithms): first you transform along the <math>n_1</math> dimension, then along the <math>n_2</math> dimension, and so on (or actually, any ordering will work).  This method is easily shown to have the usual <math>O(N \log N)</math> complexity, where <math>N = N_1 N_2 \cdots N_d</math> is the total number of data points transformed.  In particular, there are <math>N/N_1</math> transforms of size <math>N_1</math>, etcetera, so the complexity of the sequence of FFTs is:</p>
<p>

<indent level="1">

<math>N/N_1 O(N_1 \log N_1) + \cdots + N/N_d O(N_d \log N_d) = O(N [\log N_1 + \cdots + \log N_d]) = O(N \log N).</math>
</indent>

In two dimensions, the <math>x_\mathbf{k}</math> can be viewed as an <math>n_1 \times n_2</math> <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrix</link>, and this algorithm corresponds to first performing the FFT of all the rows and then of all the columns (or vice versa), hence the name.</p>
<p>

In more than two dimensions, it is often advantageous for <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link> locality to group the dimensions recursively.  For example, a three-dimensional FFT might first perform two-dimensional FFTs of each planar "slice" for each fixed <math>n_1</math>, and then perform the one-dimensional FFTs along the <math>n_1</math> direction.  More generally, an <link xlink:type="simple" xlink:href="../619/3287619.xml">
asymptotically optimal</link> <link xlink:type="simple" xlink:href="../377/1773377.xml">
cache-oblivious</link> algorithm consists of recursively dividing the dimensions into two groups <math>(n_1, \cdots, n_{d/2})</math> and <math>(n_{d/2+1}, \cdots, n_d)</math> that are transformed recursively (rounding if <math>d</math> is not even) (see Frigo and Johnson, 2005).  Still, this remains a straightforward variation of the row-column algorithm that ultimately requires only a one-dimensional FFT algorithm as the base case, and still has <math>O(N \log N)</math> complexity.  Yet another variation is to perform matrix <link xlink:type="simple" xlink:href="../844/173844.xml">
transpositions</link> in between transforming subsequent dimensions, so that the transforms operate on contiguous data; this is especially important for <link xlink:type="simple" xlink:href="../722/1881722.xml">
out-of-core</link> and <link xlink:type="simple" xlink:href="../887/234887.xml">
distributed memory</link> situations where accessing non-contiguous data is extremely time-consuming.</p>
<p>

There are other multidimensional FFT algorithms that are distinct from the row-column algorithm, although all of them have <math>O(N \log N)</math> complexity.  Perhaps the simplest non-row-column FFT is the <link>
vector-radix FFT algorithm</link>, which is a generalization of the ordinary Cooley-Tukey algorithm where one divides the transform dimensions by a vector <math>\mathbf{r}=(r_1, r_2, \cdots, r_d)</math> of radices at each step.  (This may also have cache benefits.)  The simplest case of vector-radix is where all of the radices are equal (e.g. vector-radix-2 divides <it>all</it> of the dimensions by two), but this is not necessary.  Vector radix with only a single non-unit radix at a time, i.e. <math>\mathbf{r}=(1, \cdots, 1, r, 1, \cdots, 1)</math>, is essentially a row-column algorithm. Other, more complicated, methods include polynomial transform algorithms due to Nussbaumer (1977), which view the transform in terms of convolutions and polynomial products.  See Duhamel and Vetterli (1990) for more information and references.</p>

</sec>
<sec>
<st>
Other generalizations</st>

<p>

An <it>O</it>(<it>N</it>5/2 log&nbsp;<it>N</it>) generalization to <link xlink:type="simple" xlink:href="../056/203056.xml">
spherical harmonics</link> on the sphere <it>S</it>2 with <it>N</it>2 nodes was described by Mohlenkamp (1999), along with an algorithm conjectured (but not proven) to have <it>O</it>(<it>N</it>2 log2&nbsp;<it>N</it>) complexity; Mohlenkamp also provides an implementation in the <weblink xlink:type="simple" xlink:href="http://www.math.ohiou.edu/~mjm/research/libftsh.html">
libftsh library</weblink>.  A spherical-harmonic algorithm with <it>O</it>(<it>N</it>2 log&nbsp;<it>N</it>) complexity is described by Rokhlin and Tygert (2006).</p>
<p>

Various groups have also published "FFT" algorithms for non-equispaced data, as reviewed in Potts <it>et al.</it> (2001).  Such algorithms do not strictly compute the DFT (which is only defined for equispaced data), but rather some approximation thereof (a <link>
non-equispaced discrete Fourier transform</link>, or NDFT, which itself is often computed only approximately).</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../890/5283890.xml">
Split-radix FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../490/241490.xml">
Prime-factor FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../020/272020.xml">
Bruun's FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../408/241408.xml">
Rader's FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/241431.xml">
Bluestein's FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/2707212.xml">
Butterfly diagram</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 - a diagram used to describe FFTs.</entry>
<entry level="1" type="bullet">

 <link>
Overlap-add</link> - an efficient convolution method using FFT for long signals</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../895/1861895.xml">
Spectral music</link> (involves application of FFT analysis to musical composition)</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../416/313416.xml">
Spectrum analyzer</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
s - Devices that perform an FFT</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../334/2969334.xml">
FFTW</link></software>
 "Fastest Fourier Transform in the West" - 'C' library for the discrete Fourier transform (DFT) in one or more dimensions.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 N. Brenner and C. Rader, 1976, <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1162805">
A New Principle for Fast Fourier Transformation</weblink>, <it>IEEE Acoustics, Speech &amp; Signal Processing</it> <b>24</b>: 264-266.</entry>
<entry level="1" type="bullet">

 Cooley, James W., and <link xlink:type="simple" xlink:href="../974/415974.xml">
John W. Tukey</link>, 1965, "An algorithm for the machine calculation of complex Fourier series," <it>Math. Comput.</it> <b>19</b>: 297&ndash;301.</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
, 2001. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, 2nd. ed. MIT Press and McGraw-Hill. ISBN 0-262-03293-7. Especially chapter 30, "Polynomials and the FFT."</entry>
<entry level="1" type="bullet">

 Pierre Duhamel, 1990, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109/29.60070">
Algorithms meeting the lower bounds on the multiplicative complexity of length-<math>2^n</math> DFTs and their connection with practical algorithms</weblink> , <it>IEEE Trans. Acoust. Speech. Sig. Proc.</it> <b>38</b>: 1504-151.</entry>
<entry level="1" type="bullet">

 ------- and M. Vetterli, 1990, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016/0165-1684(90)90158-U">
Fast Fourier transforms: a tutorial review and a state of the art</weblink> , <it>Signal Processing</it> <b>19</b>: 259&ndash;299.</entry>
<entry level="1" type="bullet">

 A. Edelman, P. McCorquodale, and S. Toledo, 1999, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137/S1064827597316266">
The Future Fast Fourier Transform?</weblink> , <it>SIAM J. Sci. Computing</it> <b>20</b>: 1094&ndash;1114.</entry>
<entry level="1" type="bullet">

 Funda Ergün, 1995, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145/225058.225167">
Testing multivariate linear functions: Overcoming the generator bottleneck</weblink> , <it>Proc. 27th ACM Symposium on the Theory of Computing</it>: 407&ndash;416.</entry>
<entry level="1" type="bullet">

M. Frigo and S. G. Johnson, 2005, "<weblink xlink:type="simple" xlink:href="http://fftw.org/fftw-paper-ieee.pdf">
The Design and Implementation of FFTW3</weblink>," <it>Proceedings of the IEEE</it> <b>93</b>: 216–231.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../125/6125.xml">
Carl Friedrich Gauss</link></scientist>
</person>
, 1866. "Nachlass: Theoria interpolationis methodo nova tractata," <it>Werke</it> band <b>3</b>, 265&ndash;327. Göttingen: Königliche Gesellschaft der Wissenschaften.</entry>
<entry level="1" type="bullet">

 W. M. Gentleman and G. Sande, 1966, "Fast Fourier transforms&mdash;for fun and profit," <it>Proc. AFIPS</it> <b>29</b>: 563&ndash;578.</entry>
<entry level="1" type="bullet">

 H. Guo and C. S. Burrus, 1996, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1117/12.255236">
Fast approximate Fourier transform via wavelets transform</weblink> , <it>Proc. SPIE Intl. Soc. Opt. Eng.</it> <b>2825</b>: 250&ndash;259.</entry>
<entry level="1" type="bullet">

 ------- and G. A. Sitton, 1994, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109/ICASSP.1994.389994">
The Quick Discrete Fourier Transform</weblink> , <it>Proc. IEEE Conf. Acoust. Speech and Sig. Processing (ICASSP)</it> <b>3</b>: 445&ndash;448.</entry>
<entry level="1" type="bullet">

 Michael T. Heideman and C. Sidney Burrus, 1986, <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1164785">
On the number of multiplications necessary to compute a length-<math>2^n</math> DFT</weblink>, <it>IEEE Trans. Acoust. Speech. Sig. Proc.</it> <b>34</b>: 91-95.</entry>
<entry level="1" type="bullet">

 -------- and D. H. Johnson, 1984, <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1162257">
Gauss and the history of the fast Fourier transform</weblink>, <it>IEEE ASSP Magazine</it> <b>1</b>: 14&ndash;21.</entry>
<entry level="1" type="bullet">

 S. G. Johnson and M. Frigo, 2007. "<weblink xlink:type="simple" xlink:href="http://www.fftw.org/newsplit.pdf">
A modified split-radix FFT with fewer arithmetic operations</weblink>," <it>IEEE Trans. Signal Processing</it> <b>55</b> (1): 111–119.</entry>
<entry level="1" type="bullet">

 T. Lundy and J. Van Buskirk, 2007. "A new matrix approach to real FFTs and convolutions of length 2k," <it>Computing</it> <b>80</b> (1): 23-45.</entry>
<entry level="1" type="bullet">

 Jacques Morgenstern, 1973, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145/321752.321761">
Note on a lower bound of the linear complexity of the fast Fourier transform</weblink> , <it>J. ACM</it> <b>20</b>: 305-306.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007/BF01261607">
M. J. Mohlenkamp, 1999, "A fast transform for spherical harmonics", <it>J. Fourier Anal. Appl.</it> <b>5</b>, 159&ndash;184.</weblink> (<weblink xlink:type="simple" xlink:href="http://www.math.ohiou.edu/~mjm/research/MOHLEN1999P.pdf">
preprint</weblink>)</entry>
<entry level="1" type="bullet">

 H. J. Nussbaumer, 1977, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1049/el:19770280">
Digital filtering using polynomial transforms</weblink> , <it>Electronics Lett.</it> <b>13</b>: 386-387.</entry>
<entry level="1" type="bullet">

 V. Pan, 1986, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016/0020-0190(86)90035-9">
The trade-off between the additive complexity and the asyncronicity of linear and bilinear algorithms</weblink> , <it>Information Proc. Lett.</it> <b>22</b>: 11-14.</entry>
<entry level="1" type="bullet">

 Christos H. Papadimitriou, 1979, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145/322108.322118">
Optimality of the fast Fourier transform</weblink> , <it>J. ACM</it> <b>26</b>: 95-102.</entry>
<entry level="1" type="bullet">

 D. Potts, G. Steidl, and M. Tasche, 2001. "<weblink xlink:type="simple" xlink:href="http://www.tu-chemnitz.de/~potts/paper/ndft.pdf">
Fast Fourier transforms for nonequispaced data: A tutorial</weblink>", in: J.J. Benedetto and P. Ferreira (Eds.), <it>Modern Sampling Theory: Mathematics and Applications</it> (Birkhauser).</entry>
<entry level="1" type="bullet">

 Vladimir Rokhlin and Mark Tygert, 2006, "<weblink xlink:type="simple" xlink:href="http://pantheon.yale.edu/~mwt7/sph2.pdf">
Fast algorithms for spherical harmonic expansions</weblink>," <it>SIAM J. Sci. Computing</it> <b>27</b> (6): 1903-1928.</entry>
<entry level="1" type="bullet">

 James C. Schatzman, 1996, <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=240432">
Accuracy of the discrete Fourier transform and the fast Fourier transform</weblink>, <it>SIAM J. Sci. Comput.</it> <b>17</b>: 1150&ndash;1166.</entry>
<entry level="1" type="bullet">

 O. V. Shentov, S. K. Mitra, U. Heute, and A. N. Hossen, 1995, <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016/0165-1684(94)00103-7">
Subband DFT. I. Definition, interpretations and extensions</weblink> , <it>Signal Processing</it> <b>41</b>: 261&ndash;277.</entry>
<entry level="1" type="bullet">

 H. V. Sorensen, D. L. Jones, M. T. Heideman, and C. S. Burrus, 1987, <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1165220">
Real-valued fast Fourier transform algorithms</weblink>, <it>IEEE Trans. Acoust. Speech Sig. Processing</it> <b>ASSP-35</b>: 849&ndash;863.  See also <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1165284">
Corrections to "Real-valued fast Fourier transform algorithms"</weblink></entry>
<entry level="1" type="bullet">

 Peter D. Welch, 1969, <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=1162035">
A fixed-point fast Fourier transform error analysis</weblink>, <it>IEEE Trans. Audio Electroacoustics</it> <b>17</b>: 151&ndash;157.</entry>
<entry level="1" type="bullet">

 S. Winograd, 1978, <weblink xlink:type="simple" xlink:href="http://www.jstor.org/view/00255718/di970565/97p0015m/0">
On computing the discrete Fourier transform</weblink>, <it>Math. Computation</it> <b>32</b>: 175-199.</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.fftcalculator.com/">
FFT Calculator.</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.fftw.org/links.html">
Links to FFT code and information online.</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.jjj.de/fxt/">
Online documentation, links, book, and code.</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.dl.ac.uk/TCSC/Subjects/Parallel_Algorithms/FFTreport/">
Parallel Application Software on High Performance Computers. Serial and Parallel FFT Routines.</weblink></entry>
<entry level="1" type="bullet">

 ^<weblink xlink:type="simple" xlink:href="http://www.vosesoftware.com/ModelRiskHelp/index.htm#Aggregate_distributions/Aggregate_modeling_-_Fast_Fourier_Transform_FFT_method.htm">
Using FFT to construct aggregate probability distributions</weblink></entry>
<entry level="1" type="bullet">

 Sri Welaratna, "<weblink xlink:type="simple" xlink:href="http://www.dataphysics.com/support/library/downloads/articles/DP-30%20Years%20of%20FFT.pdf">
30 years of FFT Analyzers</weblink>", <it>Sound and Vibration</it> (January 1997, 30th anniversary issue).  A historical review of hardware FFT devices. </entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</entity>
</event>
</article>
