<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:13:53[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Page fault</title>
<id>1157143</id>
<revision>
<id>241819888</id>
<timestamp>2008-09-29T18:04:58Z</timestamp>
<contributor>
<username>RichardDSFAR</username>
<id>6234728</id>
</contributor>
</revision>
<categories>
<category>Articles lacking in-text citations</category>
<category>Computer errors</category>
<category>Virtual memory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../300/5300.xml">
computer storage</link> technology, a <link xlink:type="simple" xlink:href="../911/11254911.xml">
page</link> is a fixed-length block of memory that is used as a unit of transfer between <link>
physical memory</link> and external storage like a <link xlink:type="simple" xlink:href="../777/13777.xml">
disk</link>, and a <b>page fault</b> is an <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link> (or <abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../231/59231.xml">
exception</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
) to the software raised by the hardware, when a program accesses a page that is mapped in address space, but not loaded in physical memory.<p>

The hardware that detects this situation is the <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link> in a processor. The <link xlink:type="simple" xlink:href="../231/59231.xml">
exception handling</link> software that handles the page fault is generally part of an <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>. The operating system tries to handle the page fault by making the required page accessible at a location in physical memory or kills the program in case it is an illegal access.</p>
<p>

Contrary to what their name might suggest, page faults are not necessarily fatal and are common and necessary to increase the amount of memory available to programs in any operating system that utilizes <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link>, including <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link>, <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 and <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
.</p>

<sec>
<st>
 Reasons for page fault </st>
<p>

Hardware generates a page fault for page accesses where:
<list>
<entry level="1" type="bullet">

 the page corresponding to the requested address is not loaded in memory.</entry>
<entry level="1" type="bullet">

 the page corresponding to the memory address accessed is loaded, but its present status is not updated in hardware.</entry>
</list>
</p>
<p>

The closely related exception known as the <b>protection fault</b> is generated for page accesses where:
<list>
<entry level="1" type="bullet">

 the page is not part of the program, and so is not mapped in program memory.</entry>
<entry level="1" type="bullet">

 the program does not have sufficient privileges to read or write the page.</entry>
<entry level="1" type="bullet">

 the page access is legal, but it is mapped with <link xlink:type="simple" xlink:href="../997/1310997.xml">
demand paging</link>.</entry>
</list>

Protection fault can also be generated for many other invalid accesses not related to paging.</p>
<p>

On the <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> architecture, accesses to pages that are not present and accesses to pages that do not conform to the permission attributes for a given page (<it>protection faults</it> as described above) are both reported via the page fault processor exception.  Internally, the processor hardware provides information to the page fault handler that indicates what sort of access triggered the fault, so that these scenarios may be differentiated from the perspective of the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>.  The usage of the term <it>protection fault</it> (when speaking in relation to page faults) is thus not to be confused with the <link xlink:type="simple" xlink:href="../943/573943.xml">
general protection fault</link> exception, which is used to signal <link xlink:type="simple" xlink:href="../131/1323131.xml">
segmentation</link>-based memory access violations, as well as a variety of other general protection related violations (such as the use of an instruction that is not valid at the <link>
current privilege level</link>).</p>
<p>

<table class="wikitable">
<row>
<header>
Page Mapped</header>
<header>
Page Loaded</header>
<header>
Page Status</header>
<header>
Page access valid</header>
<header>
Exception</header>
</row>
<row>
<col>
yes</col>
<col>
yes</col>
<col>
present</col>
<col>
yes</col>
<col>
No exception</col>
</row>
<row>
<col>
yes</col>
<col>
--</col>
<col>
not present</col>
<col>
yes</col>
<col>
Page fault</col>
</row>
<row>
<col>
no</col>
<col>
yes</col>
<col>
yes</col>
<col>
yes</col>
<col>
Protection fault</col>
</row>
<row>
<col>
--</col>
<col>
--</col>
<col>
--</col>
<col>
no</col>
<col>
Protection fault</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Types </st>

<ss1>
<st>
 Minor page fault </st>
<p>

If the page is loaded in memory at the time the fault is generated, but its status is not updated as 'present' in hardware, then it is called a minor or soft page fault. This could happen if the <link xlink:type="simple" xlink:href="../653/825653.xml">
memory is shared</link> by different programs and the page is already brought into memory for other programs. Since these faults do not involve disk latency, they are faster and less expensive than major page faults.</p>

</ss1>
<ss1>
<st>
 Major page fault </st>
<p>

If the page is not loaded in memory at the time the fault is generated, then it is called a major or hard page fault. Major faults are more expensive than minor page faults and add disk latency to the interrupted program's execution. This is the mechanism used by an operating system to increase the amount of program memory available on demand. The operating system delays loading parts of the program from disk until the program attempts to use it and the page fault is generated.</p>

</ss1>
<ss1>
<st>
 Invalid page fault </st>
<p>

If a page fault occurs that attempts to read the memory referenced by a null pointer, the system may alternatively generate an invalid page fault. The operating system maps a dummy page for catching null pointers.</p>

</ss1>
<ss1>
<st>
 Protection fault </st>
<p>

When a program attempts invalid page accesses, for example trying to access pages not mapped into its memory, tries to write to read-only pages, or tries to modify privileged pages, the system hardware will generate a <it>protection fault</it>. Not all protection faults are illegal accesses, and they are the mechanism used by an operating system to implement <link xlink:type="simple" xlink:href="../603/407603.xml">
copy on write</link> access to share the same copy of memory among many programs until one of the programs wants to modify its copy.</p>
<p>

A program trying to access memory that belongs to another process is attempting 'illegal access' which generates a protection fault.  The operating system handles this protection fault much like an invalid page fault:  The operating system temporarily blocks 'write permission' until a page fault is generated, then creates new access information to allow the program to successfully find this memory.</p>
<p>

Note that in terms of the <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> architecture, memory protection violations reported via the page fault mechanism (<it>protection faults</it>, as described in this article) are distinct from memory protection violations reported via the <link xlink:type="simple" xlink:href="../943/573943.xml">
general protection fault</link> mechanism.  The general protection fault mechanism is used to report <link>
segmentation</link>-based memory access violations as well as other classes of protection violations.  The page fault mechanism is used to report paging-based memory protection violations.</p>

</ss1>
</sec>
<sec>
<st>
 Handling illegal accesses and invalid page faults </st>
<p>

Illegal accesses and invalid page faults can result in a program crash, segmentation error, bus error or <link xlink:type="simple" xlink:href="../721/49721.xml">
core dump</link> depending on the semantics of the operating system environment. Frequently these problems are the manifestation of software bugs, but the hardware memory errors frequently caused by <link xlink:type="simple" xlink:href="../973/175973.xml">
overclocking</link> may corrupt pointers causing even correct software to fail.</p>
<p>

Operating systems such as <link xlink:type="simple" xlink:href="../890/18890.xml">
Windows</link> and <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> (and other <link xlink:type="simple" xlink:href="../815/31815.xml">
UNIX-like</link> systems) provide differing mechanisms for reporting errors caused by page faults.  Windows uses <link xlink:type="simple" xlink:href="../231/59231.xml">
structured exception handling</link> to report page fault-based invalid accesses as <link xlink:type="simple" xlink:href="../803/28803.xml">
access violation</link> exceptions, and UNIX (and UNIX-like) systems typically use <link xlink:type="simple" xlink:href="../473/28473.xml">
signals</link>, such as <signal wordnetid="106791372" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../721/703721.xml">
SIGSEGV</link></signal>
, to report these error conditions to programs.</p>
<p>

If the program that received the error does not handle it, then the operating system typically performs some sort of default action, typically involving the termination of the running <link xlink:type="simple" xlink:href="../766/4746766.xml">
process</link> that caused the error condition, and a notification to the user that the program has malfunctioned.  In this vein, recent versions of Windows often report such problems with less technical error messages simply stating something along the lines of "this program must close" (an experienced user or <link xlink:type="simple" xlink:href="../716/23716.xml">
programmer</link> with access to a <link xlink:type="simple" xlink:href="../485/50485.xml">
debugger</link> can still retrieve detailed information, if necessary).  Additionally, recent Windows versions also write a <link>
minidump</link> (similar in principle to a <link xlink:type="simple" xlink:href="../721/49721.xml">
core dump</link>) describing the state of the crashed process for later analysis alongside such less-technical error messages. <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> and <link xlink:type="simple" xlink:href="../815/31815.xml">
UNIX-like</link> operating systems typically report these conditions to the user with error messages such as "segmentation violation", or "bus error".</p>

</sec>
<sec>
<st>
 Performance </st>
<p>

Page faults, by their very nature, degrade the performance of a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link> or operating system and in the degenerate case can cause <link xlink:type="simple" xlink:href="../891/665891.xml">
thrash</link>ing.  <link xlink:type="simple" xlink:href="../779/225779.xml">
Optimizations</link> to programs and the operating system that reduce the number of page faults that occur improve the performance of the program or even the entire system. The two primary focuses of the optimization effort focus on reducing overall memory usage and improving <link>
memory locality</link>. Generally, making more physical memory available also reduces page faults. Many <link xlink:type="simple" xlink:href="../476/727476.xml">
page replacement algorithm</link>s have been proposed, implementing a <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic</link> to reduce the incidence of page faults.</p>
<p>

How much does a page fault reduce the performance of your computer? An average hard disk has an average latency of 3ms, seek-time of 5ms and a transfer-time of 0.05ms/page. So the total time for paging comes in near 8ms (8 000 000 ns). If the memory access time is 200ns, then the page fault would make the system about 40000 times slower.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../997/1310997.xml">
Demand paging</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Text_document_with_red_question_mark.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 This article or section includes a  or , but its sources remain unclear because it lacks <b>.</b>
You can  this article by introducing more precise citations . <it>(February 2008)''</it></col>
</row>
</table>

 
<list>
<entry level="1" type="bullet">

John L. Hennessy, David A. Patterson, <it>Computer Architecture, A Quantitative Approach</it> (ISBN 1-55860-724-2)</entry>
<entry level="1" type="bullet">

Tanenbaum, Andrew S. <it>Operating Systems: Design and Implementation (Second Edition)</it>. New Jersey: Prentice-Hall 1997.</entry>
<entry level="1" type="bullet">

<it>Intel Architecture Software Developer's Manual</it>–Volume 3: System Programming</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.osronline.com/article.cfm?article=222">
So What Is A Page Fault?</weblink>" from OSR Online (a Windows-specific explanation)</entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.redhat.com/docs/manuals/linux/RHL-9-Manual/admin-primer/s1-memory-virt-details.html">
Virtual Memory Details</weblink>" from the Red Hat website.</entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/ms681401.aspx">
UnhandledExceptionFilter (Windows)</weblink>" from <weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/library">
MSDN Online</weblink>.</entry>
</list>
</p>


</sec>
</bdy>
</article>
