<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:26:00[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Flood fill</title>
<id>11635</id>
<revision>
<id>243109981</id>
<timestamp>2008-10-05T05:22:01Z</timestamp>
<contributor>
<username>RobHar</username>
<id>1520818</id>
</contributor>
</revision>
<categories>
<category>Computer graphics algorithms</category>
<category>Articles with example pseudocode</category>
<category>All articles to be merged</category>
<category>Articles to be merged&amp;#32;since July 2008</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-move" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Mergefrom.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 It has been suggested that  be  into this article or section. ()</col>
</row>
</table>


<image location="right" width="150px" src="Recursive_Flood_Fill_4_(aka).gif" type="thumb">
<caption>

recursive flood-fill with 4 directions
</caption>
</image>

<b>Flood fill,</b> also called <b>seed fill,</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that determines the area <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<glossary wordnetid="106420781" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<wordbook wordnetid="106418693" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../802/325802.xml#xpointer(//*[./st=%22Connectivity%22])">
connected</link></publication>
</reference_book>
</book>
</wordbook>
</artifact>
</glossary>
</creation>
</product>
</work>
 to a given node in a multi-dimensional <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>. It is used in the "bucket" fill tool of <link xlink:type="simple" xlink:href="../564/44564.xml">
paint program</link>s to determine which parts of a <link xlink:type="simple" xlink:href="../326/13390326.xml">
bitmap</link> to fill with color, and in puzzle games such as <condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../433/19654433.xml">
Minesweeper</link></psychological_feature>
</game>
</difficulty>
</problem>
</contest>
</social_event>
</state>
</event>
</condition>
, <event wordnetid="100029378" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../040/300040.xml">
Puyo Puyo</link></psychological_feature>
</game>
</contest>
</social_event>
</event>
, <event wordnetid="100029378" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../644/1521644.xml">
Lumines</link></psychological_feature>
</game>
</contest>
</social_event>
</event>
, and <link xlink:type="simple" xlink:href="../412/834412.xml">
Magical Drop</link> for determining which pieces are cleared.
<sec>
<st>
The algorithm</st>
<p>

<image location="right" width="150px" src="Recursive_Flood_Fill_8_(aka).gif" type="thumb">
<caption>

recursive flood-fill with 8 directions
</caption>
</image>

The flood fill algorithm takes three parameters: a start node, a target color, and a replacement color. The algorithm looks for all nodes in the array which are connected to the start node by a path of the target color, and changes them to the replacement color. There are many ways in which the flood-fill algorithm can be structured, but they all make use of a <link xlink:type="simple" xlink:href="../265/25265.xml">
queue</link> or <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link> data structure, explicitly or implicitly. One implicitly stack-based (<link xlink:type="simple" xlink:href="../407/25407.xml">
recursive</link>) flood-fill implementation (for a two-dimensional array) goes as follows:
<b>Flood-fill</b> (node, target-color, replacement-color):
1. If the color of <it>node</it> is not equal to <it>target-color</it>, return.
2. If the color of <it>node</it> is equal to <it>replacement-color</it>, return.
3. Set the color of <it>node</it> to <it>replacement-color</it>.
4. Perform <b>Flood-fill</b> (one step to the west of <it>node</it>, <it>target-color</it>, <it>replacement-color</it>).
Perform <b>Flood-fill</b> (one step to the east of <it>node</it>, <it>target-color</it>, <it>replacement-color</it>).
Perform <b>Flood-fill</b> (one step to the north of <it>node</it>, <it>target-color</it>, <it>replacement-color</it>).
Perform <b>Flood-fill</b> (one step to the south of <it>node</it>, <it>target-color</it>, <it>replacement-color</it>).
5. Return.</p>

<ss1>
<st>
Alternative implementations</st>
<p>

Though easy to understand, the implementation of the algorithm used above is impractical in languages and environments where stack space is severely constrained (e.g. <link xlink:type="simple" xlink:href="../593/13593.xml">
Java applet</link>s).</p>
<p>

An explicitly queue-based implementation is shown in the pseudo-code below. This implementation is not very efficient, but can be coded quickly, does not use a stack, and it is easy to debug:</p>
<p>

<b>Flood-fill</b> (node, target-color, replacement-color):
1. Set <it>Q</it> to the empty queue.
2. If the color of <it>node</it> is not equal to <it>target-color</it>, return.
3. Add <it>node</it> to the end of <it>Q</it>.
4. While "Q" is not empty: 
5.     Set "n" equal to the first element of "Q"
6.     If the color of <it>n</it> is equal to <it>target-color</it>, set the color of <it>n</it> to <it>replacement-color</it>.
7.     Remove first element from "Q"
8.     If the color of the node to the west of <it>n</it> is <it>target-color</it>, set the color of that node to <it>replacement-color</it>, add that node to the end of <it>Q</it>.
9.     If the color of the node to the east of <it>n</it> is <it>target-color</it>, set the color of that node to <it>replacement-color</it>, add that node to the end of <it>Q</it>.
10.    If the color of the node to the north of <it>n</it> is <it>target-color</it>, set the color of that node to <it>replacement-color</it>, add that node to the end of <it>Q</it>.
11.    If the color of the node to the south of <it>n</it> is <it>target-color</it>, set the color of that node to <it>replacement-color</it>, add that node to the end of <it>Q</it>.
12. Return.</p>
<p>

Most practical implementations use a loop for the west and east directions as an optimization to avoid the overhead of stack or queue management:</p>
<p>

<b>Flood-fill</b> (node, target-color, replacement-color):
1. Set <it>Q</it> to the empty queue.
2. If the color of <it>node</it> is not equal to <it>target-color</it>, return.
3. Add <it>node</it> to <it>Q</it>.
4. For each element <it>n</it> of <it>Q</it>:
5.  If the color of <it>n</it> is equal to <it>target-color</it>:
6.   Set <it>w</it> and <it>e</it> equal to <it>n</it>.
7.   Move <it>w</it> to the west until the color of the node to the west of <it>w</it> no longer matches <it>target-color</it>.
8.   Move <it>e</it> to the east until the color of the node to the east of <it>e</it> no longer matches <it>target-color</it>.
9.   Set the color of nodes between <it>w</it> and <it>e</it> to <it>replacement-color</it>.
10.   For each node <it>n</it> between <it>w</it> and <it>e</it>:
11.    If the color of the node to the north of <it>n</it> is <it>target-color</it>, add that node to <it>Q</it>.
If the color of the node to the south of <it>n</it> is <it>target-color</it>, add that node to <it>Q</it>.
12. Continue looping until <it>Q</it> is exhausted.
13. Return.</p>
<p>

Adapting the algorithm to use an additional array to store the shape of the region allows generalization to cover "fuzzy" flood filling, where an element can differ by up to a specified threshold from the source symbol. Using this additional array as an <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../049/2049.xml">
alpha channel</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 allows the edges of the filled region to blend somewhat smoothly with the not-filled region.</p>

</ss1>
</sec>
<sec>
<st>
Fixed memory method (right-hand fill method)</st>
<p>

A method exists that uses essentially no memory for four-connected regions by pretending to be a painter trying to paint the region without painting themselves into a corner. This is also a method for solving mazes. The four pixels making the primary boundary are examined to see what action should be taken. The painter could find themselves in one of several conditions:</p>
<p>

1. All four boundary pixels are filled.
2. Three of the boundary pixels are filled.
3. Two of the boundary pixels are filled.
4. One boundary pixel is filled.
5. Zero boundary pixels are filled.</p>
<p>

Where a path or boundary is to be followed, the right-hand rule is used. The painter follows the region by placing their right-hand on the wall (the boundary of the region) and progressing around the edge of the region without removing their hand.</p>
<p>

For case #1, the painter paints (fills) the pixel the painter is standing upon and stops the algorithm.</p>
<p>

For case #2, a path leading out of the area exists. Paint the pixel the painter is standing upon and move in the direction of the open path.</p>
<p>

For case #3, the two boundary pixels define a path which, if we painted the current pixel, may block us from ever getting back to the other side of the path. We need a "mark" to define where we are and which direction we are heading to see if we ever get back to this exact same pixel. If we already created such a "mark", then we preserve our previous mark and move to the next pixel following the right-hand rule.</p>
<p>

A mark is used for the first 2-pixel boundary that is encountered to remember where the passage started and in what direction the painter was moving. If the mark is encountered again and the painter is traveling in the same direction, then the painter knows that it is safe to paint the square with the mark and to continue in the same direction. This is because (through some unknown path) the pixels on the other side of the mark can be reached and painted in the future. The mark is removed for future use.</p>
<p>

If the painter encounters the mark but is going in a different direction, then some sort of loop has occurred which caused the painter to return to the mark. This loop must be eliminated. The mark is picked up and the painter then proceeds in the direction indicated previously by the mark using a left-hand rule for the boundary (similar to the right-hand rule but using the painter's left hand). This continues until an intersection is found (with three or more open boundary pixels). Still using the left-hand rule the painter now searches for a simple passage (made by two boundary pixels). Upon finding this two-pixel boundary path, that pixel is painted. This breaks the loop and allows the algorithm to continue.</p>
<p>

For case #4, we need to check the opposite 8-connected corners to see if they are filled or not. If either or both are filled, then this creates a many-path intersection and cannot be filled. If both are empty, then the current pixel can be painted and the painter can move following the right-hand rule.</p>
<p>

Similarly, for case #5, we need to check all the 8-connected corners to see if any are filled or not. If only one of the corner pixels is filled, then the painter can paint the current pixel and move on using the right-hand rule. If more than one of the corner pixels is filled, then this is a many-path intersection and cannot be filled.</p>
<p>

The mark is not stored in the image as some images are too small in color depth to save additional information. Rather the X and Y position is saved as well as the direction traveled (up, down, left, or right). In one sense this can be thought of as a queue or stack of depth one, but "fixed-memory" is more appropriate.</p>
<p>

The algorithm trades time for memory. For simple shapes it is very efficient. However, if the shape is complex with many features, the algorithm spends a large amount of time tracing the edges of the region trying to ensure that all can be painted.</p>
<p>

This algorithm was first available commercially in 1981 on a Vicom Image Processing system manufactured by Vicom Systems, Inc. The classic recursive flood fill algorithm was also available on this system as well.</p>

</sec>
<sec>
<st>
Scanline fill</st>
<p>

The algorithm can be sped up by filling lines. Instead of pushing each potential future pixel coordinate into the stack, it inspects the neighbour lines (previous and next) to find adjacent segments that may be filled in a future pass; the coordinates (either the start or the end) of the line segment are pushed on the stack. In most cases this scanline algorithm is at least an order of magnitude faster than the per-pixel one.</p>

</sec>
<sec>
<st>
Vector implementations</st>
<p>

Version 0.46 of <work wordnetid="100575741" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<undertaking wordnetid="100795720" confidence="0.8">
<visual_communication wordnetid="106873252" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<artwork wordnetid="106998748" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../916/412916.xml">
Inkscape</link></activity>
</artwork>
</psychological_feature>
</act>
</visual_communication>
</undertaking>
</event>
</work>
 includes a bucket fill tool, giving output similar to ordinary bitmap operations and indeed using one: the canvas is rendered, a flood fill operation is performed on the selected area and the result is then traced back to a path. It uses the concept of a <link xlink:type="simple" xlink:href="../779/436779.xml">
boundary condition</link>.</p>

</sec>
<sec>
<st>
Large scale behaviour</st>

<p>

<image width="150px" src="Wfm_floodfill_animation_queue.gif">
<caption>

4-way floodfill using a queue for storage
</caption>
</image>
</p>

<p>

<image width="150px" src="Wfm_floodfill_animation_stack.gif">
<caption>

4-way floodfill using a stack for storage
</caption>
</image>
</p>
<p>

Most floodfill applications use a queue as their internal pixel store; this yields an expanding lozenge-shaped fill.  Some applications (particularly older 8-bit computer games) instead use a stack as the store - this exhibits a characteristic "leave gaps and then return to fill them later" behaviour.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../102/15115102.xml">
Boundary fill</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is an algorithm used for the similar purposes as flood fill</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../467/7174467.xml">
Connected Component Labeling</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codecodex.com/wiki/index.php?title=Implementing_the_flood_fill_algorithm">
Source code for implementing the flood fill algorithm in Java, C, and OCaml</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://student.kuleuven.be/~m0216922/CG/floodfill.html">
Sample implementations for recursive and non-recursive, classic and scanline flood fill</weblink>, by Lode Vandevenn.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://tog.acm.org/GraphicsGems/gems/SeedFill.c">
C implementation of Flood/Seed Fill Algorithm from Graphics Gems; BSD(ish) license</weblink>, by Paul Heckbert.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.emanueleferonato.com/2008/06/06/flash-flood-fill-implementation/">
Flash flood fill implementation</weblink>, by Emanuele Feronato.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
