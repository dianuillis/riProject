<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 00:48:47[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Kirkpatrick–Seidel algorithm</title>
<id>11699089</id>
<revision>
<id>227397942</id>
<timestamp>2008-07-23T12:12:34Z</timestamp>
<contributor>
<username>BRG</username>
<id>10857</id>
</contributor>
</revision>
<categories>
<category>Convex geometry</category>
<category>Geometric algorithms</category>
</categories>
</header>
<bdy>

The <b>Kirkpatrick–Seidel algorithm</b>, called by its authors "the ultimate planar convex hull algorithm" is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for computing the <link xlink:type="simple" xlink:href="../634/40634.xml">
convex hull</link> of a set of points in the plane, with O(<it>n</it> log <it>h</it>) <link xlink:type="simple" xlink:href="../543/7543.xml">
time complexity</link>, where <it>n</it> is the number of input points and <it>h</it> is the number of points in the hull. Thus, the algorithm is <link xlink:type="simple" xlink:href="../990/12127990.xml">
output-sensitive</link>: its running time depends on both the input size and the output size. Another output-sensitive algorithm, the <link xlink:type="simple" xlink:href="../318/393318.xml">
gift wrapping algorithm</link>, was known much earlier, but the Kirkpatrick–Seidel algorithm has an asymptotic running time that is significantly smaller and that always improves on the O(<it>n</it> log <it>n</it>) bounds of non-output-sensitive algorithms. The Kirkpatrick–Seidel algorithm is named after its inventors, <link>
David G. Kirkpatrick</link> and Raimund Seidel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
<sec>
<st>
Algorithm</st>
<p>

The basic idea of the algorithm is a kind of reversal of the <link xlink:type="simple" xlink:href="../154/201154.xml">
divide-and-conquer algorithm</link> for convex hulls of <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../906/9597906.xml">
Preparata</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 and Hong, dubbed as "marriage-before-conquest" by the authors. </p>
<p>

The traditional divide-and-conquer algorithm splits the input points into two equal parts, e.g., by a vertical line, <link xlink:type="simple" xlink:href="../407/25407.xml">
recursively</link> finds convex hulls for the left and right subsets of the input, and then merges the two hulls into one by finding the "bridge edges", <link xlink:type="simple" xlink:href="../212/2605212.xml">
bitangent</link>s that connect the two hulls from above and below.</p>
<p>

The Kirkpatrick–Seidel algorithm splits the input as before, by finding the <link xlink:type="simple" xlink:href="../837/18837.xml">
median</link> of the <it>x</it>-coordinates of the input points. However, the algorithm reverses the order of the subsequent steps: its next step is to find the edges of the convex hull that intersect the vertical line defined by this median x-coordinate, which turns out to require linear time. The points on the left and right sides of the splitting line that cannot contribute to the eventual hull are discarded, and the algorithm proceeds recursively on the remaining points. In more detail, the algorithm performs a separate recursion for the upper and lower parts of the convex hull; in the recursion for the upper hull, the noncontributing points to be discarded are those below the bridge edge, while in the recursion for the lower hull the points above the bridge edge are discarded.</p>
<p>

At the <it>i</it>th level of the recursion, the algorithm solves at most 2<it>i</it> subproblems, each of size at most <it>n</it>/2<it>i</it>. The total number of subproblems considered is at most <it>h</it>, since each subproblem finds a new convex hull edge. The worst case occurs when no points can be discarded and the subproblems are as large as possible; that is, when there are exactly 2<it>i</it> subproblems in each level of recursion up to level log2<it>h</it>. For this worst case, there are O(log <it>h</it>) levels of recursion and O(<it>n</it>) points considered within each level, so the total running time is O(<it>n</it> log <it>h</it>) as stated.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../430/8320430.xml">
Chan algorithm</link>, a simpler output-sensitive convex hull algorithm.</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Kirkpatrick, David G.; Seidel, Raimund&#32;(1986).&#32;"The ultimate planar convex hull algorithm". <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../724/1230724.xml">
SIAM Journal on Computing</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>&#32;<b>15</b>&#32;(1): 287–299. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137%2F0215021">
10.1137/0215021</weblink>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
</bdy>
</algorithm>
</article>
