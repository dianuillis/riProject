<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:15:30[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Level of detail</title>
<id>1177500</id>
<revision>
<id>241499096</id>
<timestamp>2008-09-28T09:23:04Z</timestamp>
<contributor>
<username>TaBOT-zerem</username>
<id>7359933</id>
</contributor>
</revision>
<categories>
<category>3D computer graphics</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, accounting for <b>level of detail</b> involves decreasing the complexity of a 3D object representation as it moves away from the viewer or according other metrics such as object importance, eye-space speed or position.
Level of detail techniques increases the efficiency of rendering by decreasing the workload on <link xlink:type="simple" xlink:href="../951/1441951.xml">
graphics pipeline</link> stages, usually vertex transformations.
The reduced visual quality of the model is often unnoticed because of the small effect on object appearance when distant or moving fast.<p>

Although most of the time LOD is applied to geometry detail only, the basic concept can be generalized. Recently, LOD techniques included also <link xlink:type="simple" xlink:href="../096/1090096.xml">
shader</link> management to keep control of pixel complexity.
A form of level of detail management has been applied to textures for years, under the name of <link xlink:type="simple" xlink:href="../107/437107.xml">
mipmapping</link>, also providing higher rendering quality.</p>
<p>

It is commonplace to say that "an object has been <it>LODded</it>" when the object is simplified by the underlying <it>LODding algorithm</it>.</p>

<sec>
<st>
 Historical reference </st>
<p>

The origin<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Level_of_detail#endnote_oldOldOld">
http://localhost:18088/wiki/index.php/Level_of_detail#endnote_oldOldOld</weblink> of all the LoD algorithms for 3D computer graphics, can be traced back to an article originally appeared in the October 1976 issue of <weblink xlink:type="simple" xlink:href="http://www.acm.org/pubs/cacm/">
Communications of the ACM</weblink> by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/98668.xml">
James H. Clark</link></scholar>
</professional>
</adult>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
.
At the time, computers were monolithic and rare, graphics was being driven by researchers. The hardware itself was completely different, both architecturally and performance-wise. As such, many differences could be observed with regard to today's algorithms but also many common points.</p>
<p>

The original algorithm presented a much more generic approach to what will be discussed here. After introducing some available algorithms for geometry management, it is stated than most fruitful gains came from <it>"...structuring the environments being rendered"</it>, allowing to exploit faster transformations and <link xlink:type="simple" xlink:href="../701/1932701.xml">
clipping (computer graphics)</link> operations.</p>
<p>

The same environment structuring is now proposed as a way to control varying detail thus avoiding unnecessary computations, yet delivering adequate visual quality:</p>
<p>

<table style="margin:auto; border-collapse:collapse; border-style:none; background-color:transparent; " class="cquote">
<row>
<col style="color:#B2B7F2;font-size:35px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;padding:10px 10px;" width="20" valign="top">
“</col>
<col style="padding:4px 10px;" valign="top">
For example, a dodecahedron looks like a sphere from a sufficiently large distance and thus can be used to model it so long as it is viewed from that or a greater distance. However, if it must ever be viewed more closely, it will look like a dodecahedron. One solution to this is simply to define it with the most detail that will ever be necessary. However, then it might have far more detail than is needed to represent it at large distances, and in a complex environment with many such objects, there would be too many polygons (or other geometric primitives) for the visible surface algorithms to efficiently handle.</col>
<col style="color:#B2B7F2;font-size:36px;font-family:'Times New Roman',serif;font-weight:bold;text-align:right;padding:10px 10px;" width="20" valign="bottom">
”</col>
</row>
</table>
</p>
<p>

The proposed algorithm envisions a <link xlink:type="simple" xlink:href="../806/30806.xml">
tree data structure</link> which encodes in its arcs both transformations and transitions to more detailed objects. In this way, each node encodes an object and according to a fast <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic</link>, the tree is descended to the leafs which provide each object with more detail. When a leaf is reached, other methods could be used when higher detail is needed, such as <link xlink:type="simple" xlink:href="../051/174051.xml">
Catmull</link>'s recursive subdivision<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Level_of_detail#endnote_Catmull">
http://localhost:18088/wiki/index.php/Level_of_detail#endnote_Catmull</weblink>.</p>

<p>

<table style="margin:auto; border-collapse:collapse; border-style:none; background-color:transparent; " class="cquote">
<row>
<col style="color:#B2B7F2;font-size:35px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;padding:10px 10px;" width="20" valign="top">
“</col>
<col style="padding:4px 10px;" valign="top">
The significant point, however, is that in a complex environment, the amount of information presented about the various objects in the environment varies according to the fraction of the field of view occupied by those objects.</col>
<col style="color:#B2B7F2;font-size:36px;font-family:'Times New Roman',serif;font-weight:bold;text-align:right;padding:10px 10px;" width="20" valign="bottom">
”</col>
</row>
</table>
</p>
<p>

The paper then introduces clipping (not to be confused with <link>
culling (computer graphics)</link>, although often similar), various considerations on the <it>graphical working set</it> and its impact on performance, interactions between the proposed algorithm and others to improve rendering speed.  Interested readers are encouraged in checking the references for further details on the topic.</p>

</sec>
<sec>
<st>
 Well known approaches </st>
<p>

Although the algorithm introduced above covers a whole range of level of detail management techniques, real world applications usually employ different methods according the information being rendered. Because of the appearance of the considered objects, two main algorithm families are used.</p>
<p>

The first is based on subdividing the space in a finite amount of regions, each with a certain level of detail. The result is discrete amount of detail levels, from which the name <it>Discrete LoD</it> (DLOD). There's no way to support a smooth transition between LOD levels at this level, although <link xlink:type="simple" xlink:href="../049/2049.xml">
alpha blending</link> or <link xlink:type="simple" xlink:href="../391/59391.xml">
morphing</link> can be used to avoid visual <link>
popping</link>.</p>
<p>

The latter considers the <link xlink:type="simple" xlink:href="../191/988191.xml">
polygon mesh</link> being rendered as a function which must be evaluated requiring to avoid excessive errors which are a function of some heuristic (usually distance) themselves. The given "mesh" function is then continuously evaluated and an optimized version is produced according to a tradeoff between visual quality and performance. Those kind of algorithms are usually referred as <it>Continuous LOD</it> (CLOD).</p>

<ss1>
<st>
 Details on Discrete LOD </st>
<p>

<image location="right" width="200px" src="DiscreteLodAndCullExampleRanges.MaxDZ8.svg" type="thumb">
<caption>

An example of various DLOD ranges. Darker areas are meant to be rendered with higher detail. An additional culling operation is run, discarding all the information outside the frustum (colored areas).
</caption>
</image>

The basic concept of discrete LOD (DLOD) is to provide various models to represent the same object. Obtaining those models requires an external algorithm which is often non-trivial and subject of many <link>
polygon reduction technique</link>s. Successive LODding algorithms will simply assume those models are available.</p>
<p>

DLOD algorithms are often used in performance-intensive applications with small data sets which can easily fit in memory. Although <link>
out of core</link> algorithms could be used, the information granularity is not well suited to this kind of application. This kind of algorithm is usually easier to get working, providing both faster performance and lower <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> usage because of the few operations involved.</p>
<p>

DLOD methods are often used for "stand-alone" moving objects, possibly including complex animation methods. A different approach is used for <link xlink:type="simple" xlink:href="../989/18041989.xml">
geomipmapping</link> <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Level_of_detail#endnote_geomipmapping">
http://localhost:18088/wiki/index.php/Level_of_detail#endnote_geomipmapping</weblink>, a popular <link xlink:type="simple" xlink:href="../482/10187482.xml">
terrain rendering</link> algorithm because this applies to terrain meshes which are both graphically and topologically different from "object" meshes. Instead of computing an error and simplify the mesh according to this, geomipmapping takes a fixed reduction method, evaluates the error introduced and computes a distance at which the error is acceptable. Although straightforward, the algorithm provides decent performance.</p>

</ss1>
<ss1>
<st>
 A discrete LOD example </st>
<p>

As a simple example, consider the following <link xlink:type="simple" xlink:href="../859/27859.xml">
sphere</link>. A discrete LOD approach would cache a certain number of models to be used at different distances.
Because the model can trivially be <link xlink:type="simple" xlink:href="../623/2215623.xml">
procedurally generated</link> by its mathematical formulation, using a different amount of sample points distributed on the surface is sufficient to generate the various models required. This pass is not a LODding algorithm.</p>
<p>

<table width="700" cellpadding="2" class="wikitable" border="1">
<caption>
Visual impact comparisons and measurements</caption>
<row>
<header>
Image</header>
<col>
 <image width="120px" src="WireSphereMaxTass.MaxDZ8.jpg">
<caption>

A finely tassellated wireframe sphere featuring over 5000 sample points.
</caption>
</image>
</col>
<col>
 <image width="120px" src="WireSphereHiTass.MaxDZ8.jpg">
<caption>

A highly tassellated wireframe sphere, almost 2900 points.
</caption>
</image>
</col>
<col>
 <image width="120px" src="WireSphereStdTass.MaxDZ8.jpg">
<caption>

A wireframe sphere with roughtly 1600 sample points.
</caption>
</image>
</col>
<col>
 <image width="120px" src="WireSphereLowTass.MaxDZ8.jpg">
<caption>

A wireframe sphere with almost 700 vertices, good when viewed from a distance.
</caption>
</image>
</col>
<col>
 <image width="120px" src="WireSphereMinTass.MaxDZ8.jpg">
<caption>

A wireframe sphere with less than 150 sample points but still enough for far away objects.
</caption>
</image>
</col>
</row>
<row>
<header>
Vertices</header>
<col>
~5500</col>
<col>
~2880</col>
<col>
~1580</col>
<col>
~670</col>
<col>
140</col>
</row>
<row>
<header>
Notes</header>
<col>
Maximum detail, for closeups.</col>



<col>
Minimum detail, very far objects.</col>
</row>
</table>
</p>
<p>

To simulate a realistic transform bound scenario, we'll use an ad-hoc written application. We'll make sure we're not CPU bound by using simple algorithms and minimum fragment operations.
Each frame, the program will compute each sphere's distance and choose a model from a pool according to this information. To easily show the concept, the distance at which each model is used is <link xlink:type="simple" xlink:href="../114/1257114.xml">
hard code</link>d in the source. A more involved method would compute adequate models according to the usage distance chosen.</p>
<p>

We use <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../497/22497.xml">
OpenGL</link></software>
 for rendering because its high efficiency in managing small <link xlink:type="simple" xlink:href="../986/344986.xml">
batch</link>es, storing each model in a <link xlink:type="simple" xlink:href="../037/1697037.xml">
display list</link> thus avoiding communication overheads. Additional vertex load is given by applying two directional light sources ideally located infinitely far away.</p>
<p>

The following table compares the performance of LoD aware rendering and a full detail (<it>brute force</it>) method.</p>
<p>

<table width="700" cellpadding="2" class="wikitable" border="1">
<caption>
Visual impact comparisons and measurements</caption>
<row>

<col>
Brute</col>
<col>
DLOD</col>
<col>
Comparison</col>
</row>
<row>
<header>
Rendered  images</header>
<col>
 <image width="200px" src="SpheresBruteForce.MaxDZ8.jpg">
<caption>

Scene at maximum detail.
</caption>
</image>
</col>
<col>
 <image width="200px" src="SpheresLodded.MaxDZ8.jpg">
<caption>

Same scene as above with lodding enabled.
</caption>
</image>
</col>
<col>
 <image width="200px" src="DifferenceImageBruteLod.MaxDZ8.png">
<caption>

Almost black difference image shows no easily noticeable difference.
</caption>
</image>
</col>
</row>
<row>
<header>
Render time</header>
<col>
27.27 ms</col>
<col>
1.29 ms</col>
<col>
21 &amp;times; reduction</col>
</row>
<row>
<header>
Scene vertices (thousands)</header>
<col>
2328.48</col>
<col>
109.44</col>
<col>
21 &amp;times; reduction</col>
</row>
</table>
</p>

</ss1>
<ss1>
<st>
 Hierarchical LOD </st>
<p>

Because hardware is geared towards large amounts of detail, rendering low polygon objects may score sub-optimal performances. HLOD avoids the problem by grouping different objects together<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Level_of_detail#endnote_hlod">
http://localhost:18088/wiki/index.php/Level_of_detail#endnote_hlod</weblink>. This allows for higher efficiency as well as taking advantage of proximity considerations.</p>

</ss1>
</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="number">

 <cite id="endnote_oldOldOld" style="font-style: normal;">
<b>^</b></cite>&nbsp; Communications of the ACM, October 1976 Volume 19 Number 10. Pages 547-554. <it>Hierarchical Geometric Models for Visible Surface Algorithms</it> by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/98668.xml">
James H. Clark</link></scholar>
</professional>
</adult>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, University of California at Santa Cruz. Digitalized scan is freely available at http://accad.osu.edu/~waynec/history/PDFs/clark-vis-surface.pdf.</entry>
<entry level="1" type="number">

 <cite id="endnote_Catmull" style="font-style: normal;">
<b>^</b></cite>&nbsp; Catmull E., <it>A Subdivision Algorithm for Computer Display of Curved Surfaces</it>. Tech. Rep. UTEC-CSc-74-133, University of Utah, Salt Lake City, Utah, Dec. 1974.</entry>
<entry level="1" type="number">

 <cite id="endnote_geomipmapping" style="font-style: normal;">
<b>^</b></cite>&nbsp; de Boer, W.H., <it>Fast Terrain Rendering using Geometrical Mipmapping</it>, in flipCode featured articles, October 2000. Available at http://www.flipcode.com/tutorials/tut_geomipmaps.shtml.</entry>
<entry level="1" type="number">

 <cite id="endnote_hlod" style="font-style: normal;">
<b>^</b></cite>&nbsp; Carl Erikson's paper at http://www.cs.unc.edu/Research/ProjectSummaries/hlods.pdf provides a quick, yet effective overlook at HLOD mechanisms. A more involved description follows in his thesis, at http://www.cs.unc.edu/~geom/HLOD/Dissertation/Dissertation.pdf.</entry>
</list>
</p>



</sec>
</bdy>
</article>
