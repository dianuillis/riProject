<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:15:29[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<region  confidence="0.8" wordnetid="108630985">
<field  confidence="0.8" wordnetid="108569998">
<location  confidence="0.8" wordnetid="100027167">
<tract  confidence="0.8" wordnetid="108673395">
<geographical_area  confidence="0.8" wordnetid="108574314">
<header>
<title>Itoh-Tsujii inversion algorithm</title>
<id>1180190</id>
<revision>
<id>203604656</id>
<timestamp>2008-04-05T21:43:23Z</timestamp>
<contributor>
<username>Andreas Kaufmann</username>
<id>72502</id>
</contributor>
</revision>
<categories>
<category>Computational number theory</category>
<category>Finite fields</category>
</categories>
</header>
<bdy>

The <b>Itoh-Tsujii inversion algorithm</b> is used to invert elements in a <link xlink:type="simple" xlink:href="../615/11615.xml">
finite field</link>.  It was introduced in <link xlink:type="simple" xlink:href="../670/34670.xml">
1988</link> and first used over GF(2<it>m</it>) using the <link xlink:type="simple" xlink:href="../589/1028589.xml">
normal basis</link> representation of elements, however the algorithm is generic and can be used for other bases, such as the <link xlink:type="simple" xlink:href="../233/1028233.xml">
polynomial basis</link>.  It can also be used in any finite field, GF(<it>pm</it>).<p>

The algorithm is as follows:
<indent level="1">

<b>Input</b>: <it>A</it> ∈ GF(<it>pm</it>)
</indent>
:<b>Output</b>: <it>A</it>&amp;minus;1
<list>
<entry level="2" type="number">

<it>r</it> ← (<it>pm</it> &amp;minus; 1)/(<it>p</it> &amp;minus; 1)</entry>
<entry level="2" type="number">

compute <it>Ar</it> &amp;minus; 1 in GF(<it>pm</it>) </entry>
<entry level="2" type="number">

compute <it>Ar</it> = <it>Ar</it> &amp;minus; 1 · <it>A''</it></entry>
<entry level="2" type="number">

compute (<it>Ar</it>)&amp;minus;1 in GF(<it>p</it>)</entry>
<entry level="2" type="number">

compute <it>A</it>&amp;minus;1 = (<it>Ar</it>)&amp;minus;1 · <it>Ar</it> &amp;minus;1</entry>
<entry level="2" type="number">

return <it>A</it>&amp;minus;1</entry>
</list>
</p>
<p>

This algorithm is fast because steps 3 and 5 both involve operations in the subfield GF(<it>p</it>).  Similarly, if a small value of <it>p</it> is used a lookup table can be used for inversion in step 4.  The majority of time spent in this algorithm is in step 2, the first exponentiation.  This is one reason why this algorithm is well-suited for the normal basis, since squaring and exponentiation are relatively easy in that basis.</p>

<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

T. Itoh and S. Tsujii. A Fast Algorithm for Computing Multiplicative Inverses in GF(2<it>m</it>) Using Normal Bases. <it>Information and Computation</it>, 78:171-177, 1988.</entry>
</list>
</p>



</sec>
</bdy>
</geographical_area>
</tract>
</location>
</field>
</region>
</article>
