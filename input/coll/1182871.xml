<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:15:57[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Hard-core predicate</title>
<id>1182871</id>
<revision>
<id>234827938</id>
<timestamp>2008-08-28T18:18:13Z</timestamp>
<contributor>
<username>Rjwilmsi</username>
<id>203434</id>
</contributor>
</revision>
<categories>
<category>Theory of cryptography</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>, a <b>hard-core predicate</b> of a <link xlink:type="simple" xlink:href="../890/363890.xml">
one-way function</link> <it>f</it> is a <link xlink:type="simple" xlink:href="../336/7178336.xml">
predicate</link> <it>b</it> (i.e., a function whose output is a single bit) which is easy to compute given <it>x</it> but is hard to compute given <it>f(x)</it>.  In formal terms, there is no <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
probabilistic polynomial time algorithm</link></group>
</collection>
</class>
 that computes <it>b(x)</it> from <it>f(x)</it> with probability <link xlink:type="simple" xlink:href="../019/8426019.xml">
significantly greater</link> than one half over random choice of <it>x</it>. <p>

A <b>hard-core function</b> can be defined similarly.</p>
<p>

A hard-core predicate captures "in a concentrated sense" the hardness of inverting <it>f</it>.  </p>
<p>

While a one-way function is hard to invert, there are no guarantees about the feasibility of computing partial information about the <link xlink:type="simple" xlink:href="../311/579311.xml">
preimage</link> <it>c</it> from the image <it>f(x)</it>. For instance, while <link xlink:type="simple" xlink:href="../385/25385.xml">
RSA</link> is conjectured to be a one-way function, the <link xlink:type="simple" xlink:href="../313/97313.xml">
Jacobi symbol</link> of the preimage can be easily computed from that of the image. </p>
<p>

It is clear that if a <link xlink:type="simple" xlink:href="../196/45196.xml">
one-to-one function</link> has a hard-core predicate, then it must be one way.  <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../513/3421513.xml">
Oded Goldreich</link></scientist>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../708/402708.xml">
Leonid Levin</link></person>
 (1989) showed how every one-way function can be trivially modified to obtain a one-way function that has a specific hard-core predicate.  Let <it>f</it> be a one-way function. Define </p>
<p>

<indent level="1">

<it>g(x, r)</it> = <it>(f(x), r)</it>, 
</indent>

where the length of <it>r</it> is the same as that of <it>x</it>. Let <math>x_j</math> denote the <it>j</it>th bit of <it>x</it> and  <math>r_j</math> the <it>j</it>th bit of <it>r</it>. Then</p>
<p>

<indent level="1">

<math>b(x, r) = \bigoplus_j x_j r_j</math> 
</indent>

is a hard core predicate of <it>g</it>.   Note that <math>b(x,r) = \langle x, r \rangle</math> where <math>\langle \cdot, \cdot \rangle</math> denotes the standard <form wordnetid="106290637" confidence="0.8">
<word wordnetid="106286395" confidence="0.8">
<space wordnetid="100028651" confidence="0.8">
<part wordnetid="113809207" confidence="0.8">
<language_unit wordnetid="106284225" confidence="0.8">
<link xlink:type="simple" xlink:href="../856/14856.xml">
inner product</link></language_unit>
</part>
</space>
</word>
</form>
 on the <link xlink:type="simple" xlink:href="../370/32370.xml">
vector space</link> <math>(\Z/2\Z)^n</math>.  This predicate is hard-core due to computational issues; that is, it is not hard to compute because <it>g(x, r)</it> is <link xlink:type="simple" xlink:href="../773/14773.xml">
information theoretically</link> lossy.  Rather, if an algorithm exists to compute this predicate efficiently, then an algorithm exists to invert <it>f</it> efficiently.  A similar construction yields a hard-core function with <it>log (|x|)</it> output bits.</p>
<p>

It is sometimes the case that an actual bit of the input <it>x</it> is hard-core. For example, the low-order bit is hard-core for RSA. It is in fact conjectured that the lower half of the bits are all hard-core for RSA; in other words, the latter-half bits constitute a hard-core function. Note that this is stronger than each of the latter bits being hard-core predicates individually, because <math>f(x)</math> may reveal correlations between certain bits of <math>x</math> without revealing anything about individual bits.</p>
<p>

Hard-core predicates give a way to construct a <link xlink:type="simple" xlink:href="../249/182249.xml">
pseudorandom generator</link> from any <link xlink:type="simple" xlink:href="../890/363890.xml">
one-way permutation</link>. If <it>b</it> is a hard-core predicate of a one way function <it>f</it>, and <it>s</it> is a random seed, then </p>
<p>

<indent level="1">

<math>\left \{ b ( f^n ( s ) ) \right \}_n</math> 
</indent>

is a pseudorandom bit sequence.</p>
<p>

Hard-core predicates of trapdoor one-way permutations can be used to construct <link xlink:type="simple" xlink:href="../585/960585.xml">
semantically secure</link> public-key encryption schemes.  
</p>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Oded Goldreich, Foundations of Cryptography vol 1: Basic Tools, Cambridge University Press, 2001.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Oded Goldreich and Leonid A. Levin, <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=73010">
A Hard-Core Predicate for all One-Way Functions</weblink>, STOC 1989, pp25&ndash;32.</entry>
</list>
</p>


</sec>
</bdy>
</article>
