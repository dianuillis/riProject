<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:16:21[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Turing reduction</title>
<id>1188375</id>
<revision>
<id>233621603</id>
<timestamp>2008-08-22T22:05:10Z</timestamp>
<contributor>
<username>Skeptical scientist</username>
<id>4597823</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
<category>Alan Turing</category>
<category>Recursion theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability theory</link>, a <b>Turing reduction</b> from a problem <it>A</it> to a problem <it>B</it>, named after <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
, is a <link xlink:type="simple" xlink:href="../067/848067.xml">
reduction</link> which solves <it>A</it>, assuming <it>B</it> is already known (Rogers 1967, Soare 1987). More formally, a Turing reduction is a function computable by an <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle machine</link> with an oracle for <it>B</it>.  Turing reductions can be applied to both <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>s and <link xlink:type="simple" xlink:href="../345/663345.xml">
function problem</link>s. <p>

If a Turing reduction of <it>A</it> to <it>B</it> exists then every <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for <it>B</it> can be used to produce an algorithm for <it>A</it>, by inserting the algorithm for <it>B</it> at each place where the oracle machine computing <it>A</it> queries the oracle for <it>B</it>. However, because the oracle machine may query the oracle a large number of times, the resulting algorithm may require more time asymptotically than either <it>M</it> or the oracle machine, and may require as much space as both together. </p>
<p>

The first formal definition of relative computability, then called relative reducibility, was given by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
 in 1939 in terms of <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle machine</link>s. Later in 1943 and 1952 <link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link> defined an equivalent concept in terms of <link xlink:type="simple" xlink:href="../469/26469.xml">
recursive function</link>s. In 1944 <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link> used the term "Turing reducibility" to refer to the concept.</p>

<sec>
<st>
 Definition </st>

<p>

Given two sets <math>A,B \subseteq \mathbb{N}</math> of natural numbers, we say <math>A</math> is <b>Turing reducible</b> to <math>B</math> and write
<indent level="1">

<math>A \leq_T B</math> 
</indent>
if there is an <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle machine</link> that computes the characteristic function of <it>A</it> when run with oracle <it>B</it>.  In this case, we also say <it>A</it> is <b><it>B</it></b><b>-recursive</b> and <b><it>B</it></b><b>-computable</b>.</p>
<p>

If there is an oracle machine that, when run with oracle <it>B</it>,  computes a partial function with domain <it>A</it>, then <it>A</it> is said to be <b><it>B</it></b><b>-<link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable</link></b> and <b><it>B</it></b><b>-computably enumerable</b>.</p>
<p>

We say <math>A</math> is <b>Turing equivalent</b> to <math>B</math> and write <math>A \equiv_T B\,</math> if both <math>A \leq_T B</math>  and <math>B \leq_T A.</math> The <link xlink:type="simple" xlink:href="../260/9260.xml">
equivalence classes</link> of Turing equivalent sets are called <b><link xlink:type="simple" xlink:href="../405/764405.xml">
Turing degree</link>s</b>. The Turing degree of a set <math>X</math> is written <math>\textbf{deg}(X)</math>.</p>
<p>

Given a set <math>\mathcal{X} \subseteq \mathcal{P}(\mathbb{N})</math>, a set <math>A \subseteq \mathbb{N}</math> is called <b>Turing hard</b> for <math>\mathcal{X}</math> if <math>X \leq_T A</math>  for all <math>X \in \mathcal{X}</math>. If additionally <math>A \in \mathcal{X}</math> then <math>A</math> is called <b>Turing complete</b> for <math>\mathcal{X}</math>.</p>

<ss1>
<st>
Relation of Turing completeness to computational universality</st>
<p>

Turing completeness, as just defined above, corresponds only partially to <link xlink:type="simple" xlink:href="../621/30621.xml">
Turing completeness</link> in the sense of computational universality.  Specifically, a Turing machine is a <link xlink:type="simple" xlink:href="../435/71435.xml">
universal Turing machine</link> iff its halting problem (i.e., the set of inputs for which it eventually halts) is <link xlink:type="simple" xlink:href="../983/362983.xml">
many-one complete</link>.  Thus, a necessary <it>but insufficient</it> condition for a machine to be computationally universal, is that the machine's halting problem be Turing-complete for the set <math>\mathcal{X}</math> of recursively enumerable sets.</p>

</ss1>
</sec>
<sec>
<st>
 Example </st>

<p>

Let <math>W_e</math> denote the set of input values for which the Turing machine with index <it>e</it> halts.  Then the sets <math>A = \{e \mid e \in W_e\}</math> and <math>B = \{(e,n) \mid n \in W_e \}</math> are Turing equivalent (here <math>(e,n)</math> denotes an effective pairing function).  A reduction showing <math>A \leq_T B</math> can be constructed using the fact that <math>e \in A \Leftrightarrow (e,e) \in B</math>.  Given a pair <math>(e,n)</math>, a new index <math>i(e,n)</math> can be constructed using the <link xlink:type="simple" xlink:href="../936/2330936.xml">
s-m-n theorem</link> such that the program coded by <math>i(e,n)</math> ignores its input and merely simulates the computation of the machine with index <it>e</it> on input <it>n</it>.  
In particular, the machine with index <math>i(e,n)</math> either halts on every input or halts on no input.  Thus <math>i(e,n) \in A \Leftrightarrow (e,n) \in B</math> holds for all <it>e</it> and <it>n</it>.  Because the function <it>i</it> is computable, this shows <math>B \leq_T A</math>.  The reductions presented here are not only Turing reductions but <it>many-one reductions</it>, discussed below.</p>

</sec>
<sec>
<st>
 Properties </st>

<p>

<list>
<entry level="1" type="bullet">

 Every set is Turing equivalent to its complement</entry>
<entry level="1" type="bullet">

 Every <link xlink:type="simple" xlink:href="../264/332264.xml">
computable set</link> is Turing reducible to every other computable set.  Because these sets can be computed with no oracle, they can be computed by an oracle machine that ignores the oracle it is given.</entry>
<entry level="1" type="bullet">

 The relation <math>\leq_T</math> is transitive: if <math>A \leq_T B</math> and <math>B \leq_T C</math> then <math>A \leq_T C</math>.  Moreover <math>A \leq A</math> holds for every set <it>A</it>, and thus the relation <math>\leq_T</math> is a <link xlink:type="simple" xlink:href="../582/23582.xml">
preorder</link> (it is not a <link xlink:type="simple" xlink:href="../572/23572.xml">
partial order</link> because <math>A \leq_T B</math> and <math>B \leq_T A </math> does not necessarily imply <math>A = B</math>).  </entry>
<entry level="1" type="bullet">

 There are pairs of sets <math>(A,B)</math>  such that <it>A</it> is not Turing reducible to <it>B</it> and <it>B</it> is not Turing reducible to <it>A</it>.  Thus <math>\leq_T</math> is not a linear order.</entry>
<entry level="1" type="bullet">

 There are infinite decreasing sequences of sets under <math>\leq_T</math>. Thus this relation is not <link xlink:type="simple" xlink:href="../712/319712.xml">
well-founded</link>.</entry>
<entry level="1" type="bullet">

 Every set is Turing reducible to its own <link xlink:type="simple" xlink:href="../091/1681091.xml">
Turing jump</link>, but the Turing jump of a set is never Turing reducible to the original set.</entry>
</list>
</p>

</sec>
<sec>
<st>
 The use of a reduction </st>

<p>

Since every reduction from a set <it>B</it> to a set <it>A</it> has to determine whether a single element is in <it>A</it> in only finitely many steps, it can only make finitely many queries of membership in the set <it>B</it>. When the amount of information about the set <it>B</it> used to compute a single bit of <it>A</it> is discussed, this is made precise by the use function. Formally, the <it>use</it> of a reduction is the function that sends each natural number <it>n</it> to the largest natural number <it>m</it> whose membership in the set <it>B</it> was queried by the reduction while determining the membership of <it>n</it> in <it>A</it>.</p>

</sec>
<sec>
<st>
 Stronger reductions </st>

<p>

There are two common ways of producing reductions stronger than Turing reducibility.  
The first way is to limit the number and manner of oracle queries.  
<list>
<entry level="1" type="bullet">

 A set <it>A</it> is <b><link xlink:type="simple" xlink:href="../983/362983.xml">
many-one reducible</link></b> to <it>B</it> if there is a <link xlink:type="simple" xlink:href="../338/1139338.xml">
total computable function</link> <it>f</it> such that an element <it>n</it> is in <it>A</it> if and only if <it>f</it>(<it>n</it>) is in <it>B</it>.  Such a function can be used to generate a Turing reduction (by computing <it>f</it>(<it>n</it>), querying the oracle, and then interpreting the result).  </entry>
<entry level="1" type="bullet">

 A <b><link xlink:type="simple" xlink:href="../407/2695407.xml">
truth table reduction</link></b> or a <b><link xlink:type="simple" xlink:href="../407/2695407.xml">
weak truth table reduction</link></b> must present all of its oracle queries at the same time. In a truth table reduction, the reduction also gives a boolean function (a <b>truth table</b>) which, when given the answers to the queries, will produce the final answer of the reduction. In a weak truth table reduction, the reduction uses the oracle answers as a basis for further computation depending on the given answers (but not using the oracle). Equivalently, a weak truth table reduction is one for which the use of the reduction is bounded by a computable function. For this reason, weak truth table reductions are sometimes called "bounded Turing" reductions.</entry>
</list>
</p>
<p>

The second way to produce a stronger reducibility notion is to limit the computational resources that the program implementing the Turing reduction may use.   These limits on the <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link> of the reduction are important when studying subrecursive classes such as <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
.  A set <it>A</it> is <b><link xlink:type="simple" xlink:href="../695/159695.xml">
polynomial-time reducible</link></b> to a set <it>B</it> if there is a Turing reduction of <it>A</it> to <it>B</it> that runs in polynomial time.  The concept of <b><link xlink:type="simple" xlink:href="../850/1174850.xml">
log-space reduction</link></b> is similar.</p>
<p>

Note that while these reductions are stronger in the sense that they provide a finer distinction into equivalence classes, and have more restrictive requirements than Turing reductions, this is because the reductions themselves are less powerful; there may be no way to build a many-one reduction from one set to another even when a Turing reduction for the same sets exists.</p>

</sec>
<sec>
<st>
 Weaker reductions </st>

<p>

According to the <link xlink:type="simple" xlink:href="../854/6854.xml">
Church-Turing thesis</link>, a Turing reduction is the most general form of an effectively calculable reduction.  Nevertheless, weaker reductions are also considered.  A set <it>A</it> is said to be <b><link xlink:type="simple" xlink:href="../451/2342451.xml">
arithmetical</link> in</b> <it>B</it> if <it>A</it> is definable by a formula of <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link> with <it>B</it> as a parameter.  The set <it>A</it> is <b><link>
hyperarithmetical</link> in</b> <it>B</it>  if there is a <link xlink:type="simple" xlink:href="../979/5173979.xml">
recursive ordinal</link> &amp;alpha; such that <it>A</it> is computable from <math>B^{(\alpha)}</math>, the &amp;alpha;-iterated Turing jump of <it>B</it>.  The notion of <b><link xlink:type="simple" xlink:href="../335/343335.xml">
relative constructibility</link></b> is an important reducibility notion in set theory.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 M. Davis, ed., 1965.  <it>The Undecidable&mdash;Basic Papers on Undecidable Propositions, Unsolvable Problems and Computable Functions</it>, Raven, New York. Reprint, Dover, 2004. ISBN 0-486-43228-9. </entry>
<entry level="1" type="bullet">

 S. C. Kleene, 1952. Introduction to Metamathematics. Amsterdam: North-Holland.</entry>
<entry level="1" type="bullet">

 S. C. Kleene and E. L. Post, 1954. "The upper semi-lattice of degrees of recursive unsolvability". <it>Annals of Mathematics</it> v. 2 n. 59, 379--407.</entry>
<entry level="1" type="bullet">

 E. Post, 1944. "Recursively enumerable sets of positive integers and their decision problems." Bulletin of the American Mathematical Society, v. 50, pp. 284-316.  Reprinted in "The Undecidable", M. Davis ed., 1965.  </entry>
<entry level="1" type="bullet">

 A. Turing, 1939. "Systems of logic based on ordinals." <it>Proceedings of the London Mathematics Society</it>, ser. 2 v. 45, pp. 161â€“228. Reprinted in "The Undecidable", M. Davis ed., 1965. </entry>
<entry level="1" type="bullet">

 H. Rogers, 1967. Theory of recursive functions and effective computability. McGraw-Hill.</entry>
<entry level="1" type="bullet">

 R. Soare, 1987. Recursively enumerable sets and degrees, Springer.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Davis, Martin</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
&#32;(November 2006).&#32;"<weblink xlink:type="simple" xlink:href="http://www.ams.org/notices/200610/whatis-davis.pdf">
What is...Turing Reducibility?</weblink>"&#32;(<link xlink:type="simple" xlink:href="../077/24077.xml">
PDF</link>). <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/4977512.xml">
Notices of the American Mathematical Society</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>&#32;<b>53</b>&#32;(10): pp.1218&ndash;1219. Retrieved on <link>
2008-01-16</link>.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/turingredctn.html">
NIST Dictionary of Algorithms and Data Structures: Turing reduction</weblink></entry>
</list>
</p>



</sec>
</bdy>
</article>
