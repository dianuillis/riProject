<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:17:14[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<structure  confidence="0.8" wordnetid="104341686">
<artifact  confidence="0.8" wordnetid="100021939">
<header>
<title>Bit array</title>
<id>1189937</id>
<revision>
<id>228266074</id>
<timestamp>2008-07-27T22:04:16Z</timestamp>
<contributor>
<username>Thumperward</username>
<id>545027</id>
</contributor>
</revision>
<categories>
<category>Bit data structures</category>
<category>Arrays</category>
</categories>
</header>
<bdy>

A <b>bit array</b> (or <b>bitmap</b>, in some cases) is an <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link> <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link> which compactly stores individual bits (<link xlink:type="simple" xlink:href="../065/1162065.xml">
boolean value</link>s). It implements a simple <link xlink:type="simple" xlink:href="../127/201127.xml">
set data structure</link> storing a subset of {1,2,...,<it>n</it>} and is effective at exploiting bit-level parallelism in hardware to perform operations quickly. A typical bit array stores <it>kw</it> bits, where <it>w</it> is the number of bits in the unit of storage, such as a <link xlink:type="simple" xlink:href="../365/3365.xml">
byte</link> or <link xlink:type="simple" xlink:href="../344/1613344.xml">
word</link>, and <it>k</it> is some integer. If the number of bits to be stored does not divide <it>w</it>, some space is wasted due to <link xlink:type="simple" xlink:href="../369/3909369.xml">
internal fragmentation</link>.
<sec>
<st>
 Basic operations </st>
<p>

Although most machines are not able to address individual bits in memory, nor have instructions to manipulate single bits, each bit in a word can be singled out and manipulated using <link xlink:type="simple" xlink:href="../399/264399.xml">
bitwise operation</link>s. In particular:
<list>
<entry level="1" type="bullet">

 OR can be used to set a bit to one: 11101010 OR 00000100 = 11101110</entry>
<entry level="1" type="bullet">

 AND can be used to set a bit to zero: 11101010 AND 11111101 = 11101000</entry>
<entry level="1" type="bullet">

 AND together with zero-testing can be used to determine if a bit is set:</entry>
<entry level="2" type="indent">

 11101010 AND 00010000 = 00000000 = 0</entry>
<entry level="2" type="indent">

 11101010 AND 00000010 = 00000010 ≠ 0</entry>
<entry level="1" type="bullet">

 XOR can be used to invert or toggle a bit:</entry>
<entry level="2" type="indent">

 11101010 XOR 00000100 = 11101110</entry>
<entry level="2" type="indent">

 11101110 XOR 00000100 = 11101010</entry>
</list>
</p>
<p>

To obtain the bit mask needed for these operations, we can use a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/264399.xml#xpointer(//*[./st=%22Bit+shifts%22])">
bit shift</link></concept>
</idea>
 operator to shift the number 1 to the left by the appropriate number of places.</p>
<p>

We can view a bit array as a subset of {1,2,...,<it>n</it>}, where a 1 bit indicates a number in the set and a 0 bit a number not in the set. This set data structure uses about <it>n</it>/<it>w</it> words of space, where <it>w</it> is the number of bits in each machine word. Whether the least significant bit or the most significant bit indicates the smallest-index number is largely irrelevant, but the former tends to be preferred.</p>
<p>

Given two bit arrays of the same size representing sets, we can compute their <link xlink:type="simple" xlink:href="../949/47949.xml">
union</link>, <link xlink:type="simple" xlink:href="../157/48157.xml">
intersection</link>, and <link xlink:type="simple" xlink:href="../347/54347.xml">
set-theoretic difference</link> using <it>n</it>/<it>w</it> simple bit operations each (2<it>n</it>/<it>w</it> for difference), as well as the <link xlink:type="simple" xlink:href="../139/74139.xml">
complement</link> of either:</p>
<p>

<b>for</b> i <b>from</b> 0 <b>to</b> n/w-1
complement_a[i] := <b>not</b> a[i]
union[i]        := a[i] <b>or</b> b[i]
intersection[i] := a[i] <b>and</b> b[i]
difference[i]   := a[i] <b>and</b> (<b>not</b> b[i])</p>
<p>

If we wish to iterate through the bits of a bit array, we can do this efficiently using a doubly-nested loop which loops through each word, one at a time. Only <it>n</it>/<it>w</it> memory accesses are required:</p>
<p>

<b>for</b> i <b>from</b> 0 <b>to</b> n/w-1
index := 0    <it>// if needed</it>
word := a[i]
<b>for</b> b <b>from</b> 0 <b>to</b> w-1
value := word <b>and</b> 1 ≠ 0
word := word shift right 1
<it>// do something with value</it>
index := index + 1   <it>// if needed</it></p>
<p>

Both of these code samples exhibit ideal <link xlink:type="simple" xlink:href="../028/64028.xml">
locality of reference</link>, and so get a large performance boost from a data cache. If a cache line is <it>k</it> words, only about <it>n</it>/<it>wk</it> cache misses will occur.</p>

</sec>
<sec>
<st>
 More complex operations </st>

<ss2>
<st>
 Population / Hamming weight </st>
<p>

If we wish to find the number of 1 bits in a bit array, sometimes called the <it>population function</it>, or <link xlink:type="simple" xlink:href="../884/1127884.xml">
Hamming weight</link>, there are efficient branch-free algorithms which can compute the number of bits in a word using a series of simple bit operations. We simply run such an algorithm on each word and keep a running total. Counting zeros is similar. See the <link xlink:type="simple" xlink:href="../884/1127884.xml">
Hamming weight</link> article for examples of an efficient implementation.</p>

</ss2>
<ss2>
<st>
 Sorting </st>
<p>

Similarly, sorting a bit array is trivial to do in O(<it>n</it>) time using <link xlink:type="simple" xlink:href="../864/99864.xml">
counting sort</link> &mdash; we count the number of ones <it>k</it>, fill the last <it>k</it>/<it>w</it> words with ones, set only the low <it>k</it> mod <it>w</it> bits of the next word, and set the rest to zero.</p>

</ss2>
<ss2>
<st>
 Find First One </st>
<p>

Bit arrays are useful in some contexts as <link xlink:type="simple" xlink:href="../485/24485.xml">
priority queue</link>s. The goal in such a context is to identify the one bit of smallest index, that is the least significant bit has the highest priority. Some machines have a <it>find first one</it> or <it>find first zero</it> operation that does this on a single word. With this, the operation is obvious: find the first nonzero word and run <it>find first one</it> on it, or <it>find first zero</it> on its complement. On machines that do not feature this operation, such as most PCs, the operation can be reproduced using sequences of bit operations.</p>
<p>

On machines that use <link xlink:type="simple" xlink:href="../145/307145.xml">
two's complement</link> arithmetic, such as all PCs, the <it>find first one</it> function can be performed quickly by anding a word with its two's complement, that is performing (w and -w) results in a word with only the righmost bit set of the bits that were set before the operation. For instance, if the original value were 6 (...110), after this operation the result would be 2 (...010).</p>

</ss2>
</sec>
<sec>
<st>
 Advantages and disadvantages </st>
<p>

Bit arrays, despite their simplicity, have a number of marked advantages over other data structures for the same problems:
<list>
<entry level="1" type="bullet">

 They are extremely compact; few other data structures can store <it>n</it> independent pieces of data in <it>n</it>/<it>w</it> words.</entry>
<entry level="1" type="bullet">

 They allow small arrays of bits to be stored and manipulated in the register set for long periods of time with no memory accesses.</entry>
<entry level="1" type="bullet">

 Because of their ability to exploit bit-level parallelism, limit memory access, and maximally utilize the <link xlink:type="simple" xlink:href="../181/849181.xml">
data cache</link>, they often outperform many other data structures on practical data sets, even those which are more efficient asymptotically.</entry>
</list>

However, bit arrays aren't the solution to everything. In particular:
<list>
<entry level="1" type="bullet">

 They are wasteful set data structures for sparse sets (those with few elements compared to their range) in both time and space. For such applications, <work wordnetid="100575741" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<undertaking wordnetid="100795720" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../569/484569.xml">
Judy array</link></activity>
</psychological_feature>
</act>
</undertaking>
</event>
</work>
s, <link xlink:type="simple" xlink:href="../274/31274.xml">
trie</link>s, or even <link xlink:type="simple" xlink:href="../211/602211.xml">
Bloom filter</link>s should be considered instead.</entry>
<entry level="1" type="bullet">

 Accessing individual elements can be expensive and difficult to express in some languages. If random access is more common than sequential and the array is relatively small, a byte array may be preferable on a machine with byte addressing. A word array, however, is probably not justified due to the huge space overhead and additional cache misses it causes, unless the machine only has word addressing.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Applications </st>
<p>

Because of their compactness, bit arrays have a number of applications in areas where space or efficiency is at a premium. Most commonly, they are used to represent a simple group of boolean flags or an ordered sequence of boolean values.</p>
<p>

We mentioned above that bit arrays are used for <link xlink:type="simple" xlink:href="../485/24485.xml">
priority queue</link>s, where the bit at index <it>k</it> is set if and only if <it>k</it> is in the queue; this data structure is used, for example, by the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/18510.xml">
Linux kernel</link></software>
, and benefits strongly from a find-first-zero operation in hardware.</p>
<p>

Bit arrays can be used for the allocation of <link xlink:type="simple" xlink:href="../911/11254911.xml">
memory pages</link>, <link xlink:type="simple" xlink:href="../170/580170.xml">
inode</link>s, disk sectors, etc. In such cases, the term <it>bitmap</it> may be used. However, this term is frequently used to refer to <link xlink:type="simple" xlink:href="../742/25742.xml">
raster images</link>, which may use multiple <link xlink:type="simple" xlink:href="../448/331448.xml">
bits per pixel</link>.</p>
<p>

Another application of bit arrays is the <link xlink:type="simple" xlink:href="../211/602211.xml">
Bloom filter</link>, a probabilistic <link xlink:type="simple" xlink:href="../127/201127.xml">
set data structure</link> that can store large sets in a small space in exchange for a small probability of error. It is also possible to build probabilistic <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link>s based on bit arrays that accept either false positives or false negatives.</p>
<p>

Bit arrays and the operations on them are also important for constructing <link xlink:type="simple" xlink:href="../951/10122951.xml">
succinct data structure</link>s, which use close to the minimum possible space. In this context, operations like finding the <it>n</it>th 1 bit or counting the number of 1 bits up to a certain position become important.</p>
<p>

Bit arrays are also a useful abstraction for examining streams of <link xlink:type="simple" xlink:href="../013/8013.xml">
compressed</link> data, which often contain elements that occupy portions of bytes or are not byte-aligned. For example, the compressed <plant wordnetid="100017222" confidence="0.8">
<tree wordnetid="113104059" confidence="0.8">
<vascular_plant wordnetid="113083586" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<woody_plant wordnetid="113103136" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../883/13883.xml">
Huffman coding</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</woody_plant>
</rule>
</event>
</vascular_plant>
</tree>
</plant>
 representation of a single 8-bit character can be anywhere from 1 to 255 bits long.</p>
<p>

In <link xlink:type="simple" xlink:href="../271/15271.xml">
information retrieval</link>, bit arrays are a good representation for the <link>
posting list</link>s of very frequent terms. If we compute the gaps between adjacent values in a list of strictly increasing integers and encode them using <link xlink:type="simple" xlink:href="../041/236041.xml">
unary coding</link>, the result is a bit array with a 1 bit in the <it>n</it>th position if and only if <it>n</it> is in the list. The implied probability of a gap of <it>n</it> is 1/2<it>n</it>. This is also the special case of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../230/147230.xml">
Golomb coding</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 where the parameter M is 1; this parameter is only normally selected when -log(2-<it>p</it>)/log(1-<it>p</it>) &amp;le; 1, or roughly the term occurs in at least 38% of documents.</p>

</sec>
<sec>
<st>
 Language support </st>
<p>

The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
's <it><link xlink:type="simple" xlink:href="../276/2667276.xml">
bitfield</link>s</it>, pseudo-objects found in structs with size equal to some number of bits, are in fact small bit arrays; they are limited in that they cannot span words. Although they give a convenient syntax, the bits are still accessed using bitwise operators on most machines, and they can only be defined statically (like C's static arrays, their sizes are fixed at compile-time). It is also a common idiom for C programmers to use words as small bit arrays and access bits of them using bit operators.  A widely available header file included in the <link xlink:type="simple" xlink:href="../147/34147.xml">
X11</link> system, xtrapbits.h, is "a portable way for systems to define bit field manipulation of arrays of bits.".</p>
<p>

In <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, although individual bools typically occupy the same space as a byte or an integer, the <link xlink:type="simple" xlink:href="../777/156777.xml">
STL</link> type vector is a partial specialization in which bits are packed as a space efficiency optimization. Since bytes (and not bits) are the smallest addressable unit in C++, the  operator does <it>not</it> return a reference to an element, but instead returns a <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../856/164856.xml">
proxy reference</link></form>
</structure>
. This might seem a minor point, but it means that vector is <it>not</it> a standard STL container, which is why the use of vector is generally discouraged. Another unique STL class, bitset, creates a vector of bits fixed at a particular size at compile-time, and in its interface and syntax more resembles the idiomatic use of words as bit sets by C programmers. It also has some additional power, such as the ability to efficiently count the number of bits that are set. The <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/711324.xml">
Boost C++ Libraries</link></room>
</library>
</area>
</artifact>
</structure>
 provides a dynamic_bitset class whose size is specified at run-time.</p>
<p>

The <link xlink:type="simple" xlink:href="../881/243881.xml">
D programming language</link> provides bit arrays in both of its competing standard libraries.  In phobos, they are provided in  std.bitmanip, and in Tango, they are provided in tango.core.BitArray.  As in C++, the  operator does not return a reference, since individual bits are not directly addressable on most hardware, but instead returns a bool.</p>
<p>

In <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, the class <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/BitSet.html">
BitSet</weblink> creates a bit array which is then manipulated with functions named after bitwise operators familiar to C programmers. Unlike the bitset in C++, the Java BitSet expands dynamically if a bit is set at an index beyond the current size of the bit vector. In addition, there is a class <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/EnumSet.html">
EnumSet</weblink>, which represents a Set of values of an <link xlink:type="simple" xlink:href="../370/4723370.xml">
enumerated type</link> internally as a bit vector, as a safer alternative to bitfields.</p>
<p>

The <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/60402.xml">
.NET Framework</link></implement>
</horizontal_surface>
</tool>
</instrumentality>
</surface>
</artifact>
</platform>
 supplies a BitArray collection class. It stores boolean values, supports random access and bitwise operators, can be iterated over, and its Length property can be changed to grow or truncate it.</p>
<p>

Although <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../337/100337.xml">
Standard ML</link></programming_language>
 has no support for bit arrays, Standard ML of New Jersey has an extension, the BitArray structure, in its SML/NJ Library. It is not fixed in size and supports set operations and bit operations, including, unusually, shift operations.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../276/2667276.xml">
Bit field</link></entry>
<entry level="1" type="bullet">

 <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../528/284528.xml">
Bitboard</link></psychological_feature>
</game>
</contest>
</social_event>
</event>
</artifact>
</structure>
 Chess and similar games.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../214/2017214.xml">
Bitmap index</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.boost.org/libs/dynamic_bitset/dynamic_bitset.html">
boost::dynamic_bitset</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.sgi.com/tech/stl/bitset.html">
std::bitset</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gotw.ca/publications/N1185.pdf">
vector Is Nonconforming, and Forces Optimization Choice</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gotw.ca/publications/N1211.pdf">
vector: More Problems, Better Solutions</weblink></entry>
</list>
</p>

</sec>
</bdy>
</artifact>
</structure>
</article>
