<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:18:21[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Scale-invariant feature transform</title>
<id>1208345</id>
<revision>
<id>244103243</id>
<timestamp>2008-10-09T10:57:25Z</timestamp>
<contributor>
<username>Alexbot</username>
<id>5517884</id>
</contributor>
</revision>
<categories>
<category>All articles with unsourced statements</category>
<category>Computer vision</category>
<category>Articles with invalid date parameter in template</category>
<category>Articles with unsourced statements since August 2008</category>
</categories>
</header>
<bdy>

<table style="width: 22em; text-align: left; font-size: 88%; line-height: 1.5em; width:20em;" class="infobox " cellspacing="5">
<row>
<col colspan="2" style="text-align:center; font-size: 125%; font-weight: bold; " class="">
<link xlink:type="simple" xlink:href="../224/1284224.xml">
Feature detection</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
 <image width="200px" src="Corner.png">
</image>
Output of a typical corner detection algorithm</col>
</row>
<row>
<header colspan="2" style="text-align:center; ">
<link xlink:type="simple" xlink:href="../680/331680.xml">
Edge detection</link></header>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../817/476817.xml">
Canny</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../817/476817.xml#xpointer(//*[./st=%22Conclusion%22])">
Canny-Deriche</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../680/331680.xml#xpointer(//*[./st=%22Differential+edge+detection%22])">
Differential</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../116/476116.xml">
Sobel</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; ">
<link xlink:type="simple" xlink:href="../669/7046669.xml">
Interest point detection</link></header>
</row>
<row>
<header colspan="2" style="text-align:center; ">
<link xlink:type="simple" xlink:href="../759/4921759.xml">
Corner detection</link></header>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../759/4921759.xml#xpointer(//*[./st=%22The+Harris+=26+Stephens+/+Plessey+corner+detection+algorithm%22])">
Harris operator</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../759/4921759.xml#xpointer(//*[./st=%22The+Shi+and+Tomasi+corner+detection+algorithm%22])">
Shi and Tomasi</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../759/4921759.xml#xpointer(//*[./st=%22The+level+curve+curvature+approach%22])">
Level curve curvature</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../759/4921759.xml#xpointer(//*[./st=%22The+SUSAN+corner+detector%22])">
SUSAN</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../759/4921759.xml#xpointer(//*[./st=%22The+FAST+feature+detector%22])">
FAST</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; ">
<link xlink:type="simple" xlink:href="../205/6840205.xml">
Blob detection</link></header>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../205/6840205.xml#xpointer(//*[./st=%22The+Laplacian+of+Gaussian%22])">
Laplacian of Gaussian (LoG)</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<happening wordnetid="107283608" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<movement wordnetid="107309781" confidence="0.8">
<wave wordnetid="107352190" confidence="0.8">
<ripple wordnetid="107344663" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../943/3334943.xml">
Difference of Gaussians (DoG)</link></psychological_feature>
</ripple>
</wave>
</movement>
</event>
</happening>
</col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../205/6840205.xml#xpointer(//*[./st=%22The+determinant+of+the+Hessian%22])">
Determinant of Hessian  (DoH)</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../901/14669901.xml">
Maximally stable extremal regions</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; ">
<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../898/6185898.xml">
Ridge detection</link></function>
</mathematical_relation>
</header>
</row>
<row>
<header colspan="2" style="text-align:center; ">
Affine invariant feature detection</header>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../265/6866265.xml">
Affine shape adaptation</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../078/14664078.xml">
Harris affine</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../110/14664110.xml">
Hessian affine</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; ">
Feature description</header>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../345/1208345.xml">
SIFT</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../697/12341697.xml">
SURF</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../751/12341751.xml">
GLOH</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../795/15895795.xml">
LESH</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; ">
<link xlink:type="simple" xlink:href="../661/1703661.xml">
Scale-space</link></header>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../404/5481404.xml">
Scale-space axioms</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../059/5477059.xml">
Implementation details</link></col>
</row>
<row>
<col colspan="2" style="text-align:center; " class="">
<link xlink:type="simple" xlink:href="../023/15966023.xml">
Pyramids</link></col>
</row>
<row>
<col colspan="2" style="text-align:right;"></col>
</row>
</table>

<p>

<b>Scale-invariant feature transform</b> (or <b>SIFT</b>) is an algorithm in <link xlink:type="simple" xlink:href="../596/6596.xml">
computer vision</link> to detect and describe local features in images. The algorithm was published by <weblink xlink:type="simple" xlink:href="http://www.cs.ubc.ca/~lowe/">
David Lowe</weblink> in 1999.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

Applications include <link xlink:type="simple" xlink:href="../466/14661466.xml">
object recognition</link>, <link xlink:type="simple" xlink:href="../112/623112.xml">
robotic mapping</link> and navigation, <link xlink:type="simple" xlink:href="../768/2889768.xml">
image stitching</link>, <process wordnetid="100029677" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<phenomenon wordnetid="100034213" confidence="0.8">
<consequence wordnetid="111410625" confidence="0.8">
<link xlink:type="simple" xlink:href="../382/764382.xml">
3D modeling</link></consequence>
</phenomenon>
</physical_entity>
</process>
, <link xlink:type="simple" xlink:href="../452/1400452.xml">
gesture recognition</link>, <link xlink:type="simple" xlink:href="../217/2032217.xml">
video tracking</link>, and <link xlink:type="simple" xlink:href="../353/1478353.xml">
match moving</link>.</p>
<p>

The algorithm is patented; the owner is the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../411/173411.xml">
University of British Columbia</link></university>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

<sec>
<st>
 Features </st>
<p>

The detection and description of local image features can help in object recognition. The SIFT features are local and based on the appearance of the object at particular interest points, and are invariant to image scale and rotation. They are also robust to changes in illumination, noise, and minor changes in viewpoint. In addition to these properties, they are highly distinctive, relatively easy to extract, allow for correct object identification with low probability of mismatch and are easy to match against a (large) database of local features. Object description by set of SIFT features is also robust to partial occlusion; as few as 3 SIFT features from an object are enough to compute its location and pose. Recognition can be performed in close-to-real time, at least for small databases and on modern computer hardware.&#91;&#93;</p>

</sec>
<sec>
<st>
 Algorithm </st>

<p>

The algorithm has four stages.</p>

<ss1>
<st>
 Scale-space extrema detection </st>

<p>

This is the stage where the interest points, which are called keypoints in the SIFT framework, are detected. For this, the image is convolved with Gaussian filters at different scales, and then the difference of successive Gaussian-blurred images are taken. Keypoints are then taken as maxima/minima of the <happening wordnetid="107283608" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<movement wordnetid="107309781" confidence="0.8">
<wave wordnetid="107352190" confidence="0.8">
<ripple wordnetid="107344663" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../943/3334943.xml">
Difference of Gaussians</link></psychological_feature>
</ripple>
</wave>
</movement>
</event>
</happening>
 (DoG) that occur at multiple scales. Specifically, a DoG image <math>D \left( x, y, \sigma \right)</math> is given by</p>
<p>

<indent level="1">

<math>D \left( x, y, \sigma \right) = L \left( x, y, k_i\sigma \right) - L \left( x, y, k_j\sigma \right)</math>, 
</indent>
:where <math>L \left( x, y, k\sigma \right)</math> is the original image <math>I \left( x, y \right)</math> convolved with the <link xlink:type="simple" xlink:href="../685/1842685.xml">
Gaussian blur</link> <math>G \left( x, y, k\sigma \right)</math> at scale <math>k\sigma</math>, i.e.,</p>
<p>

<indent level="1">

<math>L \left( x, y, k\sigma \right) = G \left( x, y, k\sigma \right) * I \left( x, y \right)</math>
</indent>

Hence a DoG image between scales <math>k_i\sigma</math> and <math>k_j\sigma</math> is just the difference of the Gaussian-blurred images at scales <math>k_i\sigma</math> and <math>k_j\sigma</math>. For <link xlink:type="simple" xlink:href="../661/1703661.xml">
scale-space</link> extrema detection in the SIFT algorithm, the image is first convolved with Gaussian-blurs at different scales. The convolved images are grouped by octave (an octave corresponds to doubling the value of <math>\sigma</math>), and the value of <math>k_i</math> is selected so that we obtain a fixed number of convolved images per octave. Then the Difference-of-Gaussian images are taken from adjacent Gaussian-blurred images per octave.</p>
<p>

Once DoG images have been obtained, keypoints are identified as local minima/maxima of the DoG images across scales. This is done by comparing each pixel in the DoG images to its eight neighbors at the same scale and nine corresponding neighboring pixels in each of the neighboring scales. If the pixel value is the maximum or minimum among all compared pixels, it is selected as a candidate keypoint. </p>
<p>

This keypoint detection step is a variation of one of the <link xlink:type="simple" xlink:href="../205/6840205.xml">
blob detection</link> methods by detecting scale-space extrema of the scale normalized Laplacian,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> that is detecting points that are local extrema with respect to both space and scale, in the discrete case by comparisons with the nearest 26 neighbours in a discretized scale-space volume. The difference of Gaussians operator can be seen as an approximation to the Laplacian, here expressed in a <link xlink:type="simple" xlink:href="../023/15966023.xml">
pyramid</link> setting.</p>

</ss1>
<ss1>
<st>
 Keypoint localization </st>

<p>

<image width="150px" src="Sift_keypoints_filtering.jpg" type="thumb">
<caption>

After scale space extremas are detected (their location being shown in the uppermost image) the SIFT algorithm discards low contrast keypoints (remaining points are shown in the middle image) and then filters out those located on edges. Resulting set of keypoints is shown on last image.
</caption>
</image>
 Scale-space extrema detection produces too many keypoint candidates, some of which are unstable. The next step in the algorithm is to perform a detailed fit to the nearby data for accurate location, scale, and ratio of principal curvatures. This information allows points to be rejected that have low contrast (and are therefore sensitive to noise) or are poorly localized along an edge. </p>

<ss2>
<st>
 Interpolation of nearby data for accurate position </st>

<p>

First, for each candidate keypoint, interpolation of nearby data is used to accurately determine its position. The initial approach was to just locate each keypoint at the location and scale of the candidate keypoint.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> The new approach  calculates the interpolated location of the maximum, which substantially improves matching and stability.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> The interpolation is done using the quadratic <link>
Taylor expansion</link> of the Difference-of-Gaussian scale-space function, <math>D \left( x, y, \sigma \right)</math> with the candidate keypoint as the origin. This Taylor expansion is given by:</p>
<p>

<indent level="1">

<math>D(\textbf{x}) = D + \frac{\partial D^T}{\partial \textbf{x}}\textbf{x} + \frac{1}{2}\textbf{x}^T \frac{\partial^2 D}{\partial \textbf{x}^2} \textbf{x}</math>    
</indent>

where D and its derivatives are evaluated at the candidate keypoint and <math>\textbf{x} = \left( x, y, \sigma \right)</math> is the offset
from this point. The location of the extremum, <math>\hat{\textbf{x}}</math>, is determined by taking the derivative of this function with respect to <math>\textbf{x}</math> and setting it to zero. If the offset <math>\hat{\textbf{x}}</math> is larger than <math>0.5</math> in any dimension, then that's an indication that the extremum lies closer to another candidate keypoint. In this case, the candidate keypoint is changed and
the interpolation performed instead about that point. Otherwise the offset is added to its candidate keypoint to get the interpolated estimate for the location of the extremum.</p>

</ss2>
<ss2>
<st>
 Discarding low-contrast keypoints </st>

<p>

To discard the keypoints with low contrast, the value of the second-order Taylor expansion <math>D(\textbf{x})</math> is computed at the offset <math>\hat{\textbf{x}}</math>. If this value is less than <math>0.03</math>, the candidate keypoint is discarded. Otherwise it is kept, with final location <math>\textbf{y} + \hat{\textbf{x}}</math> and scale <math>\sigma</math>, where <math>\textbf{y}</math> is the original location of the keypoint at scale <math>\sigma</math>.   </p>

</ss2>
<ss2>
<st>
 Eliminating edge responses </st>

<p>

The DoG function will have strong responses along edges, even if the candidate keypoint is unstable to small amounts of noise. Therefore, in order to increase stability, we need to eliminate the keypoints that have poorly determined locations but have high edge responses.</p>
<p>

For poorly defined peaks in the DoG function, the principal curvature across the edge would be much larger than the principal curvature along it. Finding these principal curvatures amounts to solving for the eigenvalues of the second-order Hessian matrix, <b>H</b>:</p>
<p>

<indent level="1">

<math> \textbf{H} =  \begin{bmatrix}
  D_{xx} &amp; D_{xy} \\
  D_{xy} &amp; D_{yy}
\end{bmatrix} </math>
</indent>

The eigenvalues of <b>H</b> are proportional to the principal curvatures of D. It turns out that the ratio of the two eigenvalues, say <math>\alpha</math> is the larger one, and <math>\beta</math> the smaller one, with ratio <math> r = \frac{\alpha}{\beta} </math>, is sufficient for SIFT's purposes. The trace of <b>H</b>, i.e. <math>D_{xx} + D_{yy}</math>, gives us the sum of the two eigenvalues, while its determinant, i.e <math>D_{xx} D_{yy} - D_{xy}^2</math>, yields the product. The ratio <math> \text{R} = \frac{\text{Tr} \left( \textbf{H} \right)^2}{\text{Det}  \left( \textbf{H} \right) }</math> can be shown to be equal to <math>\frac{ \left( r+1 \right)^2}{r}</math>, which depends only on the ratio of the eigenvalues rather than their individual values. R is minimum when the eigenvalues are equal to each other. Therefore the higher the absolute difference between the two eigenvalues, which is equivalent to a higher absolute difference between the two principal curvatures of D, the higher the value of R. It follows that, for some threshold eigenvalue ratio <math>r_{\text{th}}</math>, if R for a candidate keypoint is larger than <math>\frac{ \left( r_{\text{th}} + 1 \right)^2}{r_{\text{th}}}</math>, that keypoint is poorly localized and hence rejected. The new approach uses <math>r_{\text{th}} = 10</math>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>
<p>

This processing step for suppressing responses at edges is a transfer of a corresponding approach in the Harris operator for <link xlink:type="simple" xlink:href="../759/4921759.xml">
corner detection</link>. The difference is that the measure for thresholding is computed from the Hessian matrix instead of a second-moment matrix (see <link xlink:type="simple" xlink:href="../466/7096466.xml">
structure tensor</link>).</p>

</ss2>
</ss1>
<ss1>
<st>
 Orientation assignment </st>

<p>

In this step, each keypoint is assigned one or more orientations based on local image gradient directions. This is the key step in achieving <link xlink:type="simple" xlink:href="../202/424202.xml">
invariance to rotation</link> as the keypoint descriptor can be represented relative to this orientation and therefore achieve invariance to image rotation.</p>
<p>

First, the Gaussian-smoothed image <math>L \left( x, y, \sigma \right)</math> at the keypoint's scale <math>\sigma</math> is taken so that all computations are performed in a scale-invariant manner. For an image sample <math>L \left( x, y \right)</math> at scale <math>\sigma</math>, the gradient magnitude, <math>m \left( x, y \right)</math>, and orientation, <math>\theta \left( x, y \right)</math>, are precomputed using pixel
differences:</p>
<p>

<indent level="1">

<math>m \left( x, y \right) = \sqrt{\left( L \left( x+1, y \right) - L \left( x-1, y \right) \right)^2 + \left( L \left( x, y+1 \right) - L \left( x, y-1 \right) \right)^2}</math>
</indent>

<indent level="1">

<math>\theta \left( x, y \right) = \tan^{-1}\left(\frac{L \left( x, y+1 \right) - L \left( x, y-1 \right)}{L \left( x+1, y \right) - L \left( x-1, y \right)} \right)</math>
</indent>

The magnitude and direction calculations for the gradient are done for every pixel in a neighboring region around the keypoint in the Gaussian-blurred image L. An orientation histogram with 36 bins is formed, with each bin covering 10 degrees. Each sample in the neighboring window added to a histogram bin is weighted by its gradient magnitude and by a Gaussian-weighted circular window with a <math>\sigma</math> that is 1.5 times that of the scale of the keypoint. The peaks in this histogram correspond to dominant orientations. Once the histogram is filled, the orientations corresponding to the highest peak and local peaks that are within 80% of the highest peaks are assigned to the keypoint. In the case of multiple orientations being assigned, an additional keypoint is created having the same location and scale as the original keypoint for each additional orientation.</p>

</ss1>
<ss1>
<st>
 Keypoint descriptor </st>

<p>

Previous steps found keypoint locations at particular scales and assigned orientations to them. This ensured invariance to image location, scale and rotation. Now we want to compute descriptor vectors for these keypoints such that the descriptors are highly distinctive and partially invariant to the remaining variations, like illumination, 3D viewpoint, etc. This step is pretty similar to the Orientation Assignment step. The feature descriptor is computed as a set of orientation histograms on (4 x 4) pixel neighborhoods. The orientation histograms are relative to the keypoint orientation and the orientation data comes from the Gaussian image closest in scale to the keypoint's scale. Just like before, the contribution of each pixel is weighted by the gradient magnitude, and by a Gaussian with <math>\sigma</math> 1.5 times the scale of the keypoint. Histograms contain 8 bins each, and each descriptor contains a 4x4 array of 16 histograms around the keypoint. This leads to a SIFT feature vector with (4 x 4 x 8 = 128 elements). This vector is normalized to enhance invariance to changes in illumination. </p>
<p>

Although the dimension of the descriptor, i.e. 128, seems high, descriptors with lower dimension than this don't perform as well across the range of matching tasks,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> and the computational cost remains low due to the approximate BBF (see below) method used for finding the nearest-neighbor. Longer descriptors continue to do better but not by much and there is an additional danger of increased sensitivity to distortion and occlusion. It is also shown that feature matching accuracy is above 50% for viewpoint changes of up to 50 degrees. Therefore SIFT descriptors are invariant to minor affine changes. To test the distinctiveness of the SIFT descriptors, matching accuracy is also measured against varying number of keypoints in the testing database, and it is shown that matching accuracy decreases only very slightly for very large database sizes, thus indicating that SIFT features are highly distinctive.</p>

</ss1>
</sec>
<sec>
<st>
Comparison of SIFT features with other local features</st>

<p>

There has been an extensive study done on the performance evaluation of different local descriptors, including SIFT, using a range of detectors.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> The main results are summarized below:</p>
<p>

<list>
<entry level="1" type="bullet">

 SIFT and SIFT-like <link xlink:type="simple" xlink:href="../751/12341751.xml">
GLOH</link> features exhibit the highest matching accuracies (recall rates) for an affine transformation of 50 degrees. After this transformation limit, results start getting unreliable.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Distinctiveness of descriptors is measured by summing the eigenvalues of the descriptors, obtained by the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../340/76340.xml">
Principal components analysis</link></part>
</component>
</concept>
</idea>
 of the descriptors normalized by their variance. This corresponds to the amount of variance captured by different descriptors, therefore, to their distinctiveness. PCA-SIFT (Principal Components Analysis applied to SIFT descriptors), GLOH and SIFT features give the highest values.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 SIFT-based descriptors outperform other local descriptors on both textured and structured scenes, with the difference in performance larger on the textured scene. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 For scale changes in the range 2-2.5 and image rotations in the range 30 to 45 degrees, SIFT and SIFT-based descriptors again outperform other local descriptors with both textured and structured scene content. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Performance for all local descriptors degraded on images introduced with a significant amount of blur, with the descriptors that are based on edges, like <link xlink:type="simple" xlink:href="../107/15281107.xml">
shape context</link>, performing increasingly poorly with increasing amount blur. This is because edges disappear in the case of a strong blur. But GLOH, PCA-SIFT and SIFT still performed better than the others. This is also true for evaluation in the case of illumination changes.</entry>
</list>
</p>
<p>

The evaluations carried out suggests strongly that SIFT-based descriptors, which are region-based, are the most robust and distinctive, and are therefore best suited for feature matching. However, most recent feature descriptors such as <link xlink:type="simple" xlink:href="../697/12341697.xml">
SURF</link> have not been evaluated in this study.</p>
<p>

<link xlink:type="simple" xlink:href="../697/12341697.xml">
SURF</link> has later been shown to have similar performance to <link xlink:type="simple" xlink:href="../350/1208350.xml">
SIFT</link>, while at the same time being much faster.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>

</sec>
<sec>
<st>
Applications</st>

<ss1>
<st>
Object recognition using SIFT features</st>

<p>

Given SIFT's ability to find distinctive keypoints that are invariant to location, scale and rotation, and robust to <link xlink:type="simple" xlink:href="../449/38449.xml">
affine transformations</link> (changes in <link xlink:type="simple" xlink:href="../271/29271.xml">
scale</link>, <link xlink:type="simple" xlink:href="../789/39789.xml">
rotation</link>, <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../405/799405.xml">
shear</link></function>
</mathematical_relation>
, and position) and changes in illumination, they are usable for object recognition. The steps are given below.</p>
<p>

<list>
<entry level="1" type="bullet">

 First, SIFT features are obtained from the input image using the algorithm described above.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 These features are matched to the SIFT feature database obtained from the training images. This feature matching is done through a Euclidean-distance based nearest neighbor approach. To increase robustness, matches are rejected for those keypoints for which the ratio of the nearest neighbor distance to the second nearest neighbor distance is greater than 0.8. This discards many of the false matches arising from background clutter. Finally, to avoid the expensive search required for finding the Euclidean distance based nearest neighbor, an approximate algorithm, called the Best-Bin-First (BBF) algorithm is used.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> This is a fast method for returning the nearest neighbor with high probability, and can give speedup by factor of 1000 while finding nearest neighbor (of interest) 95% of the time.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Although the distance ratio test described above discards many of the false matches arising from background clutter, we still have matches that belong to different objects. Therefore to increase robustness to object identification, we want to cluster those features that belong to the same object and reject the matches that are left out in the clustering process. This is done using the <link xlink:type="simple" xlink:href="../897/434897.xml">
Hough Transform</link>. This will identify clusters of features that vote for the same object pose. When clusters of features are found to vote for the same pose of an object, the probability of the interpretation being correct is much higher than for any single feature. Each keypoint votes for the set of object poses that are consistent with the keypoint's location, scale, and orientation. <it>Bins</it> that accumulate at least 3 votes are identified as as candidate object/pose matches.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 For each candidate cluster, a least-squares solution for the best estimated affine projection parameters relating the training image to the input image is obtained. If the projection of a keypoint through these parameters lies within half the error range that was used for the parameters in the Hough transform bins, the keypoint match is kept. If fewer than 3 points remain after discarding outliers for a bin, then the object match is rejected. The least-squares fitting is repeated until no more rejections take place. This works better for planar surface recognition than 3D object recognition since the affine model is no longer accurate for 3D objects.</entry>
</list>
</p>
<p>

SIFT features can essentially be applied to any task that requires identification of matching locations between images. Work has been done on applications such as recognition of particular object categories in 2D images, 3D reconstruction,
motion tracking and segmentation, robot localization, image panorama stitching and epipolar calibration. Some of these are discussed in more detail below.</p>

</ss1>
<ss1>
<st>
Robot localization and mapping</st>

<p>

In this application,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> a trinocular stereo system is used to determine 3D estimates for keypoint locations. Keypoints are used only when they appear in all 3 images with consistent disparities, resulting in very few outliers. As the robot moves, it localizes itself using feature matches to the existing 3D map, and then incrementally adds features to the map while updating their 3D positions using a Kalman filter. This provides a robust and accurate solution to the problem of robot localization in unknown environments.</p>

</ss1>
<ss1>
<st>
Panorama stitching</st>

<p>

SIFT feature matching can be used in <link xlink:type="simple" xlink:href="../768/2889768.xml">
image stitching</link> for fully automated <link xlink:type="simple" xlink:href="../599/175599.xml">
panorama</link> reconstruction from non-panoramic images. The SIFT features extracted from the input images are matched against each other to find <it>k</it> nearest-neighbors for each feature. These correspondences are then used to find <it>m</it> candidate matching images for each image. <link xlink:type="simple" xlink:href="../962/3051962.xml">
Homographies</link> between pairs of images are then computed using <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../270/1089270.xml">
RANSAC</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and a probabilistic model is used for verification. Because there is no restriction on the input images, graph search is applied to find connected components of image matches such that each connected component will correspond to a panorama. Finally for each connected component <link xlink:type="simple" xlink:href="../920/13754920.xml">
Bundle adjustment</link> is performed to solve for joint camera parameters, and the panorama is rendered using <link>
multi-band blending</link>. Because of the SIFT-inspired object recognition approach to panorama stitching, the resulting system is insensitive to the ordering, orientation, scale and illumination of the images. The input images contain multiple panoramas and noise images, and panoramic sequences are recognized and rendered as output. As said earlier, the algorithm is insensitive to the ordering, scale and orientation of the images. It is also insensitive to noise images which are not part of a panorama.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></p>

</ss1>
<ss1>
<st>
3D scene modeling, recognition and tracking</st>

<p>

This application uses SIFT features for <link xlink:type="simple" xlink:href="../421/14669421.xml">
3D object recognition</link> and <process wordnetid="100029677" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<phenomenon wordnetid="100034213" confidence="0.8">
<consequence wordnetid="111410625" confidence="0.8">
<link xlink:type="simple" xlink:href="../382/764382.xml">
3D modeling</link></consequence>
</phenomenon>
</physical_entity>
</process>
 in context of <link xlink:type="simple" xlink:href="../631/85631.xml">
augmented reality</link>, in which synthetic objects with accurate pose are superimposed on real images. SIFT matching is done for a number of 2D images of a scene or object taken from different angles. This is used with <link xlink:type="simple" xlink:href="../920/13754920.xml">
bundle adjustment</link> to build a sparse 3D model of the viewed scene and to simultaneously recover camera poses and calibration parameters. Then the position, orientation and size of the virtual object are defined relative to the coordinate frame of the recovered model. For online <link xlink:type="simple" xlink:href="../353/1478353.xml">
match moving</link>, SIFT features again are extracted from the current video frame and matched to the features already computed for the world mode, resulting in a set of 2D-to-3D correspondences. These correspondences are then used to compute the current camera pose for the virtual projection and final rendering. A regularization technique is used to reduce the jitter in the virtual projection.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></p>

</ss1>
<ss1>
<st>
3D SIFT descriptors for human action recognition</st>

<p>

This application introduces 3D SIFT descriptors for spatio-temporal data in context of human action recognition in video sequences.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> The Orientation Assignment and Descriptor Representation stages of the 2D SIFT algorithm are extended to describe SIFT features in a spatio-temporal domain. For application to human action recognition in a video sequence, random sampling of the training videos is carried out at different locations, times and scales. The spatio-temporal regions around these interest points are then described using the 3D SIFT descriptor. These descriptors are then clustered to form a spatio-temporal <link xlink:type="simple" xlink:href="../441/14003441.xml">
Bag of words model</link>. 3D SIFT descriptors extracted from the test videos are then matched against these <it>words</it> for human action classification.</p>
<p>

The authors report much better results with their 3D SIFT descriptor approach than with other approaches like simple 2D SIFT descriptors and Gradient Magnitude.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></p>

</ss1>
</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../421/14669421.xml">
3D single object recognition</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../835/13580835.xml">
autostitch</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../224/1284224.xml">
Feature detection (computer vision)</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../697/12341697.xml">
SURF</link> (Speeded Up Robust Features)</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Lowe, David G.&#32;(1999). "<weblink xlink:type="simple" xlink:href="http://doi.ieeecs.org/10.1109/ICCV.1999.790410">
Object recognition from local scale-invariant features</weblink>".&#32;<it>Proceedings of the International Conference on Computer Vision</it>&#32;<b>2</b>: 1150–1157. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109/ICCV.1999.790410">
10.1109/ICCV.1999.790410</weblink>.</cite>&nbsp;</entry>
<entry id="2">
Nowozin, Sebastian&#32;(2005).&#32;"<weblink xlink:type="simple" xlink:href="http://user.cs.tu-berlin.de/~nowozin/autopano-sift/">
autopano-sift</weblink>".&#32;Retrieved on <link>
2008-08-20</link>.</entry>
<entry id="3">
 <cite style="font-style:normal">Lindeberg, Tony&#32;(1998).&#32;"<weblink xlink:type="simple" xlink:href="http://www.nada.kth.se/cvap/abstracts/cvap198.html">
Feature detection with automatic scale selection</weblink>". <it>International Journal of Computer Vision</it>&#32;<b>30</b>&#32;(2): 79–116. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1023%2FA%3A1008045108935">
10.1023/A:1008045108935</weblink>.</cite>&nbsp;</entry>
<entry id="4">
 <cite style="font-style:normal">Lowe, David G.&#32;(2004).&#32;"<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/lowe04distinctive.html">
Distinctive Image Features from Scale-Invariant Keypoints</weblink>". <it>International Journal of Computer Vision</it>&#32;<b>60</b>&#32;(2): 91–110. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1023%2FB%3AVISI.0000029664.99615.94">
10.1023/B:VISI.0000029664.99615.94</weblink>.</cite>&nbsp;</entry>
<entry id="5">
 <cite style="font-style:normal">Mikolajczyk, K.; Schmid, C.&#32;(2005).&#32;"<weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/manik/projects/trade-off/papers/MikolajczykPAMI05.pdf">
A performance evaluation of local descriptors</weblink>". <it>IEEE Transactions on Pattern Analysis and Machine Intelligence</it>&#32;<b>27</b>: 1615–1630. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109%2FTPAMI.2005.188">
10.1109/TPAMI.2005.188</weblink>.</cite>&nbsp;</entry>
<entry id="6">
http://www.tu-chemnitz.de/etit/proaut/rsrc/iav07-surf.pdf</entry>
<entry id="7">
 <cite style="font-style:normal">Beis, J.;&#32;Lowe, David G.&#32;(1997). "<weblink xlink:type="simple" xlink:href="http://www.cs.ubc.ca/~lowe/papers/cvpr97.pdf">
Shape indexing using approximate nearest-neighbour search in high-dimensional spaces</weblink>".&#32;<it>Conference on Computer Vision and Pattern Recognition, Puerto Rico: sn</it>: 1000–1006. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109/CVPR.1997.609451">
10.1109/CVPR.1997.609451</weblink>.</cite>&nbsp;</entry>
<entry id="8">
 <cite style="font-style:normal">Se, S.; Lowe, David G.; Little, J.&#32;(2001). "<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/425735.html">
Vision-based mobile robot localization and mapping using scale-invariant features</weblink>".&#32;<it>Proceedings of the IEEE International Conference on Robotics and Automation (ICRA)</it>&#32;<b>2</b>: 2051. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109/ROBOT.2001.932909">
10.1109/ROBOT.2001.932909</weblink>.</cite>&nbsp;</entry>
<entry id="9">
 <cite style="font-style:normal">Brown, M.; Lowe, David G.&#32;(2003). "<weblink xlink:type="simple" xlink:href="http://graphics.cs.cmu.edu/courses/15-463/2005_fall/www/Papers/BrownLowe.pdf">
Recognising Panoramas</weblink>".&#32;<it>Proceedings of the ninth IEEE International Conference on Computer Vision</it>&#32;<b>2</b>: 1218–1225. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109/ICCV.2003.1238630">
10.1109/ICCV.2003.1238630</weblink>.</cite>&nbsp;</entry>
<entry id="10">
Iryna Gordon and David G. Lowe, "<weblink xlink:type="simple" xlink:href="http://www.cs.ubc.ca/labs/lci/papers/docs2006/lowe_gordon.pdf">
What and where: 3D object recognition with accurate pose</weblink>," in Toward Category-Level Object Recognition, (Springer-Verlag, 2006), pp. 67-82</entry>
<entry id="11">
 <cite style="font-style:normal">Scovanner, Paul;&#32;Ali, S; Shah, M&#32;(2007). "A 3-dimensional sift descriptor and its application to action recognition".&#32;<it>Proceedings of the 15th International Conference on Multimedia</it>: 357-360. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145/1291233.1291311">
10.1145/1291233.1291311</weblink>.</cite>&nbsp;</entry>
<entry id="12">
 <cite style="font-style:normal">Niebles, J. C. Wang, H. and Li, Fei-Fei&#32;(2006). "<weblink xlink:type="simple" xlink:href="http://vision.cs.princeton.edu/niebles/humanactions.htm">
Unsupervised Learning of Human Action Categories Using Spatial-Temporal Words</weblink>".&#32;<it>Proceedings of the British Machine Vision Conference (BMVC)</it>. Retrieved on <link>
2008-08-20</link>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Implementations </st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://user.cs.tu-berlin.de/~nowozin/libsift/">
Sebastian Nowozin (C#)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://vision.ucla.edu/~vedaldi/code/sift/sift.html">
Andrea Vedaldi (Matlab/C)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://vision.ucla.edu/~vedaldi/code/siftpp/siftpp.html">
Andrea Vedaldi (C++)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.ubc.ca/~lowe/keypoints/">
David Lowe (C/Matlab)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://web.engr.oregonstate.edu/~hess/index.html">
Rob Hess (C)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="ftp://ftp.cs.utoronto.ca/pub/jepson/teaching/vision/2503/SIFTtutorial.zip">
Thomas El-Maraghi (Matlab)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.robots.ox.ac.uk/~vgg/research/affine/">
Dr Krystian Mikolajczyk (C)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://fly.mpi-cbg.de/~saalfeld/javasift.html">
Stephan Saalfeld (Java)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=18441&amp;objectType=File">
Adam Chapman / ChangChang Wu (Matlab-GPU implementation)</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
