<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 01:10:01[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Espresso heuristic logic minimizer</title>
<id>12152395</id>
<revision>
<id>238767434</id>
<timestamp>2008-09-16T08:22:22Z</timestamp>
<contributor>
<username>Berton</username>
<id>549980</id>
</contributor>
</revision>
<categories>
<category>Digital electronics</category>
<category>Electronics optimization</category>
<category>Articles lacking reliable references from October 2007</category>
<category>Electronic design automation</category>
<category>Articles with invalid date parameter in template</category>
<category>Electronic design automation software</category>
<category>Electronic engineering</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Question_book-new.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This article or section relies largely or entirely upon a .</b>
Please help <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Espresso_heuristic_logic_minimizer&amp;action=edit">
improve this article</weblink> by introducing appropriate of additional sources. <it>(October 2007)''</it></col>
</row>
</table>


The <b>Espresso logic minimizer</b> is a widely used<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> computer program using heuristic and specific algorithms for efficiently reducing the complexity of digital electronic gate circuits. Espresso was developed at IBM by Richard L. Rudell.  Rudell later published the variant Espresso-MV in 1986 under the title "Multiple-Valued Logic Minimization for PLA Synthesis".<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>.  Espresso has inspired many derivatives.
<sec>
<st>
 Introduction </st>
<p>

Digital electronic equipment has deeply penetrated everyone's life. Electronic devices are embedded in all kinds of appliances from coffee makers to automobiles. All such devices are composed of numerous blocks of digital circuits, the combination of which performs the required task. As a result, the efficient implementation of logic functions in the form of logical gate circuits has become an economical key factor in the success of many contemporary industrial products.</p>

<ss1>
<st>
 Designing digital logic circuits </st>

<p>

All digital systems are composed of two elementary functions: memory elements for storing information and combinational logic gate circuits for translating that information. State machines, like counters, are nothing but a combination of memory elements and combinational gate circuits. Since memory elements are standard components to be selected out of a limited set, in essence designing digital functions comes to implementing the combinational gate circuits for the basic building blocks as well as interconnecting all these building blocks.</p>
<p>

In general the implementation of gate circuits is referred to as <link xlink:type="simple" xlink:href="../894/1082894.xml">
Logic Synthesis</link>, which basically can be carried out by hand, but usually some formal method by computer is applied. In this article the design methods for combinational gate circuits are briefly summarized.</p>
<p>

The starting point for the design of a logic gate circuit is its desired functionality, having derived from the analysis of the system as a whole, the gate circuit is to make part of. The description can be stated in some algorithmic form or by logic equations, but may be summarized in the form of a table as well. The below example shows a part of such a table for a 7-segment driver that translates the binary code for the values of a decimal digit into the signals that cause the respective segments of the display to light up.</p>
<p>


  Digit  Code      Segments  A-G
    0    0000      1 1 1 1 1 1 0          -A-
    1    0001      0 1 1 0 0 0 0         F   B
    2    0010      1 1 0 1 1 0 1         |-G-|
    3    0011      1 1 1 1 0 0 1         E   C
    .    ....      . . . . . . .          -D-
</p>
<p>

The implementation process starts with a <b>logic minimization</b> phase, to be described below, in order to simplify the function table by combining the separate terms into larger ones containing fewer variables.</p>
<p>

Next the minimized result may be split up in smaller parts by a factorization procedure and is eventually mapped onto the available basic logic cells of the target technology. This operation is commonly referred to as <link xlink:type="simple" xlink:href="../346/7457346.xml">
Logic Optimization</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</ss1>
<ss1>
<st>
 Classical minimization methods </st>

<p>

Minimizing Boolean functions by hand using the classical <link xlink:type="simple" xlink:href="../684/10854684.xml">
Karnaugh maps</link> is a laborious, tedious and error prone process. It isn't suited for more than 6 input variables and practical only for up to 4 variables, while product term sharing for multiple output functions is even harder to carry out.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> Moreover, this method doesn't lend itself to be automated in the form of a computer program. However, since modern logic functions are generally not constrained to such a small number of variables, while the cost as well as the risk of making errors is prohibitive for manual implementation of logic functions, the use of computers became indispensable.</p>
<p>

The first alternative method to become popular was the tabular method developed by Quine and McCluskey. Starting with the truth table for a set of logic functions, by combining the minterms for which the functions are active - the ON-cover - or for which the function value is irrelevant - the DC-cover - a set of prime implicants is composed. Finally a systematic procedure is followed to find the smallest set of prime implicants the output functions can be realised with.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>
<p>

Although this <link xlink:type="simple" xlink:href="../263/317263.xml">
Quine-McCluskey algorithm</link> is very well suited to be implemented in a computer program, the result is still far from efficient in terms of processing time and memory usage. Adding a variable to the function will roughly double both of them, because the truth table length increases exponentially with the number of variables. A similar problem occurs when increasing the number of output functions of a combinational function block. As a result the Quine-McCluskey method is practical only for functions with a limited number of input variables and output functions.</p>

</ss1>
</sec>
<sec>
<st>
 Espresso algorithm </st>

<p>

A radically different approach to this issue is followed in the ESPRESSO algorithm, developed by Brayton e.a. at the University of California, Berkeley.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> Rather than expanding a logic function into minterms, the program manipulates "cubes", representing the product terms in the ON-, DC- and OFF-covers iteratively. Although the minimization result is not guaranteed to be the global minimum, in practice this is very closely approximated, while the solution is always free from <link xlink:type="simple" xlink:href="../009/12220009.xml">
redundancy</link>. Compared to the other methods, this one is essentially more efficient, reducing memory usage and computation time by several orders of magnitude. Its name reflects the way of instantly making a cup of fresh coffee. There is hardly any restriction to the number of variables, output functions and product terms of a combinational function block. In general, e.g. tens of variables with tens of output functions are readily dealt with.</p>
<p>

The input for ESPRESSO is a function table of the desired functionality; the result is a minimized table, describing either the ON-cover or the OFF-cover of the function, depending on the selected options. By default the product terms will be shared as much as possible by the several output functions, but the program can be instructed to handle each of the output functions separately. This allows for efficient implementation in two-level logic arrays such as a <link xlink:type="simple" xlink:href="../688/578688.xml">
PLA</link> (Programmable Logic Array) or a <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../693/578693.xml">
PAL</link></array>
</group>
</arrangement>
 (Programmable Array Logic).</p>
<p>

The ESPRESSO algorithm proved so successful that it has been incorporated as a standard logic function minimization step into virtually any contemporary logic synthesis tool. For implementing a function in multi-level logic, the minimization result is optimized by factorization and mapped onto the available basic logic cells in the target technology, whether this concerns an <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../969/10969.xml">
FPGA (Field Programmable Gate Array)</link></array>
</group>
</arrangement>
 or an <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../845/147845.xml">
ASIC (Application Specific Integrated Circuit)</link></array>
</group>
</arrangement>
.</p>

<ss1>
<st>
 Software </st>

<ss2>
<st>
 Minilog </st>
<p>

<b> Minilog </b> is a logic minimization program exploiting this ESPRESSO algorithm. It is able to generate a two-level gate implementation for a combinational function block with up to 40 inputs and outputs or a synchronous state machine with up to 256 states. It is part of the <b> Publicad </b> educational design package, that can be downloaded from the website
http://pico1.e.ft.fontys.nl/publicad.html - free Publicad toolkit including Minilog logic minimization program (© W.M.J. de Valk)</p>

</ss2>
<ss2>
<st>
 Logic Friday </st>
<p>

<b> Logic Friday </b> is a free Windows program that provides a graphical interface to ESPRESSO, as well as to misII, another module in the Berkeley Octtools package. With Logic Friday users can enter a logic function as a truth table, equation, or gate diagram, minimize the function, and then view the results in both of the other two representations. Logic Friday is available at http://www.sontrak.com.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
J.P. hayes, <it>Digital Logic Design</it>, Addison Wesley, 1993</entry>
<entry id="2">
http://www.eecs.berkeley.edu/Pubs/TechRpts/1986/ERL-86-65.pdf</entry>
<entry id="3">
G. De Micheli, <it>Synthesis and Optimization of Digital Circuits</it>, McGraw-Hill Science Engineering, 1994</entry>
<entry id="4">
D. Lewin, <it>Design of Logic Systems</it>,Van Nostrand (UK),1985</entry>
<entry id="5">
R.H. Katz, <it>Contemporary Logic Design</it>, The Benjamin/Cummings Publishing Company, 1994</entry>
<entry id="6">
P.K. Lala, <it>Practical Digital Logic Design and Testing</it>, Prentice Hall, 1996</entry>
<entry id="7">
R.K. Brayton, A. Sangiovanni-Vincentelli, C. McMullen, G. Hachtel, <it><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=577427">
Logic Minimization Algorithms for VLSI Synthesis</weblink></it>, Kluwer Academic Publishers, 1984</entry>
</reflist>
</p>


</sec>
</bdy>
</article>
