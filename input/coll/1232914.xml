<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:19:40[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Iterative Viterbi decoding</title>
<id>1232914</id>
<revision>
<id>238880171</id>
<timestamp>2008-09-16T20:35:51Z</timestamp>
<contributor>
<username>Shields415</username>
<id>2927420</id>
</contributor>
</revision>
<categories>
<category>Error detection and correction</category>
</categories>
</header>
<bdy>

<b>Iterative Viterbi decoding</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that spots the subsequence <it>S</it> of an observation <it>O</it> = {<it>o</it>1, ..., <it>on</it>} having the highest average probability (i.e., probability scaled by the length of <it>S</it>) of being generated by a given <link xlink:type="simple" xlink:href="../770/98770.xml">
hidden Markov model</link> <it>M</it> with <it>m</it> states.  The algorithm uses a modified <link xlink:type="simple" xlink:href="../015/228015.xml">
Viterbi algorithm</link> as an internal step.<p>

The scaled probability measure was first proposed by <link>
John S. Bridle</link>. An early algorithm to solve this problem, <link xlink:type="simple" xlink:href="../727/12824727.xml">
sliding window</link>, was proposed by <link>
Jay G. Wilpon</link> et al., 1989, with constant cost <it>T</it> = <it>mn</it>2/2.</p>
<p>

A faster algorithm consists of an iteration of calls to the <link xlink:type="simple" xlink:href="../015/228015.xml">
Viterbi algorithm</link>, reestimating a filler score until convergence.</p>

<sec>
<st>
 The algorithm </st>

<p>

A basic (non-optimized) version, finding the sequence <it>s</it> with the smallest normalized distance from some subsequence of <it>t</it> is:</p>
<p>


// input is placed in observation s[1..n], template t[1..m],
// and [[distance matrix]] d[1..n,1..m]
// remaining elements in matrices are solely for internal computations
(int, int, int) AverageSubmatchDistance(char s[0..(n+1)], char t[0..(m+1)], int d[1..n,0..(m+1)]) {
    // score, subsequence start, subsequence end
    declare int e, B, E
    t'[0] := t'[m+1] := s'[0] := s'[n+1] := 'e'

    e := random()
    do
        e' := e
	for i := 1 to n	do	d'[i,0] := d'[i,m+1] := e
	(e, B, E)  := ViterbiDistance(s', t', d')
        e := e/(E-B+1)
    until (e == e')

    return (e, B, E)
}
</p>
<p>

The ViterbiDistance() procedure returns the tuple (<it>e</it>, <it>B</it>, <it>E</it>), i.e., the Viterbi score "<it>e</it>" for the match of <it>t</it> and the selected entry (<it>B</it>) and exit (<it>E</it>) points from it. "<it>B</it>" and "<it>E</it>" have to be recorded using a simple modification to Viterbi.</p>
<p>

A modification that can be applied to CYK tables, proposed by Antoine Rozenknop, consists in subtracting <it>e</it> from all elements of the initial matrix <it>d</it>.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 Silaghi, M., "Spotting Subsequences matching a HMM using the Average Observation Probability Criteria with application to Keyword Spotting", AAAI, 2005.</entry>
<entry level="1" type="bullet">

 Rozenknop, Antoine, and Silaghi, Marius; "Algorithme de décodage de treillis selon le critère de coût moyen pour la reconnaissance de la parole", TALN 2001.</entry>
</list>
</p>

</sec>
</bdy>
</article>
