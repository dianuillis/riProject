<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:19:39[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Pipeline (Unix)</title>
<id>1236117</id>
<revision>
<id>243730616</id>
<timestamp>2008-10-07T20:27:31Z</timestamp>
<contributor>
<username>Ghettoblaster</username>
<id>6603820</id>
</contributor>
</revision>
<categories>
<category>Unix</category>
<category>Inter-process communication</category>
</categories>
</header>
<bdy>

<image width="280px" src="Pipeline.svg" type="thumb">
<caption>

A pipeline of three programs run on a text terminal
</caption>
</image>

In <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../815/31815.xml">
Unix-like</link></family>
 computer <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s, a <b>pipeline</b> is the original <it><link xlink:type="simple" xlink:href="../238/1241238.xml">
software pipeline</link></it>: a set of <link xlink:type="simple" xlink:href="../178/45178.xml">
process</link>es chained by their <link xlink:type="simple" xlink:href="../067/220067.xml">
standard streams</link>, so that the output of each process (<it><link>
stdout</link></it>) feeds directly as input (<it><link>
stdin</link></it>) of the next one. Each connection is implemented by an <link xlink:type="simple" xlink:href="../014/3503014.xml">
anonymous pipe</link>. <link xlink:type="simple" xlink:href="../479/100479.xml">
Filter program</link>s are often used in this configuration. The concept was invented by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../744/189744.xml">
Douglas McIlroy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 for <link xlink:type="simple" xlink:href="../035/32035.xml">
Unix shell</link>s and it was named by analogy to a physical <link xlink:type="simple" xlink:href="../111/51111.xml">
pipeline</link>.
<sec>
<st>
Examples</st>


<ss1>
<st>
Simple example</st>


<p>

ls -l | less</p>

<p>

In this example, <link xlink:type="simple" xlink:href="../682/158682.xml">
ls</link> is the Unix directory lister, and <link xlink:type="simple" xlink:href="../143/926143.xml">
less</link> is an interactive text <link xlink:type="simple" xlink:href="../162/16207162.xml">
pager</link> with searching capabilities.
The pipeline lets the user scroll up and down a directory listing that may not fit on the screen.</p>
<p>

Pipelines ending in less (or <link xlink:type="simple" xlink:href="../817/2436817.xml">
more</link>, a similar text pager) are among the most commonly used.
They let the user navigate potentially large (or infinite) amounts of text, which otherwise would have scrolled past the top of the terminal and been lost.
Put differently, they relieve programmers from the burden of implementing text pagers in their applications: they can pipe output through less, or assume that the user will do so when needed.</p>

</ss1>
<ss1>
<st>
Complex example</st>

<p>

Below is an example of a pipeline that implements a kind of <link xlink:type="simple" xlink:href="../869/605869.xml">
spell checker</link> for the <invention wordnetid="105633385" confidence="0.8">
<link xlink:type="simple" xlink:href="../139/33139.xml">
web</link></invention>
 resource indicated by a <link xlink:type="simple" xlink:href="../277/32277.xml">
URL</link>. An explanation of what it does follows. (Some machines have /usr/share/dict/words instead.)</p>

<p>

curl "http://en.wikipedia.org/wiki/Pipeline_(Unix)" | \
sed 's/[^a-zA-Z ]/ /g' | \
tr 'A-Z ' 'a-z\n' | \
grep '[a-z]' | \
sort -u | \
comm -23 - /usr/dict/words</p>

<p>

<list>
<entry level="1" type="bullet">

Note: The character "\" is used to place all six lines into a single command line.</entry>
<entry level="1" type="bullet">

First, <b><link xlink:type="simple" xlink:href="../497/519497.xml">
curl</link></b> obtains the <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../191/13191.xml">
HTML</link></format>
 contents of a web page (could use wget on some systems).</entry>
<entry level="1" type="bullet">

Second, <b><link xlink:type="simple" xlink:href="../163/27163.xml">
sed</link></b> removes all characters that are not spaces or letters from the web page's content, replacing them with spaces.</entry>
<entry level="1" type="bullet">

Third, <b><link xlink:type="simple" xlink:href="../674/700674.xml">
tr</link></b> changes all of the uppercase letters into lowercase and converts the spaces in the lines of text to newlines (each 'word' is now on a separate line).</entry>
<entry level="1" type="bullet">

Fourth, <b><link xlink:type="simple" xlink:href="../642/46642.xml">
grep</link></b> includes only lines that contain at least one lowercase <link xlink:type="simple" xlink:href="../489/7489.xml">
alphabetical</link> character (removing any blank lines).</entry>
<entry level="1" type="bullet">

Fifth, <b><link xlink:type="simple" xlink:href="../234/4098234.xml">
sort</link></b> sorts the list of 'words' into alphabetical order, and the -u switch removes duplicates.</entry>
<entry level="1" type="bullet">

Finally, <b><link xlink:type="simple" xlink:href="../672/220672.xml">
comm</link></b> finds lines in common between two files, -23 suppresses lines unique to the second file, and those that are common to both, leaving only those that are found only in the first file named.  The - in place of a filename causes comm to use its standard input (from the pipe line in this case). This results in a list of "words" (lines) that are not found in /usr/dict/words.</entry>
<entry level="1" type="bullet">

The special character "|" tells the operating system to pipe the output from the previous command in the line into the next command in the line.  That is, the output of the curl command is given as the input of the sed command.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 Pipelines in <link xlink:type="simple" xlink:href="../707/6707.xml">
command line interface</link>s </st>
<p>

Most <link xlink:type="simple" xlink:href="../035/32035.xml">
Unix shell</link>s have a special syntax construct for the creation of pipelines. Typically, one simply writes the filter commands in sequence, separated by the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<representation wordnetid="105926676" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../586/586.xml">
ASCII</link></rule>
</direction>
</representation>
</protocol>
</message>
 <link xlink:type="simple" xlink:href="../073/641073.xml">
vertical bar</link> character "|" (which, for this reason, is often called "pipe character" by Unix users). The shell starts the processes and arranges for the necessary connections between their standard streams (including some amount of <link xlink:type="simple" xlink:href="../183/2406183.xml">
buffer</link> storage). </p>

<ss1>
<st>
Error stream</st>
<p>

By default, the <link>
standard error stream</link>s ("<link>
stderr</link>") of the processes in a pipeline are not passed on through the pipe; instead, they are merged and directed to the  <link xlink:type="simple" xlink:href="../571/361571.xml">
console</link>. However, many shells have additional syntax for changing this behaviour.  In the <shell wordnetid="104190464" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<ammunition wordnetid="102703275" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<weaponry wordnetid="104566257" confidence="0.8">
<link xlink:type="simple" xlink:href="../833/95833.xml">
csh</link></weaponry>
</language>
</ammunition>
</instrumentality>
</artifact>
</shell>
 shell, for instance, using "|&amp;" instead of "| " signifies that the standard error stream too should be merged with the standard output and fed to the next process. The <link xlink:type="simple" xlink:href="../839/92839.xml">
Bourne Shell</link> can also merge standard error, using 2&amp;gt;&amp;1, as well as redirect it to a different file.</p>

</ss1>
<ss1>
<st>
 Pipemill </st>
<p>

In the most commonly used simple pipelines the shell connects a series of sub-processes via pipes, and executes external commands within each sub-process.  Thus the shell itself is doing no direct processing of the data flowing through the pipeline.</p>
<p>

However, it's possible for the shell to perform processing directly.  This construct generally looks something like:</p>
<p>

command | while read var1 var2 ...; do
<list>
<entry level="1" type="number">

 process each line, using variables as parsed into $var1, $var2, etc</entry>
</list>

done</p>
<p>

... which is referred to as a "pipemill" (since the while is "milling" over the results from the initial command.)</p>

<ss2>
<st>
 Example of Pipemill </st>

<p>

find / /usr /var -mount -user foo -printf "%m %p\n" | while read mode filename; do
chown $NEWOWNER "$filename"
chmod $MODE "$filename"
done</p>
<p>

(This example will traverse file directory trees changing the ownership of all files while preserving all permissions, including those that are often stripped off by many versions of the chown command).</p>
<p>

There are a number of variations of the pipemill construct including:</p>
<p>

ps lax | { read x; while read x owner pid parent x x x x x stat x; do
[ "$owner"="foo" -a "$stat"="Z" ] &amp;&amp; kill "$parent"
done
}</p>
<p>

(This example kills the parent processes for zombies owned/created by the user "foo").</p>
<p>

Here the while loop is enclosed in a command group (the braces); and preceded by a read command, which effectively "throws away" the first line from the ps command.  (Of course, in this particular example it would be harmless to process the header line, as it wouldn't match the "$owner"= test).  Note that the other references to the "x" variable are simply being used as placeholders for "throwing away" irrelevant fields from each line.</p>
<p>

The defining characteristics of a "pipemill" are: some command or series of commands feeds data into a pipe from which a shell while loop reads and processes it.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
Creating pipelines programmatically</st>

<p>

Pipelines can be created under program control.
The pipe() <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link> asks the operating system to construct a new <link xlink:type="simple" xlink:href="../014/3503014.xml">
anonymous pipe</link> object.
This results in two new, opened file descriptors in the process: the read-only end of the pipe, and the write-only end.
The pipe ends appear to be normal, anonymous <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link>s, except that they have no ability to seek.</p>
<p>

To avoid <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link> and exploit parallelism, the process with one or more new pipes will then, generally, call
<link xlink:type="simple" xlink:href="../507/301507.xml">
fork()</link> to create new
processes. Each process will then close the end(s) of
the pipe that it will not be using before producing or consuming any data.
Alternatively, a process might create a new <link xlink:type="simple" xlink:href="../671/634671.xml">
thread</link> and use the pipe to communicate between them.</p>
<p>

<it><link xlink:type="simple" xlink:href="../167/714167.xml">
Named pipe</link>s</it> may also be created using mkfifo() or <link>
mknod</link>() and then presented as the input or output file to programs as they are invoked. They allow multi-path pipes to be created, and are especially effective when combined with standard error redirection, or with <link xlink:type="simple" xlink:href="../503/2484503.xml">
tee</link>.</p>

</sec>
<sec>
<st>
Implementation</st>

<p>

In most Unix-like systems, all processes of a pipeline are started at the same time, with their streams appropriately connected, and managed by the <link xlink:type="simple" xlink:href="../920/231920.xml">
scheduler</link> together with all other processes running on the machine.    An important aspect of this, setting Unix pipes apart from other pipe implementations, is the concept of <link xlink:type="simple" xlink:href="../183/2406183.xml">
buffering</link>: a sending program may produce 5000 <link xlink:type="simple" xlink:href="../365/3365.xml">
bytes</link> per <link xlink:type="simple" xlink:href="../873/26873.xml">
second</link>, and a receiving program may only be able to accept 100 bytes per second, but no data are lost. Instead, the output of the sending program is held in a buffer, or <link xlink:type="simple" xlink:href="../265/25265.xml">
queue</link>. When the receiving program is ready to read data, the operating system sends it data from the buffer, then removes that data from the buffer. If the buffer fills up, the sending program is suspended (blocked) until the receiving program has had a chance to read some data and make room in the buffer.</p>

<ss1>
<st>
 Network pipes </st>
<p>

Tools like <link xlink:type="simple" xlink:href="../529/962529.xml">
netcat</link> and <link>
socat</link> can connect pipes to TCP/IP <link xlink:type="simple" xlink:href="../686/335686.xml">
socket</link>s, following the Unix philosophy of "everything is a file".</p>

</ss1>
</sec>
<sec>
<st>
 History</st>

<p>

The pipeline concept and the vertical-bar notation was invented by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../744/189744.xml">
Douglas McIlroy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, one of the authors of the early <link xlink:type="simple" xlink:href="../035/32035.xml">
command shells</link>, after he noticed that much of the time they were processing the output of one program as the input to another. His ideas were implemented in 1973 when <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../747/10817747.xml">
Ken Thompson</link></scientist>
</person>
 added pipes to the <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> operating system.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> The idea was eventually ported to other operating systems, such as <link xlink:type="simple" xlink:href="../146/8146.xml">
DOS</link>, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../409/22409.xml">
OS/2</link></O>
, <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link>, and <link xlink:type="simple" xlink:href="../801/4801.xml">
BeOS</link>, often with the same notation.  </p>
<p>

Although developed independently, Unix pipes are similar to, and were preceded by the 'communication files' developed by Ken Lochner <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> in the 1960's for the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../213/635213.xml">
Dartmouth Time Sharing System</link></O>
.  <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

<p>

The robot in the icon for <link xlink:type="simple" xlink:href="../856/856.xml">
Apple</link>'s <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../012/1150012.xml">
Automator</link></software>
, which also uses a pipeline concept to chain repetitive commands together, holds a pipe.</p>

<ss1>
<st>
 Other operating systems </st>

<p>

<indent level="1">

<it>Main article: <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../238/1241238.xml">
Pipeline (software)</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</form>
</structure>
</it>
</indent>

This feature of <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 was borrowed by other operating systems, such as <link>
Taos</link> and <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../027/20027.xml">
MS-DOS</link></O>
, and eventually became the <link xlink:type="simple" xlink:href="../238/1241238.xml">
pipes and filters design pattern</link> of <link xlink:type="simple" xlink:href="../010/27010.xml">
software engineering</link>.</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../503/2484503.xml">
Tee (command)</link></language>
 for fitting together two pipes</entry>
<entry level="1" type="bullet">

 <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../238/1241238.xml">
Pipeline (software)</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</form>
</structure>
 for the general software engineering concept.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../187/1236187.xml">
Pipeline (computing)</link> for other computer-related pipelines.</entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../211/692211.xml">
Hartmann pipeline</link></programming_language>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../453/11371453.xml">
Python Pipelines</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../014/3503014.xml">
Anonymous pipe</link>, a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/11347.xml">
FIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 structure used for <link xlink:type="simple" xlink:href="../106/152106.xml">
interprocess communication</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../167/714167.xml">
Named pipe</link> persistent pipes used for interprocess communication</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../829/607829.xml">
Redirection (computing)</link></entry>
<entry level="1" type="bullet">

 <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../151/261151.xml">
XML pipeline</link></system_of_measurement>
</standard>
 for processing of XML files</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.opengroup.org/onlinepubs/009695399/functions/pipe.html">
pipe</weblink>&#58;&nbsp;create an interprocess channel&nbsp;–&nbsp;System Interfaces Reference, <link xlink:type="simple" xlink:href="../540/29540.xml">
The Single UNIX® Specification</link>, Issue 6 from <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../819/57819.xml">
The Open Group</link></system_of_measurement>
</standard>
</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.linfo.org/pipe.html">
Pipes: A Brief Introduction</weblink> by The Linux Information Project (LINFO)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.softpanorama.org/Scripting/pipes.shtml">
http://www.softpanorama.org/Scripting/pipes.shtml</weblink> Unix Pipes -- powerful and elegant programming paradigm (Softpanorama)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://en.wikibooks.org/w/index.php?title=Ad_Hoc_Data_Analysis_From_The_Unix_Command_Line">
<it>Ad Hoc Data Analysis From The Unix Command Line</it> at Wikibooks</weblink> shows how to use pipelines composed of simple filters to do complex data analysis.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.pixelbeat.org/programming/stdio_buffering/">
stdio buffering</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.debian-administration.org/articles/145">
Use And Abuse Of Pipes With Audio Data</weblink> gives an introduction to using and abusing pipes with netcat, nettee and fifos to play audio across a network.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.codecrazy.net/hitting-pipe-sunday.html">
hitting the pipe</weblink> A program that forks two processes that communicate with each other using pipes.</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
http://www.linfo.org/pipe.html Pipes: A Brief Introduction by The Linux Information Project (LINFO)</entry>
<entry id="2">
http://www.cs.rit.edu/~swm/history/DTSS.doc</entry>
<entry id="3">
http://cm.bell-labs.com/who/dmr/hist.html</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../264/1047264.xml">
Sal Soghoian</link></employee>
</causal_agent>
</worker>
</person>
</physical_entity>
 on <link xlink:type="simple" xlink:href="../048/4271048.xml">
MacBreak</link> Episode 3 "Enter the Automatrix"</entry>
</list>
</p>


</sec>
</bdy>
</article>
