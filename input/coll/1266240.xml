<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:21:47[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Intersection algorithm</title>
<id>1266240</id>
<revision>
<id>183862532</id>
<timestamp>2008-01-12T17:09:00Z</timestamp>
<contributor>
<username>Violetriga</username>
<id>90192</id>
</contributor>
</revision>
<categories>
<category>Agreement algorithms</category>
</categories>
</header>
<bdy>

The <b>Intersection Algorithm</b> is an <link>
agreement algorithm</link> used to select sources for estimating accurate time from a number of <link xlink:type="simple" xlink:href="../415/41415.xml">
noisy</link> time sources, it forms part of the modern <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../886/159886.xml">
Network Time Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
. It is a modified form of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../615/776615.xml">
Marzullo's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.<p>

While Marzullo's Algorithm will return the smallest interval consistent with the largest number of sources, the returned interval does not necessarily include the center point (calculated offset) of all the sources in the intersection. The Intersection Algorithm returns an interval that includes that returned by Marzullo's algorithm but may be larger since it will include the center points.  This larger interval allows using additional statistical data to select a point within the interval, reducing the <link xlink:type="simple" xlink:href="../296/41296.xml">
jitter</link> in repeated execution.</p>

<sec>
<st>
Method</st>

<p>

Given <it>M</it> intervals of the form <it>c</it>&nbsp;&amp;plusmn;&nbsp;<it>r</it> (which means [''c''&amp;minus;''r'',''c''+''r'']), the algorithm seeks to find an interval with <it>M</it>&amp;minus;<it>f</it> sources. The value <it>f</it> is referred to as the number of falsetickers, those sources which are in error (the actual value is outside the confidence band). The best estimate is that which assumes the least number of falsetickers, <it>f</it>.  The results will be considered valid if <it>f</it>&nbsp;&nbsp;<it>m</it>/2, otherwise the algorithm will return failure instead of an interval.</p>
<p>

The intersection algorithm begins by creating a table of tuples . For each interval there are three entries: the lower endpoint, the midpoint and the upper endpoint, labelled with types &amp;minus;1, 0 and +1 respectively. Thus the interval <it>c</it>&nbsp;&amp;plusmn;&nbsp;<it>r</it> results in the entries <it>c</it>&amp;minus;<it>r</it>,&amp;minus;1&amp;gt;, <it>c</it>,0&amp;gt; and <it>c</it>+<it>r</it>,+1&amp;gt;. These entries are then sorted by offset.</p>
<p>

Variables: This algorithm uses <it>f</it> as number of false tickers, <it>endcount</it> and <it>midcount</it> are integers. <it>Lower</it> and <it>upper</it> are values of offsets.</p>
<p>

0) [initialize best f] Start with <it>f</it>=0, assuming all input intervals are valid.  Each time no interval is found f will be incremented until either an interval is found or <it>f</it>&nbsp;&amp;ge;&nbsp;<it>m</it>/2.</p>
<p>

1) [initialize] <it>endcount</it>=0 and <it>midcount</it>=0.</p>
<p>

2) [find lower endpoint] Start at beginning of the list (lowest offset) consider each tuple in order.  <it>endcount</it>&nbsp;=&nbsp;<it>endcount</it>&amp;minus;<it>type</it>. If <it>endcount</it>&nbsp;&amp;ge;&nbsp;<it>m</it>&amp;minus;<it>f</it> then <it>lower</it>&nbsp;=&nbsp;<it>offset</it> and goto step 3 because the (possible) lower endpoint has been found.  If the <it>type</it>&nbsp;=&nbsp;0 then <it>midcount</it>&nbsp;=&nbsp;<it>midcount</it>+1.  Repeat with next tuple.  If reach end of list then goto step 6.</p>
<p>

3) [tentative lower endpoint found, initialize to find upper endpoint] set <it>endcount</it>=0.  </p>
<p>

4) [determine number of midpoints] Start from end of list and work towards lower offsets.  <it>endcount</it>&nbsp;=&nbsp;<it>endcount</it>+<it>type</it>. If <it>endcount</it>&nbsp;&amp;ge;&nbsp;<it>m</it>&amp;minus;<it>f</it> then <it>upper</it>&nbsp;=&nbsp;<it>offset</it>, goto step 5.  If <it>type</it>&nbsp;=&nbsp;0 then <it>midcount</it>&nbsp;=&nbsp;<it>midcount</it>+1.  Repeat for next tuple.  If reach end of list then goto step 6.</p>
<p>

5) if <it>lower</it>&nbsp;&amp;le;&nbsp;<it>upper</it> and <it>midcount</it>&nbsp;&amp;le;&nbsp;<it>f</it> then return interval [''lowerendpoint'',''upperendpoint''] as resulting confidence interval.</p>
<p>

6) [increment number of falsetickers] <it>f</it>&nbsp;=&nbsp;<it>f</it>+1. If <it>f</it>&nbsp;&amp;ge;&nbsp;<it>m</it>/2 then terminate and return FAILED, otherwise goto step 1.</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
