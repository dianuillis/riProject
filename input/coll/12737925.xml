<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 01:33:30[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Abductive logic programming</title>
<id>12737925</id>
<revision>
<id>206425197</id>
<timestamp>2008-04-18T04:22:08Z</timestamp>
<contributor>
<username>Gregbard</username>
<id>1193764</id>
</contributor>
</revision>
<categories>
<category>Logic programming</category>
</categories>
</header>
<bdy>

<b>Abductive Logic Programming</b> is a high level knowledge-representation framework that can be used to solve problems declaratively based on <link xlink:type="simple" xlink:href="../459/60459.xml">
abductive reasoning</link>. It extends normal <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
Logic Programming</link> by allowing some predicates to be incompletely defined, declared as abducible predicates. Problem solving is effected by deriving hypotheses on these abducible predicates (abductive hypotheses) as solutions of problems to be solved. These problems can be either observations that need to be explained (as in classical abduction) or goals to be achieved (as in normal <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic programming</link>). It can be used to solve problems in <link xlink:type="simple" xlink:href="../525/18507525.xml">
Diagnosis</link>, <link xlink:type="simple" xlink:href="../010/378010.xml">
Planning</link>, Natural Language and <link xlink:type="simple" xlink:href="../488/233488.xml">
Machine Learning</link>. It has also been used to interpret <link xlink:type="simple" xlink:href="../537/2526537.xml">
Negation as failure</link> as a form of abductive reasoning.
<sec>
<st>
Syntax</st>

<p>

Abductive Logic Programs have three components, <math>&amp;lt;P,A,IC&amp;gt;,</math> where:</p>
<p>

<list>
<entry level="1" type="bullet">

 P is a logic program of exactly the same form as in Logic Programming</entry>
<entry level="1" type="bullet">

 A is a set of predicate names, called the abducible predicates</entry>
<entry level="1" type="bullet">

 IC is a set of first order classical formulae.</entry>
</list>
</p>
<p>

Normally, the logic program P does not contain any clauses whose head (or conclusion) refers to an abducible predicate. (This restriction can be made without loss of generality.) Also in practice, many times the integrity constraints in IC are often restricted to the form of denials, i.e. clauses of the form:</p>
<p>

false:- A1,...,An, not B1, ..., not Bm.</p>
<p>

Such a constraint means that it is not possible for all A1,...,An to be true and at the same time all of B1,...,Bm to be false.</p>

</sec>
<sec>
<st>
Informal meaning and problem solving</st>

<p>

The clauses in P define a set of non-abducible predicates and through this they provide a description (or model) of the problem domain. The integrity constraints in IC specify general properties of the problem domain that need to be respected in any solution of our problem.</p>
<p>

A problem, G, which expresses either an observation that needs to be explained or a goal that is desired, is represented
by a conjunction of positive and negative (NAF) literals. Such problems are solved by computing "abductive explanations" of G.</p>
<p>

An abductive explanation of a problem G is a set of positive (and sometimes also negative) ground instances of the abducible predicates, such that, when these are added to the logic program P, the problem G and the integrity constraints I both hold. Thus abductive explanations extend the logic program P by the addition of full or partial definitions of the abducible predicates. In this way, abductive explanations form solutions of the problem according to the description of the problem domain in P and IC. The extension or completion of the problem description given by the abductive explanations provides new information, hitherto not contained in the solution to the problem. Quality criteria to prefer one solution over another, often expressed via integrity constraints, can be applied to select specific abductive explanations of the problem G.</p>
<p>

Computation in ALP combines the backwards reasoning of normal logic programming (to reduce problems to sub-problems) with a kind of integrity checking to show that the abductive explanations satisfy the integrity constraints.</p>
<p>

The following two examples, written in simple structured English rather than in the strict syntax of ALP, illustrate the notion
of abductive explanation in ALP and its relation to problem solving.</p>

<ss1>
<st>
Example 1</st>

<p>

The abductive logic program, <math>&amp;lt;P,A,IC&amp;gt;</math>, has in <math>P</math> the following sentences:</p>
<p>

Grass is wet <b>if</b> it rained.
Grass is wet <b>if</b> the sprinkler was on.
The sun was shining.</p>
<p>

The abducible predicates in <math>A</math> are "it rained" and "the sprinkler was on" and the only integrity constraintin in <math>IC</math>is:</p>
<p>

false <b>if</b> it rained and the sun was shining.</p>
<p>

The observation that the grass is wet has two potential explanations, "it rained" and "the sprinkler was on", which entail the observation. However, only the second potential explanation, "the sprinkler was on", satisfies the integrity constraint.</p>

</ss1>
<ss1>
<st>
Example 2</st>

<p>

Consider the abductive logic program consisting of the following (simplified) clauses:</p>
<p>

X is citizen <b>if</b> X is born in USA.
X is citizen <b>if</b> X is born outside USA <b>and</b> X is resident of USA <b>and</b> X is naturalised.
X is citizen <b>if</b> X is born outside USA <b>and</b> Y is mother of X is Y is citizen <b>and</b> X is registered.
Mary is mother of John.
Mary is citizen.</p>
<p>

together with the four abducible predicates, "is born in USA", "is born outside USA, "is resident of USA" and "is naturalised" and the integrity constraint:</p>
<p>

false <b>if</b> John is resident of USA.</p>
<p>

The goal "John is citizen" has two abductive solutions, one of which is "John is born in USA", the other of which is "John is born outside USA" and "John become registered". The potential solution of becoming a citizen by residence and naturalisation fails because it violates the integrity constraint.</p>
<p>

A more complex example that is also written in the more formal syntax of ALP is the following.</p>

</ss1>
<ss1>
<st>
Example 3</st>

<p>

The abductive logic program below describes a simple model of the lactose metabolism of the bacterium E. Coli. The program P describes the fact that E. coli can feed on the sugar lactose if it makes two enzymes permease and galactosidase. Like all enzymes (E), these are made if they are coded by a gene (G) that is expressed. These enzymes are coded by two genes (lac(y) and lac(z)) in cluster of genes (lac(X)) – called an operon – that is expressed when the amounts (amt) of glucose are low
and lactose are high or when they are both at medium level. The abducibles, A, declare all ground instances of the predicates "amount" as assumable. This reflects the fact that in the model the amounts at any time of the various substances are unknown. This is incomplete information that is to be determined in each problem case. 
The integrity constraints state that the amount of a substance (S) can only take one value.</p>
<p>

Domain Knowledge (P) </p>
<p>

feed(lactose):-make(permease),make(galactosidase).
make(Enzyme):-code(Gene,Enzyme),express(Gene).
express(lac(X)):-amount(glucose,low),amount(lactose,hi).
express(lac(X)):-amount(glucose,medium),amount(lactose,medium).
code(lac(y),permease).
code(lac(z),galactosidase).</p>
<p>

temperature(low):-amount(glucose,low).</p>
<p>

Integrity Constraints (IC) </p>
<p>

false :- amount(S,V1), amount(S,V2), V1 <math>\neq</math> V2.</p>
<p>

Abducibles (A) </p>
<p>

abducible_predicate(amount).</p>
<p>

The problem goal is <math>G=feed(lactose)</math>. This can arise either as an observation to be explained or as a state of affairs to be achieved by finding a plan. This goal has two abductive explanations:</p>
<p>

<math>\Delta_1=\{amount(lactose,hi), amount(glucose,low)\}</math></p>
<p>

<math>\Delta_2=\{amount(lactose,medium), amount(glucose,medium)\}</math></p>
<p>

The decision which of the two to adopt could depend on addition information that is available, e.g. it may be known that when the level of glucose is low then the organism exhibits a certain behaviour - in the model such additional information is that the temperature of the organism is low - and by observing the truth or falsity of this it is possible to choose the first or second explanation respectively.</p>
<p>

Once an explanation has been chosen, then this becomes part of the theory, which can be used to draw new conclusions. The explanation and more generally these new conclusions form the solution of the problem.</p>

</ss1>
</sec>
<sec>
<st>
Formal semantics</st>

<p>

The formal semantics of the central notion of an abductive explanation in ALP, can be defined in the following way:</p>
<p>

Given an abductive logic program, <math>&amp;lt;P,A,IC&amp;gt;</math>, an abductive explanation for a problem <math>G</math> is a set <math>\Delta</math> of ground atoms on abducible predicates such that:</p>
<p>

- <math>P \cup \Delta \models G</math>
- <math>P \cup \Delta \models IC</math>
- <math>P \cup \Delta \ is \ [[consistent]].</math></p>
<p>

This definition is generic in the underlying semantics of Logic Programming. Each particular choice of semantics defines its own entailment relation <math>\models</math>, its own notion of consistent logic programs and hence its own notion of what an abductive solution is. In practice, the three main semantics of logic programming --- completion, stable and well-founded semantics --- have been used to define different ALP frameworks.</p>
<p>

The integrity constraints <math>IC</math> define <it>how</it> they constrain the abductive solutions.  There are different views on this. Early work on abduction in Theorist in the context of classical logic was based on the <it>consistency view</it> on constraints.  In this view, any extension of the given theory with an abductive solution  <math>\Delta</math> is required to be consistent with the integrity constraints IC: <math>P \cup IC \cup \Delta</math> is consistent.  The above definition formalizes the <it>entailment view</it>: the abductive solution <math>\Delta</math> together with <math>P</math> should entail the constraints. This view is the one taken in most versions of ALP and is stronger than the consistency view in the sense that a solution according to the entailment view is a solution according to the consistency view but not vice versa.</p>
<p>

The difference between the two views can be subtle but in practice the different views usually coincide. E.g. it frequently happens that <math>P\cup \Delta</math> has a unique model, in which case the two views are equivalent. In practice, many ALP systems use the entailment view as this can be easily implemented without the need for any extra specialized procedures for the satisfaction of the integrity constraints since this semantics treats the constraints in the same way as the goal.</p>

</sec>
<sec>
<st>
Comparison with other frameworks</st>

<p>

ALP can be viewed as a refinement of Theorist, which explored the use of abduction in first-order logic for both explanation and default reasoning. Poole later developed a logic programming variant of Theorist, in which abducible predicates have associated probabilities. He showed that probabilistic Horn abduction incorporates both pure <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link> and <link xlink:type="simple" xlink:href="../996/203996.xml">
Bayesian networks</link> as special cases.</p>
<p>

There exist strong links between some ALP frameworks and other extensions of Logic Programming. In particular, ALP has close connections with Answer Set Programming. An abductive logic program can be translated into an equivalent answer set program under the stable model semantics. Consequently, systems for computing stable models such as SMODELS can be used to compute abduction in ALP.</p>
<p>

ALP is also closely related to Constraint Logic Programming. On the one hand, the integration of constraint solving and abductive logic programming enhances the practical utility of ALP through a more efficient computation of abduction. On the other hand, the integration of ALP and CLP can be seen as a high-level constraint programming environment that allows more modular and flexible representations of the problem domain.</p>
<p>

There is also a strong link between ALP and Argumentation in Logic Programming. This relates both to the interpretation of Negation as Failure and Integrity Constraints.</p>

</sec>
<sec>
<st>
Implementation and systems</st>

<p>

Most of the implementations of ALP extend the SLD resolution based computational model of Logic Programming. ALP can also be implemented by means on its link with Answer Set Programming (ASP), where the ASP systems can be employed. Examples of systems of the former approach are ACLP, A-system, CIFF, SCIFF, ABDUAL and ProLogICA.</p>

</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../459/60459.xml">
Abductive Reasoning</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../211/2386211.xml">
Answer set programming</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../069/54069.xml">
Inductive logic programming</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../537/2526537.xml">
Negation as failure</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../383/1317383.xml">
Argumentation</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 D. Poole, R. Goebel and R. Aleliunas, <it>Theorist: a logical reasoning system for defaults and diagnosis</it>, in N. Cercone and G. McCalla (Eds.) The Knowledge Frontier: Essays in the Representation of Knowledge, Springer Varlag, New York, 1987, pp. 331-352. </entry>
<entry level="1" type="bullet">

 A.C. Kakas and P. Mancarella, "Generalised Stable Models: A Semantics for Abduction" in <it>Proceedings of the ninth European Conference on Artificial Intelligence, ECAI-90</it>, Stockholm, Sweden, (ed. L.C. Aiello) Pitman Publishing,  pp. 385-391, (1990).</entry>
<entry level="1" type="bullet">

 L.Console, D.T. Dupre and P. Torasso", "On the Relationship between Abduction and Deduction", <it>Journal of Logic and Computation</it>, Vol 1, no 5, pp. 661-690, 1991.</entry>
<entry level="1" type="bullet">

 A.C. Kakas, R.A. Kowalski and F. Toni, "Abductive Logic Programming", <it>Journal of Logic and Computation</it>, Vol. 2 no 6, pp. 719-770, (1993).</entry>
<entry level="1" type="bullet">

 Marc Denecker and Danny De Schreye, "SLDNFA: An Abductive Procedure for Abductive Logic Programs", <it>Journal of Logic Programming</it>, Vol 34, no 2, pp. 111-167, 1998.</entry>
<entry level="1" type="bullet">

 M. Denecker and A.C. Kakas, Abductive Logic Programming, Special issue of <it>Journal of Logic Programming</it>, JLP, Vol. 44(1-3), Elsevier Science, 2000.</entry>
<entry level="1" type="bullet">

 M. Denecker and A.C. Kakas, Abduction in Logic Programming, in <it>Computational Logic: Logic Programming and Beyond, LNAI</it> Vol, 2407, pp. 402-437,  Springer Verlag, 2002.</entry>
<entry level="1" type="bullet">

 D. Poole, <it>Probabilistic Horn abduction and Bayesian networks</it>, Artificial Intelligence, 64(1), 81-129, 1993.</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>

<p>

<list>
<entry level="1" type="bullet">

 ACLP: <weblink xlink:type="simple" xlink:href="http://www.cs.ucy.ac.cy/aclp/">
http://www.cs.ucy.ac.cy/aclp/</weblink></entry>
<entry level="1" type="bullet">

 A-system: <weblink xlink:type="simple" xlink:href="http://www.cs.kuleuven.be/~dtai/krr/Asystem/Asystem/asystem.html">
http://www.cs.kuleuven.be/~dtai/krr/Asystem/Asystem/asystem.html</weblink></entry>
<entry level="1" type="bullet">

 ProLogICA: <weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~or/proLogICA/">
http://www.doc.ic.ac.uk/~or/proLogICA/</weblink></entry>
<entry level="1" type="bullet">

 CIFF: <weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~ue/ciff/">
http://www.doc.ic.ac.uk/~ue/ciff/</weblink></entry>
<entry level="1" type="bullet">

 ACL: <weblink xlink:type="simple" xlink:href="http://www-lia.deis.unibo.it/Software/ACL/">
http://www-lia.deis.unibo.it/Software/ACL/</weblink></entry>
<entry level="1" type="bullet">

 SCIFF: <weblink xlink:type="simple" xlink:href="http://lia.deis.unibo.it/sciff/">
http://lia.deis.unibo.it/sciff/</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
