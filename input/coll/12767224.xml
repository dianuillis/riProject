<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 01:37:24[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Digital Differential Analyzer (graphics algorithm)</title>
<id>12767224</id>
<revision>
<id>237616507</id>
<timestamp>2008-09-11T00:54:19Z</timestamp>
<contributor>
<username>Scarecroe</username>
<id>129667</id>
</contributor>
</revision>
<categories>
<category>Computer graphics algorithms</category>
<category>Articles with example pseudocode</category>
<category>Digital geometry</category>
</categories>
</header>
<bdy>

This article is about a graphics algorithm.&#32;&#32;For other uses of DDA, see <link xlink:type="simple" xlink:href="../995/824995.xml">
DDA</link>.&#32;&#32;For the digital implementation of a Differential Analyzer, see <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../906/15646906.xml">
Digital Differential Analyzer</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
.&#32;&#32;<p>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
Computer graphics</link>, an hard- or software implementation of a <b><computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../906/15646906.xml">
Digital Differential Analyzer</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 (DDA)</b> is used for linear interpolation of variables over an interval between start and end point. DDAs are used for rasterization of lines, triangles and polygons. In its simplest implementation the DDA algorithm interpolates values in interval [(xstart, ystart) ... (xend, yend)] by computing for each xi the equations xi =  xi−1+1, yi =  yi−1 + Δy/Δx, where Δx = xend − xstart and  Δy = yend − ystart.</p>

<sec>
<st>
 Basic algorithm (naïve floating-point implementation) </st>
<p>

The straightforward DDA algorithm requires a fast floating-point add and round() operation for good performance. Here an example in the <link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link> interpolating a single value y between start point (xa, ya) and end point (xb, yb):<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

<p>

<list>
<entry level="1" type="number">

include                      /* for round() */</entry>
</list>

extern void output (int x, int y);    /* forward declaration for user-defined output */</p>
<p>

/* Interpolate values between start (xa, ya) and end (xb, yb) */
void DDA (int xa, int ya, int xb, int yb)
{
int x;
float dydx = (float) (yb - ya) / (float) (xb - xa);
float y = ya;
for (x=xa; x=xb; x++) {
output(x, round(y));
y = y + dydx;
}
}</p>


</sec>
<sec>
<st>
 Interpolating multiple values </st>
<p>

Usually not only the coordinate component, but also additional values like depth, color, alpha, texture coordinates etc. are required for every point. For good performance on common architectures all values should get interpolated in the same inner loop:</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

extern void output (int x, int y, int color [3]);</p>
<p>

/* Interpolate y-coord and RGB color values between start (xa, ya, colora) and end (xb, yb, colorb) */
void DDA (int xa, int ya, int colora[3], int xb, int yb, int colorb [3])
{
int x;
float dx = xb - xa;
float dydx = (yb - ya) / dx;
float dc0dx = (colorb[0] - colora[0]) / dx;
float dc1dx = (colorb[1] - colora[1]) / dx;
float dc2dx = (colorb[2] - colora[2]) / dx;
float y = ya, color [3] = { colora[0], colora[1], colora[2] };
for (x=xa; x=xb; x++) {
output(x, round(y), round(color[0]), round(color[1]), round(color[2]));
y = y + dydx;
color[0] += dc0dx;    /* Red component */
color[1] += dc1dx;    /* Green component */
color[2] += dc2dx;    /* Blue component */
}
}</p>


</sec>
<sec>
<st>
 Integer implementation with separated fractional part </st>
<p>

By splitting the integer and fractional part of all floating-point numbers, the algorithm can get converted to fixed-point arithmetics, so that it achieves good performance on architectures without floating-point support. Now the inner-loop rounding is replaced by a fractional-part overflow handler:</p>

<p>

/* Interpolate values between start (xa, ya) and end (xb, yb) */
void DDA (int xa, int ya, int xb, int yb)
{
int x;
int yi = ya;
int yf = -(xb - xa);
int mi = (yb - ya) / (xb - xa);
int mf = 2 * ((yb - ya) % (xb - xa));
int mtwo_xb_minus_xa = -2 * (xb - xa);
for (x=xa; x=xb; x++) {
output(x, yi);
yi = yi + mi;
yf = yf + mf;
if (yf &amp;gt; 0) {
yf += mtwo_xb_minus_xa;
yi++;
}
}
}</p>


</sec>
<sec>
<st>
 DDAs for triangle and line drawing </st>
<p>

The above implementations interpolate only y values and iterate x values.</p>
<p>

In order to rasterizlng triangles with horizontal spanlines one uses 3 independent DDAs: two DDAs interpolate x coordinate for incremental y, colors etc. for the left and right edge, a third DDA interpolates colors etc. on the span inbetween while iterating over x.</p>
<p>

When rasterizing lines, then gaps would occur when abs(dydx) &amp;gt; 1 (thus, when |Δy| &amp;gt; |Δx|). So a line drawing algorithm using DDAs has to check whether abs(dydx) &amp;gt; 1, and interpolate x over y instead of y over x if so.</p>

</sec>
<sec>
<st>
 Performance </st>
<p>

The DDA method can be implemented using <link xlink:type="simple" xlink:href="../376/11376.xml">
floating-point</link> or <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link> arithmetic. The naïve floating-point implementation requires one addition and one rounding operation per interpolated value (e.g. coordinate x, y, depth, color component etc.) and output result. This process is only efficient when a <link xlink:type="simple" xlink:href="../061/37061.xml">
FPU</link> with fast add and rounding operation is available.</p>
<p>

The <link xlink:type="simple" xlink:href="../245/11245.xml">
fixed-point</link> integer operation requires two additions per output cycle, and in case of fractional part overflow one additional increment and subtraction. The probability of fractional part overflows is proportional to the ratio m of the interpolated start/end values.</p>
<p>

DDAs are well-suited for hardware implementation and can get pipelined for maximized throughput.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/64005.xml">
Bresenham's line algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is an algorithm for line rendering.</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../689/222689.xml">
Xiaolin Wu's line algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is an algorithm for line antialiasing</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
Code is inspired by Watt 2000, p. 184.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Literature </st>
<p>

<list>
<entry level="1" type="bullet">

Alan Watt: <it>3D Computer Graphics</it>, 3rd edition 2000, p. 184 (Rasterizing edges). ISBN 0-201-39855-9</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://programmers-lounge-basicgraphics.blogspot.com/">
Basic Computer Graphics Programs</weblink></entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
