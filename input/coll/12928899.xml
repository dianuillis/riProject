<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 01:34:44[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Pollard&apos;s lambda algorithm</title>
<id>12928899</id>
<revision>
<id>197577551</id>
<timestamp>2008-03-11T22:05:48Z</timestamp>
<contributor>
<username>Bdesham</username>
<id>4319</id>
</contributor>
</revision>
<categories>
<category>Number theoretic algorithms</category>
<category>Computer algebra</category>
<category>Logarithms</category>
</categories>
</header>
<bdy>

In mathematics, specifically <link xlink:type="simple" xlink:href="../466/511466.xml">
computational number theory</link> and <link>
computational algebra</link>, <b>Pollard's lambda algorithm</b> (aka <b>Pollard's kangaroo algorithm</b>, see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Naming%22])">
Naming</link> below) is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for solving the <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete logarithm</link>.  The algorithm was introduced in 1978 by the accomplished number theorist <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../500/1068500.xml">
J. M. Pollard</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
, in the same paper <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> as his better-known <link xlink:type="simple" xlink:href="../817/1630817.xml">
rho algorithm</link> for solving the same problem.  Although Pollard described the application of his algorithm to the discrete logarithm problem in the multiplicative group of units modulo a prime <it>p</it>, it is in fact a generic discrete logarithm algorithm—it will work in any finite cyclic group.
<sec>
<st>
The algorithm</st>

<p>

Suppose <math>G</math> is a finite cyclic group of order <math>n</math> which is generated by the element <math>\alpha</math>, and we seek to find the discrete logarithm <math>x</math> of the element <math>\beta</math> to the base <math>\alpha</math>.  In other words, we seek <math>x \in Z_n</math> such that <math>\alpha^x = \beta</math>.  The lambda algorithm allows us to search for <math>x</math> in some subset <math>\{a,\ldots,b\}</math> of <math>Z_n</math>.  We may search the entire range of possible logarithms by setting <math>a=0</math> and <math>b=p-1</math>, although in this case Pollard's rho algorithm is more efficient.  We proceed as follows:</p>
<p>

1. Choose a set <math>S</math> of integers and define a <link xlink:type="simple" xlink:href="../210/23210.xml">
pseudorandom</link> map <math>f: G \rightarrow S</math>.</p>
<p>

2. Choose an integer <math>N</math> and compute a sequence of group elements <math>\{x_0,x_1,\ldots,x_N\}</math> according to:
<list>
<entry level="1" type="bullet">

 <math>x_0 = \alpha^b</math></entry>
<entry level="1" type="bullet">

 <math>x_{i+1} = x_i\alpha^{f(x_i)}</math> for <math>i=0,1,\ldots,N-1</math></entry>
</list>

3. Compute
<indent level="1">

<math>d = \sum_{i=0}^{N-1}f(x_i)</math>.
</indent>
Observe that:
<indent level="1">

<math>x_N = x_0\alpha^d = \alpha^{b+d}</math>.
</indent>
4. Begin computing a second sequence of group elements <math>\{y_0,y_1,\ldots\}</math> according to:
<list>
<entry level="1" type="bullet">

 <math>y_0 = \beta</math></entry>
<entry level="1" type="bullet">

 <math>y_{i+1} = y_i\alpha^{f(y_i)}</math> for <math>i=0,1,\ldots,N-1</math></entry>
</list>

and a corresponding sequence of integers <math>\{d_0,d_1,\ldots\}</math> according to:
<indent level="1">

<math>d_n = \sum_{i=0}^{n-1}f(y_i)</math>.
</indent>
Observe that:
<indent level="1">

<math>y_i = y_0\alpha^{d_i} = \beta\alpha^{d_i}</math> for <math>i=0,1,\ldots,N-1</math>
</indent>
5. Stop computing terms of <math>\{y_i\}</math> and <math>\{d_i\}</math> when either of the following conditions are met:</p>
<p>

<indent level="1">

A) <math>y_j = x_N</math> for some <math>j</math>.  If the sequences <math>\{x_i\}</math> and <math>\{y_j\}</math> "collide" in this manner, then we have:
</indent>
::<math>x_N = y_j \Rightarrow \alpha^{b+d} = \beta\alpha^{d_j} \Rightarrow \beta = \alpha^{b+d-d_j} \Rightarrow x \equiv b+d-d_j \pmod{p}</math>
<indent level="1">

and so we are done.
</indent>

<indent level="1">

B) <math>d_i &amp;gt; b-a+d</math>.  If this occurs, then the algorithm has failed to find <math>x</math>.  Subsequent attempts can be made by changing the choice of <math>S</math> and/or <math>f</math>.
</indent>

</p>
</sec>
<sec>
<st>
Complexity</st>

<p>

Pollard gives the time complexity of the algorithm as <math>{\scriptstyle O(\sqrt{b-a})}</math>, based on a probabilistic argument which follows from the assumption that <it>f</it> acts pseudorandomly.  Note that when the size of the set {<it>a</it>,&nbsp;…,&nbsp;<it>b</it>} to be searched is measured in <link xlink:type="simple" xlink:href="../690/1036690.xml">
bits</link>, as is normal in <link xlink:type="simple" xlink:href="../132/6132.xml">
complexity theory</link>, the set  has size log(<it>b</it>&amp;thinsp;&amp;minus;&amp;thinsp;<it>a</it>), and so the algorithm's complexity is <math>{\scriptstyle O(\sqrt{b-a}) = O(e^{\frac{1}{2}\log(b-a)})}</math>, which is exponential in the problem size.  For this reason, Pollard's lambda algorithm is considered an <link xlink:type="simple" xlink:href="../581/44581.xml">
exponential time</link> algorithm.  For an example of a <link>
subexponential time</link> discrete logarithm algorithm, see the <link xlink:type="simple" xlink:href="../595/1549595.xml">
index calculus algorithm</link>.</p>

</sec>
<sec>
<st>
Naming</st>
<p>

The algorithm is well known by two names.</p>
<p>

The first is "Pollard's lambda algorithm".  Much like the name of another of Pollard's discrete logarithm algorithms, <link xlink:type="simple" xlink:href="../817/1630817.xml">
Pollard's rho algorithm</link>, this name refers to the similarity between a visualisation of the algorithm and the <link xlink:type="simple" xlink:href="../909/715909.xml">
Greek letter</link> <link xlink:type="simple" xlink:href="../851/17851.xml">
lambda</link> (<math>\lambda</math>).  The longer stroke of the letter lambda corresponds to the sequence <math>\{x_i\}</math>.  The shorter stroke corresponds to the sequence <math>\{y_i\}</math>, which "collides with" the first sequence (just like the strokes of a lambda intersect) and then follows it subsequently.</p>
<p>

The second is "Pollard's kangaroo algorithm".  This name is a reference to an analogy used in the paper presenting the algorithm, where the algorithm is explained in terms of using a <it>tame</it> kangaroo to trap a <it>wild</it> kangaroo.  Pollard has explained<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> that this analogy was inspired by a "fascinating " article published in the same issue of Scientific American as an exposition of the <link xlink:type="simple" xlink:href="../385/25385.xml">
RSA</link> <link xlink:type="simple" xlink:href="../222/24222.xml">
public key cryptosystem</link>.  The article<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> described an experiment in which a kangaroo's "energetic cost of locomotion, measured in terms of oxygen consumption at various speeds, was determined by placing kangaroos on a treadmill".</p>
<p>

Pollard has expressed a preference for the name "kangaroo algorithm", as this avoids confusion with some parallel versions of his rho algorithm, which have also been called "lambda algorithms".</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <operation wordnetid="100955060" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<attack wordnetid="100972621" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../284/2403284.xml">
Rainbow table</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</attack>
</rule>
</event>
</operation>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
J. Pollard, <it>Monte Carlo methods for index computation mod p</it>, Mathematics of Computation, Volume 32, 1978</entry>
<entry id="2">
J. M. Pollard, <it>Kangaroos, Monopoly and Discrete Logarithms</it>, Journal of Cryptology, Volume 13, pp 437-447, 2000</entry>
<entry id="3">
T. J. Dawson, <it>Kangaroos</it>, Scientific American, August 1977, pp. 78-89</entry>
</reflist>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
