<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:24:10[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Operator-precedence parser</title>
<id>1301946</id>
<revision>
<id>217004236</id>
<timestamp>2008-06-04T05:05:14Z</timestamp>
<contributor>
<username>Paul Foxworthy</username>
<id>977567</id>
</contributor>
</revision>
<categories>
<category>Articles with example C code</category>
<category>Parsing algorithms</category>
</categories>
</header>
<bdy>

An <b>operator precedence parser</b> is a computer program that interprets an <link xlink:type="simple" xlink:href="../147/2012147.xml">
operator-precedence grammar</link>. For example, most <link xlink:type="simple" xlink:href="../593/7593.xml">
calculator</link>s use operator precedence parsers to convert from <link xlink:type="simple" xlink:href="../014/199014.xml">
infix notation</link> with <link xlink:type="simple" xlink:href="../980/212980.xml">
order of operations</link> (the usual format humans use for mathematical expressions) into a different format they use internally to compute the result.<p>

<link xlink:type="simple" xlink:href="../018/10018.xml">
Dijkstra</link>'s <link xlink:type="simple" xlink:href="../773/2692773.xml">
shunting yard algorithm</link> (named after the <link xlink:type="simple" xlink:href="../863/292863.xml">
shunting yard</link>) is commonly used to implement operator precedence parsers which convert from infix notation to <link xlink:type="simple" xlink:href="../513/26513.xml">
Reverse Polish notation</link> (RPN).</p>

<sec>
<st>
 Relationship to other parsers </st>

<p>

An operator-precedence parser is a simple <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../521/679521.xml">
shift-reduce parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 capable of parsing a subset of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR(1)</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 grammars.  More precisely, the operator-precedence parser can parse all LR(1) grammars where two consecutive <link xlink:type="simple" xlink:href="../061/7689061.xml">
nonterminal</link>s never appear in the right-hand side of any rule. </p>
<p>

Operator-precedence parsers are not used often in practice, however they do have some properties that make them useful within a larger design.  First, they are simple enough to write by hand, which is not generally the case with more sophisticated shift-reduce parsers.  Second, they can be written to consult an operator table at <link xlink:type="simple" xlink:href="../263/192263.xml">
runtime</link>, which makes them suitable for languages that can add to or change their operators while parsing.</p>
<p>

<link xlink:type="simple" xlink:href="../638/1146638.xml">
Perl 6</link> "sandwiches" an operator-precedence parser in between two <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../089/70089.xml">
Recursive descent parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s in order to achieve a balance of speed and dynamism. This is expressed in the virtual machine for Perl 6, <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../511/60511.xml">
Parrot</link></machine>
</writer>
</causal_agent>
</compiler>
</device>
</instrumentality>
</artifact>
</person>
</communicator>
</physical_entity>
 as the <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../206/7152206.xml">
Parser Grammar Engine</link></machine>
</language>
</device>
</instrumentality>
</artifact>
 (PGE). <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/12323.xml">
GCC</link></writer>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
's C and C++ parsers, which are hand-coded <link xlink:type="simple" xlink:href="../089/70089.xml">
recursive descent parser</link>s, are both sped up by an operator-precedence parser that can quickly examine arithmetic expressions.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../521/679521.xml">
Bottom-up parsers</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 are divided into 2 categories.
<list>
<entry level="1" type="number">

 Operator-precedence parser</entry>
<entry level="1" type="number">

 LR Parsers</entry>
</list>
</p>
<p>

To show that one grammar is <b>operator precedence</b>, first it should be <b>operator grammar.
</b>
Operator precedence grammar is the only grammar which can construct the parse tree even though the given grammar is ambiguous.</p>

</sec>
<sec>
<st>
 Example algorithm to parse infix notation </st>

<p>

An <link xlink:type="simple" xlink:href="../289/71289.xml">
EBNF</link> grammar that parses infix notation will usually look like this:</p>
<p>


   expression ::= equality-expression
   equality-expression ::= additive-expression ( ( '==' | '!=' ) additive-expression ) *
   additive-expression ::= multiplicative-expression ( ( '+' | '-' ) multiplicative-expression ) *
   multiplicative-expression ::= primary ( ( '*' | '/' ) primary ) *
   primary ::= '(' expression ')' | NUMBER | VARIABLE | '-' primary
</p>
<p>

With many levels of precedence, implementing this grammar with a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../089/70089.xml">
predictive recursive-descent parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 can become inefficient.  Parsing a number, for example, can require five function calls (one for each non-terminal in the grammar, until we reach primary).</p>
<p>

An operator-precedence parser can do the same more efficiently.  The idea is that we can left associate the arithmetic operations as long as we find operators with the same precedence, but we have to save a temporary result to evaluate higher precedence operators.  The algorithm that is presented here does not need an explicit stack: instead, it uses recursive calls to implement the stack.  </p>
<p>

The algorithm is not a pure operator-precedence parser like the Dijkstra <link xlink:type="simple" xlink:href="../773/2692773.xml">
shunting yard algorithm</link>.  It assumes that the primary nonterminal is parsed in a separate subroutine, like in a <link xlink:type="simple" xlink:href="../089/70089.xml">
recursive descent parser</link>.</p>

<ss1>
<st>
 Pseudo-code </st>

<p>

The pseudo-code for the algorithm is as follows.  The parser starts at function parse_expression.  Precedence levels are greater or equal to 0.</p>
<p>

<it>parse_expression</it> ()
return <it>parse_expression_1</it> (<it>parse_primary</it> (), 0)</p>
<p>

<it>parse_expression_1 (lhs, min_precedence)
while the next token is a binary operator whose precedence is &amp;gt;= </it>min_precedenceop<it> := next token
</it>rhs<it> := </it>parse_primary<it> ()
while the next token is a binary operator whose precedence is greater
than </it>op<it>'s, or a right-associative operator
whose precedence is equal to </it>op<b>s
<it>lookahead</it></b><b> := next token
<it>rhs</it></b><b> := <it>parse_expression_1</it></b><b> (<it>rhs</it></b><b>, lookahead's precedence)
<it>lhs</it></b><b> := the result of applying <it>op</it></b><b> with operands <it>lhs</it></b><b> and <it>rhs</it></b><b>
return <it>lhs</it></b></p>


</ss1>
<ss1>
<st>
 Example execution of the algorithm </st>

<p>

An example execution on the expression 2 + 3 * 4 + 5 == 19 is as follows.  We give precedence 0 to equality expressions, 1 to additive expressions, 2 to multiplicative expressions.</p>
<p>

parse_expression_1 (lhs = 2, min_precedence = 0)
<list>
<entry level="1" type="bullet">

  the next token is +, with precedence 1.  the while loop is entered.</entry>
<entry level="1" type="bullet">

  op is + (precedence 1)</entry>
<entry level="1" type="bullet">

  rhs is 3</entry>
<entry level="1" type="bullet">

  the next token is *, with precedence 2.  recursive invocation.parse_expression_1 (lhs = 3, min_precedence = 2)</entry>
<entry level="2" type="bullet">

   the next token is *, with precedence 2.  the while loop is entered.</entry>
<entry level="3" type="bullet">

    op is * (precedence 2)</entry>
<entry level="3" type="bullet">

    rhs is 4</entry>
<entry level="3" type="bullet">

    the next token is +, with precedence 1.  no recursive invocation.</entry>
<entry level="3" type="bullet">

    lhs is assigned 3*4 = 12</entry>
<entry level="3" type="bullet">

    the next token is +, with precedence 1.  the while loop is left.</entry>
<entry level="2" type="bullet">

   12 is returned.</entry>
<entry level="1" type="bullet">

  the next token is +, with precedence 1.  no recursive invocation.</entry>
<entry level="1" type="bullet">

  lhs is assigned 2+12 = 14</entry>
<entry level="1" type="bullet">

  the next token is +, with precedence 1.  the while loop is not left.</entry>
<entry level="1" type="bullet">

  op is + (precedence 1)</entry>
<entry level="1" type="bullet">

  rhs is 5</entry>
<entry level="1" type="bullet">

  the next token is ==, with precedence 0.  no recursive invocation.</entry>
<entry level="1" type="bullet">

  lhs is assigned 14+5 = 19</entry>
<entry level="1" type="bullet">

  the next token is ==, with precedence 0.  the while loop is not left.</entry>
<entry level="1" type="bullet">

  op is == (precedence 0)</entry>
<entry level="1" type="bullet">

  rhs is 19</entry>
<entry level="1" type="bullet">

  the next token is end-of-line, which is not an operator.  no recursive invocation.</entry>
<entry level="1" type="bullet">

  lhs is assigned the result of evaluating 19 == 19, for example 1 (as in the C standard).</entry>
<entry level="1" type="bullet">

  the next token is end-of-line, which is not an operator.  the while loop is left.</entry>
</list>

1 is returned.</p>

</ss1>
</sec>
<sec>
<st>
 Alternatives to Dijkstra's Algorithm </st>

<p>

There are alternative ways to apply operator precedence rules which do not involve the Shunting Yard algorithm.  </p>
<p>

One is to build a tree of the original expression, then apply tree rewrite rules to it.  </p>
<p>

Such trees do not necessarily need to be implemented using data structures conventionally used for trees. Instead, tokens can be stored in flat structures, such as tables, by simultaneously building a priority list which states what elements to process in which order. As an example, such an approach is used in the <it>Mathematical Formula Decomposer</it> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.</p>
<p>

Another is the algorithm used in the early FORTRAN I compiler, which is to first fully parenthesise the expression by a trivial macro replacement — inserting a number of parentheses around each operator, such that they lead to the correct precedence when parsed with a 'flat' grammar.  (A hack which takes longer to explain properly than to write code for - see below!)</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>

int main(int argc, char *argv){
int i;</p>
<p>

printf("((((");
for(i=1;i!=argc;i++){
if(     strcmp(argv[i], "^")==0) printf(")^(");
else if(strcmp(argv[i], "*")==0) printf("))*((");
else if(strcmp(argv[i], "/")==0) printf("))/((");
else if(strcmp(argv[i], "+")==0) printf(")))+(((");
else if(strcmp(argv[i], "-")==0) printf(")))-(((");
else                             printf("%s", argv[i]);
}
printf("))))\n");
return 0;
}</p>
<p>

Invoke it as: 
$ cc -o parenthesise parenthesise.c
$ ./parenthesise a \* b + c ^ d / e
((((a))*((b)))+(((c)^(d))/((e))))
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://herbert.gandraxa.com/herbert/mfd.asp">
Mathematical Formula Decomposer</weblink></entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">
Parsing Expressions by Recursive Descent</weblink> Theodore Norvell (C) 1999-2001. Access data September 14, 2006.</entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
