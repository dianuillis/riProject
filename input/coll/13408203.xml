<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 01:59:59[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<language  confidence="0.8" wordnetid="106282651">
<header>
<title>FRACTRAN</title>
<id>13408203</id>
<revision>
<id>238314034</id>
<timestamp>2008-09-14T07:37:06Z</timestamp>
<contributor>
<username>Ricknightcrawler</username>
<id>1284927</id>
</contributor>
</revision>
<categories>
<category>Functional languages</category>
<category>Esoteric programming languages</category>
</categories>
</header>
<bdy>

<b>FRACTRAN</b> is a <link xlink:type="simple" xlink:href="../621/30621.xml">
Turing-complete</link> <link xlink:type="simple" xlink:href="../933/10933.xml">
functional</link> <link xlink:type="simple" xlink:href="../398/53398.xml">
esoteric programming language</link> invented by the mathematician <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../807/15807.xml">
John Conway</link></scientist>
</person>
. FRACTRAN programs are given as a list of <link xlink:type="simple" xlink:href="../763/477763.xml">
fraction</link>s which are applied to a single <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../375/324375.xml">
argument</link></concept>
</idea>
 <it>p</it> as follows: 
<list>
<entry level="1" type="number">

multiply <it>p</it> by each fraction &amp;fnof; in the list in turn until <it>p</it>&amp;fnof; is an integer; replace <it>p</it> by <it>p</it>&amp;fnof; and repeat;</entry>
<entry level="1" type="number">

halt if no member of the list produces an integer when multiplied by <it>p</it>. This algorithm can be implemented very simply; for example, in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../227/73227.xml">
J</link></programming_language>
, a basic FRACTRAN interpretor might be (*{~1 i.~[@(=.)@:*).</entry>
</list>
<p>

Conway gave an interesting <link xlink:type="simple" xlink:href="../009/509009.xml">
formula for primes</link> in FRACTRAN:</p>
<p>

<indent level="1">

 <math>\frac{17}{91}, \frac{78}{85}, \frac{19}{51}, \frac{23}{38}, \frac{29}{33}, \frac{77}{29}, \frac{95}{23}, \frac{77}{19}, \frac{1}{17}, \frac{11}{13}, \frac{13}{11}, \frac{15}{14}, \frac{15}{2}, \frac{55}{1}.</math>
</indent>

Starting with <it>p</it>=2, this FRACTRAN program generates the following sequence of integers:</p>
<p>

<indent level="1">

2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290, 770, ... (sequence <weblink xlink:type="simple" xlink:href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A007542">
A007542</weblink> in <series wordnetid="108457976" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/500004.xml">
OEIS</link></group>
</ordering>
</sequence>
</arrangement>
</series>
)
</indent>

After 2, this sequence contains the following powers of 2:</p>
<p>

<indent level="1">

<math>2^2=4,\, 2^3=8,\, 2^5=32,\, 2^7=128,\, 2^{11}=2048,\, 2^{13}=8192,\, 2^{17}=131072,\, 2^{19}=524288,\,  \dots</math> (sequence <weblink xlink:type="simple" xlink:href="http://www.research.att.com/cgi-bin/access.cgi/as/njas/sequences/eisA.cgi?Anum=A034785">
A034785</weblink> in <series wordnetid="108457976" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/500004.xml">
OEIS</link></group>
</ordering>
</sequence>
</arrangement>
</series>
)
</indent>

which are the prime powers of 2.</p>

<sec>
<st>
Explanation of FRACTRAN</st>

<p>

A FRACTRAN program uses a potentially unlimited number of variables, each of which can store an arbitrarily large positive integer (FRACTRAN has no direct representation of negative integers, floating point numbers or text strings, although conventions could be adopted to represent these data types indirectly).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> The <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/285512.xml">
state</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 of a FRACTRAN program is represented by a single positive integer; the value of each variable is encoded as the exponent of a prime number in the <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<premise wordnetid="106753800" confidence="0.8">
<postulate wordnetid="106753299" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/15491.xml">
prime factorization</link></proposition>
</postulate>
</premise>
</message>
</statement>
 of that integer. For example, the number</p>
<p>

<indent level="1">

<math>60=2^2\times3^1\times5^1\, ,</math>
</indent>

represents a state in which one variable (which we will call V_2) holds the value 2 and two other variables (V_3 and V_5) hold the value 1. All other variables hold the value 0.</p>
<p>

A FRACTRAN program is an ordered list of positive fractions. Each fraction in a FRACTRAN program represents an instruction that tests one or more variables, represented by the prime factors of its <link xlink:type="simple" xlink:href="../824/1704824.xml">
denominator</link>. If the values of these variables are greater than 0, then they are decremented and the values of the variables represented by the prime factors of the <link xlink:type="simple" xlink:href="../039/113039.xml">
numerator</link> are incremented. For example:</p>
<p>

<indent level="1">

<math>\frac{10}{3}\, ,</math>
</indent>

tests V_3; if V_3 is greater than 0 it subtracts 1 from V_3 and adds 1 to V_2 and V_5.</p>
<p>

These test-decrement-increment instructions are the only instructions in a FRACTRAN program. This means that a FRACTRAN program has certain key features:</p>
<p>

<list>
<entry level="2" type="bullet">

Each time a variable is tested, it is also decremented.</entry>
<entry level="2" type="bullet">

The same variable cannot be both decremented and incremented in a single instruction (otherwise the fraction representing that instruction would not be in its <link xlink:type="simple" xlink:href="../822/14822.xml">
lowest terms</link>). Therefore each FRACTRAN instruction consumes variables as it tests them.</entry>
<entry level="2" type="bullet">

It is not possible for a FRACTRAN instruction to directly test if a variable is 0. However, an indirect test can be implemented by creating a default instruction that is placed after other instructions that test a particular variable.</entry>
</list>
</p>
<p>

The simplest FRACTRAN program is a single instruction such as</p>
<p>

<indent level="1">

<math>\frac{3}{2}\, .</math>
</indent>

This program can be represented as a (very simple) <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/10931.xml">
finite state machine</link></method>
</know-how>
 as follows:</p>
<p>

<indent level="1">

| class="wikitable"
</indent>
|-
! Current State
! Condition
! Action
! Next State
|-
| rowspan="2" | A
| V_2 &amp;gt; 0
| Subtract 1 from V_2
Add 1 to V_3
| A
|-
| V_2 = 0
| None
| Stop
|}</p>
<p>

Given an initial state or input of the form 2<it>a</it>3<it>b</it>, this program will stop with a final state or output of the form 3<it>a</it>+<it>b</it>. It therefore adds two positive integers together.</p>
<p>

We can create a "multiplier" by putting a loop around this "adder". Writing this out as a finite state machine gives:</p>
<p>

<indent level="1">

| class="wikitable"
</indent>
|-
! Current State
! Condition
! Action
! Next State
|-
| rowspan="4" | A
| V_11 &amp;gt; 0
| Subtract 1 from V_11
Add 1 to V_3
| A
|-
| V_11 = 0 and
V_2 &amp;gt; 0
| Subtract 1 from V_2
| B
|-
| V_11 = 0 and
V_2 = 0 and</p>
<p>

V_3 &amp;gt; 0
| Subtract 1 from V_3
| A
|-
| V_11 = 0 and
V_2 = 0 and</p>
<p>

V_3 = 0
| None
| Stop
|-
| rowspan="2" | B
| V_3 &amp;gt; 0
| Subtract 1 from V_3
Add 1 to V_5</p>
<p>

Add 1 to V_11
| B
|-
| V_3 = 0
| None
| A
|}</p>
<p>

where state B is a loop that adds V_3 to V_5 and also moves V_3 to V_11, and state A is an outer control loop that repeats the loop in state B V_2 times. State A also restores the value of V_3 from V_11 after the loop in state B has completed.</p>
<p>

In FRACTRAN the loop in state B can be controlled by state control flags. The state control flags for state B will be V_7 and V_13. Note that we require two state control flags for one loop; a primary flag (V_7) and a secondary flag (V_13). Because each flag is consumed whenever it is tested, we need an secondary flag to say "continue in the current state"; this secondary flag is swapped back to the primary flag in the next instruction, and the loop continues.</p>
<p>

Adding FRACTRAN control flags and instructions to the finite state machine table, we have:</p>
<p>

<indent level="1">

| class="wikitable"
</indent>
|-
! Current State
! FRACTRAN
Control Flags
! Condition
! Action
! Next State
! FRACTRAN
Instructions
|-
| rowspan="4" | A
| rowspan="4" | None
| V_11 &amp;gt; 0
| Subtract 1 from V_11
Add 1 to V_3
| A
| <math>\frac{3}{11}</math>
|-
| V_11 = 0 and
V_2 &amp;gt; 0
| Subtract 1 from V_2
| B
| <math>\frac{7}{2}</math>
|-
| V_11 = 0 and
V_2 = 0 and</p>
<p>

V_3 &amp;gt; 0
| Subtract 1 from V_3
| A
| <math>\frac{1}{3}</math>
|-
| V_11 = 0 and
V_2 = 0 and</p>
<p>

V_3 = 0
| None
| Stop
|
|-
| rowspan="2" | B
| rowspan="2" | V_7, V_13
| V_3 &amp;gt; 0
| Subtract 1 from V_3
Add 1 to V_5</p>
<p>

Add 1 to V_11
| B
| <math>\frac{13}{21}, \frac{385}{13}</math>
|-
| V_3 = 0
| None
| A
| <math>\frac{1}{7}</math>
|}</p>
<p>

When we write out the FRACTRAN instructions, we must put the state A instructions last, because state A has no state control flags. So as a FRACTRAN program, the multiplier becomes:</p>
<p>

<indent level="1">

<math>\frac{13}{21}, \frac{385}{13}, \frac{1}{7}, \frac{3}{11}, \frac{7}{2}, \frac{1}{3}\, ,</math>
</indent>

and input 2<it>a</it> 3<it>b</it> produces output 5<it>ab</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

In a similar way, we can create a FRACTRAN "subtracter", and repeated subtractions allow us to create a "quotient and remainder" algorithm as follows:</p>
<p>

<indent level="1">

| class="wikitable"
</indent>
|-
! Current State
! FRACTRAN
Control Flags
! Condition
! Action
! Next State
! FRACTRAN
Instructions
|-
| rowspan="3" | A
| rowspan="3" | V_11, V_13
| V_2 &amp;gt; 0 and
V_3 &amp;gt; 0
| Subtract 1 from V_2
Subtract 1 from V_3</p>
<p>

Add 1 to V_7
| A
| <math>\frac{91}{66}, \frac{11}{13}</math>
|-
| V_2 = 0 and
V_3 &amp;gt; 0
| Subtract 1 from V_3
| B
| <math>\frac{1}{33}</math>
|-
| V_3 = 0
| None
| C
| <math>\frac{17}{11}</math>
|-
| rowspan="2" | B
| rowspan="2" | None
| V_3 &amp;gt; 0
| Subtract 1 from V_3
| B
| <math>\frac{1}{3}</math>
|-
| V_3 = 0
| None
| Stop
|
|-
| C
| V_17
| 
| Add 1 to V_5
| D
| <math>\frac{95}{17}</math>
|-
| rowspan="2" | D
| rowspan="2" | V_19, V_23
| V_7 &amp;gt; 0
| Subtract 1 from V_7
Add 1 to V_3
| D
| <math>\frac{69}{133}, \frac{19}{23}</math>
|-
| V_7 = 0
| None
| A
| <math>\frac{11}{19}</math>
|}</p>
<p>

Writing out the FRACTRAN program, we have:</p>
<p>

<indent level="1">

<math>\frac{91}{66}, \frac{11}{13}, \frac{1}{33}, \frac{17}{11}, \frac{95}{17}, \frac{69}{133}, \frac{19}{23}, \frac{11}{19}, \frac{1}{3}\, ,</math>
</indent>

and input 2<it>n</it> 3<it>d</it> 11 produces output 5<it>q</it> 7<it>r</it> where <it>n</it> = <it>qd</it> + <it>r</it> and 0 &amp;le; <it>r</it>   <it>d</it>.</p>
<p>

Conway's prime generating algorithm above is essentially a quotient and remainder algorithm within two loops. Given input of the form 2<it>n</it> 7<it>m</it> where 0 &amp;le; <it>m</it>   <it>n</it>, the algorithm tries to divide <it>n</it>+1 by each number from <it>n</it> down to 1, until it finds the largest number <it>k</it> that is a divisor of <it>n</it>+1. It then returns 2<it>n</it>+1 7<it>k</it>-1 and repeats. The only times that the sequence of state numbers generated by the algorithm produces a power of 2 is when <it>k</it> is 1 (so that the exponent of 7 is 0), which only occurs if the exponent of 2 is a prime. A step-by-step explanation of Conway's algorithm can be found in Havil(2007).</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../927/146927.xml">
Unlambda</link></language>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Proposed extensions to FRACTRAN include <weblink xlink:type="simple" xlink:href="http://www.esolangs.org/wiki/Fractran_plus_plus">
FRACTRAN++</weblink> and <weblink xlink:type="simple" xlink:href="http://home.nvg.org/~oerjan/esoteric/bag/">
Bag</weblink>.</entry>
<entry id="2">
This multiplier algorithm is described at the <weblink xlink:type="simple" xlink:href="http://www.esolangs.org/wiki/Fractran">
Esolang FRACTRAN page</weblink>.</entry>
</reflist>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book">Conway, John H.;&#32;Guy, Richard K.&#32;(1996). The Book of Numbers.&#32;Springer-Verlag New York, Inc.. ISBN 038797993X.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book">Havil, Julian&#32;(2007). Nonplussed!.&#32;Princeton University Press. ISBN 0691120560.</cite>&nbsp;</entry>
</list>
</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://scienceblogs.com/goodmath/2006/10/prime_number_pathology_fractra.php">
"Prime Number Pathology: Fractran"</weblink></entry>
<entry level="1" type="bullet">

 "<weblink xlink:type="simple" xlink:href="http://mathworld.wolfram.com/FRACTRAN.html">
FRACTRAN</weblink>".&#32;<it><link xlink:type="simple" xlink:href="../235/374235.xml">
Mathworld</link></it>.&#32;Retrieved on <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
August 10</link>, <link xlink:type="simple" xlink:href="../984/35984.xml">
2005</link>.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://brainwagon.org/?p=2207">
<it>Prime Number Pathology''</it></weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.esolangs.org/wiki/Fractran">
FRACTRAN</weblink> -(Esolang wiki)</entry>
</list>
</p>





</sec>
</bdy>
</language>
</article>
