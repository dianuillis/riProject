<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:27:34[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Schönhage-Strassen algorithm</title>
<id>1354446</id>
<revision>
<id>240783118</id>
<timestamp>2008-09-24T23:47:45Z</timestamp>
<contributor>
<username>Dcoetzee</username>
<id>13476</id>
</contributor>
</revision>
<categories>
<category>Multiplication</category>
<category>Arbitrary precision algorithms</category>
</categories>
</header>
<bdy>

The <b>Schönhage-Strassen algorithm</b> is an asymptotically fast <link xlink:type="simple" xlink:href="../411/57411.xml">
multiplication algorithm</link> for large <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>s. It was developed by <link>
Arnold Schönhage</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../960/771960.xml">
Volker Strassen</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 in 1971.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> The run-time <link xlink:type="simple" xlink:href="../245/18597245.xml">
bit complexity</link> is, in <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link>, <math>O(N\cdot\log N\cdot\log\log N)</math>, while the <link>
arithmetic complexity</link> is <math>O(N \cdot \log N)</math>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> The algorithm uses recursive <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/11512.xml">
Fast Fourier transform</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s in <link xlink:type="simple" xlink:href="../404/48404.xml">
rings</link> with <math>2^{2^n}+1</math> elements, a specific type of <link>
number theoretic transform</link>.<p>

The Schönhage-Strassen algorithm was the asymptotically fastest multiplication method known from 1971 to 2007 when a new method, <link>
Fürer's algorithm</link>, was announced with lower asymptotic complexity;<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> however, Fürer's algorithm currently only achieves an advantage for astronomically large values and is not used in practice.</p>
<p>

In practice the Schönhage-Strassen algorithm starts to outperform older methods such as <link xlink:type="simple" xlink:href="../589/6395589.xml">
Karatsuba</link> and <link>
Toom–Cook multiplication</link> for numbers beyond <math>2^{2^{15}}</math> to <math>2^{2^{17}}</math> (10,000 to 40,000 decimal digits).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>

<sec>
<st>
Details</st>

<p>

This section explains in detail how Schönhage-Strassen is implemented. It is based primarily on an overview of the method by Crandall and Pomerance in their <it>Prime Numbers: A Computational Perspective</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> Another source for detailed information is <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Knuth</link></scientist>
</person>
's <it>The Art of Computer Programming</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref>
</p>
<ss1>
<st>
 Convolutions </st>

<p>

Suppose we are multiplying two numbers like 123 and 456 using long multiplication with base <it>B</it> digits, but without performing any carrying. The result might look something like this:</p>
<p>

<table width="300">
<row>


<col>
1</col>
<col>
2</col>
<col>
3</col>
</row>
<row>

<col>
&amp;times;</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
</row>
<row>
<col colspan="5"></col>
</row>
<row>


<col>
6</col>
<col>
12</col>
<col>
18</col>
</row>
<row>

<col>
5</col>
<col>
10</col>
<col>
15</col>

</row>
<row>
<col>
4</col>
<col>
8</col>
<col>
12</col>


</row>
<row>
<col colspan="5"></col>
</row>
<row>
<col>
4</col>
<col>
13</col>
<col>
28</col>
<col>
27</col>
<col>
18</col>
</row>
</table>
</p>
<p>

This sequence (4, 13, 28, 27, 18) is called the <it>acyclic</it> or <it>linear convolution</it> of the two original sequences (1,2,3) and (4,5,6). Once you have the acyclic convolution of two sequences, computing the product of the original numbers is easy: you just perform the carrying (for example, in the rightmost column, you'd keep the 8 and add the 1 to the column containing 27). In the example this yields the correct product 56088.</p>
<p>

There are two other types of convolutions that will be useful. Suppose the input sequences have <it>n</it> elements (here 3). Then the acyclic convolution has 2<it>n</it>&amp;minus;1 elements; if we take the rightmost <it>n</it> elements and add the leftmost <it>n</it>&amp;minus;1 elements, this produces the cyclic convolution:</p>
<p>

<table width="300">
<row>

<col>
28</col>
<col>
27</col>
<col>
18</col>
</row>
<row>
<col>
+</col>

<col>
4</col>
<col>
13</col>
</row>
<row>
<col colspan="5"></col>
</row>
<row>

<col>
28</col>
<col>
31</col>
<col>
31</col>
</row>
</table>
</p>
<p>

If we perform carrying on the cyclic convolution, the result is equivalent to the product of the inputs mod B<it>n</it>&nbsp;&amp;minus;&nbsp;1. In the example, 103&nbsp;&amp;minus;&nbsp;1 = 999, performing carrying on (28, 31, 31) yields 3141, and 3141 &amp;equiv; 56088 (mod 999).</p>
<p>

Conversely, if we take the rightmost <it>n</it> elements and <it>subtract</it> the leftmost <it>n</it>&amp;minus;1 elements, this produces the <it>negacyclic convolution</it>:</p>
<p>

<table width="300">
<row>

<col>
28</col>
<col>
27</col>
<col>
18</col>
</row>
<row>
<col>
&amp;minus;</col>

<col>
4</col>
<col>
13</col>
</row>
<row>
<col colspan="5"></col>
</row>
<row>

<col>
28</col>
<col>
23</col>
<col>
5</col>
</row>
</table>
</p>
<p>

If we perform carrying on the cyclic convolution, the result is equivalent to the product of the inputs mod B<it>n</it>&nbsp;+&nbsp;1. In the example, 103&nbsp;+&nbsp;1 = 1001, performing carrying on (28, 23, 5) yields 3035, and 3035 &amp;equiv; 56088 (mod 1001). The negacyclic convolution can contain negative numbers, which can be eliminated during carrying using borrowing, as is done in long subtraction.</p>

</ss1>
<ss1>
<st>
 Convolution theorem </st>

<p>

Like other <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link>
multiplication methods based on the Fast Fourier transform</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, Schönhage-Strassen depends fundamentally on the <link xlink:type="simple" xlink:href="../268/53268.xml">
convolution theorem</link>, which provides an efficient way to compute the cyclic convolution of two sequences. It states that:</p>
<p>

<indent level="1">

The cyclic convolution of two vectors can be found by taking the <link xlink:type="simple" xlink:href="../811/8811.xml">
discrete Fourier transform</link> (DFT) of each of them, multiplying the resulting vectors element by element, and then taking the inverse discrete Fourier transform (IDFT).
</indent>

Or in symbols:</p>
<p>

<indent level="1">

CyclicConvolution(X, Y) = IDFT(DFT(X) &middot; DFT(Y))
</indent>

If we compute the DFT and IDFT using a <link xlink:type="simple" xlink:href="../512/11512.xml">
fast Fourier transform</link> algorithm, and invoke our multiplication algorithm recursively to multiply the entries of the transformed vectors DFT(X) and DFT(Y), this yields an efficient algorithm for computing the cyclic convolution.</p>
<p>

In this algorithm, it will be more useful to compute the <it>negacyclic</it> convolution; as it turns out, a slightly modified version of the convolution theorem can enable this as well. Suppose the vectors X and Y have length <it>n</it>, and <it>a</it> is a primitive root of unity of order 2<it>n</it> (that is, <it>a</it>2<it>n</it> = 1 and <it>a</it> to all smaller powers is not 1). Then we can define a third vector A, called the <it>weight vector</it>, as:</p>
<p>

<indent level="1">

A = (<it>aj</it>), 0 &amp;le; <it>j</it>  <it>n</it>
</indent>
:A-1 = (<it>a-j</it>), 0 &amp;le; <it>j</it>  <it>n</it></p>
<p>

Now, we can state:</p>
<p>

<indent level="1">

NegacyclicConvolution(X, Y) = A-1 &middot; IDFT(DFT(A &middot; X) &middot; DFT(A &middot; Y))
</indent>

In other words, it's the same as before except that the inputs are first multiplied by A, and the result is multiplied by A-1.</p>

</ss1>
<ss1>
<st>
 Choice of ring </st>

<p>

The discrete Fourier transform is an abstract operation that can be performed in any <link xlink:type="simple" xlink:href="../404/48404.xml">
algebraic ring</link>; typically it's performed in the complex numbers, but actually performing complex arithmetic to sufficient precision to ensure accurate results for multiplication is slow and error-prone. Instead, we will use the approach of the <link>
number theoretic transform</link>, which is to perform the transform in the integers mod N for some integer N. Just like there are primitive roots of unity of every order in the complex plane, given any order <it>n</it> we can choose a suitable N such that <it>b</it> is a primitive root of unity of order <it>n</it> in the integers mod N (in other words, <it>bn</it> &amp;equiv; 1 (mod N), and no smaller power of <it>b</it> is equivalent to 1 mod N).</p>
<p>

The algorithm will spend most of its time performing recursive multiplications of smaller numbers; with a naive algorithm, these occur in a number of places:</p>
<p>

<list>
<entry level="1" type="number">

 Inside the fast Fourier transform algorithm, where the primitive root of unity <it>b</it> is repeatedly powered, squared, and multiplied by other values.</entry>
<entry level="1" type="number">

 When taking powers of the primitive root of unity <it>a</it> to form the weight vector A and when multiplying A or A-1 by other vectors.</entry>
<entry level="1" type="number">

 When performing element-by-element multiplication of the transformed vectors.</entry>
</list>
</p>
<p>

The key insight to Schönhage-Strassen is to choose N, the modulus, to be equal to 2<it>n</it>&nbsp;+&nbsp;1 for some integer <it>n</it>. This has a number of benefits in standard systems that represent large integers in binary form:</p>
<p>

<list>
<entry level="1" type="bullet">

 Any value can be rapidly reduced modulo 2<it>n</it>&nbsp;+&nbsp;1 using only shifts and adds, as explained in the next section.</entry>
<entry level="1" type="bullet">

 All primitive roots of unity in this ring can be written in the form 2<it>k</it>; consequently we can multiply or divide any number by a root of unity using a shift, and power or square a root of unity by operating only on its exponent.</entry>
<entry level="1" type="bullet">

 The element-by-element recursive multiplications of the transformed vectors can be performed using a negacyclic convolution, which is faster than an acyclic convolution and already has "for free" the effect of reducing its result mod 2<it>n</it>&nbsp;+&nbsp;1.</entry>
</list>
</p>
<p>

To make the recursive multiplications convenient, we will frame Schönhage-Strassen as being a specialized multiplication algorithm for computing not just the product of two numbers, but the product of two numbers mod 2n&nbsp;+&nbsp;1 for some given <it>n</it>. This is not a loss of generality, since one can always choose <it>n</it> large enough so that the product mod 2n&nbsp;+&nbsp;1 is simply the product.</p>

</ss1>
<ss1>
<st>
 Shift optimizations </st>

<p>

In the course of the algorithm, there are many cases in which multiplication or division by a power of two (including all roots of unity) can be profitably replaced by a small number of shifts and adds. This makes use of the observation that:</p>
<p>

<indent level="1">

2<it>n</it> &amp;equiv; &amp;minus;1 (mod 2<it>n</it> + 1)
</indent>

This makes it simple to reduce a number represented in binary mod 2<it>n</it>&nbsp;+&nbsp;1: take the rightmost (least significant) <it>n</it> bits, subtract the next <it>n</it> bits, add the next <it>n</it> bits, and so on until the bits are exhausted. If the resulting value is still not between 0 and 2<it>n</it>, normalize it by adding or subtracting a multiple of the modulus 2<it>n</it>&nbsp;+&nbsp;1. For example, if <it>n</it>=3 (and so the modulus is 23+1 = 9) and the number being reduced is 656, we have:</p>
<p>

<indent level="1">

656 = 10100100002 &amp;equiv; 0002 - 0102 + 0102 - 12 = 0 - 2 + 2 - 1 = &amp;minus;1 &amp;equiv; 8 (mod 23 + 1).
</indent>

Moreover, it's possible to effect very large shifts without ever constructing the shifted result. Suppose we have a number A between 0 and 2<it>n</it>, and wish to multiply it by 2<it>k</it>. Dividing <it>k</it> by <it>n</it> we find <it>k</it> = <it>qn</it> + <it>r</it> with <it>r</it>  <it>n</it>. It follows that:</p>
<p>

<indent level="1">

A(2<it>k</it>) = A(2<it>qn</it> + <it>r</it>) = A[(2''n'')''q''(2''r'')] &amp;equiv; (&amp;minus;1)<it>q</it>(A shift-left <it>r</it>) (mod 2<it>n</it> + 1).
</indent>

Since A is &amp;le; 2<it>n</it> and <it>r</it>  <it>n</it>, A shift-left <it>r</it> has at most 2<it>n</it>&amp;minus;1 bits, and so only one shift and subtraction (followed by normalization) is needed.</p>
<p>

Finally, to divide by 2<it>k</it>, observe that squaring the first equivalence above yields:</p>
<p>

<indent level="1">

22<it>n</it> &amp;equiv; 1 (mod 2<it>n</it> + 1)
</indent>

Hence,</p>
<p>

<indent level="1">

A/2<it>k</it> = A(2&amp;minus;<it>k</it>) &amp;equiv; A(22<it>n</it> &amp;minus; <it>k</it>) = A shift-left (2<it>n</it> &amp;minus; <it>k</it>) (mod 2<it>n</it> + 1).
</indent>

</p>
</ss1>
<ss1>
<st>
 Overview </st>

<p>

Given an input numbers <it>x</it> and <it>y</it>, and an integer <it>N</it>, the following algorithm computes <it>xy</it> mod 2<it>N</it>&nbsp;+&nbsp;1:</p>
<p>

<list>
<entry level="1" type="number">

 Split each input number into vectors X and Y of 2<it>k</it> parts each, where 2<it>k</it> divides <it>N</it>. (e.g. 12345678 -&amp;gt; (12, 34, 56, 78)).</entry>
<entry level="1" type="number">

 In order to make progress, it's necessary to use a smaller <it>N</it> for recursive multiplications. For this purpose choose <it>n</it> as the smallest integer at least 2<it>n</it>/2<it>k</it> + <it>k</it> and divisible by 2<it>k</it>.</entry>
<entry level="1" type="number">

 Compute the product of X and Y mod 2<it>n</it>&nbsp;+&nbsp;1 using the negacyclic convolution:</entry>
<entry level="2" type="number">

 Multiply X and Y each by the weight vector using shifts (shift the <it>j</it>th entry left by <it>jn</it>/2<it>k</it>).</entry>
<entry level="2" type="number">

 Compute the DFT of X and Y using the number-theoretic FFT (perform all multiplies using shifts; for the 2<it>k</it>-th root of unity, use 22<it>n</it>/2<it>k</it>).</entry>
<entry level="2" type="number">

 Recursively apply this algorithm to multiply corresponding elements of the transformed X and Y.</entry>
<entry level="2" type="number">

 Compute the IDFT of the resulting vector to get the result vector C (perform all multiplies using shifts).</entry>
<entry level="2" type="number">

 Multiply the result vector C by A-1 using shifts.</entry>
<entry level="2" type="number">

 Adjust signs: some elements of the result may be negative. We compute the largest possible positive value for the <it>j</it>th element of C, (j + 1)22N/2<it>k</it>, and if it exceeds this we subtract the modulus 2<it>n</it>&nbsp;+&nbsp;1.</entry>
<entry level="1" type="number">

 Finally, perform carrying mod 2N+1 to get the final result.</entry>
</list>
</p>
<p>

In step 2, the observation is used that:
<list>
<entry level="1" type="bullet">

 Each element of the input vectors has at most <it>n</it>/2<it>k</it> bits;</entry>
<entry level="1" type="bullet">

 The product of any two input vector elements has at most 2<it>n</it>/2<it>k</it> bits;</entry>
<entry level="1" type="bullet">

 Each element of the convolution is the sum of at most 2<it>k</it> such products, and so cannot exceed 2<it>n</it>/2<it>k</it> + <it>k</it> bits.</entry>
<entry level="1" type="bullet">

 <it>n</it> must be divisible by 2<it>k</it> to ensure that in the recursive calls the condition "2<it>k</it> divides <it>N</it>" holds in step 1.</entry>
</list>
</p>
<p>

The parameter <it>k</it> is fixed and in practice is typically set to a small value such as 5, 6, or 7, depending on the size of the input numbers.</p>


</ss1>
</sec>
<sec>
<st>
 Optimizations </st>

<p>

This section explains a number of important practical optimizations that have been considered when implementing Schönhage-Strassen in real systems. It is based primarily on a 2007 work by Gaudry, Kruppa, and Zimmermann describing enhancements to the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../126/483126.xml">
GNU Multi-Precision Library</link></software>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></p>
<p>

Below a certain cutoff point, it's more efficient to perform the recursive multiplications using other algorithms, such as <link>
Toom–Cook multiplication</link>. The results must be reduced mod 2<it>n</it>&nbsp;+&nbsp;1, which can be done efficiently as explained above with shifts and adds/subtracts.</p>
<p>

Computing the IDFT involves dividing each entry by the primitive root of unity 22<it>n</it>/2<it>k</it>, an operation that is frequently combined with multiplying the vector by A-1 afterwards, since both involve division by a power of two.</p>
<p>

In a system where a large number is represented as an array of 2<it>w</it>-bit words, it's useful to ensure that the vector size 2<it>k</it> is also a multiple of the bits per word by choosing <it>k</it> &amp;ge; <it>w</it>; this allows the inputs to be broken up into pieces without bit shifts, and provides a uniform representation for values mod 2<it>n</it>&nbsp;+&nbsp;1 where the high word can only be zero or one.</p>
<p>

Normalization involves adding or subtracting the modulus 2<it>n</it>+1; this value has only two bits set, which means this can be done in constant time on average with a specialized operation.</p>
<p>

Iterative FFT algorithms such as the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/352702.xml">
Cooley-Tukey FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, although frequently used for FFTs on vectors of complex numbers, tend to exhibit very poor cache <link xlink:type="simple" xlink:href="../028/64028.xml">
locality</link> with the large vector entries used in Schönhage-Strassen. The straightforward recursive, not in-place implementation of FFT is more successful, with all operations fitting in the cache beyond a certain point in the call depth, but still makes suboptimal use of the cache in higher call depths. Gaudry, Kruppa, and Zimmerman used a technique combining Bailey's 4-step algorithm with higher radix transforms that combine multiple recursive steps. They also mix phases, going as far into the algorithm as possible on each element of the vector before moving on to the next one.</p>
<p>

The "square root of 2 trick", first described by Schönhage, is to note that, provided <it>k</it> &amp;ge; 2, 23<it>n</it>/4&amp;minus;2<it>n</it>/4 is a square root of 2 mod 2<it>n</it>+1, and so a 4<it>n</it>-th root of unity (since 22<it>n</it> &amp;equiv; 1). This allows the transform length to be extended from 2<it>k</it> to 2<it>k</it> + 1.</p>
<p>

Finally, the authors are careful to choose the right value of <it>k</it> for different ranges of input numbers, noting that the optimal value of <it>k</it> may go back and forth between the same values several times as the input size increases.</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
A. Schönhage and V. Strassen, "Schnelle Multiplikation großer Zahlen", <it>Computing</it> <b>7</b> (1971), pp. 281–292.</entry>
<entry id="2">
Peter Bürgisser, Michael Clausen and <link>
Amin Shokrollahi</link>, Algebraic Complexity Theory, 1997. Springer-Verlag, ISBN 3540605827.</entry>
<entry id="3">
Martin Fürer, "<weblink xlink:type="simple" xlink:href="http://www.cse.psu.edu/~furer/Papers/mult.pdf">
Faster integer multiplication</weblink>", STOC 2007 Proceedings, pp. 57-66.</entry>
<entry id="4">
Rodney Van Meter and Kohei M. Itoh, "<weblink xlink:type="simple" xlink:href="http://www.appi.keio.ac.jp/Itoh_group/publications/PhysRevA_71_052320.pdf">
Fast quantum modular exponentiation</weblink>", <it>Physical Review</it> A, Vol. 71 (2005).</entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://magma.maths.usyd.edu.au/magma/Features/node86.html">
Overview of Magma V2.9 Features, arithmetic section</weblink>: Discusses practical crossover points between various algorithms.</entry>
<entry id="6">
Luis Carlos Coronado García, "<weblink xlink:type="simple" xlink:href="http://www.cdc.informatik.tu-darmstadt.de/~coronado/Vortrag/MoraviaCrypt-talk-s.pdf">
 Can Schönhage multiplication speed up the RSA encryption or decryption?</weblink>", <it>University of Technology, Darmstadt</it> (2005)</entry>
<entry id="7">
R. Crandall &amp; C. Pomerance. <it>Prime Numbers - A Computational Perspective</it>. Second Edition, Springer, 2005. Section 9.5.6: Schönhage method, pg.459. ISBN 0-387-94777-9</entry>
<entry id="8">
Donald E. Knuth, <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, Volume 2: Seminumerical Algorithms (3rd Edition), 1997. Addison-Wesley Professional, ISBN 0201896842. Section 4.3.3.C: Discrete Fourier transforms, pg.305.</entry>
<entry id="9">
Pierrick Gaudry, Alexander Kruppa, and Paul Zimmermann. <weblink xlink:type="simple" xlink:href="http://www.loria.fr/~gaudry/publis/issac07.pdf">
A GMP-based Implementation of Schönhage-Strassen’s Large Integer Multiplication Algorithm</weblink>. Proceedings of the 2007 International Symposium on Symbolic and Algebraic Computation, pp.167&ndash;174.</entry>
</reflist>
</p>


</sec>
</bdy>
</algorithm>
</article>
