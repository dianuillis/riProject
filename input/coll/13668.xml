<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:27:01[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Halting problem</title>
<id>13668</id>
<revision>
<id>244365649</id>
<timestamp>2008-10-10T13:21:31Z</timestamp>
<contributor>
<username>PiracyFundsTerrorism</username>
<id>7717405</id>
</contributor>
</revision>
<categories>
<category>Theory of computation</category>
<category>Recursion theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../136/442136.xml">
computability theory</link>, the <b>halting problem</b> is a <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link> which can be stated as follows: given a description of a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link> and a finite input, decide whether the program finishes running or will run forever, given that input.<p>

<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
 proved in 1936 that a general <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> to solve the halting problem for <it>all</it> possible program-input pairs cannot exist. We say that the halting problem is <it><link xlink:type="simple" xlink:href="../795/54795.xml">
undecidable</link></it> over <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s.
Copeland (2004) attributes the actual term <it>halting problem</it> to <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

<sec>
<st>
Formal statement</st>
<p>

The halting problem is a <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link> about properties of computer programs on a fixed <link xlink:type="simple" xlink:href="../621/30621.xml">
Turing-complete</link> model of computation. The question is, given a program and an input to the program, whether the program will eventually halt when run with that input. In this abstract framework, there are no resource limitations of memory or time on the program's execution; it can take arbitrarily long, and use arbitrarily much storage space, before halting. The question is simply whether the given program will ever halt on a particular input.  </p>
<p>

For example, in <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>, the program </p>
<p>

<indent level="1">

while True: continue
</indent>

does not halt; rather, it goes on forever in an <link xlink:type="simple" xlink:href="../273/45273.xml">
infinite loop</link>. On the other hand, the program</p>
<p>

<indent level="1">

print "Hello World!"
</indent>

halts very quickly.</p>
<p>

The halting problem is famous because it was one of the first problems proved undecidable, which means there is no computer program capable of correctly answering the question for all possible inputs. </p>

<ss1>
<st>
 Representing the halting problem as a set </st>
<p>

Decision problems are conventionally represented by the set of objects that do have the property in question. The <b>halting set</b>
<indent level="1">

 <it>K</it> := { (i, x) | program <it>i</it> will eventually halt if run with input <it>x</it>}
</indent>
represents the halting problem. </p>
<p>

This set is <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable</link>, which means there is a computable function that lists all of the pairs (<it>i</it>,<it>x</it>) it contains. This computable function simulates all programs on all inputs in parallel, in a manner similar to a multithreaded computer program, and notices whenever one of the programs being simulated halts. </p>
<p>

There are many equivalent formulations of the halting problem; any set whose <link xlink:type="simple" xlink:href="../405/764405.xml">
Turing degree</link> is the same as that of the halting problem can be thought of as such a formulation.  Examples of such sets include:
<list>
<entry level="1" type="bullet">

{ <it>i</it> | program <it>i</it> eventually halts when run with input 0 }</entry>
<entry level="1" type="bullet">

{ <it>i</it> | there is any input <it>x</it> such that program <it>i</it> eventually halts when run with input <it>x</it> }</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Importance and consequences</st>
<p>

The historical importance of the halting problem lies in the fact that it was one of the first problems to be proved <link xlink:type="simple" xlink:href="../795/54795.xml">
undecidable</link>. (Turing's proof went to press in May 1936, whereas <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Church</link></scientist>
's proof of the undecidability of a problem in the <link xlink:type="simple" xlink:href="../203/18203.xml">
lambda calculus</link> had already been published in April 1936.) Subsequently, many other such problems have been described; the typical method of proving a problem to be undecidable is with the technique of <it><link xlink:type="simple" xlink:href="../067/848067.xml">
reduction</link></it>.  To do this, the computer scientist shows that if a solution to the new problem were found, it could be used to decide an undecidable problem (by transforming instances of the undecidable problem into instances of the new problem).  Since we already know that <it>no</it> method can decide the old problem, no method can decide the new problem either.</p>
<p>

One such consequence of the halting problem's undecidability is that there cannot be a general <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that decides whether a given statement about <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s is true or not. The reason for this is that the <link xlink:type="simple" xlink:href="../094/81094.xml">
proposition</link> stating that a certain algorithm will halt given a certain input can be converted into an equivalent statement about natural numbers. If we had an algorithm that could solve every statement about natural numbers, it could certainly solve this one; but that would determine whether the original program halts, which is impossible, since the halting problem is undecidable.</p>
<p>

Yet another consequence of the undecidability of the halting problem is <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../852/25852.xml">
Rice's theorem</link></proposition>
</theorem>
</message>
</statement>
 which states that the truth of <it>any</it> <link xlink:type="simple" xlink:href="../053/193053.xml">
non-trivial</link> statement about the function that is defined by an algorithm is undecidable. So, for example, the decision problem "will this algorithm halt for the input 0" is already undecidable. Note that this theorem holds for the <it>function defined by the algorithm</it> and not the algorithm itself. It is, for example, quite possible to decide if an algorithm will halt within 100 steps, but this is not a statement about the function that is defined by the algorithm.</p>
<p>

<person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../308/12308.xml">
Gregory Chaitin</link></person>
 has defined a <link xlink:type="simple" xlink:href="../205/6205.xml">
halting probability</link>, represented by the symbol Ω, a type of real number that informally is said to represent the <link xlink:type="simple" xlink:href="../934/22934.xml">
probability</link> that a randomly produced program halts.  These numbers have the same <link xlink:type="simple" xlink:href="../405/764405.xml">
Turing degree</link> as the halting problem. It is a <link xlink:type="simple" xlink:href="../277/204277.xml">
normal</link> and <link xlink:type="simple" xlink:href="../325/30325.xml">
transcendental number</link> which can be <link xlink:type="simple" xlink:href="../361/8361.xml">
defined</link> but cannot be completely <link xlink:type="simple" xlink:href="../206/6206.xml">
computed</link>. This means one can prove that there is no <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> which produces the digits of Ω, although its first few digits can be calculated in simple cases.</p>
<p>

While Turing's proof shows that there can be no general method or algorithm to determine whether algorithms halt, individual instances of that problem may very well be susceptible to attack. Given a specific algorithm, one can often show that it must halt for any input, and in fact <link xlink:type="simple" xlink:href="../784/328784.xml">
computer scientist</link>s often do just that as part of a <link xlink:type="simple" xlink:href="../339/357339.xml">
correctness proof</link>. But each proof has to be developed specifically for the algorithm at hand; there is no <it>mechanical, general way</it> to determine whether algorithms on a Turing machine halt. However, there are some <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristics</link> that can be used in an automated fashion to attempt to construct a proof, which succeed frequently on typical programs. This field of research is known as automated <link xlink:type="simple" xlink:href="../658/6782658.xml">
termination analysis</link>.  </p>
<p>

Turing's introduction of the machine model that has become known as the <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
, introduced in the paper, has proven a convenient model for much <link xlink:type="simple" xlink:href="../392/323392.xml">
theoretical computer science</link> since.</p>

</sec>
<sec>
<st>
Sketch of proof</st>
<p>

The proof shows there is no <link xlink:type="simple" xlink:href="../577/23577.xml">
total</link> <link xlink:type="simple" xlink:href="../338/1139338.xml">
computable function</link> that decides whether an arbitrary program <it>i</it> halts on arbitrary input <it>x</it>; that is, the following function <it>h</it> is not computable:
<indent level="1">

<math>h(i,x) =
\begin{cases}
  1 &amp; \mbox{if } \mbox{  program }i\mbox{ halts on input }x, \\
  0 &amp; \mbox{otherwise.}
\end{cases}</math>
</indent>
Here <it>program i</it> refers to the <it>i</it> th program in an <link xlink:type="simple" xlink:href="../115/212115.xml">
enumeration</link> of all the programs of a fixed <link xlink:type="simple" xlink:href="../621/30621.xml">
Turing-complete</link> model of computation. </p>
<p>

The proof proceeds by directly establishing that every total computable function with two arguments differs from the required function <it>h</it>.  To this end, given any total computable binary function <it>f</it>, the following <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link> <it>g</it> is also computable:
<indent level="1">

<math>g(i) =
\begin{cases} 
  0  &amp; \mbox{if } f(i,i) = 0,\\
  \mbox{undefined} &amp; \mbox{otherwise.} 
\end{cases}</math>
</indent>
The following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link> illustrates a straightforward way to compute <it>g</it>:</p>
<p>

<b>procedure</b> compute_g(i):
<b>if</b> f(i,i) == 0 <b>then</b>
<b>return</b> 0
<b>else</b>
<b>loop forever</b></p>

<p>

Because <it>g</it> is partial computable, there must be a program that computes <it>g</it> by the assumption that the model is Turing-complete. This program is one of all the programs on which the halting function <it>h</it> is defined, so let its enumeration index be denoted <it>e</it>. </p>
<p>

It follows from the definition of <it>g</it> that exactly one of the following two cases must hold:
<list>
<entry level="1" type="bullet">

 <it>g</it>(<it>e</it>) = <it>f</it>(<it>e</it>,<it>e</it>) = 0. In this case <it>h</it>(<it>e</it>,<it>e</it>) = 1,  because program <it>e</it> halts on input <it>e</it>. </entry>
<entry level="1" type="bullet">

 <it>g</it>(<it>e</it>) is undefined and <it>f</it>(<it>e</it>,<it>e</it>) ≠ 0. In this case <it>h</it>(<it>e</it>,<it>e</it>) = 0,  because program <it>e</it> does not halt on input <it>e</it>.</entry>
</list>

In either case, <it>f</it> cannot be the same function as <it>h</it>. Because <it>f</it> was an <it>arbitrary</it> total computable function with two arguments, all such functions must differ from <it>h</it>.</p>
<p>

The verification that <it>g</it> is computable relies on the following constructs (or their equivalents):
<list>
<entry level="1" type="bullet">

 computable subprograms (the program that computes <it>f</it> is a subprogram in program <it>e</it>),</entry>
<entry level="1" type="bullet">

 duplication of values (program <it>e</it> computes the inputs <it>i</it>,<it>i</it> for <it>f</it> from the input <it>i</it> for <it>g</it>),</entry>
<entry level="1" type="bullet">

 conditional branching (program <it>e</it> selects between two results depending on the value it computes for <it>f</it>(<it>i</it>,<it>i</it>)),</entry>
<entry level="1" type="bullet">

 not producing a defined result (for example, by looping forever), </entry>
<entry level="1" type="bullet">

 returning a value of 0.</entry>
</list>
</p>


<p>

<table style="padding-bottom: 0.5em; margin-bottom: 0em; margin-top: 1em;" class="wikitable">
<row style="font-size:9pt" align="center" valign="bottom">
<col colspan="2" style="vertical-align: middle;" rowspan="2">
<it>f</it>(<it>i</it>,<it>j</it>)</col>
<col style="background-color:#F2F2F2" width="24.75">
i</col>
<col style="background-color:#F2F2F2" width="24.75">
i</col>
<col style="background-color:#F2F2F2" width="24.75">
i</col>
<col style="background-color:#F2F2F2" width="24.75">
i</col>
<col style="background-color:#F2F2F2" width="24.75">
i</col>
<col style="background-color:#F2F2F2" width="24.75">
i</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2">
1</col>
<col style="background-color:#F2F2F2">
2</col>
<col style="background-color:#F2F2F2">
3</col>
<col style="background-color:#F2F2F2">
4</col>
<col style="background-color:#F2F2F2">
5</col>
<col style="background-color:#F2F2F2">
6</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2" width="18.75" Height="12">
j</col>
<col style="background-color:#F2F2F2">
1</col>
<col style="background-color:#FFC000">
1</col>
<col>
0</col>
<col>
0</col>
<col>
1</col>
<col>
0</col>
<col>
1</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2" Height="12">
j</col>
<col style="background-color:#F2F2F2">
2</col>
<col>
0</col>
<col style="background-color:#FFC000">
0</col>
<col>
0</col>
<col>
1</col>
<col>
0</col>
<col>
0</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2" Height="12">
j</col>
<col style="background-color:#F2F2F2">
3</col>
<col>
0</col>
<col>
1</col>
<col style="background-color:#FFC000">
0</col>
<col>
1</col>
<col>
0</col>
<col>
1</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2" Height="12">
j</col>
<col style="background-color:#F2F2F2">
4</col>
<col>
1</col>
<col>
0</col>
<col>
0</col>
<col style="background-color:#FFC000">
1</col>
<col>
0</col>
<col>
0</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2" Height="12">
j</col>
<col style="background-color:#F2F2F2">
5</col>
<col>
0</col>
<col>
0</col>
<col>
0</col>
<col>
1</col>
<col style="background-color:#FFC000">
1</col>
<col>
1</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="background-color:#F2F2F2" Height="12">
j</col>
<col style="background-color:#F2F2F2">
6</col>
<col>
1</col>
<col>
1</col>
<col>
0</col>
<col>
0</col>
<col>
1</col>
<col style="background-color:#FFC000">
0</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="12"></col>







</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="12"></col>
<col style="background-color:#FFC000">
<it>f</it>(<it>i</it>,<it>i</it>)</col>
<col style="background-color:#FFC000">
1</col>
<col style="background-color:#FFC000">
0</col>
<col style="background-color:#FFC000">
0</col>
<col style="background-color:#FFC000">
1</col>
<col style="background-color:#FFC000">
1</col>
<col style="background-color:#FFC000">
0</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="12"></col>
<col style="background-color:#99FF8B">
<it>g</it>(<it>i</it>)</col>
<col style="background-color:#99FF8B">
U</col>
<col style="background-color:#99FF8B">
0</col>
<col style="background-color:#99FF8B">
0</col>
<col style="background-color:#99FF8B">
U</col>
<col style="background-color:#99FF8B">
U</col>
<col style="background-color:#99FF8B">
0</col>
</row>
</table>
</p>

<p>

Possible values for a total computable function <it>f</it> arranged in a 2D array. The orange cells are the diagonal. The values of <it>f</it>(<it>i</it>,<it>i</it>) and <it>g</it>(<it>i</it>) are shown at the bottom; <it>U</it> indicates that the function <it>g</it> is undefined for a particular input value.</p>
<p>

This proof is typically referred to as a <b>diagonalization proof</b>. One may visualize a two-dimensional array with one column and one row for each natural number. The value of <it>f</it>(<it>i</it>,<it>j</it>) is placed at column <it>i</it>, row <it>j</it>. Because <it>f</it> is assumed to be a total computable function, any element of the array can be calculated using <it>f</it>. The construction of the function <it>g</it> can be visualized using the main diagonal of this array.  If the array has a 0 at position (<it>i</it>,<it>i</it>), then <it>g</it>(<it>i</it>) is 0. Otherwise, <it>g</it>(<it>i</it>) is undefined. The contradiction comes from the fact that there is some column <it>e</it> of the array corresponding to <it>g</it> itself. If <it>f</it> were the halting function <it>h</it>, there would be a 1 at position (<it>e</it>,<it>e</it>) if and only if <it>g</it>(<it>e</it>) is defined. But <it>g</it> is constructed so that <it>g</it>(<it>e</it>) is defined if and only if there is a 0 in position (<it>e</it>,<it>e</it>).</p>

</sec>
<sec>
<st>
Common pitfalls</st>
<p>

The difficulty in the halting problem lies in the requirement that the decision procedure must work for all programs and inputs. Every particular program either halts on a given input or does not halt. Consider one algorithm that always answers "halts" and another that always answers "doesn't halt." For any specific program and input, one of these two algorithms answers correctly, even though nobody may know which one.  </p>
<p>

There are programs (<link xlink:type="simple" xlink:href="../868/59868.xml">
interpreters</link>) that simulate the execution of whatever source code they are given. Such programs can demonstrate that a program does halt if this is the case: the interpreter itself will eventually halt its simulation, which shows that the original program halted. However, an interpreter will not halt if its input program does not halt, so this approach cannot solve the halting problem as stated. It does not successfully answer "doesn't halt" for programs that do not halt. </p>
<p>

The halting problem is, <it>in theory</it> if not in practice, decidable for <link xlink:type="simple" xlink:href="../962/1811962.xml">
linear bounded automata</link> (LBAs), or deterministic machines with finite memory.  A machine with finite memory has a finite number of states, and thus any deterministic program on it must eventually either halt or repeat a previous state:
<indent level="1">

"...<it>any finite-state machine, if left completely to itself, will fall eventually into a perfectly periodic repetitive pattern</it>. The duration of this repeating pattern cannot exceed the number of internal states of the machine..."(italics in original, Minsky 1967, p. 24)
</indent>

Minsky warns us, however, that machines such as computers with e.g. a million small parts, each with two states, will have on the order of 21,000,000 possible states: 
<indent level="1">

"This is a 1 followed by about three hundred thousand zeroes ... Even if such a machine were to operate at the frequencies of cosmic rays, the aeons of galactic evolution would be as nothing compared to the time of a journey through such a cycle" (Minsky p. 25)
</indent>

Minsky exhorts the reader to be suspicious -- although a machine may be finite, and finite automata "have a number of theoretical limitations":
<indent level="1">

"...the magnitudes involved should lead one to suspect that theorems and arguments based chiefly on the mere finiteness [of] the state diagram may not carry a great deal of significance" (ibid).
</indent>

For more on this issue of "intractability" see the article <link xlink:type="simple" xlink:href="../911/67911.xml">
Busy beaver</link>.</p>
<p>

It can also be decided automatically whether a nondeterministic machine with finite memory halts on no, some, or all possible sequences of nondeterministic decisions, by enumerating states after each possible decision.</p>

</sec>
<sec>
<st>
Formalization of the halting problem</st>
<p>

In his original proof Turing formalized the concept of <it><link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link></it> by introducing <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s.  However, the result is in no way specific to them; it applies equally to any other model of <link xlink:type="simple" xlink:href="../926/5926.xml">
computation</link> that is equivalent in its computational power to Turing machines, such as <link xlink:type="simple" xlink:href="../156/198156.xml">
Markov algorithm</link>s, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../203/18203.xml">
Lambda calculus</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
, <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post system</link>s, <link xlink:type="simple" xlink:href="../218/505218.xml">
register machine</link>s, or <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link>
tag systems</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
.</p>
<p>

What is important is that the formalization allows a straightforward <link xlink:type="simple" xlink:href="../937/18937.xml">
mapping</link> of algorithms to some <link xlink:type="simple" xlink:href="../817/93817.xml">
data type</link> that the <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> can operate upon.  For example, if the <link xlink:type="simple" xlink:href="../700/13447700.xml">
formalism</link> lets algorithms define functions over strings (such as Turing machines) then there should be a mapping of these algorithms to strings, and if the formalism lets algorithms define functions over natural numbers (such as <link xlink:type="simple" xlink:href="../338/1139338.xml">
computable function</link>s) then there should be a mapping of algorithms to natural numbers. The mapping to strings is usually the most straightforward, but strings over an <link xlink:type="simple" xlink:href="../670/670.xml">
alphabet</link> with <it>n</it> <link xlink:type="simple" xlink:href="../443/73443.xml">
characters</link> can also be mapped to numbers by interpreting them as numbers in an <it>n</it>-ary <link xlink:type="simple" xlink:href="../170/21170.xml">
numeral system</link>.</p>

</sec>
<sec>
<st>
Relationship with Gödel's incompleteness theorem</st>
<p>

The <link xlink:type="simple" xlink:href="../978/6978.xml">
concept</link>s raised by <link>
Gödel's incompleteness theorem</link>s are very similar to those raised by the halting problem, and the proofs are quite similar.  In fact, a weaker form of the First Incompleteness Theorem is an easy consequence of the undecidability of the halting problem. This weaker form differs from the standard statement of the incompleteness theorem by asserting that a complete, <link xlink:type="simple" xlink:href="../802/75802.xml">
consistent</link> and <link xlink:type="simple" xlink:href="../819/26819.xml">
sound</link> <link xlink:type="simple" xlink:href="../401/188401.xml">
axiomatization</link> of all statements about natural numbers is unachievable. The "sound" part is the weakening: it means that we require the axiomatic system in question to prove only <it>true</it> statements about natural numbers (it's very important to observe that the statement of the standard form of Gödel's First Incompleteness Theorem is completely unconcerned with the question of truth, but only concerns the issue of whether it can be <link xlink:type="simple" xlink:href="../285/82285.xml">
proven</link>).</p>
<p>

The weaker form of the theorem can be proved from the undecidability of the halting problem as follows. Assume that we have a consistent and complete <link xlink:type="simple" xlink:href="../401/188401.xml">
axiomatization</link> of all true <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link> statements about <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s. Then we can build an algorithm that enumerates all these statements. This means that there is an algorithm <it>N</it>(<it>n</it>) that, given a natural number <it>n</it>, computes a true first-order logic statement about natural numbers such that, for all the true statements, there is at least one <it>n</it> such that <it>N</it>(<it>n</it>) yields that statement. Now suppose we want to decide if the algorithm with representation <it>a</it> halts on input <it>i</it>.  We know that this statement can be expressed with a first-order logic statement, say <it>H</it>(<it>a</it>, <it>i</it>).  Since the axiomatization is complete it follows that either there is an <it>n</it> such that <it>N</it>(<it>n</it>) =  <it>H</it>(<it>a</it>, <it>i</it>) or there is an <it>n&#39;</it> such that <it>N</it>(<it>n&#39;</it>) = ¬ <it>H</it>(<it>a</it>, <it>i</it>).  So if we <link xlink:type="simple" xlink:href="../833/68833.xml">
iterate</link> over all <it>n</it> until we either find <it>H</it>(<it>a</it>, <it>i</it>) or its negation, we will always halt. This means that this gives us an algorithm to decide the halting problem. Since we know that there cannot be such an algorithm, it follows that the assumption that there is a consistent and complete axiomatization of all true first-order logic statements about natural numbers must be false.</p>

</sec>
<sec>
<st>
Recognizing partial solutions</st>
<p>

There are many programs that either return a correct answer to the halting problem or do not return an answer at all. If it were possible to decide whether a program gives only correct answers, one might hope to collect a large number of such programs and run them in parallel, in the hope of being able to determine whether any programs halt. However, recognizing such partial halting solvers (PHS) is just as hard as the halting problem itself.</p>
<p>

Suppose someone claims that program PHSR is a partial halting solver recognizer. Construct a program H:
input a program P
X := "input Q. <b>if</b> Q = P output 'halts' <b>else</b> loop forever"
run PHSR with X as input</p>
<p>

If PHSR recognizes the constructed program X as a partial halting solver, that means that P, the only input for which X produces a result, halts. If PHSR fails to recognize X, then it must be because P does not halt. Therefore H can decide whether an arbitrary program P halts; it solves the halting problem. Since this is impossible, the program PHSR could not have been a partial halting solver recognizer as claimed. Therefore no program can be a partial halting solver recognizer.</p>
<p>

Another example, <it>HT</it>, of a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 which gives correct answers only for <it>some</it> instances of the halting problem can be described by the requirements that, if <it>HT</it> is started scanning a field which carries the first of a finite string of <it>a</it> consecutive "1"s, followed by one field with symbol "0" (i.&nbsp;e. a blank field), and followed in turn by a finite string of <it>i</it> consecutive "1"s, on an otherwise blank tape, then
<list>
<entry level="1" type="bullet">

 <it>HT</it> halts for any such starting state, i.&nbsp;e. for any input of finite positive integers <it>a</it> and <it>i</it>;</entry>
<entry level="1" type="bullet">

 <it>HT</it> halts  on a completely <it>blank</it> tape if and only if the Turing machine represented by <it>a</it> does not halt when given the starting state and input represented by <it>i</it>; and </entry>
<entry level="1" type="bullet">

 <it>HT</it> halts on a <it>nonblank</it> tape, scanning an appropriate field (which however does not necessarily carry the symbol "1") if and only if the Turing machine represented by <it>a</it> does halt when given the starting state and input represented by <it>i</it>. In this case, the final state in which <it>HT</it> halted (contents of the tape, and field being scanned) shall be equal to some particular intermediate state which the Turing machine represented by <it>a</it> attains when given the starting state and input represented by <it>i</it>; or, if all those intermediate states (including the starting state represented by <it>i</it>) leave the tape blank, then the final state in which <it>HT</it> halted shall be scanning a "1" on an otherwise blank tape. </entry>
</list>

While its existence has not been refuted (essentially: because there's no Turing machine which would halt <it>only</it> if started on a blank tape), such a Turing machine <it>HT</it> would solve the halting problem only <it>partially</it> either (because it doesn't necessarily scan the symbol "1" in the final state, if the Turing machine represented by <it>a</it> does halt when given the starting state and input represented by <it>i</it>, as explicit statements of the halting problem for Turing machines may require).</p>

</sec>
<sec>
<st>
History of the halting problem</st>

<p>

<indent level="1">

<it>Further information: </it>
</indent>

In the following: U refers to the source Davis, 1965.
<list>
<entry level="1" type="bullet">

 1900 -- <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../302/8302.xml">
David Hilbert</link></scientist>
</person>
 poses his "23 questions" cf <link xlink:type="simple" xlink:href="../584/154584.xml">
Hilbert problems</link> at the Second <social_group wordnetid="107950920" confidence="0.8">
<congress wordnetid="108308800" confidence="0.8">
<meeting wordnetid="108307589" confidence="0.8">
<gathering wordnetid="107975026" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../842/627842.xml">
International Congress of Mathematicians</link></group>
</gathering>
</meeting>
</congress>
</social_group>
 in Paris, "Of these, the second was that of proving the consistency of the '<process wordnetid="105701363" confidence="0.8">
<maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/25005.xml">
Peano axioms</link></higher_cognitive_process>
</theory>
</explanation>
</auditory_communication>
</thinking>
</saying>
</speech>
</maxim>
</process>
' on which, as he had shown, the rigour of mathematics depended" (Hodges p. 83, Davis' commentary in U p. 108).</entry>
<entry level="1" type="bullet">

 1920-1921 -- <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link> explores the halting problem for tag systems, regarding it as a candidate for unsolvability. (Source: <it>Absolutely unsolvable problems and relatively undecidable propositions - account of an anticipation</it>, in U, pp. 340–433.) Its unsolvability was not established until much later, by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
[1961]. </entry>
<entry level="1" type="bullet">

 1928 -- Hilbert recasts his 'Second Problem' at the Bologna International Congress (cf Reid pp. 188-189). Hodges claims he posed three questions: i.e. #1: Was mathematics <it>complete</it>? #2: Was mathematics <it>consistent</it>? #3: Was mathematics <it>decidable</it>?  (Hodges p. 91). The third question is known as the <it><link xlink:type="simple" xlink:href="../672/9672.xml">
Entscheidungsproblem</link></it> (Decision Problem) (Hodges p. 91, Penrose p. 34)</entry>
<entry level="1" type="bullet">

 1930 -- <link>
Kurt Gödel</link> announces a proof as an answer to the first two of Hilbert's 1928 questions [cf Reid p. 198]. "At first he [Hilbert] was only angry and frustrated, but then he began to try to deal constructively with the problem... Gödel himself felt -- and expressed the thought in his paper -- that his work did not contradict Hilbert's formalistic point of view" (Reid p. 199).   </entry>
<entry level="1" type="bullet">

 1931 -- Gödel publishes "On Formally Undecidable Propositions of Principia Mathematica and Related Systems I", (reprinted in U p. 5ff)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../ury/22nd_century.xml">
19 April</link> <link xlink:type="simple" xlink:href="../980/34980.xml">
1935</link> -- <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Alonzo Church</link></scientist>
 publishes "An Unsolvable Problem of Elementary Number Theory" identifies what it means for a function to <it>effective calculable</it>. Such a function will have an algorithm, and "...the fact that the algorithm has <it>terminated</it> becomes effectively known ..." (italics added, U p. 100). </entry>
<entry level="1" type="bullet">

 1936 -- Church publishes the first proof that the <it>Entscheidungsproblem</it> is unsolvable [''A Note on the Entscheidungsproblem'', reprinted in U p. 110].</entry>
<entry level="1" type="bullet">

 7 October <link xlink:type="simple" xlink:href="../673/34673.xml">
1936</link> -- <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link>'s paper "Finite Combinatory Processes. Formulation I" is received. Post adds to his "process" an instruction "(C) Stop". He called such a process "type 1 ... if the process it determines terminates for each specific problem." (U. p.289ff)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../684/34684.xml">
1937</link>-- <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
's paper <it>On Computable Numbers With an Application to the Entscheidungsproblem</it> reaches print in January 1937 (reprinted in U, p. 115). Turing's proof departs from calculation by <link xlink:type="simple" xlink:href="../264/5987264.xml">
recursive functions</link> and introduces the notion of  computation by machine. Stephen Kleene (1952) refers to this as one of the "first examples of decision problems proved unsolvable".</entry>
<entry level="1" type="bullet">

 1939 -- <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../224/679224.xml">
J. Barkley Rosser</link></scientist>
 observes the essential equivalence of "effective method" defined by Gödel, Church, and Turing (Rosser in U p. 273, "Informal Exposition of Proofs of Gödel's Theorem and Church's Theorem"). </entry>
<entry level="1" type="bullet">

 1943 -- In a paper, <link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link> states that "In setting up a complete algorithmic theory, what we do is describe a procedure ... which procedure necessarily terminates and in such manner that from the outcome we can read a definite answer, 'Yes' or 'No,' to the question, 'Is the predicate value true?'."</entry>
<entry level="1" type="bullet">

 1952 -- Kleene (1952) Chapter XIII ("Computable Functions") includes a discussion of the unsolvability of the halting problem for Turing machines and reformulates it in terms of machines that "eventually stop", i.e. halt: "... there is no algorithm for deciding whether any given machine, when started from any given situation, <it>eventually </it>'stops<b><it>." (Kleene (1952) p.382) </it></b></entry>
<entry level="1" type="bullet">

 1952 -- "Davis [ [[Martin Davis]]  ] thinks it likely that he first used the term 'halting problem' in a series of lectures that he gave at the Control Systems Laboratory at the University of Illinois in 1952 (letter from Davis to Copeland, 12 Dec. 2001.)" (Footnote 61 in Copeland (2004) pp.40ff)</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../051/1029051.xml">
Worst-case execution time</link></instrumentality>
</artifact>
</system>
</entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>


<p>

<reflist>
<entry id="1">
    
In none of his work did Turing use the word "halting" or "termination". Turing's biographer Hodges does not have the word "halting" or words "halting problem" in his index.  The earliest known use of the words "halting problem" is in a proof by Davis (p. 70&ndash;71, Davis 1958):
<indent level="1">

"Theorem 2.2 <it>There exists a Turing machine whose halting problem is recursively unsolvable</it>.
</indent>
:"A related problem is the <it>printing problem</it> for a simple Turing machine Z with respect to a symbol Si" (p. 70).
Davis adds no attribution for his proof, so one infers that it is original with him. But Davis has pointed out that a statement of the proof exists informally in Kleene (1952) on page 382. Copeland (2004) states that:
<indent level="1">

 "The halting problem was so named (and it appears, first stated) by Martin Davis [cf Copeland footnote 61]... (It is often said that Turing stated and proved the halting theorem in 'On Computable Numbers', but strictly this is not true)." (p. 40)  
</indent>
For more see the <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22History+of+the+halting+problem%22])">
History section</link> above.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
, <it>On computable numbers, with an application to the Entscheidungsproblem</it>,  Proceedings of the London Mathematical Society, Series 2, 42 (1936), pp 230-265. <weblink xlink:type="simple" xlink:href="http://www.turingarchive.org/browse.php/B/12">
online version</weblink> This is the epochal paper where Turing defines <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s, formulates the halting problem, and shows that it (as well as the <link xlink:type="simple" xlink:href="../672/9672.xml">
Entscheidungsproblem</link>) is unsolvable.</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Sipser-2006" style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Sipser, Michael</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(2006).&#32;"Section 4.2: The Halting Problem", Introduction to the Theory of Computation, Second Edition,&#32;PWS Publishing,&#32;pp.173–182. ISBN  053494728X.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 </entry>
<entry level="1" type="bullet">

 B. <physical_entity wordnetid="100001930" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<historian wordnetid="110177150" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../942/5717942.xml">
Jack Copeland</link></educator>
</scholar>
</professional>
</historian>
</adult>
</academician>
</causal_agent>
</intellectual>
</person>
</philosopher>
</physical_entity>
 ed. (2004), <it>The Essential Turing: Seminal Writings in Computing, Logic, Philosophy, Artificial Intelligence, and Artificial Life plus The Secrets of Enigma,</it> Clarendon Press (Oxford University Press), Oxford UK, ISBN 0-19-825079-7.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, <it>The Undecidable, Basic Papers on Undecidable Propositions, Unsolvable Problems And Computable Functions</it>, Raven Press, New York, 1965. Turing's paper is #3 in this volume. Papers include those by Godel, Church, Rosser, Kleene, and Post.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, <it>Computability and Unsolvability</it>, McGraw-Hill, New York, 1958.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../395/43395.xml">
Alfred North Whitehead</link></philosopher>
</person>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../163/4163.xml">
Bertrand Russell</link></philosopher>
</person>
, <it>Principia Mathematica</it> to *56, Cambridge at the University Press, 1962. Re: the problem of paradoxes, the authors discuss the problem of a set not be an object in any of its "determining functions", in particular "Introduction, Chap. 1 p. 24 "...difficulties which arise in formal logic", and Chap. 2.I. "The Vicious-Circle Principle" p.37ff, and Chap. 2.VIII. "The Contradictions" p. 60ff.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, "What is a computation", in <it>Mathematics Today</it>, Lynn Arthur Steen, Vintage Books (Random House), 1980. A wonderful little paper, perhaps the best ever written about Turing Machines for the non-specialist. Davis reduces the Turing Machine to a far-simpler model based on Post's model of a computation. Discusses <link xlink:type="simple" xlink:href="../308/12308.xml">
Chaitin</link> proof. Includes little biographies of <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link>, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../987/952987.xml">
Julia Robinson</link></scientist>
</person>
. </entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
, <it>Computation, Finite and Infinite Machines</it>, Prentice-Hall, Inc., N.J., 1967. See chapter 8, Section 8.2 "The Unsolvability of the Halting Problem." Excellent, i.e. readable, sometimes fun. A classic.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../193/26193.xml">
Roger Penrose</link></scientist>
</person>
, <it>The Emperor's New Mind: Concerning computers, Minds and the Laws of Physics</it>, Oxford University Press, Oxford England, 1990 (with corrections). Cf: Chapter 2, "Algorithms and Turing Machines". An overly-complicated presentation (see Davis's paper for a better model), but a thorough presentation of Turing machines and the halting problem, and Church's Lambda Calculus.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../443/299443.xml">
John Hopcroft</link></scientist>
</person>
 and <peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/1702318.xml">
Jeffrey Ullman</link></scholar>
</causal_agent>
</alumnus>
</laureate>
</associate>
</recipient>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</physical_entity>
</peer>
, <it>Introduction to Automata Theory, Languages and Computation</it>, Addison-Wesley, Reading Mass, 1979. See Chapter 7 "Turing Machines." A book centered around the machine-interpretation of "languages", NP-Completeness, etc.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../990/18550990.xml">
Andrew Hodges</link></person>
, <it>Alan Turing: The Enigma</it>, Simon and Schuster, New York. Cf Chapter "The Spirit of Truth" for a history leading to, and a discussion of, his proof.</entry>
<entry level="1" type="bullet">

 <popularizer wordnetid="110454752" confidence="0.9173553029164789">
<writer wordnetid="110794014" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../851/5867851.xml">
Constance Reid</link></writer>
</popularizer>
, <it>Hilbert</it>, Copernicus: Springer-Verlag, New York, 1996 (first published 1970). Fascinating history of German mathematics and physics from 1880s through 1930s. Hundreds of names familiar to mathematicians, physicists and engineers appear in its pages. Perhaps marred by no overt references and few footnotes: Reid states her sources were numerous interviews with those who personally knew Hilbert, and Hilbert's letters and papers. </entry>
<entry level="1" type="bullet">

 <link>
Edward Beltrami</link>, <it>What is Random? Chance and order in mathematics and life</it>, Copernicus: Springer-Verlag, New York, 1999. Nice, gentle read for the mathematically-inclined non-specialist, puts tougher stuff at the end. Has a Turing-machine model in it. Discusses the <link xlink:type="simple" xlink:href="../308/12308.xml">
Chaitin</link> contributions. </entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../778/1216778.xml">
Ernest Nagel</link></associate>
</scholar>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</philosopher>
</peer>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<historian wordnetid="110177150" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../510/887510.xml">
James R. Newman</link></scholar>
</mathematician>
</historian>
</scientist>
</causal_agent>
</intellectual>
</person>
</physical_entity>
, <it>Godel’s Proof</it>, New York University Press, 1958. Wonderful writing about a very difficult subject. For the mathematically-inclined non-specialist. Discusses Gentzen's proof on pages 96-97 and footnotes. Appendices discuss the <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano Axioms</link> briefly, gently introduce readers to formal logic.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../372/10387372.xml">
Taylor Booth</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
, <it>Sequential Machines and Automata Theory</it>, Wiley, New York, 1967. Cf Chapter 9, Turing Machines. Difficult book, meant for electrical engineers and technical specialists. Discusses recursion, partial-recursion with reference to Turing Machines, halting problem. Has a <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing Machine</link> model in it. References at end of Chapter 9 catch most of the older books (i.e. 1952 until 1967 including authors Martin Davis, F. C. Hennie, H. Hermes, S. C. Kleene, M. Minsky, T. Rado) and various technical papers. See note under Busy-Beaver Programs.    </entry>
<entry level="1" type="bullet">

 <link>
Busy Beaver</link> Programs are described in Scientific American, August 1984, also March 1985 p. 23. A reference in Booth attributes them to Rado, T.(1962), On non-computable functions, Bell Systems Tech. J. 41. Booth also defines Rado's Busy Beaver Problem in problems 3, 4, 5, 6 of Chapter 9, p. 396.</entry>
<entry level="1" type="bullet">

 <link>
David Bolter</link>, <it>Turing’s Man: Western Culture in the Computer Age</it>, The University of North Carolina Press, Chapel Hill, 1984. For the general reader. May be dated. Has yet another (very simple) Turing Machine model in it.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link>, <it>Introduction to Metamathematics</it>, North-Holland, 1952.  Chapter XIII ("Computable Functions") includes a discussion of the unsolvability of the halting problem for Turing machines. In a departure from Turing's terminology of circle-free nonhalting machines, Kleene refers instead to machines that "stop", i.e. halt.</entry>
</list>
</p>


</sec>
</bdy>
</article>
