<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:28:51[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<idea  confidence="0.8" wordnetid="105833840">
<concept  confidence="0.8" wordnetid="105835747">
<header>
<title>Monitor (synchronization)</title>
<id>1367789</id>
<revision>
<id>241977721</id>
<timestamp>2008-09-30T10:01:35Z</timestamp>
<contributor>
<username>Thijs!bot</username>
<id>1392310</id>
</contributor>
</revision>
<categories>
<category>Concurrency control</category>
<category>Programming constructs</category>
</categories>
</header>
<bdy>

A <b>monitor</b> is an approach to synchronize two or more computer <link xlink:type="simple" xlink:href="../191/1655191.xml">
tasks</link> that use a shared resource, usually a <link xlink:type="simple" xlink:href="../310/5310.xml">
hardware device</link> or a set of <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s. With monitor-based concurrency, the <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> or <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreter</link> transparently inserts locking and unlocking code to appropriately designated procedures, instead of the programmer having to access <link xlink:type="simple" xlink:href="../605/2581605.xml">
concurrency</link> primitives explicitly.<p>

Invented by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Per Brinch Hansen</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
, first implemented in the <link xlink:type="simple" xlink:href="../343/9637343.xml">
Concurrent Pascal</link> language and used to structure <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> in the <link>
Solo Operating System</link>.</p>

<sec>
<st>
Mutual exclusion</st>
<p>

A monitor consists of:
<list>
<entry level="1" type="bullet">

a set of <link xlink:type="simple" xlink:href="../066/25066.xml">
procedures</link> that allow interaction with the shared resource</entry>
<entry level="1" type="bullet">

a <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> lock</entry>
<entry level="1" type="bullet">

the variables associated with the resource</entry>
<entry level="1" type="bullet">

a monitor <link xlink:type="simple" xlink:href="../643/1126643.xml">
invariant</link> that defines the assumptions needed to avoid <link xlink:type="simple" xlink:href="../661/98661.xml">
race condition</link>s</entry>
</list>
</p>
<p>

A monitor procedure takes the lock before doing anything else, and holds it until it either finishes or waits for a condition (explained below). If every procedure guarantees that the invariant is true before it releases the lock, then no task can ever find the resource in a state that might lead to a race condition.</p>
<p>

As a simple example, consider a monitor for performing transactions on a <link xlink:type="simple" xlink:href="../024/242024.xml">
bank account</link>.</p>
<p>

<b>monitor</b> account {
<it>int</it> balance := 0</p>
<p>

<b>function</b> withdraw(<it>int</it> amount) {
<b>if</b> amount  0 <b>then</b> <b>error</b> "Amount may not be negative"
<b>else if</b> balance  amount <b>then</b> <b>error</b> "Insufficient funds"
<b>else</b> balance := balance - amount
}</p>
<p>

<b>function</b> deposit(<it>int</it> amount) {
<b>if</b> amount  0 <b>then</b> <b>error</b> "Amount may not be negative"
<b>else</b> balance := balance + amount
}
}
The <link xlink:type="simple" xlink:href="../643/1126643.xml">
monitor invariant</link> in this case simply says that the balance must reflect all past operations before another operation can begin. It is usually not stated in the code but may be mentioned in <link xlink:type="simple" xlink:href="../308/8592308.xml">
comment</link>s. There are however programming languages like <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../838/9838.xml">
Eiffel</link></programming_language>
, which can check invariants. The lock is added by the <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>. This makes monitors safer and more reliable than approaches that require the programmer to insert locking and unlocking operations by hand, since the programmer can forget them.</p>

</sec>
<sec>
<st>
Condition variables</st>
<p>

To avoid entering a <link xlink:type="simple" xlink:href="../489/671489.xml">
busy waiting</link> state, processes must be able to signal each other about events of interest. Monitors provide this capability through <b>condition variables</b>. When a monitor function requires a particular condition to be true before it can proceed, it waits on an associated condition variable. By waiting, it gives up the lock and is removed from the set of runnable processes. Any process that subsequently causes the condition to be true may then use the condition variable to notify a process waiting for the condition. A process that has been notified regains the lock and can proceed.</p>
<p>

The following monitor uses condition variables to implement an interprocess communication <link>
channel</link> that can store only one integer value at a time.</p>
<p>

<b>monitor</b> channel {
<it>int</it> contents
<it>boolean</it> full := false
<it>condition</it> snd
<it>condition</it> rcv</p>
<p>

<b>function</b> send(<it>int</it> message) {
<b>while</b> full <b>do</b> wait(rcv)   //Mesa Semantics: See Explanation Below
contents := message
full := true
notify(snd)
}</p>
<p>

<b>function</b> receive() {
<b>var</b> <it>int</it> received</p>
<p>

<b>while</b> <b>not</b> full <b>do</b> wait(snd)   //Mesa Semantics: See Explanation Below
received := contents
full := false
notify(rcv)
return received
}
}</p>
<p>

Note that since waiting on a condition forfeits the lock, the waiter must make sure the monitor invariant is satisfied before it waits. In the example above, the same is true for notifying.</p>

<ss1>
<st>
Hoare vs. Mesa semantics</st>
<p>

In early style monitor implementations (known as <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../434/39434.xml">
Hoare</link></scientist>
</person>
 semantics), notifying a condition variable caused a waiting process to receive the lock and run immediately, thereby guaranteeing that the condition would still be true. Implementing this behavior is complicated and has a high overhead. It is also incompatible with <link>
scheduler</link>s that can interrupt a process arbitrarily. For these reasons, researchers have considered various other semantics for condition variables.</p>
<p>

In most modern implementations (known as <link xlink:type="simple" xlink:href="../962/19962.xml">
Mesa</link> semantics), notifying does not take control away from the running process, but merely makes some waiting process runnable. The notifying process continues to hold the lock until it leaves the monitor function. The side effects of this approach are that the notifying process does not have to set up the monitor invariant before notifying, and the waiting process must double-check the condition it was waiting for.  Specifically, if a monitor function includes the expression  <b>if</b> <it>test</it> <b>then</b> wait(cv), another process could enter the monitor after the notification and invert the sense of <it>test</it> before the waiting process runs. The expression must be rewritten as  <b>while</b> <it>test</it> <b>do</b> wait(cv) so that the condition is re-checked before the process continues. </p>
<p>

Implementations also provide a "notifyAll" or "broadcast" operation that notifies every process waiting on a given condition. This operation is useful, for example, when several processes are waiting for different amounts of storage to become available. Releasing storage can enable any number of these processes to proceed, but the scheduler does not know which ones.</p>
<p>

A sample implementation for a condition variable is as follows:</p>
<p>

conditionVariable {
int queueSize = 0;
semaphore lock;
semaphore waiting;</p>
<p>

wait() {
lock.acquire();
queueSize++;
lock.release();
waiting.down();
}</p>
<p>

signal() {
lock.acquire();
while (queueSize &amp;gt; 0){
queueSize--;
waiting.up();
}
lock.release();
}
}</p>

</ss1>
</sec>
<sec>
<st>
History</st>
<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Per Brinch Hansen</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
 was the first to describe and implement monitors, basing them on ideas from <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../434/39434.xml">
C.&nbsp;A.&nbsp;R. Hoare</link></scientist>
</person>
. Hoare subsequently developed the theoretical framework and demonstrated their equivalence to <link xlink:type="simple" xlink:href="../557/164557.xml">
semaphores</link> (when using the original semantics).</p>
<p>

Programming languages that have supported monitors include
<list>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../242/1242.xml">
Ada</link></causal_agent>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 (and other languages that use the <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/60402.xml">
.NET Framework</link></implement>
</horizontal_surface>
</tool>
</instrumentality>
</surface>
</artifact>
</platform>
)</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../343/9637343.xml">
Concurrent Pascal</link></entry>
<entry level="1" type="bullet">

<link>
D programming language</link></entry>
<entry level="1" type="bullet">

<message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 (via the synchronized keyword)</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../962/19962.xml">
Mesa</link></entry>
<entry level="1" type="bullet">

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../545/241545.xml">
Modula-3</link></programming_language>
</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../426/37426.xml">
Squeak Smalltalk</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../199/3405199.xml">
uC++</link></entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../827/36827.xml">
Mutual exclusion</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../370/247370.xml">
Communicating sequential processes</link> - a later development of monitors by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../434/39434.xml">
C. A. R. Hoare</link></scientist>
</person>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 Bibliography </st>
<p>

<list>
<entry level="1" type="bullet">

Monitors: an operating system structuring concept, C. A. R. Hoare - Communications of the ACM, v.17 n.10, p.549-557, Oct. 1974 <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/355620.361161">
http://doi.acm.org/10.1145/355620.361161</weblink></entry>
<entry level="1" type="bullet">

Monitor classification P.A. Buhr, M. Fortier, M.H. Coffin - ACM Computing Surveys (CSUR), 1995 <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/214037.214100">
http://doi.acm.org/10.1145/214037.214100</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.acm.org/classics/feb96/">
Monitors: An Operating System Structuring Concept</weblink>" by <link xlink:type="simple" xlink:href="../434/39434.xml">
Charles Antony Richard Hoare</link></entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=807647">
Signalling in Monitors</weblink>" by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<painter wordnetid="110391653" confidence="0.8">
<artist wordnetid="109812338" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<link xlink:type="simple" xlink:href="../755/11368755.xml">
John H. Howard</link></creator>
</artist>
</painter>
</causal_agent>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=358824">
Experience with Processes and Monitors in Mesa</weblink>" by <link xlink:type="simple" xlink:href="../249/77249.xml">
Butler W. Lampson</link> and <link>
David D. Redell</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.opengroup.org/onlinepubs/009695399/functions/pthread_cond_wait.html">
pthread_cond_wait</weblink> - description from the Open Group Base Specifications Issue 6, IEEE Std 1003.1</entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://gd.tuwien.ac.at/languages/c/programming-dmarshall/node31.html#SECTION003125000000000000000">
Block on a Condition Variable</weblink>" by <link xlink:type="simple" xlink:href="../452/7418452.xml">
Dave Marshall</link></entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.cs.wustl.edu/~schmidt/win32-cv-1.html">
Strategies for Implementing POSIX Condition Variables on Win32</weblink>" by <link>
Douglas C. Schmidt</link> and <link>
Irfan Pyarali</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://apr.apache.org/docs/apr/group__apr__thread__cond.html">
Condition Variable Routines</weblink> from the <link xlink:type="simple" xlink:href="../377/1825377.xml">
Apache Portable Runtime</link> Library</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://wxwidgets.org/manuals/2.6.3/wx_wxcondition.html">
wxCondition description</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.boost.org/doc/html/thread/synchronization.html#thread.synchronization.condvar_ref">
Boost Condition Variables Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://zthread.sourceforge.net/html/classZThread_1_1Condition.html">
ZThread Condition Class Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://wefts.sourceforge.net/wefts-apidoc-0.99c/classWefts_1_1Condition.html">
Wefts::Condition Class Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.dre.vanderbilt.edu/Doxygen/Stable/ace/classACE__Condition.html">
ACE_Condition Class Template Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://doc.trolltech.com/latest/qwaitcondition.html">
QWaitCondition Class Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.gnu.org/software/commoncpp/docs/refman/html/class_conditional.html">
Common C++ Conditional Class Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://austria.sourceforge.net/dox/html/classat_1_1ConditionalMutex.html">
at::ConditionalMutex Class Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://perldoc.perl.org/threads/shared.html">
threads::shared</weblink> - Perl extension for sharing data structures between threads</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.asyncop.net/MTnPDirEnum.aspx?treeviewPath=%5bd%5d+Tutorial%5c%5ba%5d+Multiprocessing+Traps+%26+Pitfalls%5c%5bb%5d+Synchronization+API%5c%5bg%5d+Condition+Variables">
 Tutorial multiprocessing traps</weblink></entry>
<entry level="1" type="bullet">

 http://msdn.microsoft.com/en-us/library/ms682052(VS.85).aspx</entry>
</list>
</p>


</sec>
</bdy>
</concept>
</idea>
</article>
