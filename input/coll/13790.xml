<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:27:21[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<function  confidence="0.9511911446218017" wordnetid="113783816">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Hash function</title>
<id>13790</id>
<revision>
<id>244478982</id>
<timestamp>2008-10-11T00:24:45Z</timestamp>
<contributor>
<username>Twri</username>
<id>7976492</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Error detection and correction</category>
<category>Hash functions</category>
</categories>
</header>
<bdy>

A <b>hash function</b> is any <link xlink:type="simple" xlink:href="../775/775.xml">
well-defined procedure</link> or <link xlink:type="simple" xlink:href="../427/185427.xml">
mathematical function</link> for turning some kind of <link xlink:type="simple" xlink:href="../040/18985040.xml">
data</link> into a relatively small <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>, that may serve as an <link xlink:type="simple" xlink:href="../763/1603763.xml">
index</link> into an <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>.  The values returned by a hash function  are called <b>hash values</b>, <b>hash codes</b>, <b>hash sums</b>, or simply <b>hashes</b>.<p>

Hash functions are mostly used to speed up table lookup or data comparison tasks &mdash; such as finding items in a <link xlink:type="simple" xlink:href="../377/8377.xml">
database</link>, detecting duplicated or similar <link xlink:type="simple" xlink:href="../142/1041142.xml">
record</link>s in a large <link xlink:type="simple" xlink:href="../077/7077.xml">
file</link>, finding similar stretches in <link xlink:type="simple" xlink:href="../496/21496.xml">
DNA</link> sequences, and so on.  </p>
<p>

Hash functions are related to (and often confused with)  <link xlink:type="simple" xlink:href="../538/7538.xml">
checksum</link>s, <link xlink:type="simple" xlink:href="../938/486938.xml">
check digit</link>s, <link xlink:type="simple" xlink:href="../261/15925261.xml">
fingerprint</link>s, <link>
randomizing function</link>s, <link xlink:type="simple" xlink:href="../375/10375.xml">
error correcting codes</link>, and <link xlink:type="simple" xlink:href="../526/439526.xml">
cryptographic hash function</link>s.  Although these concepts overlap to some extent, each has its own uses and requirements.  The <link xlink:type="simple" xlink:href="../816/6114816.xml">
HashKeeper</link> database maintained by the <administrative_unit wordnetid="108077292" confidence="0.8">
<agency wordnetid="108337324" confidence="0.8">
<link xlink:type="simple" xlink:href="../013/1712013.xml">
National Drug Intelligence Center</link></agency>
</administrative_unit>
, for instance, is more aptly described as a catalog of file fingerprints than of hash values.</p>
<p>

<image location="right" width="330px" src="Hash_function.svg" type="thumb">
<caption>

A typical hash function at work
</caption>
</image>
</p>

<sec>
<st>
Applications</st>

<ss1>
<st>
Hash tables</st>
<p>

<b>Hash</b> functions are mostly used in <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link>s, to quickly locate a data record (for example, a <link xlink:type="simple" xlink:href="../931/7931.xml">
dictionary</link> definition) given its <link>
search key</link> (the headword).  Specifically, the hash function is used to map the search key to the index of a slot in the table where the corresponding record is supposedly stored.</p>
<p>

In general, a hashing function may map several different keys to the same hash value.  Therefore, each slot of  a  hash table contains (implicitly or explicitly) a <link xlink:type="simple" xlink:href="../691/26691.xml">
set</link> of records, rather than a single record.  For this reason, each slot of a hash table is often called a <b>bucket</b>, and hash values are also called <it>bucket indices</it>.</p>
<p>

Thus, the hash function only hints at the record's location &mdash; it only tells where one should start looking for it.  Still, in a half-full table, a good hash function will typically narrow the search down to only one or two entries.</p>
<p>

In the <link xlink:type="simple" xlink:href="../881/15881.xml">
Java programming language</link>, for example, the Object <link xlink:type="simple" xlink:href="../757/22757.xml">
parent class</link> provides a standard hashCode() <link xlink:type="simple" xlink:href="../817/232817.xml">
method</link> that is required to generate a 32-bit integer hash value of its object.  This method is used in several hash-table-based classes, such as HashMap and HashSet.</p>

</ss1>
<ss1>
<st>
Finding duplicate records</st>
<p>

To find duplicated records in a large unsorted file, one may use a hash function to map each file record to an index into a table <it>T</it>, and collect in each bucket <it>T</it>[''i''] a <link xlink:type="simple" xlink:href="../382/208382.xml">
list</link> of the numbers of all records with the same hash value <it>i</it>.  Once the table is complete, any two duplicate records will end up in the same bucket.  The duplicates can then be found by scanning every bucket <it>T</it>[''i''] which contains two or more members, fetching those records, and comparing them.  With a table of appropriate size, this method is likely to be much faster than any alternative approach (such as sorting the file and comparing all consecutive pairs).</p>

</ss1>
<ss1>
<st>
Finding similar records</st>
<p>

Hash functions can also be used to locate table records whose key is similar, but not identical, to a given key; or pairs of records in a large file which have similar keys.   For that purpose, one needs a hash function that maps similar keys to hash values that differ by at most <it>m</it>, where <it>m</it> is a small integer (say, 1 or 2).  If one builds a table of <it>T</it> of all record numbers, using such a hash function, then similar records will end up in the same bucket, or in nearby buckets.  Then one need only check the records in each bucket <it>T</it>[''i''] against those in buckets <it>T</it>[''i''+''k''] where <it>k</it> ranges between -<it>m</it> and <it>m</it>.  </p>
<p>

This class includes the so-called <link xlink:type="simple" xlink:href="../533/1841533.xml">
acoustic fingerprint</link> algorithms,  that are used to locate similar-sounding entries in large collection of <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
audio file</link>s (as in the <web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../797/20797.xml">
MusicBrainz</link></web_site>
 song labeling service). For this application, the hash function must be as insensitive as possible to data capture or transmission errors, and to "trivial" changes such as timing and volume changes, compression, etc. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.</p>

</ss1>
<ss1>
<st>
Finding similar substrings</st>
<p>

The same techniques can be used to find equal or similar stretches in a large collection of strings, such as a document repository or a <link>
genomic database</link>.  In this case, the input strings are broken into many small pieces, and a hash function is used to detect potentially equal pieces, as above.</p>
<p>

The <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../698/684698.xml">
Rabin-Karp algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a relatively fast <link xlink:type="simple" xlink:href="../648/28648.xml">
string searching algorithm</link> that works in <link xlink:type="simple" xlink:href="../578/44578.xml">
O(n)</link> time on average. It is based on the use of hashing to compare strings.</p>

</ss1>
<ss1>
<st>
Geometric hashing</st>
<p>

This principle is widely used in <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, <link xlink:type="simple" xlink:href="../927/176927.xml">
computational geometry</link> and many other disciplines, to locate close pairs of points in the plane or in three-dimensional space, similar shapes in a list of shapes, similar <link xlink:type="simple" xlink:href="../332/76332.xml">
image</link>s in an <link>
image database</link>, and so on.  In these applications, the set of all inputs is some sort of <link xlink:type="simple" xlink:href="../018/20018.xml">
metric space</link>, and the hashing function can be interpreted as a <link xlink:type="simple" xlink:href="../666/624666.xml">
partition</link> of that space into a grid of <it>cells</it>.  The table is often an array with two or more indices (called a <it><link>
bucket grid</link>s</it>), and the hash function returns an index tuple.  This special case of hashing  is known as  <link xlink:type="simple" xlink:href="../939/474939.xml">
geometric hashing</link> or <it>the grid method</it>.</p>

</ss1>
</sec>
<sec>
<st>
Properties</st>

<p>

Good hash functions, in the original sense of the term, are usually required to satisfy certain properties listed below.  Note that different requirements apply to the other related concepts (cryptographic hash functions, checksums, etc.).</p>

<ss1>
<st>
Low cost</st>
<p>

The cost of computing a hash function must be small enough to make a hashing-based solution advantageous other approaches.  For instance, <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> can locate an item in a table of <it>n</it> items with log2 <it>n</it> key comparisons.  Therefore, a hash-table solution will be more efficient than binary search only if computing the hash function for one key costs less than performing log2 <it>n</it> key comparisons.</p>

</ss1>
<ss1>
<st>
Determinism</st>
<p>

A hash function must be <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic</link> &mdash; meaning that two identical or equivalent inputs must generate the same hash value.</p>

</ss1>
<ss1>
<st>
Uniformity</st>
<p>

A good hash function  should map the expected inputs as evenly as possible over its output range.  That is, every hash value in the output range should be generated with roughly the same  <link xlink:type="simple" xlink:href="../934/22934.xml">
probability</link>.  The reason for this last requirement is that the cost of hashing-based methods goes up sharply as the number of <it>collisions</it> &mdash; pairs of inputs that are mapped to the same hash value &mdash; increases.  Basically, if some hash values are more likely to occur than others, a larger fraction of the lookup operations will have to search through a larger set of colliding table entries.</p>
<p>

Note that this criterion only requires the value to be <it>uniformly distributed</it>, not <it>random</it> in any sense.  A good randomizing function is usually good for hashing, but the converse need not be true. </p>
<p>

Hash tables often contain only a small subset of the valid inputs.  For instance, a club membership list may contain only a hundred or so member names, out of the very large set of all possible names.  In these cases, the uniformity criterion should hold for almost all typical subsets of entries that may be found in the table, not just for the global set of all possible entries.  </p>
<p>

In other words, if a typical set of <it>m</it> records is hashed to <it>n</it> table slots, the probability of a bucket receiving many more than <it>m/n</it> records should be vanishingly small.  In particular, if <it>m</it> is less than <it>n</it>, very few buckets should have more than one or two records.  (Ideally, no bucket should have more than one record; but a small number of collisions is virtually inevitable, even if <it>n</it> is much larger than <it>m</it> (see the <link xlink:type="simple" xlink:href="../242/73242.xml">
birthday paradox</link>).</p>

</ss1>
<ss1>
<st>
Variable range</st>
<p>

In many applications, the range of hash values may be different for each run of the program, or may change along the same run (for instance, when a hash table needs to be expanded).  In those situations, one needs a hash function which takes two parameters &mdash; the input data <it>z</it>, and the number <it>n</it> of allowed hash values. </p>

</ss1>
<ss1>
<st>
Data normalization</st>
<p>

In some applications, the input data may contain features that are irrelevant for comparison purposes.  When looking up a personal name, for instance, it may be desirable to ignore the distinction between upper and lower case letters.  For such data, one must use a hash function that is compatible with the data <link xlink:type="simple" xlink:href="../259/9259.xml">
equivalence</link> criterion being used: that is, any two inputs that are considered equivalent must yield the same hash value.   </p>

</ss1>
<ss1>
<st>
Continuity</st>
<p>

A hash function that is used to search for similar (as opposed to equivalent) data must be as <link xlink:type="simple" xlink:href="../122/6122.xml">
continuous</link> as possible; two inputs that differ by a little should be mapped to equal or nearly equal hash values.  </p>
<p>

Note that continuity is usually considered a fatal flaw for checksums, cryptographic hash functions, and other related concepts.  Continuity is desirable for hash functions only in some applications, such as hash tables that use <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link>.</p>

</ss1>
</sec>
<sec>
<st>
Hash function algorithms</st>
<p>

The choice of a hashing function depends strongly on the nature of the input data, and their <link xlink:type="simple" xlink:href="../543/23543.xml">
probability distribution</link> in the intended application. </p>

<ss1>
<st>
Trivial hash function</st>
<p>

If the data to be hashed is small enough, one can use the data itself (reinterpreted as an integer in binary notation) as the hashed value.   Invalid data values (such as the country code 'xx' or the zip code 00000) may be left undefined in the table, or mapped to some appropriate 'null' value.  The cost of computing this "trivial" (<link xlink:type="simple" xlink:href="../069/15069.xml">
identity</link>) hash function is effectively zero.</p>
<p>

The meaning of 'small enough' depends on how much memory is available for the hash table.  A typical PC (as of 2008) might have a gigabyte of available memory, meaning that hash values of up to 30 bits could be accommodated.  However, there are many applications that can get by with much less.  For example, when mapping <link xlink:type="simple" xlink:href="../701/27701.xml">
character string</link>s between <link xlink:type="simple" xlink:href="../125/625125.xml">
upper and lower case</link>, one can use the binary encoding of each character, interpreted as an integer, to index a table that gives the alternate form of that character ('A' for 'a', '8' for '8', etc.).  If each character is stored in 8 bits (as in <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<representation wordnetid="105926676" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../586/586.xml">
ASCII</link></rule>
</direction>
</representation>
</protocol>
</message>
 or <link xlink:type="simple" xlink:href="../019/15019.xml">
ISO Latin 1</link>), the table has only 28 = 256 entries; in the case of <link xlink:type="simple" xlink:href="../742/31742.xml">
Unicode</link> characters, the table would have 216 = 65536 entries. The same technique can be used to map two-letter country codes like 'us' or 'za' to country names (65536 table entries), 5-digit zip codes like 13083 to city names (100000 entries), etc.</p>

</ss1>
<ss1>
<st>
Injective and perfect hashing</st>
<p>

The ideal hashing function should be <link xlink:type="simple" xlink:href="../196/45196.xml">
injective</link> &mdash; that is, it should map  each valid input to a different hash value.  Such a function would directly locate the desired entry in a hash table, without any additional search.</p>
<p>

An injective hash function whose range is all integers between 0 and <it>n</it>−1, where <it>n</it> is the number of valid inputs, is said to be <link xlink:type="simple" xlink:href="../162/268162.xml">
perfect</link>.  Besides providing single-step lookup, a perfect hash function also results in a compact hash table, without any vacant slots.</p>
<p>

Unfortunately, injective and perfect hash functions exist only in very few special situations (such as mapping month names to the integers 0 to 11); and even then they are often too complicated or expensive to be of practical use.  Indeed, hash functions are typically required to map a large set of valid potential inputs to a much smaller range of hash values and therefore cannot be injective.</p>

</ss1>
<ss1>
<st>
Hashing uniformly distributed data</st>
<p>

If the inputs are bounded-length <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link> (such as <link xlink:type="simple" xlink:href="../003/30003.xml">
telephone</link> numbers, <link>
car license plate</link>s, <link xlink:type="simple" xlink:href="../201/842201.xml">
invoice</link> numbers, etc.), and each input may <link xlink:type="simple" xlink:href="../593/27593.xml">
independently</link> occur with <link xlink:type="simple" xlink:href="../835/5509835.xml">
uniform</link> probability, then a hash function need only map roughly the same number of inputs to each hash value.  For instance, suppose that each input is an integer <it>z</it> in the range 0 to <it>N</it>−1, and the output must be an integer <it>h</it> in the range 0 to <it>n</it>−1, where <it>N</it> is much larger than <it>n</it>.  Then the hash function could be  <it>h</it> = <it>z</it> <b>mod</b> <it>n</it> (the remainder of <it>z</it> divided by <it>n</it>), or <it>h</it> = (<it>z</it> × <it>n</it>) ÷ <it>N</it> (the value <it>z</it> scaled down by <it>n</it>/<it>N</it> and truncated to an integer), or many other formulas.</p>

</ss1>
<ss1>
<st>
Hashing data with other distributions</st>
<p>

These simple formulas will not do if the input values are not equally likely, or are not independent.  For instance, most patrons of a <link xlink:type="simple" xlink:href="../862/51862.xml">
supermarket</link> will live in the same geographic area, so their telephone numbers are likely to begin with the same 3 to 4 digits.   In that case, if <it>n</it> is 10000 or so, the division formula  (<it>z</it> × <it>n</it>) ÷ <it>N</it>, which depends mainly on the leading digits, will generate a lot of collisions; whereas the remainder formula <it>z</it> <b>mod</b> <it>n</it>, which is quite sensitive to the trailing digits, may still yield a fairly even distribution of hash values.</p>
<p>

When the data values are long (or variable-length) <link xlink:type="simple" xlink:href="../443/73443.xml">
character</link> strings &mdash; such as personal names, <link xlink:type="simple" xlink:href="../277/32277.xml">
web page addresses</link>, or mail messages &mdash; their distribution is usually very uneven, with complicated dependencies.  For example, text in any <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link> has highly non-uniform distributions of <link xlink:type="simple" xlink:href="../269/5269.xml">
characters</link>, and <link xlink:type="simple" xlink:href="../746/403746.xml">
character pair</link>s, very characteristic of the language.  For such data, it is prudent to use a hash function that depends on all characters of the string &mdash; and depends on each character in a different way.</p>

</ss1>
<ss1>
<st>
Special-purpose hash functions</st>
<p>

In many such cases, one can design a special-purpose (<link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic</link>) hash function that yield many fewer collisions than a good general-purpose hash function.  For example, suppose that the input data are  file names such as FILE0000.CHK, FILE0001.CHK, FILE0002.CHK, etc., with mostly sequential numbers.  For such data, a function that extracts the numeric part <it>k</it> of the file name and returns <it>k</it> <b>mod</b> <it>n</it> would be nearly optimal. Needless to say, a function that is exceptionally good for a specific kind of data may have dismal performance on data with different distribution.</p>

</ss1>
<ss1>
<st>
Hashing with checksum functions</st>
<p>

One can obtain good general-purpose hash functions for string data by adapting certain checksum or fingerprinting algorithms.  Some of those algorithms will map arbitrary long string data <it>z</it>, with any typical real-world distribution &mdash; no matter how non-uniform and dependent &mdash; to a fixed length bit string, with a fairly uniform distribution.  This string can be interpreted as a binary integer <it>k</it>, and turned into a hash value by the formula  <it>h</it> = <it>k</it> <b>mod</b> <it>n</it>.</p>
<p>

This method will produce a fairly even distribution of hash values, as long as the hash range size <it>n</it> is small compared to the range of the checksum function.   Bob Jenkins' <weblink xlink:type="simple" xlink:href="http://burtleburtle.net/bob/c/lookup3.c">
LOOKUP3</weblink> algorithm<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> uses a 32-bit checksum.  A 64-bit checksum should provide adequate hashing for tables of any feasible size.</p>

</ss1>
<ss1>
<st>
Hashing with cryptographic hash functions</st>
<p>

Some cryptographic hash functions, such as <function wordnetid="113783816" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../826/18826.xml">
MD5</link></function>
, have even stronger uniformity guarantees than checksums or fingerprints, and thus can provide very good general-purpose hashing functions.  However, the uniformity advantage may be too small to offset their much higher cost.</p>

</ss1>
</sec>
<sec>
<st>
 Origins of the term </st>

<p>

<image location="none" width="50px" src="Wiktionary-logo-en.svg">
<caption>

Wiktionary
</caption>
</image>

Look up  in <web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../658/156658.xml">
Wiktionary</link></web_site>
, the free dictionary.</p>

<p>

The term "hash" comes by way of analogy with its standard meaning in the physical world, to "chop and mix". 
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
 notes that <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../602/1015602.xml">
Hans Peter Luhn</link></employee>
</scientist>
</causal_agent>
</worker>
</person>
</physical_entity>
 of <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 appears to have been the first to use the concept, in a memo dated January <link xlink:type="simple" xlink:href="../865/34865.xml">
1953</link>, and that <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<cryptanalyst wordnetid="109981540" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<decoder wordnetid="109995398" confidence="0.8">
<link xlink:type="simple" xlink:href="../338/230338.xml">
Robert Morris</link></decoder>
</scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</specialist>
</cryptanalyst>
</person>
</expert>
</physical_entity>
 used the term in a survey paper in <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
CACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
 which elevated the term from technical jargon to formal terminology.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

In the <link xlink:type="simple" xlink:href="../672/26672.xml">
SHA-1</link> algorithm, for example, the domain is "flattened" and "chopped" into "words" which are then "mixed" with one another using carefully chosen mathematical functions.  The range ("hash value") is made to be a definite size, 160 bits (which may be either smaller or larger than the domain), through the use of <link xlink:type="simple" xlink:href="../087/20087.xml">
modular division</link>.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../666/4024666.xml">
Universal hashing</link></algorithm>
</function>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../432/18934432.xml">
Cryptography</link></entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<primitive wordnetid="109627462" confidence="0.8">
<link xlink:type="simple" xlink:href="../526/439526.xml">
Cryptographic hash function</link></primitive>
</causal_agent>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<written_communication wordnetid="106349220" confidence="0.8">
<code wordnetid="106667317" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/17112.xml">
HMAC</link></code>
</written_communication>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../939/474939.xml">
Geometric hashing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../141/192141.xml">
Distributed hash table</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../162/268162.xml">
Perfect hash function</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../764/2981764.xml">
Linear hash</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../549/4071549.xml">
Rolling hash</link></function>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../698/684698.xml">
Rabin-Karp string search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../880/1963880.xml">
Zobrist hashing</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../211/602211.xml">
Bloom filter</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../833/13833.xml">
Hash table</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../149/2497149.xml">
Hash list</link></function>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../388/2497388.xml">
Hash tree</link></function>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../605/2381605.xml">
Coalesced hashing</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../748/242748.xml">
Transposition table</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../690/2155690.xml">
List of hash functions</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>
<p>

<list>
<entry level="1" type="number">

  <cite id="endnote_function" style="font-style: normal;">
<b>^</b></cite>&nbsp; In the remainder of this article, the term <it>function</it> is used to refer to <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s as well as the <link xlink:type="simple" xlink:href="../427/185427.xml">
functions</link> they compute.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/rd/11787382%2C504088%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/25861/http:zSzzSzwww.extra.research.philips.comzSznatlabzSzdownloadzSzaudiofpzSzcbmi01audiohashv1.0.pdf/haitsma01robust.pdf">
"Robust Audio Hashing for Content Identification by Jaap Haitsma, Ton Kalker and Job Oostveen"</weblink></entry>
<entry id="2">
  <cite id="CITEREFJenkins1997" style="font-style:normal">Jenkins, Bob&#32;(September, 1997),&#32;<weblink xlink:type="simple" xlink:href="http://www.ddj.com/184410284">
<it>Hash Functions''</it></weblink>,&#32;"Algorithm Alley",&#32;<it>Dr. Dobb's Journal</it>, </cite>&nbsp; </entry>
<entry id="3">
 <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Knuth, Donald</link></scientist>
</person>
&#32;(1973). <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, volume 3, Sorting and Searching,&#32;506-542.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.partow.net/programming/hashfunctions/index.html">
General purpose hash function algorithms (C/C++/Pascal/Java/Python/Ruby)</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://burtleburtle.net/bob/hash/index.html">
Hash Functions and Block Ciphers  by Bob Jenkins</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.concentric.net/~Ttwang/tech/inthash.htm">
Integer Hash Function</weblink> by Thomas Wang</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.geocities.com/drone115b/Goulburn06.pdf">
The Goulburn Hashing Function</weblink> (<message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../077/24077.xml">
PDF</link></format>
</language>
</information>
</message>
) by Mayur Patel</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.azillionmonkeys.com/qed/hash.html">
Hash Functions</weblink> by Paul Hsieh</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://herbert.gandraxa.com/herbert/hsh.asp">
HSH 11/13</weblink> by Herbert Glarner</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.paulschou.com/tools/xlate/">
Online Char (ASCII), HEX, Binary, Base64, etc... Encoder/Decoder with MD2, MD4, MD5, SHA1+2, etc. hashing algorithms</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://isthe.com/chongo/tech/comp/fnv/">
FNV</weblink> Fowler, Noll, Vo Hash Function</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.sinfocol.org/herramientas/hashes.php">
Hash Generator</weblink> Online Hash Generator (md2,md4,md5,sha1,tiger,snefru,ripemd,whirlpool,haval...)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://hash.stephan-brumme.com/">
Ajax-based Hash Generator</weblink> Online Hash Generator with instant hash computation while typing</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.qdecoder.org/goto/qHash.html">
qDecoder's C/C++ hash functions</weblink> &mdash; opensource library</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</function>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
