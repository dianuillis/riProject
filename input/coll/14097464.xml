<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 02:19:06[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Flashsort</title>
<id>14097464</id>
<revision>
<id>238701901</id>
<timestamp>2008-09-16T00:19:32Z</timestamp>
<contributor>
<username>SamuelRiv</username>
<id>353639</id>
</contributor>
</revision>
<categories>
<category>Sorting algorithms</category>
</categories>
</header>
<bdy>

<b>Flashsort</b> is a <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link> with extremely good <link xlink:type="simple" xlink:href="../578/44578.xml">
<math>O(n)</math></link> efficiency for balanced data sets published in 1998 by Karl-Dietrich Neubert.

<sec>
<st>
 Algorithm </st>

<p>

Flashsort works based on the principle that in either a randomized or partially-ordered data set in which data are in a balanced distribution, one can immediately estimate where an item should be placed when one knows the range of the set. This approximate location is called the <it>class</it> of an item <math>A_i</math>, and is computed as</p>
<p>

<math>K(A_i) = 1+\textrm{INT}\left((m-1)\frac{A_i-A_\textrm{min}}{A_\textrm{max}-A_\textrm{min}}\right)</math></p>
<p>

which gives a total of <math>m</math> possible classes. After calculating the class of an element, it is inserted into the position in the array given by the order of the class (arranged from 1 through <math>m</math>). The final step is an <link xlink:type="simple" xlink:href="../205/15205.xml">
insertion sort</link> to arrange items in each class and fix any remaining errors <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. For implementations of the algorithm, see <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>.</p>

</sec>
<sec>
<st>
 Efficiency </st>
<p>

In the ideal case of a balanced data set, the efficiency scales as <math>O(n)</math> because each class is similarly sized, creating well-sorted data for the final insertion sort. As an <link xlink:type="simple" xlink:href="../861/219861.xml">
in-place algorithm</link>, it uses minimal memory and it also makes efficient use of the machine <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link>. In the worst case of unbalanced data, flashsort is as slow as insertion sort, scaling as <math>O(n^2)</math> precisely due to the need to use insertion sort on data that was poorly sorted during classification. Using a faster algorithm such as <link xlink:type="simple" xlink:href="../249/3268249.xml">
quicksort</link> in the final step alleviates this problem somewhat, giving an efficiency of <math>O(n\log n)</math> for any randomized data, although the worst case is still <math>O(n^2)</math><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link></entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../304/3189304.xml">
Comparison sort</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../543/7543.xml">
Computational complexity theory</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../568/18568.xml">
List of algorithms</link></entry>
</list>
</p>


</sec>
<sec>
<st>
References </st>


<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Neubert, Karl-Dietrich&#32;(February 1998).&#32;"<weblink xlink:type="simple" xlink:href="http://www.ddj.com/">
The Flashsort Algorithm</weblink>". <it>Dr. Dobb's Journal</it>: 123. Retrieved on <link>
2007-11-06</link>.</cite>&nbsp;</entry>
<entry id="2">
Karl-Dietrich Neubert&#32;(1998).&#32;"<weblink xlink:type="simple" xlink:href="http://www.neubert.net/FSOIntro.html">
The FlashSort Algorithm</weblink>".&#32;Retrieved on <link>
2007-11-06</link>.</entry>
<entry id="3">
Li Xiao, Xiaodong Zhang, Stefan A. Kubricht.&#32;"<weblink xlink:type="simple" xlink:href="http://jea.acm.org/ARTICLES/Vol5Nbr3/node4.html">
Cache-Effective Quicksort</weblink>".&#32;<it>Improving Memory Performance of Sorting Algorithms</it>.&#32;  Department of Computer Science, College of William and Mary, Williamsburg, VA 23187-8795.&#32;Retrieved on <link>
2007-11-06</link>.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://elliottback.com/wp/archives/2006/01/07/sorting-in-linear-time/">
Sorting in Linear time</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/91922.html">
Implementations of Randomized Sorting on Large Parallel Machines (1992)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://stinet.dtic.mil/oai/oai?verb=getRecord&amp;metadataPrefix=html&amp;identifier=ADA253638">
Implementation of Parallel Algorithms (1992)</weblink></entry>
</list>
</p>



</sec>
</bdy>
</article>
