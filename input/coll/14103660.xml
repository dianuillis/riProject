<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 02:19:22[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Read-only Turing machine</title>
<id>14103660</id>
<revision>
<id>218239097</id>
<timestamp>2008-06-09T19:55:03Z</timestamp>
<contributor>
<username>DOI bot</username>
<id>6652755</id>
</contributor>
</revision>
<categories>
<category>All articles with dead external links</category>
<category>Automata</category>
<category>Articles with invalid date parameter in template</category>
<category>Articles with dead external links since June 2008</category>
</categories>
</header>
<bdy>

A <b>read-only Turing machine</b> or <b>Two-way deterministic finite-state automaton (2DFA)</b> is class of models of <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability</link> that behave like a standard <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 and can move in both directions across input, except cannot write to its input tape. The machine in its bare form is equivalent to a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../404/653404.xml">
Deterministic finite-state machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 or DFA in computational power, and therefore can only parse a <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>.
<sec>
<st>
 Theory </st>
<p>

We define a standard Turing machine by the 9-tuple</p>
<p>

<math>M = (Q, \Sigma, \Gamma, \vdash, \_, \delta, s, t, r)</math> where</p>
<p>

<list>
<entry level="1" type="bullet">

 <math>Q</math> is a finite set of <it>states</it>;</entry>
<entry level="1" type="bullet">

 <math>\Sigma</math> is the finite set of the <it>input alphabet</it>;</entry>
<entry level="1" type="bullet">

 <math>\Gamma</math> is the finite <it>tape alphabet</it>;</entry>
<entry level="1" type="bullet">

 <math>\vdash \in \Gamma - \Sigma</math> is the <it>left endmarker</it>;</entry>
<entry level="1" type="bullet">

 <math>\_ \in \Gamma - \Sigma</math> is the <it>blank symbol</it>;</entry>
<entry level="1" type="bullet">

 <math>\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{L,R\}</math> is the <it>transition function</it>;</entry>
<entry level="1" type="bullet">

 <math>s \in Q</math> is the <it>start state</it>;</entry>
<entry level="1" type="bullet">

 <math>t \in Q</math> is the <it>accept state</it>;</entry>
<entry level="1" type="bullet">

 <math>r \in Q, ~ r \ne t</math> is the <it>reject state</it>.</entry>
</list>
</p>
<p>

So given initial state <math>q</math> reading symbol <math>a</math>, we have a transition defined by <math>\delta(q,a)=(q_2,a_2,d)</math> which replaces <math>a</math> with <math>a_2</math>, transitions to state <math>q_2</math>, and moves the "read head" in direction <math>d</math> (left or right) to read the next input <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. In our 2DFA read-only machine, however, <math>a=a_2</math> always.</p>
<p>

This model is now equivalent to a DFA. The proof is outlined by noting that a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
Nondeterministic finite state machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 (NFA) can model a 2DFA by offering both leftward and rightward movement of the read head as possible transitions. The NFA is then reducible to a DFA by a well-established proof (see article for details). The 2DFA can model a standard DFA quite easily by simply having all transitions move the head in one direction.</p>

<ss1>
<st>
 Variants </st>

<p>

Several variants of this model are also equivalent to DFAs. In particular, the nondeterministic case (in which the transition from one state can be to multiple states given the same input) is reducible to a DFA.</p>
<p>

Other variants of this model allow more <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link>. With a single infinite <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link> the model can parse (at least) any language that is computable by a Turing machine in <link xlink:type="simple" xlink:href="../258/754258.xml">
linear time</link>. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> In particular, the language {anbncn} can be parsed by an algorithm which verifies first that there are the same number of a's and b's, then rewinds and verifies that there are the same number of b's and c's. With the further aid of <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
nondeterminism</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 the machine can parse any <link xlink:type="simple" xlink:href="../867/6867.xml">
context-free language</link>. With two infinite stacks the machine is <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> and can parse any recursive <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>.</p>
<p>

If the machine is allowed to have multiple tape heads, it can parse any language in <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../999/1149999.xml">
L</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
 or <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
, according to whether nondeterminism is allowed.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</ss1>
</sec>
<sec>
<st>
 Applications </st>

<p>

A read-only Turing machine is used in the definition of a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../435/71435.xml">
Universal Turing machine</link></machine>
</causal_agent>
</worker>
</device>
</assistant>
</instrumentality>
</artifact>
</model>
</person>
</physical_entity>
 to accept the definition of the Turing machine that is to be modelled, after which computation continues with a standard Turing machine.</p>
<p>

In modern research, the model has become important in describing a new complexity class of <link xlink:type="simple" xlink:href="../008/7926008.xml">
Quantum finite automata</link> or deterministic <link xlink:type="simple" xlink:href="../719/11519719.xml">
probabilistic automata</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>.</p>

</sec>
<sec>
<st>
 References </st>


<p>

<reflist>
<entry id="1">
 <cite id="Reference-Kozen-1997" style="font-style:normal" class="book">Kozen, Dexter C.&#32;[1951]&#32;(1997).&#32;in David Gries, Fred B. Schneider: Automata and Computability&#32;(hardcover), 1, Undergraduate Texts in Computer Science&#32;(in English),&#32;New York:&#32;Springer-Verlag,&#32;158,210,224. ISBN 0-387-94907-0.</cite>&nbsp;</entry>
<entry id="2">
 <it>Computational Complexity</it> by Wagner and Wechsung, section 13.3 (1986, isbn 9027721467)</entry>
<entry id="3">
 <it>Computational Complexity</it> by Wagner and Wechsung, section 13.1 (1986, isbn 9027721467)</entry>
<entry id="4">
 <cite style="font-style:normal">Kondacs, A.; J. Watrous&#32;(1997).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cs.uwaterloo.ca/~watrous/papers/qfa.ps">
On the power of quantum finite state automata</weblink>"&#32;(&#91;&#93; &ndash; <weblink xlink:type="simple" xlink:href="http://scholar.google.co.uk/scholar?hl=en&amp;lr=&amp;q=author%3A+intitle%3AOn+the+power+of+quantum+finite+state+automata&amp;as_publication=38th+Annual+Symposium+on+Foundations+of+Computer+Science+%28FOCS+%2797%29&amp;as_ylo=1997&amp;as_yhi=1997&amp;btnG=Search">
Scholar search</weblink>). <it>38th Annual Symposium on Foundations of Computer Science (FOCS '97)</it>: 66–75. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109%2FSFCS.1997.646094">
10.1109/SFCS.1997.646094</weblink>. Retrieved on <link>
2007-11-07</link>.</cite>&nbsp;</entry>
<entry id="5">
 <cite style="font-style:normal">Dwork, Cynthia; Larry Stockmeyer&#32;(1990).&#32;"<weblink xlink:type="simple" xlink:href="http://www.geocities.com/stockmeyer@sbcglobal.net/pfa_gap.ps">
A Time Complexity Gap For 2-Way Probabilistic Finite State Automata</weblink>". <it>SIAM Journal on Computing</it>&#32;<b>19</b>&#32;(6): 1011–1023. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137%2F0219069">
10.1137/0219069</weblink>. Retrieved on <link>
2007-11-07</link>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../084/3244084.xml">
Computability</link></entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../864/6263864.xml">
Turing machine equivalents</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../078/510078.xml">
Stack machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../258/14098258.xml">
Queue machine</link></entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../220/25220.xml">
Quantum computer</link></group>
</collection>
</causal_agent>
</class>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<weblink xlink:type="simple" xlink:href="http://www.webber-labs.com/fl/lectures/ppt-slides/09.ppt">
Lecture on finite-state automata by Adam Webber</weblink></p>



</sec>
</bdy>
</article>
