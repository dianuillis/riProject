<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:18:45[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>XOR swap algorithm</title>
<id>145555</id>
<revision>
<id>236808901</id>
<timestamp>2008-09-07T06:10:02Z</timestamp>
<contributor>
<username>Quuxplusone</username>
<id>245306</id>
</contributor>
</revision>
<categories>
<category>All articles with unsourced statements</category>
<category>Algorithms</category>
<category>Articles with example C code</category>
<category>Articles with unsourced statements since July 2008</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../311/5311.xml">
computer programming</link>, the <b>XOR swap</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that uses the <link xlink:type="simple" xlink:href="../979/105979.xml">
XOR</link> <link xlink:type="simple" xlink:href="../399/264399.xml">
bitwise operation</link> to <link xlink:type="simple" xlink:href="../549/6067549.xml">
swap</link> distinct values of <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s having the same <link xlink:type="simple" xlink:href="../817/93817.xml">
data type</link> without using a temporary variable.
<sec>
<st>
The algorithm</st>
<p>

Standard swapping algorithms require the use of a temporary storage variable. Using the XOR swap algorithm, however, no temporary storage is needed. The algorithm is as follows:
X := X XOR Y
Y := X XOR Y
X := X XOR Y
The algorithm typically corresponds to three <link xlink:type="simple" xlink:href="../683/20683.xml">
machine code</link> instructions. For example, in IBM <link xlink:type="simple" xlink:href="../785/59785.xml">
System/370</link> assembly code:
XR    R1,R2
XR    R2,R1
XR    R1,R2
where R1 and R2 are <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link>s and each XR operation leaves its result in the register named in the first argument.</p>
<p>

However, the problem still remains that if <it>x</it> and <it>y</it> use the same storage location, the value stored in that location will be zeroed out by the first XOR instruction, and then remain zero; it will not be "swapped with itself".  (Note that this is <it>not</it> the same as if <it>x</it> and <it>y</it> have the same values.  The trouble only comes when <it>x</it> and <it>y</it> use the same storage location.)</p>

</sec>
<sec>
<st>
Proof that the XOR swap works</st>
<p>

The <link xlink:type="simple" xlink:href="../948/3948.xml">
binary operation</link> XOR over bit strings of length <math>N</math> exhibits the following properties (where <math>\oplus</math> denotes XOR):<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
<list>
<entry level="1" type="bullet">

 <b>L1.</b> <link xlink:type="simple" xlink:href="../390/294390.xml">
Commutativity</link>: <math>A \oplus B = B \oplus A</math></entry>
<entry level="1" type="bullet">

 <b>L2.</b> <link xlink:type="simple" xlink:href="../335/1335.xml">
Associativity</link>: <math>(A \oplus B) \oplus C = A \oplus (B \oplus C)</math></entry>
<entry level="1" type="bullet">

 <b>L3.</b> <link xlink:type="simple" xlink:href="../962/14962.xml">
Identity exists</link>: there is a bit string, 0, (of length <it>N</it>) such that <math>A \oplus 0 = A</math> for any <math>A</math></entry>
<entry level="1" type="bullet">

 <b>L4.</b> Each element is its own <link xlink:type="simple" xlink:href="../199/45199.xml">
inverse</link>: for each <math>A</math>, <math>A \oplus A = 0</math>.</entry>
</list>
</p>
<p>

Suppose that we have two registers R1 and R2, as in the table below, with initial values <it>A</it> and <it>B</it> respectively. We perform the operations below in sequence, and reduce our results using the properties listed above.</p>
<p>

<table class="wikitable">
<row>
<header>
Step</header>
<header>
Operation</header>
<header>
Register 1</header>
<header>
Register 2</header>
<header>
Reduction</header>
</row>
<row>
<col>
0</col>
<col>
Initial value</col>
<col>
<math>\ A</math></col>
<col>
<math>\ B</math></col>
<col>
—</col>
</row>
<row>
<col>
1</col>
<col>
R1 := R1 XOR R2</col>
<col>
<math>\ A \oplus B</math></col>
<col>
<math>\ B</math></col>
<col>
—</col>
</row>
<row>
<col>
2</col>
<col>
R2 := R1 XOR R2</col>
<col>
<math>\ A \oplus B</math></col>
<col>
<math>\begin{align} (A \oplus B) \oplus B =&amp; A \oplus (B \oplus B) \\=&amp; A \oplus 0 \\=&amp; A \end{align}</math></col>
<col>
<b>L2 L4 L3</b></col>
</row>
<row>
<col>
3</col>
<col>
R1 := R1 XOR R2</col>
<col>
<math>\begin{align} (A \oplus B) \oplus A =&amp; A \oplus (A \oplus B) \\=&amp; (A \oplus A) \oplus B \\=&amp; 0 \oplus B \\=&amp; B \end{align}</math></col>
<col>
<math>\ A</math></col>
<col>
<b>L1 L2 L4 L3</b></col>
</row>
</table>
</p>

</sec>
<sec>
<st>
Code example</st>
<p>

A <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 function that implements the XOR swap algorithm:</p>

<p>

void xorSwap (int *x, int *y)
{
if (x != y) {
<list>
<entry level="1" type="bullet">

x ^= *y;</entry>
<entry level="1" type="bullet">

y ^= *x;</entry>
<entry level="1" type="bullet">

x ^= *y;</entry>
</list>

}
}</p>
<p>

Note that the code does not swap the integers passed immediately, but first checks if their memory locations are distinct. This will remove problems caused by possible <link xlink:type="simple" xlink:href="../841/671841.xml">
aliasing</link>.</p>
<p>

The body of this function is sometimes seen incorrectly shortened to if (x != y) *x^=*y^=*x^=*y;. This code has undefined behavior, since it modifies the <link xlink:type="simple" xlink:href="../331/338331.xml">
lvalue</link> *x twice without an intervening <link xlink:type="simple" xlink:href="../835/1230835.xml">
sequence point</link>.</p>

</sec>
<sec>
<st>
Reasons for use in practice</st>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_content.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This article or section is missing  or needs .</b>
Using helps guard against copyright violations and factual inaccuracies. <it>(July 2008)''</it></col>
</row>
</table>


The algorithm is not uncommon in embedded assembly code, where there is often very limited space available for a temporary swap variable, and this form of swap can also avoid a load/store which can be much faster than the equivalent operation using a temporary variable. On some architectures, certain operations require their operands to be in particular registers, requiring a swap; and all available "temporary" registers may be in use storing other data. Some <link xlink:type="simple" xlink:href="../355/40355.xml">
optimizing compiler</link>s can generate code using XOR swap in these situations.</p>

</sec>
<sec>
<st>
Reasons for avoidance in practice</st>
<p>

Most modern compilers can optimize away the temporary variable in the naive swap, in which case the naive swap uses the same amount of memory and the same number of registers as the XOR swap and is at least as fast, and often faster.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> As a general rule, you should never use the XOR swap unless you know for a fact that the naive swap will not suit your application (which is very rare in this day and age). The XOR swap is also much less readable, and can be completely opaque to anyone who isn't already familiar with the technique.</p>
<p>

On modern (desktop) CPUs, the XOR technique is considerably slower than using a temporary variable to do swapping. One reason is that modern CPUs strive to execute commands in parallel; see <link xlink:type="simple" xlink:href="../314/220314.xml">
Instruction pipeline</link>. In the XOR technique, the inputs to each operation depend on the results of the previous operation, so they must be executed in strictly sequential order. If efficiency is of tremendous concern, it is advised to test the speeds of both the XOR technique and temporary variable swapping on the target architecture.</p>

<ss1>
<st>
The XCHG instruction</st>
<p>

Modern <link xlink:type="simple" xlink:href="../355/40355.xml">
optimizing compiler</link>s work by translating the code they are given into an <link xlink:type="simple" xlink:href="../091/485091.xml">
internal flow-based representation</link> which they transform in many ways before producing their machine-code output. These compilers are more likely to recognize and optimize a conventional (temporary-based) swap than to recognize the high-level language statements that correspond to an XOR swap. Many times, what is written as a swap in high-level code is translated by the compiler into a simple internal note that two variables have swapped memory addresses, rather than any amount of machine code. Other times, when the target architecture supports it, the compiler can use a single XCHG (exchange) instruction which performs the swap in a single operation.</p>
<p>

An XCHG operation was available as long ago as 1964, on the <link xlink:type="simple" xlink:href="../822/218822.xml">
PDP-6</link> (where it was called EXCH) and in 1970 on the <link>
Datacraft</link> 6024 series (where it was called XCHG). The <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../063/15063.xml">
Intel 8086</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, released in 1978, also included an instruction named XCHG. All three of these instructions swapped registers with registers, or registers with memory, but were unable to swap the contents of two memory locations. The <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../270/20270.xml">
Motorola 68000</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
's EXG operation can only swap registers with registers. The <link xlink:type="simple" xlink:href="../628/23628.xml">
PDP-10</link> inherited the PDP-6's EXCH instruction, but the <link xlink:type="simple" xlink:href="../399/24399.xml">
PDP-11</link> (the machine on which the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
 was developed) did not.</p>
<p>

However, the XCHG instruction in modern processors (e.g. <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>) should only be used to swap <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link>s and not <link xlink:type="simple" xlink:href="../847/25847.xml">
memory</link>, as an implicit <it>LOCK</it> instruction may be imposed by the processor on the memory location(s) involved so that the operation is <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic</link>.</p>

</ss1>
<ss1>
<st>
Aliasing</st>
<p>

The XOR swap is also complicated in practice by <link xlink:type="simple" xlink:href="../841/671841.xml">
aliasing</link>. As noted above, if an attempt is made to XOR-swap the contents of some location with itself, the result is that the location is zeroed out and its value lost. Therefore, XOR swapping must not be used blindly in a high-level language if aliasing is possible.</p>

</ss1>
</sec>
<sec>
<st>
Variations</st>
<p>

The underlying principle of the XOR swap algorithm can be applied to any reversible binary operation. Replacing XOR by addition and subtraction gives a slightly different, but largely equivalent, formulation:</p>

<p>

void addSwap (int *x, int *y)
{
if (x != y) {
<list>
<entry level="1" type="bullet">

x = *x + *y;</entry>
<entry level="1" type="bullet">

y = *x - *y;</entry>
<entry level="1" type="bullet">

x = *x - *y;</entry>
</list>

}
}</p>

<p>

Unlike the XOR swap, this variation requires that the underlying processor or programming language uses a method such as <link xlink:type="simple" xlink:href="../087/20087.xml">
modular arithmetic</link> or <link xlink:type="simple" xlink:href="../892/600892.xml">
bignum</link>s to guarantee that the computation of X + Y cannot cause an error due to <link xlink:type="simple" xlink:href="../421/2151421.xml">
integer overflow</link>. Therefore, it is seen even more rarely in practice than the XOR swap.</p>

</sec>
<sec>
<st>
 Notes </st>
<p>

<reflist>
<entry id="1">
The first three properties, along with the existence of an inverse for each element, are the definition of an <possession wordnetid="100032613" confidence="0.8">
<property wordnetid="113244109" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Abelian group</link></property>
</possession>
.  The last property is a structural feature of XOR not necessarily shared by other Abelian groups, nor <link xlink:type="simple" xlink:href="../447/19447.xml">
groups</link> in general.
</entry>
<entry id="2">
http://big-bad-al.livejournal.com/98093.html</entry>
</reflist>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../288/262288.xml">
Symmetric difference</link></concept>
</idea>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../683/291683.xml">
XOR linked list</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
