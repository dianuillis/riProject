<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 02:35:53[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>K-approximation of k-hitting set</title>
<id>14643464</id>
<revision>
<id>218411066</id>
<timestamp>2008-06-10T15:06:07Z</timestamp>
<contributor>
<username>DOI bot</username>
<id>6652755</id>
</contributor>
</revision>
<categories>
<category>Optimization algorithms</category>
<category>Approximation algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>k-approximation of k-hitting set</b> is an <link xlink:type="simple" xlink:href="../105/563105.xml">
approximation algorithm</link> for weighted <link xlink:type="simple" xlink:href="../189/4052189.xml">
hitting set</link>. The input is a <link xlink:type="simple" xlink:href="../816/12119816.xml">
collection</link> <it>S</it> of <link xlink:type="simple" xlink:href="../631/27631.xml">
subset</link>s of some universe <it>T</it> and a <mathematical_relation wordnetid="113783581" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/516931.xml">
mapping</link></function>
</concept>
</idea>
</mathematical_relation>
 <it>W</it> from <it>S</it> to non-negative numbers called the weights of the elements of <it>S</it>. In <b>k-hitting set</b> the size of the sets in <it>S</it> cannot be larger than <it>k</it>. That is, <math>\forall i \in S: |i| \leq k</math>. The problem is now to pick some subset <it>T</it>' of <it>T</it> such that every set in <it>S</it> contains some element of <it>T</it>', and such that the total weight of all elements in <it>T</it>' is as small as possible.
<sec>
<st>
The algorithm</st>
<p>

For each set <math>j</math> in <it>S</it> is maintained a <it>price</it>, <math>p_j</math>, which is initially 0. For an element <it>a</it> in <it>T</it>, let <it>S</it>(<it>a</it>) be the collection of sets from <it>S</it> containing <it>a</it>. During the algorithm the following invariant is kept</p>
<p>

<indent level="1">

<math>\forall a \in T: \sum_{j \in S(a)} p_j \leq W(a).\,</math>
</indent>

We say that an element a from <it>T</it> is <it>tight</it> if <math>\Sigma_{j \in S(a)} p_j = W(a)</math>. The main part of the algorithm consists of a loop: As long as there is a set in <it>S</it> that contains an element from <it>T</it> which is not tight, the price of this set is increased as much as possible without violating the invariant above. When this loop exits, all sets contain some tight element. Pick all the tight elements to be the hitting set.</p>

</sec>
<sec>
<st>
Correctness</st>
<p>

The algorithm always terminates because in each iteration of the loop the price of some set in <it>S</it> is increased enough to make one more element from <it>T</it> tight. If it cannot increase any price, it exits. It runs in polynomial time because the loop will not make more iterations than the number of elements in the union of all the sets of <it>S</it>. It returns a hitting set, because when the loop exits, all sets in <it>S</it> contain a tight element from <it>T</it>, and the set of these tight elements are returned.</p>
<p>

Note that for any hitting set <it>T*</it> and any prices <math>p_1, \ldots, p_{|S|}</math> where the invariant from the algorithm is true, the total weight of the hitting set is an upper limit to the sum over all members of <it>T*</it> of the sum of the prices of sets containing this element, that is: <math>\Sigma_{a \in T^*} \Sigma_{j \in S(a)} p_j \leq \Sigma_{a \in T^*} W(a)</math>. This follows from the invariant property. Further, since the price of every set must occur at least once on the left hand side, we get <math>\Sigma_{j \in S} p_j \leq \Sigma_{a \in T^*} W(a)</math>. Especially, this property is true for the optimal hitting set.</p>
<p>

Further, for the hitting set <it>H</it> returned from the algorithm above, we have <math>\Sigma_{a \in H} \Sigma_{j \in S(a)} p_j = \Sigma_{a \in H} W(a)</math>. Since any price <math>p_j</math> can appear at most <it>k</it> times in the left-hand side (since subsets of <it>S</it> can contain no more than <it>k</it> element from <it>T</it>) we get <math>\Sigma_{a \in H} W(a) \leq k \cdot \Sigma_{j \in S} p_j</math> Combined with the previous paragraph we get <math>\Sigma_{a \in H} W(a) \leq k \cdot \Sigma_{a \in T^*} W(a)</math>, where <it>T*</it> is the optimal hitting set. This is exactly the guarantee that it is a k-approximation algorithm.</p>

</sec>
<sec>
<st>
Relation to linear programming</st>
<p>

This algorithm is an instance of the <link>
primal-dual method</link>, also called <b>the pricing method</b>. The intutition is that it is <link xlink:type="simple" xlink:href="../737/609737.xml">
dual</link> to a <link xlink:type="simple" xlink:href="../730/43730.xml">
linear programming</link> algorithm. For an explanation see http://algo.inria.fr/seminars/sem00-01/vazirani.html.</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
J. Kleinberg</link> and <link>
E. Tardos</link>, <it>Algorithm Design</it>, 2006. ISBN 0-321-295358.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../632/632632.xml">
S. Even</link></scientist>
; R. Bar-Yehuda&#32;(1981).&#32;"A Linear-Time Approximation Algorithm for the Weighted Vertex Cover Problem". <it>J. Algorithms</it>&#32;<b>2</b>: 198â€“203. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0196-6774%2881%2990020-1">
10.1016/0196-6774(81)90020-1</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 M.X. Goemans and D. P. Williamson. <it>The primal-dual method for approximation algorithms and its application to network design problems</it>. In <it><link>
Approximation Algorithms for NP-Hard problems</link>, <link>
Dorit H. Hochbaum</link>, ed. ,PWS Publishing Company, 1997. ISBN 0-534-94968-1.</it></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
