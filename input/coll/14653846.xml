<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 02:36:12[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Boosting methods for object categorization</title>
<id>14653846</id>
<revision>
<id>238350555</id>
<timestamp>2008-09-14T12:46:08Z</timestamp>
<contributor>
<username>KYN</username>
<id>505011</id>
</contributor>
</revision>
<categories>
<category>Learning in computer vision</category>
<category>Object recognition and categorization</category>
</categories>
</header>
<bdy>

Given images containing various known objects in the world, a classifier can be learned from them to automatically categorize the objects in future images. Simple classifiers built based on some image feature of the object tend to be weak in categorization performance. <b>Using boosting methods for object categorization</b>, then, is a way to unify the weak classifiers in a special way to boost the overall ability of categorization.
<sec>
<st>
Problem of object categorization</st>
<p>

Object categorization is a typical task of <link xlink:type="simple" xlink:href="../596/6596.xml">
computer vision</link> which involves determining whether or not an image contains some specific <link xlink:type="simple" xlink:href="../425/144425.xml">
category</link> of object. The idea is closely related with <link xlink:type="simple" xlink:href="../543/1208543.xml">
recognition</link>, <link xlink:type="simple" xlink:href="../966/493966.xml">
identification</link>, and <link xlink:type="simple" xlink:href="../935/42935.xml">
detection</link>. Appearance based object categorization typically contains <link xlink:type="simple" xlink:href="../190/242190.xml">
feature extraction</link>, <link xlink:type="simple" xlink:href="../403/183403.xml#xpointer(//*[./st=%223%22])">
learning</link> a <link xlink:type="simple" xlink:href="../543/1508543.xml">
classifier</link>, and applying the classifier to new examples. There are many ways to represent a category of objects, e.g. from shape analysis, <link xlink:type="simple" xlink:href="../441/14003441.xml">
bag of words model</link>s, or local descriptors such as <link xlink:type="simple" xlink:href="../345/1208345.xml">
SIFT</link>, etc. Examples of <link xlink:type="simple" xlink:href="../926/20926.xml">
supervised classifiers</link> are <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../339/87339.xml">
Naive Bayes classifier</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, <know-how wordnetid="105616786" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../309/65309.xml">
SVM</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</method>
</rule>
</event>
</know-how>
, <link>
mixtures of Gaussian</link>, <link xlink:type="simple" xlink:href="../542/1729542.xml">
neural network</link>, etc. However, recent research has shown that object categories and their locations in images can be discovered in an <link xlink:type="simple" xlink:href="../497/233497.xml">
unsupervised manner</link> as well. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
Status quo for object categorization</st>
<p>

The recognition of object categories in images is a challenging problem in computer vision, especially when the number of categories is large. This is due to high intra class variability and the need for generalization across variations of objects within the same category. Objects within one category may look quite different. Even the same object may appear unalike under different viewpoint, <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../752/651752.xml">
scale</link></function>
</mathematical_relation>
, and <technique wordnetid="105665146" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../230/5208230.xml">
illumination</link></method>
</know-how>
</technique>
. Background clutter and partial occlusion add difficulties to recognition as well.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> Humans are able to recognize thousands of object types, whereas most of the existing object recognition systems are trained to recognize only a few, e.g., human face, car, simple objects, etc. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Research has been very active on dealing with more categories and enabling incremental additions of new categories, and although the general problem remains unsolved, several multi-category objects detectors (number of categories around 20) for clustered scenes have been developed. One means is by <link xlink:type="simple" xlink:href="../455/3193455.xml">
feature</link> sharing and <link xlink:type="simple" xlink:href="../500/90500.xml">
boosting</link>.  </p>

</sec>
<sec>
<st>
Boosting methods in machine learning</st>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../500/90500.xml">
Boosting</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a general method for improving the accuracy of any given learning algorithm. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> 
A typical application of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../603/1645603.xml">
AdaBoost</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 as one of the popular boosting algorithms is fast <link xlink:type="simple" xlink:href="../495/634495.xml">
face detection</link> by P. Viola and M. Jones. There <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../603/1645603.xml">
AdaBoost</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is used both to select good <link xlink:type="simple" xlink:href="../752/187752.xml">
feature</link>s (very simple rectangles) and to turn weak learners into a final strong classifier.</p>

</sec>
<sec>
<st>
Using boosting methods for object categorization</st>

<ss1>
<st>
Boosting for binary categorization</st>
<p>

We use Adaboost for face detection as an example here. The two categories are faces versus background. The general algorithm is as follows:
<list>
<entry level="1" type="number">

Form a large set of simple features</entry>
<entry level="1" type="number">

Initialize weights for training images</entry>
<entry level="1" type="number">

for T rounds</entry>
<entry level="2" type="number">

Normalize the weights</entry>
<entry level="2" type="number">

For available features from the set, train a classifier using a single feature and evaluate the training error</entry>
<entry level="2" type="number">

Choose the classifier with the lowest error</entry>
<entry level="2" type="number">

Update the weights of the training images: increase if classified wrongly by this classifier, decrease if correctly</entry>
<entry level="1" type="number">

Form the final strong classifier as the linear combination of the T classifiers (coefficient larger if training error is small)</entry>
</list>

After boosting, a classifier constructed from 200 features could yield a 95% detection rate under a <math>10^{-5}</math> <link xlink:type="simple" xlink:href="../877/5657877.xml">
false positive rate</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>
<p>

Another application of <link xlink:type="simple" xlink:href="../500/90500.xml">
boosting</link> for binary categorization is a system which detects pedestrians using <link xlink:type="simple" xlink:href="../351/68351.xml">
patterns</link> of motion and appearance<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>. This work is the fist to combine both motion information and appearance information as <link xlink:type="simple" xlink:href="../752/187752.xml">
feature</link>s to detect a walking person. It takes a similar approach as the face detection work of <link>
Viola and Jones</link>. 
</p>
</ss1>
<ss1>
<st>
Boosting for multi-class categorization</st>
<p>

Compared with binary categorization, multi-class categorization looks for common features that can be shared across the categories at the same time. They turn to be more generic <link xlink:type="simple" xlink:href="../680/331680.xml">
edge</link> like <link xlink:type="simple" xlink:href="../752/187752.xml">
feature</link>s. During learning, the detectors for each category can be trained jointly. Compared with training separately, it <link xlink:type="simple" xlink:href="../746/12746.xml">
generalizes</link> better, needs less training data, and requires less number of features to achieve same performance.</p>
<p>

The main flow of the algorithm is similar to the binary case. What is different is that a measure of the joint training error shall be defined in advance. During each iteration the algorithm chooses a classifier of a single feature (features which can be shared by more categories shall be encouraged). This can be done via converting multi-class classification into a binary one (a set of categories versus the rest) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>, or by introducing a penalty error from the categories which do not have the feature of the classifier. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>
<p>

In the paper "Sharing visual features for multiclass and multiview object detection", A. Torralba et. al used <link>
GentleBoost</link> for boosting and showed that when training data is limited, learning via sharing features does a much better job than no sharing, given same boosting rounds. Also, for a given performance level, the total number of features required (and therefore the run time cost of the classifier) for the feature sharing detectors, is observed to scale approximately <link xlink:type="simple" xlink:href="../860/17860.xml">
logarithmically</link> with the number of class, i.e., slower than <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../591/91591.xml">
linear</link></concept>
</idea>
 growth in the non-sharing case. Similar results are shown in the paper "Incremental learning of object detectors using a visual shape alphabet", yet the authors used <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../603/1645603.xml">
AdaBoost</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for boosting.</p>

</ss1>
</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Sivic, Russell, Efros, Freeman &amp; Zisserman,  "Discovering objects and their location in images", ICCV 2005</entry>
<entry id="2">
A. Opelt, A. Pinz, et al., "Generic Object Recognition with Boosting", IEEE Transactions on PAMI 2006</entry>
<entry id="3">
M. Marszalek, "Semantic Hierarchies for Visual Object Recognition", 2007</entry>
<entry id="4">
Y. Freund R. E. Schapire, "A Short Introduction to Boosting", 1999</entry>
<entry id="5">
P. Viola, M. Jones, "Robust Real-time Object Detection", 2001</entry>
<entry id="6">
P. Viola, et al., "Detecting Pedestrians Using Patterns of Motion and Appearance", ICCV 2003</entry>
<entry id="7">
A. Torralba, K. P. Murphy, et al., "Sharing visual features for multiclass and multiview object detection", IEEE Transactions on PAMI 2006</entry>
<entry id="8">
A. Opelt, et al., "Incremental learning of object detectors using a visual shape alphabet", CVPR 2006</entry>
</reflist>
</p>

</sec>
</bdy>
</article>
