<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:19:03[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Z-buffering</title>
<id>146904</id>
<revision>
<id>240993687</id>
<timestamp>2008-09-25T21:25:37Z</timestamp>
<contributor>
<username>Vitorpamplona</username>
<id>7703252</id>
</contributor>
</revision>
<categories>
<category>3D computer graphics</category>
</categories>
</header>
<bdy>

<image width="150px" src="Z-buffer.jpg" type="thumb">
<caption>

Z-buffer data
</caption>
</image>
<p>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, <b>z-buffering</b> is the management of image depth coordinates in three-dimensional (3-D) graphics, usually done in <link xlink:type="simple" xlink:href="../615/13615.xml">
hardware</link>, sometimes in <link xlink:type="simple" xlink:href="../309/5309.xml">
software</link>. It is one solution to the <link xlink:type="simple" xlink:href="../665/9331665.xml">
visibility problem</link>, which is the problem of deciding which elements of a rendered scene are visible, and which are hidden. The <link xlink:type="simple" xlink:href="../028/47028.xml">
painter's algorithm</link> is another common solution which, though less efficient, can also handle non-opaque scene elements. Z-buffering is also known as <b>depth buffering</b>.</p>
<p>

When an object is rendered by a <link xlink:type="simple" xlink:href="../214/390214.xml">
3D graphics card</link>, the depth of a generated <link xlink:type="simple" xlink:href="../665/23665.xml">
pixel</link> (z coordinate) is stored in a <link xlink:type="simple" xlink:href="../183/2406183.xml">
buffer</link> (the <b>z-buffer</b> or <b>depth buffer</b>). This buffer is usually arranged as a two-dimensional array (x-y) with one element for each screen pixel. If another object of the scene must be rendered in the same pixel, the graphics card compares the two depths and chooses the one closer to the observer. The chosen depth is then saved to the z-buffer, replacing the old one. In the end, the z-buffer will allow the graphics card to correctly reproduce the usual depth perception: a close object hides a farther one. This is called <b>z-culling</b>.</p>
<p>

The granularity of a z-buffer has a great influence on the scene quality: a <link xlink:type="simple" xlink:href="../535/64535.xml">
16-bit</link> z-buffer can result in <link xlink:type="simple" xlink:href="../904/584904.xml">
artifact</link>s (called "<link xlink:type="simple" xlink:href="../063/811063.xml">
z-fighting</link>") when two objects are very close to each other. A <link xlink:type="simple" xlink:href="../348/2507348.xml">
24-bit</link> or <link xlink:type="simple" xlink:href="../733/80733.xml">
32-bit</link> z-buffer behaves much better, although the problem cannot be entirely eliminated without additional algorithms. An <link xlink:type="simple" xlink:href="../148/45148.xml">
8-bit</link> z-buffer is almost never used since it has too little precision.</p>

<sec>
<st>
Developments</st>

<p>

Even with enough granularity, quality problems may arise when <link xlink:type="simple" xlink:href="../932/41932.xml">
precision</link> in the z-buffer's distance values is not spread evenly over distance. Nearer values are much more precise (and hence can display closer objects better) than values which are farther away. Generally, this is desirable, but sometimes it will cause artifacts to appear as objects become more distant. A variation on z-buffering which results in more evenly distributed precision is called <b>w-buffering</b> (see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22W-buffer%22])">
below</link>).</p>
<p>

At the start of a new scene, the z-buffer must be cleared to a defined value, usually 1.0, because this value is the upper limit (on a scale of 0 to 1) of depth, meaning that no object is present at this point through the <link xlink:type="simple" xlink:href="../564/782564.xml">
viewing frustum</link>. </p>
<p>

The invention of the z-buffer concept is most often attributed to <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<good_person wordnetid="110138767" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<saint wordnetid="110546850" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../051/174051.xml">
Edwin Catmull</link></associate>
</professional>
</saint>
</adult>
</scientist>
</causal_agent>
</colleague>
</good_person>
</person>
</peer>
</physical_entity>
, although Wolfgang Stra√üer also described this idea in his 1974 Ph.D. thesis<link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22fn_1%22])">
1</link>.</p>
<p>

On recent PC graphics cards (1999-2005), z-buffer management uses a significant chunk of the available <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> <link xlink:type="simple" xlink:href="../827/15612827.xml">
bandwidth</link>. Various methods have been employed to reduce the performance cost of z-buffering, such as <link xlink:type="simple" xlink:href="../209/18209.xml">
lossless compression</link> (computer resources to compress/decompress are cheaper than bandwidth) and ultra fast hardware z-clear that makes obsolete the "one frame positive, one frame negative" trick (skipping inter-frame clear altogether using signed numbers to cleverly check depths).</p>

</sec>
<sec>
<st>
Z-culling</st>

<p>

In <link xlink:type="simple" xlink:href="../604/6604.xml">
rendering</link>, z-culling is early pixel elimination based on depth, a method that provides an increase in performance when rendering of hidden surfaces is costly. It is a direct consequence of z-buffering, where the depth of each pixel candidate is compared to the depth of existing geometry behind which it might be hidden. </p>
<p>

When using a z-buffer, a pixel can be culled (discarded) as soon as its depth is known, which makes it possible to skip the entire process of lighting and <link xlink:type="simple" xlink:href="../903/146903.xml">
texturing</link> a pixel that would not be <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link>
visible</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 anyway. Also, time-consuming <link xlink:type="simple" xlink:href="../115/441115.xml">
pixel shader</link>s will generally not be executed for the culled pixels. This makes z-culling a good optimization candidate in situations where <link xlink:type="simple" xlink:href="../073/4377073.xml">
fillrate</link>, lighting, texturing or pixel shaders are the main <link>
bottlenecks</link>.</p>
<p>

While z-buffering allows the geometry to be unsorted, sorting <link xlink:type="simple" xlink:href="../621/23621.xml">
polygon</link>s by increasing depth (thus using a reverse <link xlink:type="simple" xlink:href="../028/47028.xml">
painter's algorithm</link>) allows each screen pixel to be rendered fewer times. This can increase performance in fillrate-limited scenes with large amounts of overdraw, but suffers from severe problems such as: 
<list>
<entry level="1" type="bullet">

 polygons might occlude one another in a cycle (e.g. : triangle A occludes B occludes C occludes A), and </entry>
<entry level="1" type="bullet">

 there is no canonical to pick a point on a triangle (e.g.: no matter whether one sorts triangles by their <link xlink:type="simple" xlink:href="../926/187926.xml">
centroid</link> or closest point or furthest point, one can always find two triangles A and B such that A is "closer" but in reality A should be drawn first). </entry>
</list>

As such, a reverse painter's algorithm cannot be used as an alternative to Z-culling (without strenuous re-engineering), except as an optimization to Z-culling. For example, an optimization might be to keep polygons sorted according to x/y-location and z-depth to provide bounds, in an effort to quickly determine if two polygons might possibly have an occlusion interaction.</p>

</sec>
<sec>
<st>
Mathematics</st>

<p>

The range of depth values in camera <link xlink:type="simple" xlink:href="../667/27667.xml">
space</link> (see <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../741/313741.xml">
3D projection</link></function>
</mathematical_relation>
) to be rendered is often defined between a <math>\mathit{near}</math> and <math>\mathit{far}</math> value of <math>z</math>. After a <link xlink:type="simple" xlink:href="../741/313741.xml">
perspective transform</link>ation, the new value of <math>z</math>, or <math>z'</math>, is defined by:</p>
<p>

<math>z'=
\frac{\mathit{far}+\mathit{near}}{\mathit{far}-\mathit{near}} +
\frac{1}{z} \left(\frac{-2 \cdot \mathit{far} \cdot \mathit{near}}{\mathit{far}-\mathit{near}}\right)
</math></p>
<p>

where <math>z</math> is the old value of <math>z</math> in camera space, and is sometimes called <math>w</math> or <math>w'</math>. </p>
<p>

The resulting values of <math>z'</math> are <link xlink:type="simple" xlink:href="../386/499386.xml">
normalize</link>d between the values of -1 and 1, where the <math>near</math> <link xlink:type="simple" xlink:href="../029/84029.xml">
plane</link> is at -1 and the <math>far</math> plane is at 1. Values outside of this range correspond to points which are not in the viewing <link xlink:type="simple" xlink:href="../405/89405.xml">
frustum</link>, and shouldn't be rendered.</p>
<p>

In order to convert the normalised values of <math>z'</math> back into camera space, the inverse of the above formula can be used:</p>
<p>

<math>z=
\frac{-2 \cdot \mathit{far} \cdot \mathit{near}}{z'\left(\mathit{far} - \mathit{near}\right) - \left(\mathit{far} + \mathit{near}\right)}
</math></p>
<p>

This allows measurement of distances (between objects and the camera) in the camera/object space, after a depth buffer calculation has been performed. This formula assumes that the value of <math>z'</math> has been normalised to the range [-1,1] as described above (this may not be the case, however, when reading a depth buffer from a hardware graphics accelerator). The resolution of values of <math>z</math> calculated from <math>z'</math> will depend on the selected <math>near</math> and <math>far</math> planes, as described below.</p>
<p>

To implement a z-buffer, the values of <math>z'</math> are <link xlink:type="simple" xlink:href="../010/160010.xml">
linearly interpolated</link> across screen space between the <link xlink:type="simple" xlink:href="../417/11308417.xml">
vertices</link> of the current <link xlink:type="simple" xlink:href="../621/23621.xml">
polygon</link>, and these intermediate values are generally stored in the z-buffer in <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../736/449736.xml">
fixed point</link></kind>
</type>
</category>
</concept>
</idea>
 format. The values of <math>z'</math> are grouped much more densely near the <math>near</math> plane, and much more sparsely farther away, resulting in better precision closer to the camera. The smaller the <math>near/far</math> ratio is, the less precision there is far away&mdash;having the <math>near</math> plane set too closely is a common cause of undesirable rendering artifacts in more distant objects.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>  </p>

<ss1>
<st>
W-buffer</st>

<p>

To implement a w-buffer, the old values of <math>z</math> in camera space, or <math>w</math>, are stored in the buffer, generally in <link xlink:type="simple" xlink:href="../376/11376.xml">
floating point</link> format. However, these values cannot be linearly interpolated across screen space from the vertices&mdash;they usually have to be <link xlink:type="simple" xlink:href="../958/193958.xml">
inverted</link>, interpolated, and then inverted again. The resulting values of <math>w</math>, as opposed to <math>z'</math>, are spaced evenly between <math>near</math> and <math>far</math>. There are implementations of the w-buffer that avoid the inversions altogether. </p>
<p>

Whether a z-buffer or w-buffer results in a better image depends on the application.</p>

</ss1>
</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Gr√©gory Massal.&#32;"<weblink xlink:type="simple" xlink:href="http://www.codermind.com/articles/Depth-buffer-tutorial.html">
Depth buffer - the gritty details</weblink>".&#32;Retrieved on <link>
2008-08-03</link>.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<good_person wordnetid="110138767" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<saint wordnetid="110546850" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../051/174051.xml">
Edwin Catmull</link></associate>
</professional>
</saint>
</adult>
</scientist>
</causal_agent>
</colleague>
</good_person>
</person>
</peer>
</physical_entity>
 &ndash; inventor of the z-buffer concept.</entry>
<entry level="1" type="bullet">

<process wordnetid="100029677" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<phenomenon wordnetid="100034213" confidence="0.8">
<consequence wordnetid="111410625" confidence="0.8">
<link xlink:type="simple" xlink:href="../073/10175073.xml">
3D computer graphics</link></consequence>
</phenomenon>
</physical_entity>
</process>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../063/811063.xml">
z-fighting</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../269/2082269.xml">
Irregular Z-buffer</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../404/887404.xml">
Z-order</link></entry>
<entry level="1" type="bullet">

<link>
Hierarchical Z-buffer</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.sjbaker.org/steve/omniv/love_your_z_buffer.html">
Learning to Love your Z-buffer</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.sjbaker.org/steve/omniv/alpha_sorting.html">
Alpha-blending and the Z-buffer</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>

<p>

<cite id="1"></cite> see W.K. Giloi, J.L. Encarna√ß√£o, W. Stra√üer. "The Giloi‚Äôs School of Computer Graphics". Computer Graphics 35 4:12‚Äì16.</p>


</sec>
</bdy>
</article>
