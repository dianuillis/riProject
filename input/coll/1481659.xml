<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:35:35[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Radix tree</title>
<id>1481659</id>
<revision>
<id>232171173</id>
<timestamp>2008-08-15T20:10:17Z</timestamp>
<contributor>
<username>Drachmae</username>
<id>7654688</id>
</contributor>
</revision>
<categories>
<category>Trees (structure)</category>
</categories>
</header>
<bdy>

<image location="right" width="150px" src="Patricia_trie.svg">
</image>

A <b>radix tree</b>, <b>Patricia trie</b>/<b>tree</b>, or <b>crit bit tree</b> is a specialized <link xlink:type="simple" xlink:href="../127/201127.xml">
set data structure</link> based on the <link xlink:type="simple" xlink:href="../274/31274.xml">
trie</link> that is used to store a set of strings.  In contrast with a regular <link xlink:type="simple" xlink:href="../274/31274.xml">
trie</link>, the edges of a Patricia trie are labelled with sequences of characters rather than with single characters. These can be strings of characters, bit strings such as integers or <link xlink:type="simple" xlink:href="../921/14921.xml">
IP address</link>es, or generally arbitrary sequences of objects in <link xlink:type="simple" xlink:href="../667/567667.xml">
lexicographical order</link>. Sometimes the names <it>radix tree</it> and <it>crit bit tree</it> are only applied to trees storing integers and <it>Patricia trie</it> is retained for more general inputs, but the structure works the same way in all cases.
<sec>
<st>
 Overview </st>
<p>

<image location="right" width="300 px" src="Patricia.svg">
</image>
</p>
<p>

The radix tree is easiest to understand as a space-optimized trie where each node with only one child is merged with its child. The result is that every internal node has at least two children. Unlike in regular tries, edges can be labelled with sequences of characters as well as single characters. This makes them much more efficient for small sets (especially if the strings are long) and for sets of strings that share long prefixes.</p>
<p>

It supports the following main operations, all of which are O(<it>k</it>), where <it>k</it> is the maximum length of all strings in the set:</p>
<p>

<list>
<entry level="1" type="bullet">

 Lookup: Determines if a string is in the set. This operation is identical to <link xlink:type="simple" xlink:href="../274/31274.xml">
trie</link>s except that some edges consume multiple characters.</entry>
<entry level="1" type="bullet">

 Insert: Add a string to the tree. We search the tree until we can make no further progress. At this point we either add a new outgoing edge labelled with all remaining characters in the input string, or if there is already an outgoing edge sharing a prefix with the remaining input string, we split it into two edges (the first labelled with the common prefix) and proceed. This splitting step ensures that no node has more children than there are possible string characters.</entry>
<entry level="1" type="bullet">

 Delete: Delete a string from the tree. First, we delete the corresponding leaf. Then, if its parent only has one child remaining, we delete the parent and merge the two incident edges.</entry>
<entry level="1" type="bullet">

 Find predecessor: Locates the largest string less than a given string, by lexicographic order. </entry>
<entry level="1" type="bullet">

 Find successor: Locates the smallest string greater than a given string, by lexicographic order.</entry>
</list>
</p>
<p>

A common extension of radix trees uses two colors of nodes, 'black' and 'white'. To check if a given string is stored in the tree, the search starts from the top and follows the edges of the input string until no further progress can be made. If the search-string is consumed and the final node is a black node, the search has failed; if it is white, the search has succeeded. This enables us to add a large range of strings with a common prefix to the tree, using white nodes, then remove a small set of "exceptions" in a space-efficient manner by <it>inserting</it> them using black nodes..</p>

</sec>
<sec>
<st>
 Applications </st>

<p>

As mentioned, radix trees are useful for constructing <link xlink:type="simple" xlink:href="../154/95154.xml">
associative array</link>s with keys that can be expressed as strings. They find particular application in the area of <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/15323.xml">
IP</link></rule>
</direction>
</protocol>
</message>
 <link xlink:type="simple" xlink:href="../750/25750.xml">
routing</link>, where the ability to contain large ranges of values with a few exceptions is particularly suited to the hierarchical organization of <link xlink:type="simple" xlink:href="../921/14921.xml">
IP address</link>es.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> They are also used for <link xlink:type="simple" xlink:href="../116/3125116.xml">
inverted index</link>es of text documents in <link xlink:type="simple" xlink:href="../271/15271.xml">
information retrieval</link>.</p>

</sec>
<sec>
<st>
 History </st>

<p>

<link>
Donald R. Morrison</link> first described what he called "Patricia tries" in <link xlink:type="simple" xlink:href="../655/34655.xml">
1968</link>; the name comes from the <link xlink:type="simple" xlink:href="../571/1052571.xml">
acronym</link> <b>PATRICIA</b>, which stands for "<it>Practical Algorithm to Retrieve Information Coded in Alphanumeric</it>". Gernot Gwehenberger independently invented and described the data structure at about the same time.</p>

</sec>
<sec>
<st>
 Comparison to other data structures </st>

<p>

(In the following comparisons, it is assumed that the keys are of length <it>k</it> and the data structure contains <it>n</it> elements.)</p>
<p>

Unlike <link xlink:type="simple" xlink:href="../310/378310.xml">
balanced trees</link>, radix trees permit lookup, insertion, and deletion in O(<it>k</it>) time rather than O(log <it>n</it>). This doesn't seem like an advantage, since normally <it>k</it> &amp;ge; log <it>n</it>, but in a balanced tree every comparison is a string comparison requiring O(<it>k</it>) worst-case time, many of which are slow in practice due to long common prefixes. In a trie, all comparisons require constant time, but it takes <it>m</it> comparisons to look up a string of length <it>m</it>. Radix trees can perform these operations with fewer comparisons and require many fewer nodes.</p>
<p>

Radix trees also share the disadvantages of tries, however: as they can only be applied to strings of elements or elements with an efficiently reversible mapping (<link xlink:type="simple" xlink:href="../960/249960.xml">
injection</link>) to strings, they lack the full generality of balanced search trees, which apply to any data type with a <link xlink:type="simple" xlink:href="../330/30330.xml">
total ordering</link>. A reversible mapping to strings can be used to produce the required total ordering for balanced search trees, but not the other way around. This can also be problematic if a data type only <link xlink:type="simple" xlink:href="../746/620746.xml">
provides</link> a comparison operation, but not a (de)<link xlink:type="simple" xlink:href="../555/28555.xml">
serialization</link> operation.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../833/13833.xml">
Hash table</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s are commonly said to have expected O(1) insertion and deletion times, but this is only true when considering computation of the hash of the key to be a constant time operation. When hashing the key is taken into account, hash tables have expected O(<it>k</it>) insertion and deletion times, but will take longer in the worst-case depending on how collisions are handled. Radix trees have worst-case O(<it>k</it>) insertion and deletion. The successor/predecessor operations of radix trees are also not implemented by hash tables.</p>

</sec>
<sec>
<st>
Variants</st>
<p>

The <b>HAT-trie</b> is a radix tree based cache-conscious data structure that offers efficient string storage and retrieval, and ordered iterations.  Performance, with respect to both time and space, is 
comparable to the cache-conscious <link xlink:type="simple" xlink:href="../833/13833.xml">
hashtable</link>. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Knizhnik, Konstantin. <weblink xlink:type="simple" xlink:href="http://www.ddj.com/architect/208800854">
 "Patricia Tries: A Better Index For Prefix Searches"</weblink>, <it>Dr. Dobb's Journal</it>, June, 2008.].</entry>
<entry id="2">
  <cite id="CITEREFAskitisSinha2007" style="font-style:normal">Askitis, Nikolas&#32;&amp;&#32;Sinha, Ranjan&#32;(2007),&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=1273749.1273761&amp;coll=GUIDE&amp;dl=">
HAT-trie: A Cache-conscious Trie-based Data Structure for Strings</weblink>",&#32;<it>Proceedings of the 30th Australasian Conference on Computer science</it>&#32;<b>62</b>:  pp. 97-105, ISBN 1-920-68243-0, </cite>&nbsp; </entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA/">
Monash University: Algorithms and Data Structures Research &amp; Reference Material: PATRICIA</weblink>, by Lloyd Allison</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=321481">
Practical Algorithm to Retrieve Information Coded in Alphanumeric</weblink>, original paper in ACM Portal</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/patriciatree.html">
NIST's Dictionary of Algorithms and Data Structures: Patricia Tree</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://herbert.gandraxa.com/herbert/dic.asp">
A heavily commented dictionary implementation</weblink> with a binary Radix Tree, by Herbert Glarner (in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../490/2316490.xml">
Linoleum</link></programming_language>
, a cross platform assembler)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://lwn.net/Articles/175432/">
Jonathan Corbet's article on the Radix Tree API in the Linux Kernel</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://code.google.com/p/radixtree/">
Java implementation of Radix Tree</weblink>, by Tahseen Ur Rehman</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codeproject.com/KB/string/PatriciaTrieTemplateClass.aspx">
Patricia Trie C++ template class implementation</weblink>, by Radu Gruian</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://cr.yp.to/critbit.html">
 Crit-bit trees</weblink>, by D.J. Bernstein</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ddj.com/architect/208800854">
Patricia Tries: A Better Index For Prefix Searches</weblink>, by Konstantin Knizhnik, <it>Dr. Dobb's Journal''</it></entry>
</list>
</p>


</sec>
</bdy>
</article>
