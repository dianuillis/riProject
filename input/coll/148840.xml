<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:18:20[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Parallel algorithm</title>
<id>148840</id>
<revision>
<id>237873326</id>
<timestamp>2008-09-12T05:14:49Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Parallel computing</category>
<category>Concurrent algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>parallel algorithm</b>, as opposed to a traditional <link>
sequential algorithm</link>, is one which can be executed a piece at a time on many different processing devices, and then put back together again at the end to get the correct result.<p>

Some algorithms are easy to divide up into pieces like this.  For example, splitting up the job of checking all of the numbers from one to a hundred thousand to see which are <link xlink:type="simple" xlink:href="../666/23666.xml">
primes</link> could be done by assigning a subset of the numbers to each available processor, and then putting the list of positive results back together.</p>
<p>

Most of the available algorithms to compute <link xlink:type="simple" xlink:href="../601/23601.xml">
Pi</link>, on the other hand, can not be easily split up into parallel portions.  They require the results from a preceding step to effectively carry on with the next step. Such problems are called inherently serial problems.  Iterative <link xlink:type="simple" xlink:href="../506/21506.xml">
numerical methods</link>, such as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 or the <link xlink:type="simple" xlink:href="../187/102187.xml">
three body problem</link>, are also algorithms which are inherently serial. Some problems are very difficult to parallelize, although they are recursive. One such example is the <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link> of graph. </p>
<p>

Parallel algorithms are valuable because it is faster to perform large computing tasks via a parallel algorithm than it is via a serial (non-parallel) algorithm, because of the way modern processors work. It is far more difficult to construct a computer with a single fast processor than one with many slow processors with the same <link xlink:type="simple" xlink:href="../932/30932.xml">
throughput</link>. There are also certain theoretical limits to the potential speed of serial processors. Every parallel algorithm has a serial part and so parallel algorithms have a saturation point (see <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/24th_century.xml">
Amdahl's law</link></rule>
</concept>
</idea>
). After that point adding more processors does not yield any more throughput but only increases the overhead and cost.</p>
<p>

The cost or complexity of serial algorithms is estimated in terms of the space (memory) and time (processor cycles) that they take. Parallel algorithms need to optimize one more resource, the communication between different processors. There are two ways parallel processors communicate, shared memory or message passing.</p>
<p>

Shared memory processing needs additional locking for the data, imposes the overhead of additional processor and bus cycles, and also serializes some portion of the algorithm.</p>
<p>

Message passing processing uses channels and message boxes but this communication adds transfer overhead on the bus, additional memory need for queues and message boxes and latency in the messages. Designs of parallel processors use special buses like crossbar so that the communication overhead will be small but it is the parallel algorithm that decides the volume of the traffic.</p>
<p>

Another problem with parallel algorithms is ensuring that they are suitably <link xlink:type="simple" xlink:href="../380/4213380.xml">
load balanced</link>. For example, checking all numbers from one to a hundred thousand for primality is easy to split amongst processors, however some processors will get more work to do than the others, which will sit idle until the loaded processors complete.</p>
<p>

A subtype of parallel algorithms, <it><link xlink:type="simple" xlink:href="../202/3367202.xml">
distributed algorithms</link></it> are algorithms designed to work in <link xlink:type="simple" xlink:href="../896/18949896.xml">
cluster computing</link> and <link xlink:type="simple" xlink:href="../501/8501.xml">
distributed computing</link> environments, where additional concerns beyond the scope of "classical" parallel algorithms need to be addressed.</p>

<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../619/985619.xml">
multiple-agent system</link> (MAS), <link xlink:type="simple" xlink:href="../542/1729542.xml">
neural network</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../162/145162.xml">
Parallel computing</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.dcs.ed.ac.uk/home/stg/pub/P/par_alg.html">
Parallel Algorithm Design</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-unix.mcs.anl.gov/dbpp/">
Designing and Building Parallel Programs page at the US Argonne National Laboratories</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
