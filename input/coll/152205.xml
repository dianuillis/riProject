<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:21:02[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Forcing (mathematics)</title>
<id>152205</id>
<revision>
<id>242656366</id>
<timestamp>2008-10-03T02:46:59Z</timestamp>
<contributor>
<username>דוד שי</username>
<id>7192861</id>
</contributor>
</revision>
<categories>
<category>Forcing</category>
</categories>
</header>
<bdy>

For the use of forcing in <link xlink:type="simple" xlink:href="../414/155414.xml">
recursion theory</link>, see <link xlink:type="simple" xlink:href="../903/13012903.xml">
Forcing (recursion theory)</link>.
In the mathematical discipline of <link xlink:type="simple" xlink:href="../553/27553.xml">
set theory</link>, <b>forcing</b> is a technique invented by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../994/22994.xml">
Paul Cohen</link></scientist>
</person>
, for proving <link xlink:type="simple" xlink:href="../802/75802.xml">
consistency</link> and <link xlink:type="simple" xlink:href="../208/1141208.xml">
independence</link> results in set theory. It was first used, in 1962, to prove the independence of the <link xlink:type="simple" xlink:href="../705/5705.xml">
continuum hypothesis</link> and the <link xlink:type="simple" xlink:href="../840/840.xml">
axiom of choice</link> from <link xlink:type="simple" xlink:href="../214/152214.xml">
Zermelo-Fraenkel set theory</link>. Forcing was considerably reworked and simplified in the sixties, and has proven to be an extremely powerful technique both within set theory and in other areas of <link xlink:type="simple" xlink:href="../636/19636.xml">
mathematical logic</link> such as <link xlink:type="simple" xlink:href="../414/155414.xml">
recursion theory</link>.<p>

<link xlink:type="simple" xlink:href="../619/396619.xml">
Descriptive set theory</link> uses both the notion of forcing from <link xlink:type="simple" xlink:href="../414/155414.xml">
recursion theory</link> as well as set theoretic forcing.  Forcing has also been used in <link xlink:type="simple" xlink:href="../858/19858.xml">
model theory</link> but it is common in model theory to define <link>
genericity</link> directly without mention of forcing.</p>

<sec>
<st>
 Intuitions </st>

<p>

Forcing is equivalent to the method of <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Boolean-valued+models%22])">
Boolean-valued models</link>, which some feel is conceptually more natural and intuitive, but usually much more difficult to apply.</p>
<p>

Intuitively, forcing consists of expanding the set theoretical universe <it>V</it> to a larger universe <it>V</it>*. In this bigger universe, for example, one might have lots of new subsets of <it>ω</it> = {0,1,2,…} that weren't there in the old universe, and thereby violate the continuum hypothesis. While impossible on the face of it, this is just another version of Cantor's "paradoxes" about infinity. In principle, one could consider <it>V</it>*=<it>V</it>&amp;times;{0,1}, identify <it>x</it>∈<it>V</it> with (<it>x</it>,0), and then introduce an expanded membership relation involving the "new" sets of the form (<it>x</it>,1). Forcing is a more elaborate version of this idea, reducing the expansion to the existence of one new set, and allowing for fine control over the properties of the expanded universe.</p>
<p>

Cohen's original technique, now called <link xlink:type="simple" xlink:href="../017/15634017.xml">
ramified forcing</link>, is slightly different from the <b>unramified forcing</b> expounded here.</p>

</sec>
<sec>
<st>
Forcing posets</st>

<p>

A <b>forcing poset</b> is an ordered triple </p>
<p>

<indent level="1">

(<b>P</b>, ≤, 1) 
</indent>

where "≤" is a <link xlink:type="simple" xlink:href="../582/23582.xml">
preorder</link> on <b>P</b>, and 1 is a largest element, that is, </p>
<p>

<indent level="1">

<it>p</it> ≤ 1 for all <it>p</it> ∈ <b>P</b>. 
</indent>

Members of <b>P</b> are called <it>conditions</it>. One reads </p>
<p>

<indent level="1">

<it>p</it> ≤ <it>q</it> 
</indent>

as </p>
<p>

<indent level="1">

<it>p</it> is <it>stronger</it> than <it>q</it>. 
</indent>

Intuitively, the "smaller" condition provides "more" information, just as the smaller interval [3.1415926,3.1415927] provides more information about the number <link xlink:type="simple" xlink:href="../601/23601.xml">
π</link> than the interval [3.1,3.2] does.</p>
<p>

(There are various conventions here. Some authors require "≤" to also be <link xlink:type="simple" xlink:href="../176/1176.xml">
antisymmetric</link>, so that the relation is a <link xlink:type="simple" xlink:href="../572/23572.xml">
partial order</link>. Some use the term <link xlink:type="simple" xlink:href="../572/23572.xml">
partial order</link> anyway, conflicting with standard terminology, while some use the term <link xlink:type="simple" xlink:href="../582/23582.xml">
preorder</link>. The largest element can be dispensed with. The reverse ordering is also used, most notably by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../211/331211.xml">
Saharon Shelah</link></scientist>
</person>
 and his co-authors.)</p>
<p>

Associated with a forcing poset <b>P</b> are the <b>P</b>-<it>names</it>. <b>P</b>-names are sets of the form </p>
<p>

<indent level="1">

{(<it>u</it>,<it>p</it>):<it>u</it> is a <b>P</b>-name and <it>p</it> ∈ <b>P</b>}. 
</indent>

This definition is circular; which in set theory means it is really a definition by <link xlink:type="simple" xlink:href="../461/30461.xml">
transfinite induction</link>. In long form, one defines,
<list>
<entry level="3" type="bullet">

Name(0) = {};</entry>
<entry level="3" type="bullet">

Name(α + 1) = the power set of (Name(α) &amp;times; <b>P</b>);</entry>
<entry level="3" type="bullet">

Name(λ) =  ∪{Name(α) : α  λ}, for λ a limit ordinal,</entry>
</list>

and then defines the class of <b>P</b>-names to be </p>
<p>

<indent level="1">

V(<b>P</b>) =  ∪{Name(α) : α is an ordinal}.
</indent>

The <b>P</b>-names are, in fact, an expansion of the universe. Given <it>x</it> in <it>V</it>, one defines </p>
<p>

<indent level="1">

<it>x</it>ˇ 
</indent>

to be the <b>P</b>-name </p>
<p>

<indent level="1">

{(<it>y</it>ˇ,1) : <it>y</it> ∈ <it>x</it>}. 
</indent>

Again, this is really a definition by transfinite induction.</p>
<p>

Given any subset <it>G</it> of <b>P</b>, one next defines the <it>interpretation</it> or <it>valuation</it> map from names by </p>
<p>

<indent level="1">

val(<it>u</it>, <it>G</it>) = {val(<it>v</it>, <it>G</it>) : ∃ <it>p</it> ∈ <it>G</it> , (<it>v</it>, <it>p</it>) ∈ <it>u</it>}. 
</indent>

(Again a definition by transfinite induction.) Note that if 1 is in <it>G</it>, then </p>
<p>

<indent level="1">

val(<it>x</it>ˇ, <it>G</it>) = <it>x</it>. 
</indent>

One defines </p>
<p>

<indent level="1">

<it>G</it> = {(<it>p</it>ˇ, <it>p</it>) : <it>p</it> ∈ <it>G</it>}, 
</indent>

then </p>
<p>

<indent level="1">

val(<it>G</it>,<it>G</it>) = <it>G</it>.
</indent>

A good example of a forcing poset is </p>
<p>

<indent level="1">

(Bor(<b>I</b>) , ⊆ , <b>I</b> ), 
</indent>

where <b>I</b> = [0,1] and Bor(<b>I</b>) are the <link xlink:type="simple" xlink:href="../327/43327.xml">
Borel subset</link>s of <b>I</b> having non-zero <link xlink:type="simple" xlink:href="../198/18198.xml">
Lebesgue measure</link>. In this case, one can talk about the conditions as being probabilities, and a Bor(<b>I</b>)-name assigns membership in a probabilistic sense. Because of the ready intuition this example can provide, probabilistic language is sometimes used with other forcing posets.</p>

</sec>
<sec>
<st>
Countable transitive models and generic filters</st>

<p>

The key step in forcing is, given a ZFC universe <it>V</it>, to find appropriate <it>G</it> not in <it>V</it>. The resulting class of all interpretations of <b>P</b>-names will turn out to be a model of ZFC, properly extending the original <it>V</it> (since <it>G</it>∉<it>V</it>).</p>
<p>

Instead of working with <it>V</it>, one considers a <b>countable transitive model</b> <b>M</b> with (<b>P</b>,≤,1) ∈ <b>M</b>. By model, we mean a model of set theory, either of all of ZFC, or a model of a large but finite subset of the ZFC axioms, or some variant thereof. Transitivity means that if <it>x</it> ∈ <it>y</it> ∈ <b>M</b>, then <it>x</it> ∈ <b>M</b>. The <link xlink:type="simple" xlink:href="../604/1251604.xml">
Mostowski collapsing theorem</link> says this can be assumed if the membership relation is <link xlink:type="simple" xlink:href="../712/319712.xml">
well-founded</link>. The effect of transitivity is that membership and other elementary notions can be handled intuitively. Countability of the model relies on the <link>
Löwenheim-Skolem theorem</link>.  </p>
<p>

Since <b>M</b> is a set, there are sets not in <b>M</b> - this follows from <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<contradiction wordnetid="107206887" confidence="0.8">
<paradox wordnetid="106724559" confidence="0.8">
<falsehood wordnetid="106756407" confidence="0.8">
<link xlink:type="simple" xlink:href="../095/46095.xml">
Russell's paradox</link></falsehood>
</paradox>
</contradiction>
</message>
</statement>
. The appropriate set <b>G</b> to pick, and adjoin to <b>M</b>, is a <b>generic filter</b> on <b>P</b>. The <it>filter</it> condition means that <it>G</it>⊆<b>P</b> and
<list>
<entry level="2" type="bullet">

1 ∈ <it>G</it>&nbsp;;</entry>
<entry level="2" type="bullet">

if <it>p</it> ≥ <it>q</it> ∈ <it>G</it>, then <it>p</it> ∈ <it>G</it>&nbsp;;</entry>
<entry level="2" type="bullet">

if <it>p</it>,<it>q</it> ∈ <it>G</it>, then ∃<it>r</it> ∈ <it>G</it>, <it>r</it> ≤ <it>p</it> and <it>r</it> ≤ <it>q</it>&nbsp;;</entry>
</list>

For <it>G</it> to be <it>generic</it> means
<list>
<entry level="2" type="bullet">

if <it>D</it> ∈ <b>M</b> is a <it>dense</it> subset of <b>P</b> (that is, <it>p</it> ∈ <b>P</b> implies ∃<it>q</it> ∈ <it>D</it>, <it>q</it> ≤ <it>p</it>) then <it>G</it>∩<it>D</it> ≠ 0&nbsp;.</entry>
</list>
</p>
<p>

The existence of a generic filter <it>G</it> not in <b>M</b> follows from the <link xlink:type="simple" xlink:href="../368/2209368.xml">
Rasiowa-Sikorski lemma</link>.  In fact, slightly more is true: given a condition <it>p</it> ∈ <b>P</b>, one can find a generic filter <it>G</it> such that <it>p</it> ∈ <it>G</it>.</p>
<p>

If <b>P</b> has only countably many dense subsets, then one can pick <it>G</it> ∈ <b>M</b>.  This is the trivial case in which we are uninterested. Minimal elements in <b>P</b> are also trivial, since if <it>D</it> is dense and <it>p</it> is minimal, then since the only element <it>q</it> ≤ <it>p</it> is <it>p</it> itself, <it>p</it> ∈ <it>D</it>. Thus, any filter containing even one minimal element is generic, and one can again choose <it>G</it> ∈ <b>M</b>.</p>

</sec>
<sec>
<st>
Forcing</st>

<p>

Given a generic filter <it>G</it>⊆<b>P</b>, one proceeds as follows. The subclass of <b>P</b>-names in <b>M</b> is denoted <b>M</b>(<b>P</b>). Let <b>M</b>[''G'']={val(<it>u</it>,<it>G</it>):<it>u</it>∈<b>M</b>(<b>P</b>)}. To reduce the study of the set theory of <b>M</b>[''G''] to that of <b>M</b>, one works with the <it>forcing language</it>, which is built up like ordinary <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link>, with membership as binary relation and all the names as constants.</p>
<p>

Define <it>p</it> <math>\Vdash</math> φ(<it>u</it>1,…,<it>un</it>) (read "<it>p</it> forces φ") where <it>p</it> is a condition, φ is a formula in the forcing language, and the <it>ui</it> are names, to mean that if <it>G</it> is a generic filter containing <it>p</it>, then <b>M</b>[''G''] ⊨ φ(val(<it>u</it>1,<it>G</it>),…,val(<it>un</it>,<it>G</it>)). The special case 1 <math>\Vdash</math> φ is often written <b>P</b> <math>\Vdash</math> φ or <math>\Vdash</math> φ.  Such statements are true in <b>M</b>[''G''] no matter what <it>G</it> is.</p>
<p>

What is important is that this "external" definition of the forcing relation <it>p</it> <math>\Vdash</math> φ is equivalent to an "internal" definition, defined by transfinite induction over the names on instances of <it>u</it> ∈ <it>v</it> and <it>u</it> = <it>v</it>, and then by ordinary induction over the complexity of formulas.  This has the effect that all the properties of <b>M</b>[''G''] are really properties of <b>M</b>, and the verification of ZFC in <b>M</b>[''G''] becomes straightforward. This is usually summarized as three key properties:
<list>
<entry level="1" type="bullet">

<b>Truth</b>: <b>M</b>[''G''] ⊨ φ(val(<it>u</it>1,<it>G</it>),…,val(<it>un</it>,<it>G</it>)) <link xlink:type="simple" xlink:href="../922/14922.xml">
if and only if</link> it is forced by <it>G</it>, that is, for some condition <it>p</it> ∈ <it>G</it>, <it>p</it> <math>\Vdash</math> φ(<it>u</it>1,…,<it>un</it>).</entry>
<entry level="1" type="bullet">

<b>Definability</b>: The statement "<it>p</it> <math>\Vdash</math> φ(<it>u</it>1,…,<it>un</it>)" is definable in <b>M</b>.</entry>
<entry level="1" type="bullet">

<b>Coherence</b>: If <it>p</it> <math>\Vdash</math> φ(<it>u</it>1,…,<it>un</it>) and <it>q</it> ≤ <it>p</it>, then <it>q</it> <math>\Vdash</math> φ(<it>u</it>1,…,<it>un</it>).</entry>
</list>
</p>

</sec>
<sec>
<st>
Consistency</st>

<p>

The above can be summarized by saying the fundamental consistency result is that given a forcing poset <b>P</b>, we may assume that there exists a generic filter <it>G</it>, not in the universe <it>V</it>, such that <it>V</it>[''G''] is again a set theoretic universe, modelling ZFC. Furthermore, all truths in <it>V</it>[''G''] can be reduced to truths in <it>V</it> regarding the forcing relation.</p>
<p>

Both styles, adjoining <it>G</it> to a countable transitive model <b>M</b> or to the whole universe <it>V</it>, are commonly used. Less commonly seen is the approach using the "internal" definition of forcing, and no mention of set or class models is made. This was Cohen's original method, and in one elaboration, it becomes the method of Boolean-valued analysis.</p>

</sec>
<sec>
<st>
Cohen forcing</st>

<p>

The simplest nontrivial forcing poset is ( Fin(ω,2) , ⊇ , 0 ), the finite partial functions from ω to 2={0,1} under <it>reverse</it> inclusion. That is, a condition <it>p</it> is essentially two disjoint finite subsets <it>p</it>&amp;minus;1[1] and <it>p</it>&amp;minus;1[0] of ω, to be thought of as the "yes" and "no" parts of <it>p</it>, with no information provided on values outside the domain of <it>p</it>. <it>q</it> is stronger than <it>p</it> means that <it>q</it> ⊇ <it>p</it>, in other words, the "yes" and "no" parts of <it>q</it> are supersets of the "yes" and "no" parts of <it>p</it>, and in that sense, provide more information.</p>
<p>

Let <it>G</it> be a generic filter for this poset. If <it>p</it> and <it>q</it> are both in <it>G</it>, then <it>p</it>∪<it>q</it> is a condition, because <it>G</it> is a filter. This means that <it>g</it>=⋃<it>G</it> is a well-defined partial function from ω to 2, because any two conditions in <it>G</it> agree on their common domain.</p>
<p>

<it>g</it> is in fact a total function. Given <it>n</it> ∈ ω, let <it>Dn</it>={ <it>p</it> : <it>p</it>(<it>n</it>) is defined }, then <it>Dn</it> is dense. (Given any <it>p</it>, if <it>n</it> is not in <it>p</it>’s domain, adjoin a value for <it>n</it>, the result is in <it>Dn</it>.) A condition <it>p</it> ∈ <it>G</it>∩<it>Dn</it> has <it>n</it> in its domain, and since <it>p</it> ⊆ <it>g</it>, <it>g</it>(<it>n</it>) is defined.</p>
<p>

Let <it>X</it>=<it>g</it>&amp;minus;1[1], the set of all "yes" members of the generic conditions. It is possible to give a name for <it>X</it> directly. Let <it>X</it> = { ( <it>n</it>ˇ , <it>p</it> ) : <it>p</it>(<it>n</it>)=1 }, then val( <it>X</it> , <it>G</it> ) = <it>X</it>. Now suppose <it>A</it>⊆ω in <it>V</it>. We claim that <it>X</it>≠<it>A</it>. Let <it>DA</it> = { <it>p</it> : ∃<it>n</it>, <it>n</it>∈dom(<it>p</it>) and <it>p</it>(<it>n</it>)=1 if and only if <it>n</it>∉<it>A</it> }. <it>DA</it> is dense. (Given any <it>p</it>, if <it>n</it> is not in <it>p</it>’s domain, adjoin a value for <it>n</it> contrary to the status of "<it>n</it>∈<it>A</it>".) Then any <it>p</it>∈<it>G</it>∩<it>DA</it> witnesses <it>X</it>≠<it>A</it>. To summarize, <it>X</it> is a <it>new</it> subset of ω, necessarily infinite.</p>
<p>

Replacing ω with ω&amp;times;ω2, that is, consider instead finite partial functions whose inputs are of the form (<it>n</it>,α), with <it>n</it>2, and whose outputs are 0 or 1, one gets ω2 new subsets of ω. They are all distinct, by a density argument: given α2, let <it>D</it>α,β={<it>p</it>:∃<it>n</it>, <it>p</it>(<it>n</it>,α)≠<it>p</it>(<it>n</it>,β)}, then each <it>D</it>α,β is dense, and a generic condition in it proves that the αth new set disagrees somewhere with the βth new set.</p>
<p>

This is not yet the falsification of the continuum hypothesis. One must prove that no new maps have been introduced which map ω onto ω1 or ω1 onto ω2. For example, if one considers instead Fin(ω,ω1), finite partial functions from ω to ω1, the first uncountable ordinal, one gets in <it>V</it>[''G''] a bijection from ω to ω1. In other words, ω1 has <it>collapsed</it>, and in the forcing extension, is a countable ordinal.</p>
<p>

The last step in showing the independence of the continuum hypothesis, then, is to show that Cohen forcing does not collapse cardinals. A combinatorial property implies that all of the <link xlink:type="simple" xlink:href="../973/348973.xml">
antichain</link>s of this poset are countable.</p>

</sec>
<sec>
<st>
The countable chain condition</st>

<p>

An antichain <it>A</it> of <b>P</b> is a subset such that if <it>p</it> and <it>q</it> are in <it>A</it>, then <it>p</it> and <it>q</it> are <it>incompatible</it> (written <it>p</it> ⊥ <it>q</it>), meaning there is no <it>r</it> in <b>P</b> such that <it>r</it> ≤ <it>p</it> and <it>r</it> ≤ <it>q</it>.  In the Borel sets example, incompatibility means <it>p</it>∩<it>q</it> has measure zero.  In the finite partial functions example, incompatibility means that <it>p</it>∪<it>q</it> is not a function, in other words, <it>p</it> and <it>q</it> assign different values to some domain input.</p>
<p>

<b>P</b> has the <b>countable chain condition</b> (c.c.c.) is that assertion that every antichain is countable. (The name, which is obviously inappropriate, is a holdover from older terminology. Attempts to fix this have not succeeded.)</p>
<p>

It is easy to see that Bor(<b>I</b>) has the c.c.c., because the measures add up to at most 1. Fin(<it>E</it>,2) is also c.c.c., but the proof is more difficult.</p>
<p>

Given an uncountable subfamily <it>W</it> ⊆ Fin(<it>E</it>,2), shrink <it>W</it> to an uncountable subfamily <it>W</it>0 of sets of size <it>n</it>, for some <it>n</it>1)=<it>b</it>1 for uncountably many <it>p</it> ∈ <it>W</it>0, shrink to this uncountable subfamily <it>W</it>1, and repeat, getting a finite set { (<it>e</it>1,<it>b</it>1) , … , (<it>ek</it>,<it>bk</it>) }, and an uncountable family <it>Wk</it> of incompatible conditions of size <it>n</it>&amp;minus;<it>k</it> such that every <it>e</it> is in at most countably many dom(<it>p</it>) for <it>p</it> ∈ <it>W</it>. Now pick an arbitrary <it>p</it> ∈ <it>Wk</it>, and pick from <it>Wk</it> any <it>q</it> that is not one of the countably many members that have a domain member in common with <it>p</it>. Then <it>p</it> ∪ { (<it>e</it>1,<it>b</it>1) , … , (<it>ek</it>,<it>bk</it>) } and <it>q</it> ∪ { (<it>e</it>1,<it>b</it>1) , … , (<it>ek</it>,<it>bk</it>) } are compatible, so <it>W</it> is not an antichain. In other words, Fin(<it>E</it>,2) antichains are countable.</p>
<p>

The importance of antichains in forcing is that for most purposes, dense sets and maximal antichains are equivalent. A <it>maximal</it> antichain <it>A</it> is one that cannot be extended and still be an antichain. This means every element of <it>p</it> ∈ <b>P</b> is compatible with some member of <it>A</it>. Their existence follows from <link xlink:type="simple" xlink:href="../442/51442.xml">
Zorn's lemma</link>. Given a maximal antichain <it>A</it>, let <it>D</it> = { <it>p</it> : <it>p</it>≤<it>q</it>, some <it>q</it>∈<it>A</it> }. <it>D</it> is dense, and <it>G</it>∩<it>D</it>≠0 if and only if <it>G</it>∩<it>A</it>≠0. Conversely, given a dense set <it>D</it>, Zorn's lemma shows there exists a maximal antichain <it>A</it>⊆<it>D</it>, and then <it>G</it>∩<it>D</it>≠0 if and only if <it>G</it>∩<it>A</it>≠0.</p>
<p>

Assume <b>P</b> is c.c.c. Given <it>x</it>,<it>y</it> ∈ <it>V</it>, with <it>f</it>:<it>x</it>→<it>y</it> in <it>V</it>[''G''], one can approximate <it>f</it> inside <it>V</it> as follows. Let <it>u</it> be a name for <it>f</it> (by the definition of <it>V</it>[''G'']) and let <it>p</it> be a condition which forces <it>u</it> to be a function from <it>x</it> to <it>y</it>. Define a function <it>F</it> whose domain is <it>x</it> by <it>F</it>(<it>a</it>) = { <it>b</it> : ∃ <it>q</it> ≤ <it>p</it>, <it>q</it> forces <it>u</it>(<it>a</it>ˇ) = <it>b</it>ˇ }. By definability of forcing, this definition makes sense within <it>V</it>. By coherence of forcing, different <it>b</it>’s come from incompatible <it>p</it>’s. By c.c.c., <it>F</it>(<it>a</it>) is countable.</p>
<p>

In summary, <it>f</it> is unknown in <it>V</it>, since it depends on <it>G</it>, but it is not wildly unknown for a c.c.c. forcing. One can identify a countable set of guesses for what the value of <it>f</it> is at any input, independent of <it>G</it>.</p>
<p>

This has the following very important consequence. If in <it>V</it>[''G''], <it>f</it>:α→β is a surjection from one infinite ordinal to another, then there is a corresponding surjection in <it>V</it>. In particular, cardinals cannot collapse. The conclusion is that 2ℵ₀ ≥ ℵ2 in <it>V</it>[''G''].</p>

</sec>
<sec>
<st>
Easton forcing</st>

<p>

The exact value of the continuum in the above Cohen model, and variants like Fin(ω &amp;times; κ , 2) for cardinals κ in general, was worked out by <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<theorist wordnetid="110706812" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../110/3160110.xml">
Robert M. Solovay</link></logician>
</mathematician>
</scientist>
</causal_agent>
</intellectual>
</theorist>
</person>
</expert>
</physical_entity>
, who also worked out how to violate GCH (the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../705/5705.xml#xpointer(//*[./st=%22The+generalized+continuum+hypothesis%22])">
generalized continuum hypothesis</link></difficulty>
</problem>
</state>
</condition>
</concept>
</idea>
), for <link xlink:type="simple" xlink:href="../128/374128.xml">
regular cardinal</link>s only, a finite number of times. For example, in the above Cohen model, if CH holds in <it>V</it>, then 2ℵ₀ = ℵ2 holds in <it>V</it>[''G''].</p>
<p>

W. B. Easton worked out the infinite and proper class version of violating the GCH for regular cardinals, basically showing the known restrictions (monotonicity, <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../442/341442.xml">
Cantor's theorem</link></proposition>
</theorem>
</message>
</statement>
, and <link>
König's theorem</link>) were the only ZFC provable restrictions. See <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../250/4691250.xml">
Easton's theorem</link></proposition>
</theorem>
</message>
</statement>
.</p>
<p>

Easton's work was notable in that it involved forcing with a proper class of conditions. In general, the method of forcing with a proper class of conditions will fail to give a model of ZFC. For example, Fin ( ω &amp;times; On , 2 ), where "On" is the proper class of all ordinals, will make the continuum a proper class. Fin ( ω , On ) will introduce a countable enumeration of the ordinals. In both cases, the resulting <it>V</it>[''G''] is visibly not a model of ZFC.</p>
<p>

At the time, it was thought that more sophisticated forcing would also allow arbitrary variation in the powers of <link xlink:type="simple" xlink:href="../128/374128.xml">
singular cardinal</link>s. But this has turned out to be a difficult, subtle and even surprising problem, with several more restrictions provable in ZFC, and with the forcing models depending on the consistency of various <link xlink:type="simple" xlink:href="../644/383644.xml">
large cardinal</link>s. Many open problems remain.</p>

</sec>
<sec>
<st>
Random reals</st>

<p>

In the Borel sets ( Bor(<b>I</b>) , ⊆ , <b>I</b> ) example, the generic filter converges to a real number <it>r</it>, called a <it>random</it> real. A name for the decimal expansion of <it>r</it> (in the sense of the canonical set of decimal intervals that converge to <it>r</it>) can be given by letting <it>r</it> = { ( <it>E</it>ˇ , <it>E</it> ) : <it>E</it> = [ ''k''⋅10&amp;minus;''n'' , (''k''+1)⋅10&amp;minus;''n'' ], 0≤<it>k</it>10<it>n</it> }. This is, in some sense, just a subname of <it>G</it>.</p>
<p>

To recover <it>G</it> from <it>r</it>, one takes those Borel subsets of <b>I</b> that "contain" <it>r</it>. Since the forcing poset is in <it>V</it>, but <it>r</it> is not in <it>V</it>, this containment is actually impossible. But there is a natural sense in which the interval [.5,.6] in <it>V</it> "contains" a random real whose decimal expansion begins .5. This is formalized by the notion of "Borel code".</p>
<p>

Every Borel set can, nonuniquely, be built up, starting from intervals with rational endpoints and applying the operations of complement and countable unions, a countable number of times. The record of such a construction is called a <it>Borel code</it>. Given a Borel set <it>B</it> in <it>V</it>, one recovers a Borel code, and then applies the same construction sequence in <it>V</it>[''G''], getting a Borel set <it>B</it>*.  One can prove that one gets the same set independent of the construction of <it>B</it>, and that basic properties are preserved. For example, if <it>B</it>⊆<it>C</it>, then <it>B</it>*⊆<it>C</it>*. If <it>B</it> has measure zero, then <it>B</it>* has measure zero.</p>
<p>

So given <it>r</it>, a random real, one can show that <it>G</it> = { <it>B</it> (in <it>V</it>) : <it>r</it>∈<it>B</it>* (in <it>V</it>[''G'']) }.  Because of the mutual interdefinability between <it>r</it> and <it>G</it>, one generally writes <it>V</it>[''r''] for <it>V</it>[''G''].</p>
<p>

A different interpretation of reals in <it>V</it>[''G''] was provided by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../875/161875.xml">
Dana Scott</link></scientist>
</person>
. Rational numbers in <it>V</it>[''G''] have names that correspond to countably many distinct rational values assigned to a maximal antichain of Borel sets, in other words, a certain rational-valued function on <b>I</b> = [0,1]. Real numbers in <it>V</it>[''G''] then correspond to <link xlink:type="simple" xlink:href="../569/45569.xml">
Dedekind cut</link>s of such functions, that is, <link xlink:type="simple" xlink:href="../055/44055.xml">
measurable function</link>s.</p>

</sec>
<sec>
<st>
Boolean-valued models</st>
<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../301/2732301.xml">
Boolean-valued model</link></it> 
</indent>

Perhaps more clearly, the method can be explained in terms of Boolean-valued models. In it, any statement is assigned a truth value from some infinite <link xlink:type="simple" xlink:href="../959/3959.xml">
Boolean algebra</link>, rather than just a true/false value. Then an <link xlink:type="simple" xlink:href="../911/31911.xml">
ultrafilter</link> is picked in this Boolean algebra, which assigns values true/false to statements of our theory. The point is that the resulting theory has a model which contains this ultrafilter, which can be understood as a model obtained by extending the old one with this ultrafilter. By picking a Boolean-valued model in appropriate way, we can get a model that has the desired property. In it, only statements which must be true (are "forced" to be true) will be true, in a sense (since it has this extension/minimality property).</p>

</sec>
<sec>
<st>
Meta-mathematical explanation</st>

<p>

In forcing we usually seek to show some <link xlink:type="simple" xlink:href="../527/2129527.xml">
sentence</link> is <link xlink:type="simple" xlink:href="../802/75802.xml">
consistent</link> with <link xlink:type="simple" xlink:href="../214/152214.xml">
ZFC</link> (or optionally some extension of ZFC).  One way to interpret the argument is that we assume ZFC is consistent and use it to prove ZFC combined with our new <link xlink:type="simple" xlink:href="../527/2129527.xml">
sentence</link> is also consistent.</p>
<p>

Each "condition" is a finite piece of information - the idea is that only finite pieces are relevant for consistency, since by the <link xlink:type="simple" xlink:href="../207/152207.xml">
compactness theorem</link> a theory is satisfiable if and only if every finite subset of its axioms is satisfiable. Then, we can pick an infinite set of consistent conditions to extend our model. Thus, assuming consistency of set theory, we prove consistency of the theory extended with this infinite set.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../368/15550368.xml">
List of forcing notions</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../064/7818064.xml">
Nice name</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>

<p>

<list>
<entry level="1" type="bullet">

Tim Chow's article <weblink xlink:type="simple" xlink:href="http://alum.mit.edu/www/tchow/forcing.pdf">
A Beginner's Guide to Forcing</weblink> is a good introduction to the concepts of forcing that avoids a lot of technical detail.  This paper grew out of Chow's newsgroup article <weblink xlink:type="simple" xlink:href="http://www-math.mit.edu/~tchow/mathstuff/forcingdum">
Forcing for dummies</weblink>.  In addition to improved exposition, the Beginner's Guide includes a section on Boolean Valued Models.</entry>
<entry level="1" type="bullet">

See also Kenny Easwaran's article <weblink xlink:type="simple" xlink:href="http://www.ocf.berkeley.edu/~easwaran/papers/forcing.pdf">
A Cheerful Introduction to Forcing and the Continuum Hypothesis</weblink>, which is also aimed at the beginner but includes more technical details than Chow's article.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://links.jstor.org/sici?sici=0027-8424%2819631215%2950%3A6%3C1143%3ATIOTCH%3E2.0.CO%3B2-5">
The Independence of the Continuum Hypothesis</weblink> Paul J. Cohen, Proceedings of the National Academy of Sciences of the United States of America, Vol. 50, No. 6. (Dec. 15, 1963), pp. 1143-1148.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://links.jstor.org/sici?sici=0027-8424%2819640115%2951%3A1%3C105%3ATIOTCH%3E2.0.CO%3B2-U">
  The Independence of the Continuum Hypothesis, II</weblink>  Paul J. Cohen  Proceedings of the National Academy of Sciences of the United States of America, Vol. 51, No. 1. (Jan. 15, 1964), pp. 105-110.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 Bell, J. L. (1985) <it>Boolean-Valued Models and Independence Proofs in Set Theory</it>, Oxford. ISBN 0-19-853241-5</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book">Cohen, P. J.&#32;(1966). Set theory and the continuum hypothesis.&#32;Addison-Wesley. ISBN 0-8053-2327-9.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite id="CITEREFGrishin2001" style="font-style:normal">Grishin, V.N.&#32;(2001),&#32;<weblink xlink:type="simple" xlink:href="http://eom.springer.de/F/f040770.htm">
"Forcing method"</weblink>, in&#32;Hazewinkel, Michiel,&#32;<it><computer wordnetid="103082979" confidence="0.8">
<work wordnetid="104599396" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<encyclopedia wordnetid="106427387" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../594/4647594.xml">
Encyclopaedia of Mathematics</link></web_site>
</device>
</book>
</instrumentality>
</artifact>
</product>
</encyclopedia>
</publication>
</reference_book>
</machine>
</creation>
</work>
</computer>
</it>, Kluwer Academic Publishers, ISBN 978-1556080104</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book">Kunen, Kenneth&#32;(1980). .&#32;North-Holland. ISBN 0-444-85401-0.</cite>&nbsp;</entry>
</list>

</p>

</sec>
</bdy>
</article>
