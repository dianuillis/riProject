<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:21:13[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Root-finding algorithm</title>
<id>153299</id>
<revision>
<id>221293018</id>
<timestamp>2008-06-23T22:01:00Z</timestamp>
<contributor>
<username>Jaded-view</username>
<id>5126530</id>
</contributor>
</revision>
<categories>
<category>Root-finding algorithms</category>
</categories>
</header>
<bdy>

A <b>root-finding algorithm</b> is a numerical method, or <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>, for finding a value <it>x</it> such that <it>f</it>(<it>x</it>) = 0, for a given <link xlink:type="simple" xlink:href="../427/185427.xml">
function</link> <it>f</it>.  Such an <it>x</it> is called a <link xlink:type="simple" xlink:href="../210/264210.xml">
root</link> of the function <it>f</it>.<p>

This article is concerned with finding <link xlink:type="simple" xlink:href="../491/19725491.xml">
real</link> or <link xlink:type="simple" xlink:href="../826/5826.xml">
complex</link> roots, approximated as floating point numbers. Finding integer roots or exact algebraic roots are separate problems, whose algorithms have little in common with those discussed here. (See: <link xlink:type="simple" xlink:href="../109/9109.xml">
Diophantine equation</link> as for integer roots)</p>
<p>

Finding a root of <it>f(x)</it> &amp;minus; <it>g(x)</it> = 0 is the same as solving the <link xlink:type="simple" xlink:href="../284/9284.xml">
equation</link> <it>f</it>(<it>x</it>) = <it>g</it>(<it>x</it>). Here, <it>x</it> is called the <it>unknown</it> in the equation. Conversely, any equation can take the <link xlink:type="simple" xlink:href="../150/328150.xml">
canonical</link> form <it>f</it>(<it>x</it>) = 0, so <link xlink:type="simple" xlink:href="../048/537048.xml">
equation solving</link> is the same thing as computing (or <it>finding</it>) a root of a function. </p>
<p>

Numerical root-finding methods use <link xlink:type="simple" xlink:href="../833/68833.xml">
iteration</link>, producing a <link xlink:type="simple" xlink:href="../838/27838.xml">
sequence</link> of numbers that hopefully converge towards a <link xlink:type="simple" xlink:href="../401/19616401.xml#xpointer(//*[./st=%22Limit+of+a+sequence%22])">
limit</link> (the so called "<link xlink:type="simple" xlink:href="../738/449738.xml">
fixed point</link>") which is a root. The first values of this series are <it>initial guesses</it>. The method computes subsequent values based on the old ones and the function <it>f</it>.</p>
<p>

The behaviour of root-finding algorithms is studied in <link xlink:type="simple" xlink:href="../506/21506.xml">
numerical analysis</link>. Algorithms perform best when they take advantage of known characteristics of the given function. Thus an algorithm to find isolated real roots of a low-degree polynomial in one variable may bear little resemblance to an algorithm for complex roots of a "black-box" function which is not even known to be differentiable. Questions include ability to separate close roots, robustness in achieving reliable answers despite inevitable numerical errors, and rate of convergence.</p>

<sec>
<st>
Specific algorithms</st>
<p>

The simplest root-finding algorithm is the <link xlink:type="simple" xlink:href="../651/646651.xml">
bisection method</link>. It works when <it>f</it> is a <link xlink:type="simple" xlink:href="../122/6122.xml">
continuous function</link> and it requires previous knowledge of two initial guesses, <it>a</it> and <it>b</it>, such that <it>f</it>(<it>a</it>) and <it>f</it>(<it>b</it>) have opposite signs. Although it is reliable, it converges slowly, gaining one <link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link> of accuracy with each iteration.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 assumes the function <it>f</it> to have a continuous <link xlink:type="simple" xlink:href="../921/7921.xml">
derivative</link>. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 may not converge if started too far away from a root. However, when it does converge, it is faster than the bisection method. Convergence is usually quadratic, so the number of bits of accuracy doubles with each iteration. Newton's method is also important because it readily generalizes to higher-dimensional problems. Newton-like methods with higher order of convergence are the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../367/13075367.xml">
Householder's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s. The first one after Newton's method is <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../035/9053035.xml">
Halley's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 with cubic order of convergence.</p>
<p>

Replacing the derivative in Newton's method with a <link xlink:type="simple" xlink:href="../147/39147.xml">
finite difference</link>, we get the <link xlink:type="simple" xlink:href="../746/640746.xml">
secant method</link>. This method does not require the computation (nor the existence) of a <link xlink:type="simple" xlink:href="../921/7921.xml">
derivative</link>, but the price is slower convergence (the order is approximately 1.6).</p>
<p>

The <link xlink:type="simple" xlink:href="../796/646796.xml">
false position method</link>, also called the <it>regula falsi</it> method, is like the secant method. However, instead of retaining the last two points, it makes sure to keep one point on either side of the root.  The false position method is faster than the bisection method and more robust than the secant method.</p>
<p>

The secant method also arises if one approximates the unknown function <it>f</it> by <link xlink:type="simple" xlink:href="../010/160010.xml">
linear interpolation</link>. When <link xlink:type="simple" xlink:href="../565/203565.xml">
quadratic interpolation</link> is used instead, one arrives at <link>
Müller's method</link>. It converges faster than the secant method. A particular feature of this method is that the iterates <it>xn</it> may become <link xlink:type="simple" xlink:href="../826/5826.xml">
complex</link>.</p>
<p>

This can be avoided by interpolating the <link xlink:type="simple" xlink:href="../907/14907.xml">
inverse</link> of <it>f</it>, resulting in the <link xlink:type="simple" xlink:href="../620/1313620.xml">
inverse quadratic interpolation</link> method. Again, convergence is asymptotically faster than the secant method, but inverse quadratic interpolation often behaves poorly when the iterates are not close to the root.</p>
<p>

Finally, <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/1254323.xml">
Brent's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a combination of the bisection method, the secant method and inverse quadratic interpolation. At every iteration, Brent's method decides which method out of these three is likely to do best, and proceeds by doing a step according to that method. This gives a robust and fast method, which therefore enjoys considerable popularity.</p>

</sec>
<sec>
<st>
Finding roots of polynomials</st>
<p>

Much attention has been given to the special case that the function <it>f</it> is a <link xlink:type="simple" xlink:href="../000/23000.xml">
polynomial</link>; there exist root-finding algorithms exploiting the polynomial nature of <it>f</it>. For a univariate polynomial of degree less than five, we have closed form solutions such as the <link>
quadratic formula</link>. However, even this degree-two solution should be used with care to ensure numerical stability, the degree-four solution is unwieldy and troublesome, and higher-degree polynomials have no such general solution.</p>
<p>

For real roots, <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../919/1221919.xml">
Sturm's theorem</link></proposition>
</theorem>
</message>
</statement>
 provides a guide to locating and separating roots. This plus <link xlink:type="simple" xlink:href="../160/2176160.xml">
interval arithmetic</link> combined with <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 yields a <link xlink:type="simple" xlink:href="../299/153299.xml">
robust algorithm</link>, but other choices are more common.</p>
<p>

One possibility is to form the <link xlink:type="simple" xlink:href="../542/532542.xml">
companion matrix</link> of the polynomial. Since the eigenvalues of this matrix coincide with the roots of the polynomial, one can use any <link xlink:type="simple" xlink:href="../560/516560.xml">
eigenvalue algorithm</link> to find the roots of the polynomial. For instance the classical <link>
Bernoulli's method</link> to find the root greater in modulus, if it exists, turns out to be the <link xlink:type="simple" xlink:href="../550/5975550.xml">
power method</link> applied to the <link xlink:type="simple" xlink:href="../542/532542.xml">
companion matrix</link>.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../614/1136614.xml">
Laguerre's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is rather complicated, but it converges quickly. It exhibits cubic convergence for simple roots, dominating the quadratic convergence displayed by Newton's method. The <link>
Jenkins–Traub method</link> is another complicated method which converges faster than Newton's method.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../941/3704941.xml">
Bairstow's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 uses <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 to find quadratic factors of a polynomial with real coefficients.  It can determine both real and complex roots of a real polynomial using only real arithmetic.</p>
<p>

The simple <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../893/3675893.xml">
Durand-Kerner</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and the slightly more complicated <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../088/7378088.xml">
Aberth method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 simultaneously finds all the roots using only simple <link xlink:type="simple" xlink:href="../826/5826.xml">
complex number</link> arithmetic.</p>
<p>

The <link xlink:type="simple" xlink:href="../888/3683888.xml">
splitting circle method</link> is useful for finding the roots of polynomials of high degree to arbitrary precision; it has almost optimal complexity in this setting. Another method with this style is the <link>
Dandelin-Gräffe method</link> (actually due to <link xlink:type="simple" xlink:href="../527/648527.xml">
Lobachevsky</link>) which factors the polynomial.</p>
<p>

<link xlink:type="simple" xlink:href="../974/646974.xml">
Wilkinson's polynomial</link> illustrates that high <link xlink:type="simple" xlink:href="../110/552110.xml">
precision</link> may be  necessary when computing the roots of a polynomial.</p>

</sec>
<sec>
<st>
Finding multiple roots</st>
<p>

If <it>p</it>(<it>x</it>) is a polynomial with a multiple root at <it>r</it>, then finding the value of <it>r</it> can be difficult (inefficient or impossible) for many of the standard root-finding algorithms.  Fortunately, there is a technique especially for this case, provided that <it>p</it> is given explicitly as a polynomial in one variable with exact coefficients.</p>

<ss1>
<st>
Algorithm</st>
<p>

<list>
<entry level="1" type="number">

 First, we need to determine whether <it>p</it>(<it>x</it>) has a multiple root.  If <it>p</it>(<it>x</it>) has a multiple root at <it>r</it>, then its derivative <it>p</it>′(<it>x</it>) will also have a root at <it>r</it> (one fewer than <it>p</it>(<it>x</it>) has there).  So we calculate the greatest common divisor of the polynomials <it>p</it>(<it>x</it>) and <it>p</it>′(<it>x</it>); adjust the leading coefficient to be one and call it <it>g</it>(<it>x</it>). (See <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../919/1221919.xml">
Sturm's theorem</link></proposition>
</theorem>
</message>
</statement>
.) If <it>g</it>(<it>x</it>)&nbsp;= 1, then <it>p</it>(<it>x</it>) has no multiple roots and we can safely use those other root-finding algorithms which work best when there are no multiple roots, and then exit.</entry>
<entry level="1" type="number">

 Now suppose that there is a multiple root.  Notice that <it>g</it>(<it>x</it>) will have a root of the same multiplicity at <it>r</it> that <it>p</it>′(<it>x</it>) has and the degree of the polynomial <it>g</it>(<it>x</it>) will generally be much less than that of <it>p</it>(<it>x</it>).  Recursively call this routine, i.e. go back to step #1 above, using <it>g</it>(<it>x</it>) in place of <it>p</it>(<it>x</it>).  Now suppose that we have found the roots of <it>g</it>(<it>x</it>), i.e. we have factored it.</entry>
<entry level="1" type="number">

 Since <it>r</it> has been found, we can factor (<it>x</it>−<it>r</it>) out of <it>p</it>(<it>x</it>) repeatedly until we have removed all of the roots at <it>r</it>.  Repeat this for any other multiple roots until there are no more multiple roots.  Then the quotient, i.e. the remaining part of <it>p</it>(<it>x</it>), can be factored in the usual way with one of the other root-finding algorithms.  Exit.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Example</st>
<p>

Suppose <it>p</it>(<it>x</it>)&nbsp;= <it>x</it>3+<it>x</it>2−5<it>x</it>+3 is the function whose roots we want to find.  We calculate <it>p</it>′(<it>x</it>)&nbsp;= 3<it>x</it>2+2<it>x</it>−5.  Now divide <it>p</it>′(<it>x</it>) into <it>p</it>(<it>x</it>) to get <it>p</it>(<it>x</it>)&nbsp;= <it>p</it>′(<it>x</it>)·((1/3)<it>x</it>+(1/9))+((−32/9)<it>x</it>+(32/9)).  Divide the remainder by −32/9 to get <it>x</it>−1 which is monic.  Divide <it>x</it>−1 into <it>p</it>′(<it>x</it>) to get <it>p</it>′(<it>x</it>)&nbsp;= (<it>x</it>−1)·(3<it>x</it>+5)+0.  Since the remainder is zero, <it>g</it>(<it>x</it>)&nbsp;= <it>x</it>−1.  So the multiple root of <it>p</it>(<it>x</it>) is <it>r</it>&nbsp;= 1.  Dividing <it>p</it>(<it>x</it>) by (<it>x</it>−1)2, we get <it>p</it>(<it>x</it>)&nbsp;= (<it>x</it>+3)(<it>x</it>−1)2 so the other root is −3, a single root.</p>

</ss1>
<ss1>
<st>
Algebraic geometry</st>
<p>

The performance of standard polynomial root-finding algorithms degrades in the presence of multiple roots. Using ideas from algebraic geometry, <weblink xlink:type="simple" xlink:href="http://www.neiu.edu/~zzeng/">
Zhonggang Zeng</weblink> has published a more sophisticated approach, with a <software wordnetid="106566077" confidence="0.9508927676800064">
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../412/20412.xml">
MATLAB</link></programming_language>
</software>
 <weblink xlink:type="simple" xlink:href="http://orion.neiu.edu/~zzeng/multroot.zip">
package implementation</weblink>, that identifies and handles multiplicity structures considerably better. A different algebraic approach including symbolic computations has been pursued by <weblink xlink:type="simple" xlink:href="http://www.nd.edu/~sommese/">
Andrew Sommese</weblink> and colleagues, available as a <weblink xlink:type="simple" xlink:href="http://www.nd.edu/~sommese/preprints/BPS1.pdf">
preprint</weblink> (<link xlink:type="simple" xlink:href="../077/24077.xml">
PDF</link>).</p>

</ss1>
<ss1>
<st>
Direct algorithm for multiple root elimination</st>

<p>

There is a direct method of eliminating multiple (or repeated) roots from polynomials with exact coefficients (integers, rational numbers, Gaussian integers or rational complex numbers).</p>
<p>

Suppose <it>a</it> is a root of <it>P</it>(<it>x</it>) with multiplicity <it>m</it>&amp;gt;0.
Then <it>a</it> will be a root of the formal derivative <it>P</it>’(<it>x</it>) with multiplicity <it>m</it>-1.
(If <it>m</it>=1, then <it>a</it> will be a "root of <it>P</it>’(<it>x</it>) with multiplicity 0".
That is, if it is a distinct (non-multiple) root of the polynomial, then it won't be a root of the polynomial's derivative.)
However, <it>P</it>’(<it>x</it>) may have additional roots that are not roots of <it>P</it>(<it>x</it>).
(For example, if <it>P</it>(<it>x</it>)=(<it>x</it>-1)3(<it>x</it>-3)3, then <it>P</it>’(<it>x</it>)=6(<it>x</it>-1)2(<it>x</it>-2)(<it>x</it>-3)2.
So 2 is a root of <it>P</it>’(<it>x</it>) here, but not of <it>P</it>(<it>x</it>).)</p>
<p>

Define <it>G</it>(<it>x</it>) to be the <link xlink:type="simple" xlink:href="../354/12354.xml">
HCF</link> (highest common factor) of <it>P</it>(<it>x</it>) and <it>P</it>’(<it>x</it>).</p>
<p>

Finally, <it>G</it>(<it>x</it>) divides <it>P</it>(<it>x</it>) exactly,
so form the quotient <it>Q</it>(<it>x</it>)=<it>P</it>(<it>x</it>)/<it>G</it>(<it>x</it>).</p>
<p>

Now,
<it>a</it> is a root of <it>P</it>(<it>x</it>) with multiplicity <it>m</it>&amp;gt;0
if and only if
<it>a</it> is a root of <it>Q</it>(<it>x</it>) with multiplicity 1.
That is, <it>Q</it>(<it>x</it>) has exactly the roots of <it>P</it>(<it>x</it>), but has no multiple roots.</p>
<p>

As <it>P</it>(<it>x</it>) is a polynomial with exact coefficients, then if the algorithm is executed using exact arithmetic, <it>Q</it>(<it>x</it>) will also be a polynomial with exact coefficients.</p>
<p>

<it>Q</it>(<it>x</it>) may also be simpler than <it>P</it>(<it>x</it>): degree(<it>Q</it>(<it>x</it>)) ≤ degree(<it>P</it>(<it>x</it>)). Whether or not degree(<it>P</it>(<it>x</it>))≤4, if degree(<it>Q</it>(<it>x</it>))≤4 then the roots may be found algebraically.</p>
<p>

It is then possible to determine the multiplicities of those roots in <it>P</it>(<it>x</it>) algebraically.</p>
<p>

If degree(<it>Q</it>(<it>x</it>))&amp;gt;4, standard (iterative) root-finding algorithms may be used, and should perform well in the absence of multiple roots.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../000/1620000.xml">
Nth root algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../600/3732600.xml">
Multiplicity</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../354/12354.xml">
Greatest common divisor</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../000/23000.xml">
Polynomial</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../192/6134192.xml">
Graeffe's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../249/182249.xml">
Cryptographically secure pseudorandom number generator</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 — a class of functions designed specifically to be unsolvable by root-finding algorithms.</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../350/13199350.xml">
MPSolve</link></software>
</entry>
<entry level="1" type="bullet">

 <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link>
 GNU Scientific Library</link></room>
</library>
</area>
</artifact>
</structure>
</entry>
</list>
</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://math.fullerton.edu/mathews/a2001/Animations/RootFinding/FixedPoint/FixedPoint.html">
 Animations for Fixed Point Iteration</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://gams.nist.gov/serve.cgi/Class/F1a1/">
GAMS: Roots of polynomials with real coefficients</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nr.com">
Numerical Recipes Homepage</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</article>
