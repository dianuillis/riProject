<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:39:24[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Index calculus algorithm</title>
<id>1549595</id>
<revision>
<id>218116880</id>
<timestamp>2008-06-09T06:21:07Z</timestamp>
<contributor>
<username>Derek Ross</username>
<id>33</id>
</contributor>
</revision>
<categories>
<category>All pages needing cleanup</category>
<category>Articles with disputed statements from April 2008</category>
<category>Articles with invalid date parameter in template</category>
<category>group theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../890/41890.xml">
group theory</link>, the <b>index calculus algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>  for computing <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete logarithm</link>s. This is the best known algorithm for certain groups, such as <math>\mathbb{Z}_m^*</math> (the multiplicative group modulo <it>m</it>).&#91;&#32; &ndash; &#93;
<sec>
<st>
 Description </st>
<p>

Roughly speaking, the <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete log</link> problem asks us to find an <it>x</it> such that <math>g^x \equiv h \pmod{n}</math>, where <it>g</it>, <it>h</it>, and the modulus <it>n</it> are given.</p>
<p>

The algorithm (described in detail below) applies to the group <math>\mathbb{Z}_q^*</math> where <it>q</it> is prime. It requires a <it>factor base</it> as input. This <it>factor base</it> is usually chosen to be the number −1 and the first <it>r</it> primes starting with 2.  From the point of view of efficiency, we want this factor base to be small, but in order to solve the discrete log for a large group we require the <it>factor base</it> to be (relatively) large. In practical implementations of the algorithm, those conflicting objectives are compromised one way or another.</p>
<p>

It is noteworthy that the lack of the notion of <it>prime elements</it> in the group of points on <link xlink:type="simple" xlink:href="../225/10225.xml">
elliptic curves</link>, makes it impossible to find an efficient <it>factor base</it> to run index calculus in these groups. Therefore this algorithm is incapable of solving discrete logarithms efficiently in elliptic curve groups.  </p>
<p>

The algorithm is performed in three stages.  The first two stages depend only on the generator <it>g</it> and prime modulus <it>q</it>, and find the discrete logarithms of a <it>factor base</it> of <it>r</it> small primes.  The third stage finds the discrete log of the desired number <it>h</it> in terms of the discrete logs of the factor base.</p>
<p>

The first stage consists of searching for a set of <it>r</it> <link xlink:type="simple" xlink:href="../863/101863.xml">
linearly independent</link> <it>relations</it> between the factor base and power of the <link xlink:type="simple" xlink:href="../256/294256.xml">
generator</link>  <it>g</it>.  Each relation contributes one equation to a <link xlink:type="simple" xlink:href="../087/113087.xml">
system of linear equations</link> in <it>r</it> unknowns, namely the discrete logarithms of the <it>r</it> primes in the factor base.  This stage is <link xlink:type="simple" xlink:href="../712/1738712.xml">
embarrassingly parallel</link> and easy to divide among many computers.</p>
<p>

The second stage solves the system of linear equations to compute the discrete logs of the factor base.  Although a relatively minor computation compared to the other stages, a system of hundreds of thousands or millions of equations is a significant computation requiring large amounts of memory, and it is <it>not</it> embarrassingly parallel, so a <link xlink:type="simple" xlink:href="../153/37153.xml">
supercomputer</link> is typically used.</p>
<p>

The third stage searches for a power <it>s</it> of the generator <it>g</it> which, when multiplied by the argument <it>h</it>, may be factored in terms of the factor base <it>gsh</it> = (−1)<it>f</it>0 2<it>f</it>1 3<it>f</it>2···<it>prfr</it>.</p>
<p>

Finally, in an operation too simple to really be called a fourth stage, the results of the second and third stages can be rearranged by simple algebraic manipulation to work out the desired discrete logarithm <it>x</it> = <it>f</it>0log<it>g</it>(−1) + <it>f</it>1log<it>g</it>2 + <it>f</it>2log<it>g</it>3 + ··· + <it>fr</it>log<it>gpr</it> − <it>s</it>.</p>
<p>

The first and third stages are both embarrassingly parallel, and in fact the third stage does not depend on the results of the first two stages, so it may be done in parallel with them.</p>
<p>

The choice of the factor base size <it>r</it> is critical, and the details are too intricate to explain here.  The larger the factor base, the easier it is to find relations in stage 1, and the easier it is to complete stage 3, but the more relations you need before you can proceed to stage 2, and the more difficult stage 2 is.  The relative availability of computers suitable for the different types of computation required for stages 1 and 2 is also important.</p>

</sec>
<sec>
<st>
 The algorithm </st>
<p>

<b>Input:</b> Discrete logarithm generator <it>g</it>, modulus <it>q</it> and argument <it>h</it>.  Factor base {−1,2,3,5,7,11,...,<it>pr</it>}, of length <it>r</it>+1.
<b>Output:</b> <it>x</it> such that <it>gx</it> ≡ <it>h</it> (mod <it>q</it>).</p>
<p>

<list>
<entry level="1" type="bullet">

 relations ← empty_list</entry>
<entry level="1" type="bullet">

 for <it>k</it> = 1, 2, ...</entry>
<entry level="2" type="bullet">

 Using an <link xlink:type="simple" xlink:href="../491/15491.xml">
integer factorization</link> algorithm optimized for <link xlink:type="simple" xlink:href="../039/1035039.xml">
smooth numbers</link>, try to factor <math>g^k</math> using the factor base, i.e. find <math>e_i</math>'s such that <math>g^k = (-1)^{e_0}2^{e_1}3^{e_2}\cdots p_r^{e_r}</math></entry>
<entry level="2" type="bullet">

 Each time a factorization is found:</entry>
<entry level="3" type="bullet">

 Store <it>k</it> and the computed <math>e_i</math>'s as a vector <math>(e_0,e_1,e_2,\ldots,e_r,k)</math> (this is a called a relation)</entry>
<entry level="3" type="bullet">

 If this relation is <link xlink:type="simple" xlink:href="../863/101863.xml">
linearly independent</link> to the other relations:</entry>
<entry level="4" type="bullet">

 Add it to the list of relations</entry>
<entry level="4" type="bullet">

 If there are at least <it>r</it>+1 relations, exit loop</entry>
<entry level="1" type="bullet">

 Form a matrix whose rows are the relations</entry>
<entry level="1" type="bullet">

 Obtain the <link xlink:type="simple" xlink:href="../215/330215.xml">
reduced echelon form</link> of the matrix</entry>
<entry level="2" type="bullet">

 The first element in the last column is the discrete log of −1 and the second element is the discrete log of 2 and so on</entry>
<entry level="1" type="bullet">

 for <it>s</it> = 0, 1, 2, ...</entry>
<entry level="2" type="bullet">

 Try to factor <math>g^s h = (-1)^{f_0}2^{f_1}3^{f_1}\cdots p^{f_r}</math> over the factor base </entry>
<entry level="2" type="bullet">

 When a factorization is found:</entry>
<entry level="3" type="bullet">

 Output <math>x = f_0 \log_g(-1) + f_1 \log_g2 + \cdots + f_r \log_g p_r - s.</math></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.dtc.umn.edu/~odlyzko/doc/arch/discrete.logs.pdf">
Discrete logarithms in finite fields and their cryptographic significance</weblink>, by <link xlink:type="simple" xlink:href="../042/1986042.xml">
Andrew Odlyzko</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.toronto.edu/~cvs/dlog/">
Discrete Logarithm Problem</weblink>, by Chris Studholme, including the June 21, 2002 paper "The Discrete Log Problem".</entry>
</list>
</p>


</sec>
</bdy>
</article>
