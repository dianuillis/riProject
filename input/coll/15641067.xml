<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 03:10:56[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Super-recursive algorithm</title>
<id>15641067</id>
<revision>
<id>241073289</id>
<timestamp>2008-09-26T06:27:49Z</timestamp>
<contributor>
<username>Yakushima</username>
<id>1907235</id>
</contributor>
</revision>
<categories>
<category>Accuracy disputes from April 2008</category>
<category>Theory of computation</category>
<category>Articles with invalid date parameter in template</category>
<category>Algorithms</category>
<category>Articles to be merged since July 2008</category>
<category>NPOV disputes from April 2008</category>
<category>All articles to be merged</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_content.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>The  and  of this article are disputed.</b>
Please see the relevant discussion on the . <it>(April 2008)''</it></col>
</row>
</table>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-move" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Merge-arrow.svg">
<caption>

Merge arrow
</caption>
</image>
</p>
</col>
<col style="" class="mbox-text">
 It has been suggested that this article or section be  into . ()</col>
</row>
</table>

</p>
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link> and <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability theory</link>, <b>super-recursive algorithms</b> are <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s that are more powerful, that is, compute more, than <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machines</link>. The term was introduced by Mark Burgin, whose book "Super-recursive algorithms" develops their theory and presents several mathematical models. Turing machines and other mathematical models of conventional algorithms allow researchers to find properties of recursive algorithms and their computations. In a similar way, mathematical models of super-recursive algorithms, such as limiting recursive functions, limiting partial recursive functions, trial and error predicates, inductive Turing machines, and limit Turing machines, allow researchers to find properties of super-recursive algorithms and their computations.</p>
<p>

Burgin, as well as other researches (including Selim Akl, Eugene Eberbach, Peter Kugel, Jan van Leeuwen, Hava Siegelmann, Peter Wegner, and Jirí Wiedermann) who studied different kinds of super-recursive algorithms and contributed to the theory of super-recursive algorithms, have argued that super-recursive algorithms can be used to disprove the <link xlink:type="simple" xlink:href="../854/6854.xml">
Church-Turing thesis</link>, but this point of view has been criticized within the mathematical community and is not widely accepted.</p>

<sec>
<st>
 Definition </st>

<p>

Burgin (2005: 13) uses the term <b>recursive algorithms</b> for <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s that can be implemented on Turing machines, and uses the word <it>algorithm</it> in a more general sense. Then a <b>super-recursive class of algorithms</b> is "a class of algorithms in which it is possible to compute functions not computable by any <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
" (Burgin 2005: 107). Super-recursive algorithms are closely related to <link xlink:type="simple" xlink:href="../613/175613.xml">
hypercomputation</link> in a general sense, which Burgin defines as a "computational process (including processes of input and output) that cannot be realized by recursive algorithms." (Burgin 2005: 108). A more restricted definition demands that  <link xlink:type="simple" xlink:href="../613/175613.xml">
hypercomputation</link> solves a <link xlink:type="simple" xlink:href="../383/314383.xml">
supertask</link>, i.e., task that needs infinite resources, such as time, memory or precision, for computation (see Copeland 2002; Hagar and Korolev 2007). </p>
<p>

As a result, some types of hypercomputation in a general sense are controlled by super-recursive algorithms, e.g., inductive Turing machines, while other types are directed by algorithmic schemas, e.g., infinite time Turing machines. This explains how works on super-recursive algorithms are related to hypercomputation and vice versa. Thus, 'hypercomputation' and 'super-recursive algorithm' are not different names of the same things. They are connected but essentially different terms.</p>
<p>

However, it is important not to confuse hypercomputation and super-recursive algorithms. The main difference is the same as the difference between computation and algorithm. Computation is a process, while an algorithm is a finite constructive description of such a process. In spite of this clear distinction, some researchers do not differentiate these two concepts. For instance, Davis (2006; 128) writes, "… this kind of computation should be regarded as a "super-recursive algorithm."</p>
<p>

Super-recursive algorithms are also related to algorithmic schemes. The term <b>algorithmic scheme</b> is much more general than the term <it>super-recursive algorithm</it> and Burgin argues (2005: 115) that it's necessary to make a clear distinction between super-recursive algorithms and those algorithmic schemes that are not algorithms.
The term <b>subrecursive algorithm</b> has been also used by different authors, for example, (Axt, 1959; Kosovsky, 1981; Campagnolo, Moore, and Costa, 2000). A <b>subrecursive class of algorithms</b> is a class of algorithms in which it is impossible to compute all functions computable by <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machines</link>.  This yields three big classes of algorithms: <it>subrecursive</it>, <it>recursive</it> and <it>super-recursive algorithms</it>.</p>

</sec>
<sec>
<st>
 Examples </st>

<p>

Examples of super-recursive algorithms include (Burgin 2005: 132):
<list>
<entry level="1" type="bullet">

 <b>limiting recursive functions</b> and <b>limiting partial recursive functions</b> (E.M. Gold)</entry>
<entry level="1" type="bullet">

 <b>trial and error predicates</b> (Hilary Putnam) </entry>
<entry level="1" type="bullet">

 <b>inductive inference machines</b> (Carl Smith)</entry>
<entry level="1" type="bullet">

 <b>inductive Turing machines</b>, which perform computations similar to computations of <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machines</link> and produce their results after a finite number of steps (Mark Burgin)</entry>
<entry level="1" type="bullet">

 <b>limit Turing machines</b>, which perform computations similar to computations of Turing machines but their final results are limits of their intermediate results (Mark Burgin)</entry>
<entry level="1" type="bullet">

  <b>trial-and-error machines</b> (Ja. Hintikka and A. Mutanen)</entry>
<entry level="1" type="bullet">

 <b>general Turing machines</b> (J. Schmidhuber)</entry>
<entry level="1" type="bullet">

 <b>Internet machines</b> (van Leeuwen, J. and Wiedermann, J.)</entry>
<entry level="1" type="bullet">

 <b>evolutionary computers</b>, which use DNA to produce the value of a function (Darko Roglic)</entry>
<entry level="1" type="bullet">

 <b>fuzzy computation</b> (Jirí Wiedermann)</entry>
<entry level="1" type="bullet">

 <b>evolutionary Turing machines</b> (Eugene Eberbach)</entry>
</list>
</p>
<p>

Examples of algorithmic schemes include:</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Turing machines with arbitrary oracles</b> (Alan Turing)</entry>
<entry level="1" type="bullet">

 <b>Transrecursive operators</b> (Borodyanskii and Burgin)</entry>
<entry level="1" type="bullet">

 <b>machines that compute with real numbers</b> (L. Blum, F. Cucker, M. Shub, and S. Smale)</entry>
<entry level="1" type="bullet">

 <b>neural networks based on real numbers</b> (Hava Siegelmann)</entry>
</list>
</p>
<p>

For examples of practical <b>super-recursive algorithms</b>, see <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>, <link xlink:type="simple" xlink:href="../771/9025771.xml">
anytime algorithm</link>, and the book of Burgin.</p>
<p>

Examples of subrecursive algorithms include:</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>primitive recursive functions</b> </entry>
<entry level="1" type="bullet">

 <b>recursive functions</b> </entry>
<entry level="1" type="bullet">

 <b>finite automata</b></entry>
<entry level="1" type="bullet">

 <b>pushdown automata</b></entry>
<entry level="1" type="bullet">

  <b>monotone Turing machines</b></entry>
</list>
</p>

</sec>
<sec>
<st>
 Inductive Turing machines </st>

<p>

<b>Inductive Turing machines</b> form an important class of super-recursive algorithms because they satisfy all conditions in the definition of <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>. Namely, each inductive Turing machine is a type of effective method in which a definite list of well-defined instructions for completing a task, when given an initial state, will proceed through a well-defined series of successive states, eventually giving the final result. The difference between an inductive Turing machine and a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 is that to produce the result a Turing machine has to stop, while in some cases an inductive Turing machine can do this without stopping. Kleene called procedures that could run forever without stopping by the name <it>calculation procedure or algorithm</it> (Kleene 1952:137). Kleene also demanded that such an algorithm must eventually exhibit "some object" (Kleene 1952:137). Burgin argues that this condition is satisfied by inductive Turing machines, as their results are exhibited after a finite number of steps, but inductive Turing machines may not be able to tell at which step the result has been obtained.</p>
<p>

Simple inductive Turing machines are equivalent to other models of computation such as general Turing machines of Schmidhuber, trial and error predicates of Hilary Putnam, limiting partial recursive functions of Gold, and trial-and-error machines of Hintikka and Mutanen. More advanced inductive Turing machines are much more powerful. There are hierarchies of inductive Turing machines that can compute the Arithmetical Hierarchy (Burgin 2005). In comparison with other equivalent models of computation, simple inductive Turing machines and general Turing machines give direct constructions of computing automata that are thoroughly grounded in physical machines. In contrast, trial-and-error predicates, limiting recursive functions, and limiting partial recursive functions present only syntactic systems of symbols with formal rules for their manipulation. Simple inductive Turing machines and general Turing machines are related to limiting partial recursive functions and trial-and-error predicates as Turing machines are related to partial recursive functions and lambda calculus.</p>
<p>

Many confuse the computations of inductive Turing machines with non-stopping computations or with infinite-time computations (see, for example, Potgieter 2006; Zenil and Hernandez-Quiroz 2006). First, some computations of inductive Turing machines do halt. As in the case of conventional Turing machines, some halting computations give the result, while others do not. Second, some non-stopping computations of inductive Turing machines give results, while others do not. Rules of inductive Turing machines determine when a computation (stopping or non-stopping) gives a result. Namely, an inductive Turing machine produces output from time to time and once this output stops changing, it is considered the result of the computation. It is necessary to know that descriptions of this rule in some papers are incorrect. For instance, Davis (2006: 128) formulates the rule when a result is obtained without stopping as "… once the correct output has been produced any subsequent output will simply repeat this correct result." Third, in contrast to the widespread misconception, inductive Turing machines will always give results (when they occur) after a finite number of steps (in finite time), unlike infinite and infinite-time computations.</p>
<p>

There are two main distinctions between conventional Turing machines and simple inductive Turing machines. The first distinction is that even simple inductive Turing machine can do much more than conventional Turing machines. The second distinction is that a conventional Turing machine will always inform (by halting or by coming to a final state) when the result is obtained, while a simple inductive Turing machine, in some cases (where the conventional Turing machine is helpless), will not inform. People have an illusion that a computer will always inform (by halting or by other means) when the result is obtained. However, users often have to decide whether a computed result is what they need or it is necessary to continue computations. Indeed, everyday desktop computer applications like word processors and spreadsheets spend most of their time waiting in <link xlink:type="simple" xlink:href="../023/4378023.xml">
event loop</link>s and do not terminate until directed to do so by users.</p>

</sec>
<sec>
<st>
 Schmidhuber's generalized Turing machines </st>
<p>

A symbol sequence is <link xlink:type="simple" xlink:href="../084/3244084.xml">
computable</link> in the limit if there is a finite, possibly non-halting program on a <link xlink:type="simple" xlink:href="../435/71435.xml">
universal Turing machine</link> that incrementally outputs every symbol of the sequence. This includes the dyadic expansion of pi but still excludes most of the real numbers, because most cannot be described by a finite program. Traditional <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s cannot edit their previous outputs; generalized <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machines</link>, according to <link>
Jürgen Schmidhuber</link>, can. He defines the constructively describable symbol sequences as those that have a finite, non-halting program running on a generalized Turing machine, such that any output symbol eventually <link xlink:type="simple" xlink:href="../737/7662737.xml">
converges</link>, that is, it does not change any more after some finite initial time interval. Due to limitations first exhibited by <link>
Kurt Gödel</link> (1931), it may be impossible to predict the convergence time itself by a halting program, otherwise the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link> could be solved. Schmidhuber (2000, 2002) uses this approach to define the set of formally describable or constructively computable universes or constructive <link xlink:type="simple" xlink:href="../436/30436.xml">
theories of everything</link>. Generalized Turing machines and simple inductive Turing machines are two classes of super-recursive algorithms that are the closest to recursive algorithms.</p>

</sec>
<sec>
<st>
 Relation to the Church–Turing thesis </st>

<p>

The Church–Turing thesis in recusrion theory relies on a particular definition of the term <it>algorithm</it>. Based on definitions that are more general than the one commonly used in recursion theory, Burgin argues that super-recursive algorithms, such as <b>inductive Turing machines</b> disprove the <link>
Church–Turing thesis</link>. He proves furthermore that super-recursive algorithms could theoretically provide even greater efficiency gains than using <link xlink:type="simple" xlink:href="../220/25220.xml">
quantum algorithms</link>.</p>
<p>

Burgin's interpretation of super-recursive algorithms has encountered opposition in the mathematical community. One critic is logician <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, who argues that Burgin's claims have been well understood "for decades". Davis states, 
<indent level="1">

"The present criticism is not about the mathematical discussion of these matters but only about the misleading claims regarding physical systems of the present and future."(Davis 2006: 128)
</indent>
Davis disputes Burgin's claims that sets at level <math>\Delta^0_2</math> of the <link xlink:type="simple" xlink:href="../475/186475.xml">
arithmetical hierarchy</link> can be called computable, saying
<indent level="1">

"It is generally understood that for a computational result to be useful one must be able to at least recognize that it is indeed the result sought." (Davis 2006: 128)
</indent>

</p>
</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Akl, S.G., Three counterexamples to dispel the myth of the universal computer, <it>Parallel Processing Letters</it>, Vol. 16, No. 3, September 2006, pp. 381 - 403.</entry>
<entry level="1" type="bullet">

 Akl, S.G., The myth of universal computation, in: Parallel Numerics, Trobec, R., Zinterhof, P., Vajtersic, M., and Uhl, A., Eds., Part 2, <it>Systems and Simulation</it>, University of Salzburg, Salzburg, Austria and Jozef Stefan Institute, Ljubljana, Slovenia, 2005, pp. 211 - 236</entry>
<entry level="1" type="bullet">

 Angluin, D., and Smith, C. H. (1983) Inductive Inference: Theory and Methods, <it>Comput. Surveys</it>, v. 15, no. 3, pp. 237—269</entry>
<entry level="1" type="bullet">

 Apsïtis, K, Arikawa, S, Freivalds, R., Hirowatari, E., and Smith, C. H. (1999) On the inductive inference of recursive real-valued functions, <it>Theoret. Computer Science</it>, 219(1-2): 3—17</entry>
<entry level="1" type="bullet">

 Axt, P. (1959) On a Subrecursive Hierarchy and Primitive Recursive Degrees, <it>Transactions of the American Mathematical Society</it>, v. 92, pp. 85-105</entry>
<entry level="1" type="bullet">

 Blum, L., and Blum, M. (1975) Toward a mathematical theory of inductive inference. <it>Information and Control</it> vol. 28, pp. 125-155</entry>
<entry level="1" type="bullet">

 Blum, L.,  F. Cucker, M. Shub, and S. Smale, <it>Complexity and real computation</it>, Springer 1998</entry>
<entry level="1" type="bullet">

 Boddy, M, Dean, T.  1989.  "Solving Time-Dependent Planning Problems". Technical Report: CS-89-03, Brown University</entry>
<entry level="1" type="bullet">

 Borodyanskii, Yu. M. and Burgin, M.S. (1994) Operations with Transrecursive Operators, Cybernetics and System Analysis, No. 4, pp. 3-11</entry>
<entry level="1" type="bullet">

 Mark Burgin (2005), <it>Super-recursive algorithms</it>, Monographs in computer science, Springer. ISBN 0387955690</entry>
<entry level="2" type="bullet">

Review, José Félix Costa, <link xlink:type="simple" xlink:href="../646/1485646.xml">
MathSciNet</link>. Review <weblink xlink:type="simple" xlink:href="http://www.ams.org/mathscinet/search/publdoc.html?pg1=IID&amp;s1=193826&amp;r=3&amp;mx-pid=2246430">
MR2246430</weblink>.</entry>
<entry level="2" type="bullet">

Review, Harvey Cohn (2005), "Computing Reviews", Review <weblink xlink:type="simple" xlink:href="http://www.computingreviews.net/browse/browse_topics4.cfm?ccs_id=2376">
CR131542 (0606-0574)</weblink></entry>
<entry level="2" type="bullet">

Review, Martin Davis (2007), <it>Bulletin of Symbolic Logic</it>, v. 13 n. 2. <weblink xlink:type="simple" xlink:href="http://www.math.ucla.edu/~asl/bsl/1302/1302-004.ps">
Online version</weblink></entry>
<entry level="2" type="bullet">

Review, Marc L. Smith (2006), "The Computer Journal", Vol. 49 No. 6 <weblink xlink:type="simple" xlink:href="http://comjnl.oxfordjournals.org/cgi/reprint/49/6/762-a.pdf">
Online version</weblink></entry>
<entry level="2" type="bullet">

Review, Vilmar Trevisan (2005), <link xlink:type="simple" xlink:href="../961/1701961.xml">
Zentralblatt MATH</link>, Vol. 1070. Review <weblink xlink:type="simple" xlink:href="http://siba-sinmdb.unile.it/cgi-bin/zmen/ZMATH/en/quick.html?first=1&amp;maxdocs=3&amp;type=html&amp;an=1070.68038&amp;format=complete">
1070.68038</weblink> </entry>
<entry level="1" type="bullet">

 Burgin, M. How We Know What Technology Can Do, <it>Communications of the ACM</it>, v. 44, No. 11, 2001, pp. 82-88</entry>
<entry level="1" type="bullet">

 Burgin M., Universal limit Turing machines, <it>Notices of the Russian Academy of Sciences</it>, 325, No. 4, (1992), 654-658</entry>
<entry level="1" type="bullet">

 Burgin, M. and Klinger, A. Three Aspects of Super-recursive Algorithms and Hypercomputation or Finding Black Swans, <it>Theoretical Computer Science</it>, v. 317, No. 1/3, 2004, pp. 1-11              </entry>
<entry level="1" type="bullet">

 Burgin, M. Algorithmic Complexity of Recursive and Inductive Algorithms, <it>Theoretical Computer Science, v. 317, No. 1/3, 2004, pp. 31-60              </it></entry>
<entry level="1" type="bullet">

 Burgin, M. and Klinger, A. Experience, Generations, and Limits in Machine Learning, <it>Theoretical Computer Science</it>, v. 317, No. 1/3, 2004, pp. 71-91    </entry>
<entry level="1" type="bullet">

 Campagnolo, M.L., Moore, C., and Costa, J.F.  (2000) An analog characterization of the subrecursive functions. In Proc. of the 4th Conference on Real Numbers and Computers, Odense University, pp. 91-109   </entry>
<entry level="1" type="bullet">

 Copeland, J. (2002) Hypercomputation, <it> Minds and machines</it>, v. 12, pp. 461-502</entry>
<entry level="1" type="bullet">

 Martin Davis (2006), "<weblink xlink:type="simple" xlink:href="http://people.cs.uchicago.edu/~simon/TEACH/28000/DavisUniversal.pdf">
The Church–Turing Thesis: Consensus and opposition</weblink>". Proceedings, Computability in Europe 2006.  Lecture notes in computer science, 3988 pp. 125–132</entry>
<entry level="1" type="bullet">

 Eberbach, E. (2005) Toward a theory of evolutionary computation, <it>BioSystems</it> 82, 1-19</entry>
<entry level="1" type="bullet">

 Eberbach, E., and Wegner, P., Beyond Turing Machines, <it>Bulletin of the European Association for Theoretical Computer Science</it> (EATCS Bulletin), 81, Oct. 2003, 279-304</entry>
<entry level="1" type="bullet">

 <link>
Kurt Gödel</link>, 1931, "Über formal unentscheidbare Sätze der <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../133/24133.xml">
Principia Mathematica</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it> und verwandter Systeme," <it>Monatshefte für Mathematik und Physik 38</it>: 173-98.</entry>
<entry level="1" type="bullet">

 Gold, E.M. Limiting recursion. <it>J. Symb. Logic</it> 10 (1965), 28-48.</entry>
<entry level="1" type="bullet">

 Gold, E.M. (1967) Language Identification in the Limit, <it>Information and Control</it>, v. 10, pp. 447-474 </entry>
<entry level="1" type="bullet">

 Hagar, A. and Korolev, A. (2007) Quantum Hypercomputation – Hype or Computation? http://philsci-archive.pitt.edu/archive/00003180/</entry>
<entry level="1" type="bullet">

 Hintikka, Ja. and Mutanen, A. An Alternative Concept of Computability, in “Language, Truth, and Logic in Mathematics”, Dordrecht, pp. 174-188, 1998</entry>
<entry level="1" type="bullet">

 E.J. Horvitz. Reasoning about inference tradeoffs in a world of bounded resources. Technical Report KSL-86-55, Medical Computer Science Group, Section on Medical Informatics, Stanford University, Stanford, CA, March 1986</entry>
<entry level="1" type="bullet">

 Juraj Hromkovic, Design and Analysis of  Randomized Algorithms, Springer, 2005</entry>
<entry level="1" type="bullet">

  <cite id="CITEREFKleeneFirst_Edition_1952" style="font-style:normal"><link>
Kleene, Stephen C.</link>&#32;(First Edition 1952),&#32;<it>Introduction to Metamathematics</it>, Amsterdam: North-Holland</cite>&nbsp;.</entry>
<entry level="1" type="bullet">

 Kosovsky, N. K. (1981) <it>Elements of Mathematical Logic and its Application to the theory of Subrecursive Algorithms</it>, LSU Publ., Leningrad</entry>
<entry level="1" type="bullet">

 Peter Kugel,  It's time to think outside the computational box, <it>Communications of the ACM</it>, Volume 48, Issue 11, November 2005 </entry>
<entry level="1" type="bullet">

 Petrus H.Potgieter, Zeno machines and hypercomputation, Theoretical Computer Science, Volume 358,  Issue 1  (July 2006) pp. 23 - 33   </entry>
<entry level="1" type="bullet">

 Hilary Putnam, Trial and Error Predicates and the Solution to a Problem of Mostowski. J. Symbolic Logic, Volume 30, Issue 1 (1965), 49-57</entry>
<entry level="1" type="bullet">

Darko Roglic, "<weblink xlink:type="simple" xlink:href="http://arxiv.org/abs/0708.2686">
The universal evolutionary computer based on super-recursive algorithms of evolvability</weblink>"</entry>
<entry level="1" type="bullet">

 <link>
J. Schmidhuber</link> (2000): Algorithmic Theories of Everything  http://arxiv.org/abs/quant-ph/0011122 </entry>
<entry level="1" type="bullet">

 <link>
J. Schmidhuber</link> (2002): Hierarchies of generalized <link xlink:type="simple" xlink:href="../161/91161.xml">
Kolmogorov</link> complexities and nonenumerable universal measures computable in the limit. International Journal of Foundations of Computer Science 13(4):587-612 http://www.idsia.ch/~juergen/kolmogorov.html</entry>
<entry level="1" type="bullet">

 Hava Siegelmann, <it>Neural Networks and Analog Computation: Beyond the Turing Limit</it>, Birkhauser, 1999</entry>
<entry level="1" type="bullet">

 Turing, A. (1939) Systems of Logic Based on Ordinals, <it>Proc. Lond. Math. Soc.</it>, Ser.2, v. 45: 161-228 </entry>
<entry level="1" type="bullet">

 van Leeuwen, J. and Wiedermann, J. (2000a) <it>Breaking the Turing Barrier: The case of the Internet</it>, Techn. Report, Inst. of Computer Science, Academy of Sciences of the Czech. Rep., Prague</entry>
<entry level="1" type="bullet">

 Jiří Wiedermann, Characterizing the super-Turing computing power and efficiency of classical fuzzy Turing machines, <it>Theoretical Computer Science</it>, Volume 317, Issue 1-3, June 2004</entry>
<entry level="1" type="bullet">

 Jiří Wiedermann and Jan van Leeuwen, The emergent computational potential of evolving artificial living systems, AI Communications, v. 15, No. 4, 2002</entry>
<entry level="1" type="bullet">

 Hector Zenil and Francisco Hernandez-Quiroz, On the possible computational power of the human mind, Worldviews, Science and Us, edited by Carlos Gershenson, Diederik Aerts and Bruce Edmonds, World Scientific, 2007, (arXiv:cs.NE/0605065v3)</entry>
<entry level="1" type="bullet">

 S. Zilberstein, Using Anytime Algorithms in Intelligent Systems, "AI Magazine", 17(3):73-83, 1996</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.la-acm.org/Archives/laacm9912.html">
A New Paradigm for Computation</weblink>. Los Angeles ACM Chapter Meeting, December 1, 1999.</entry>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://foldoc.org/?anytime+algorithm">
Anytime algorithm</weblink></it> from <link xlink:type="simple" xlink:href="../324/11324.xml">
FOLDOC</link></entry>
</list>
</p>

</sec>
</bdy>
</article>
