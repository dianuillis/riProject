<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 03:28:16[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<language  confidence="0.9511911446218017" wordnetid="106282651">
<header>
<title>Recursive languages and sets</title>
<id>15867600</id>
<revision>
<id>218663624</id>
<timestamp>2008-06-11T17:06:52Z</timestamp>
<contributor>
<username>DOI bot</username>
<id>6652755</id>
</contributor>
</revision>
<categories>
<category>Theory of computation</category>
<category>Recursion theory</category>
<category>Formal languages</category>
</categories>
</header>
<bdy>

<indent level="1">

<it>This article is a temporary experiment to see whether it is feasible and desirable to merge the articles <link xlink:type="simple" xlink:href="../264/332264.xml">
Recursive set</link>, <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../874/53874.xml">
Recursive language</link></language>
, <link xlink:type="simple" xlink:href="../874/53874.xml">
Decidable language</link>, <link xlink:type="simple" xlink:href="../336/8336.xml">
Decidable problem</link> and <link xlink:type="simple" xlink:href="../055/15631055.xml">
Undecidable problem</link>. Input on how best to do this is very much welcome on . This is a work in progress so the current version may seem awkward.</it> 
</indent>

In <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability theory</link>, a set is <b>decidable</b>, <b>computable</b>, or <b>recursive</b> if there is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that terminates after a finite amount of time and correctly decides whether or not a given object belongs to the set. Decidability of a set is of particular interest when the set is viewed as a <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>; a decidable set is also a  <b>decidable problem</b>, <b>computable problem</b>, and <b>recursive problem</b>. The remainder of this article uses the term <it>decidable</it>, although <it>recursive</it> and <it>computable</it> are equivalent in this context. <p>

A <b>language</b> is a set of <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/27701.xml">
finite strings</link></kind>
</type>
</language>
</category>
</concept>
</idea>
 over a particular <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../269/4292269.xml">
alphabet</link></language>
. A language is decidable (also computable, recursive) if it is a decidable set.</p>
<p>

A set, language, or decision problem that is not decidable is <b>undecidable</b>, <b>non-recursive</b>, <b>non-computable</b>, or <b>uncomputable</b>. There are many known undecidable sets; one of the earliest, and most famous, examples is the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link>.</p>
<p>

Decidable sets and languages are a strict subclass of the class of <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable set</link>s.  For those sets, it is only required that there is an algorithm that correctly decides when an input <it>is</it> in the set; the algorithm may fail to terminate for inputs not belonging to the set.</p>

<sec>
<st>
Formal definition</st>

<p>

A subset <it>S</it> of the <link xlink:type="simple" xlink:href="../474/21474.xml">
natural numbers</link> is called <b>decidable</b> if there exists a <link xlink:type="simple" xlink:href="../577/23577.xml">
total</link> <link xlink:type="simple" xlink:href="../338/1139338.xml">
computable function</link> <math>f</math> such that 
<math>f(x) = 0\,</math> if <math>x \in S</math> and <math>f(x) \not = 0</math> if <math>x \notin S</math>.  In other words, the set <it>S</it> is decidable <link xlink:type="simple" xlink:href="../922/14922.xml">
if and only if</link> the <link xlink:type="simple" xlink:href="../790/240790.xml">
indicator function</link> <math>1_{S}</math> is <link xlink:type="simple" xlink:href="../338/1139338.xml">
computable</link>.</p>
<p>

A parallel definition applies to sets of strings over some finite alphabet; these sets are often called <b>languages</b>. A language is decidable if there is a computable function taking strings over the alphabet as input, which returns 0 when presented with a string not in the language, and returns 1 when presented with a string in the language. </p>
<p>

The definition can be extended to arbitrary countable sets via <link>
GÃ¶del numbering</link>s. If each element of a set <it>U</it> has a unique associated natural number, a subset <it>C</it> of <it>U</it> is called computable if the set of natural numbers corresponding to the elements of <it>C</it> is decidable under the definition above. A similar definition can be made in which elements of <it>U</it> are identified with finite strings rather than natural numbers.</p>
<p>

The definition can also be extended to sets of ordered pairs, ordered triples, and more generally finite sequences of objects. One way to do this is to use computable functions taking more than one argument &ndash; for example, a set <it>A</it> of ordered pairs of elements of a set <it>X</it> is decidable if there is a computable function <it>g</it> taking two arguments, such that for all <it>x</it> and <it>y</it> in <it>X</it>, <it>g</it>(<it>x</it>,<it>y</it>)= 0 if the pair (<it>x</it>,<it>y</it>) is not in <it>A</it>, and <it>g</it>(<it>x</it>,<it>y</it>)=1 if the pair is in <it>A</it>. Another way of defining decidability for sets of sequences is to use a <link xlink:type="simple" xlink:href="../848/1145848.xml">
pairing function</link> to identify each sequence with a single object (natural number or string). Then the definitions of decidability above can be directly applied. This second method is particularly useful when the set in question contains sequences of varying lengths.</p>

</sec>
<sec>
<st>
Examples</st>

<p>

There are many examples of decidable sets:
<list>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../566/9566.xml">
empty set</link> is decidable, and the entire set of natural numbers is decidable.</entry>
<entry level="1" type="bullet">

 Every finite or <link xlink:type="simple" xlink:href="../708/382708.xml">
cofinite</link> subset of the natural numbers is decidable.</entry>
<entry level="1" type="bullet">

 The set of <link xlink:type="simple" xlink:href="../666/23666.xml">
prime number</link>s is decidable.</entry>
<entry level="1" type="bullet">

 The finite binary strings with an even number of 1s is decidable.</entry>
<entry level="1" type="bullet">

 If <it>f</it> is a <link xlink:type="simple" xlink:href="../338/1139338.xml">
computable function</link> then the set of pairs (<it>x</it>,<it>y</it>) such that <it>f</it>(<it>x</it>) = <it>y</it> is decidable.</entry>
</list>
</p>
<p>

It is possible for a set to be decidable even if the precise algorithm that decides it is not known. For example, consider the set <it>A</it> containing all natural numbers <it>n</it> such that there is a pair of <link xlink:type="simple" xlink:href="../997/41997.xml">
twin prime</link>s larger than <it>n</it>.  It is not presently known whether there are infinitely many twin primes, or whether (otherwise) there is a largest pair of twin primes. But in either case, the set <it>A</it> is decidable. If there are infinitely many twin primes, <it>A</it>  contains every natural number, and is thus decidable. Otherwise, there is a largest pair of twin primes, which means <it>A</it> is finite, and thus decidable. This means that, regardless of whether there are infinitely many twin primes, the set <it>A</it> is decidable, despite the fact that the correct algorithm has not been identified.</p>

</sec>
<sec>
<st>
Properties</st>

<p>

The class of decidable sets has numerous closure properties.
<list>
<entry level="1" type="bullet">

If <it>A</it> is a decidable set then the <link xlink:type="simple" xlink:href="../347/54347.xml">
complement</link> of <it>A</it> is also a decidable set. </entry>
<entry level="1" type="bullet">

If <it>A</it> and <it>B</it> are decidable sets then <it>A</it> &amp;cap; <it>B</it>, <it>A</it> &amp;cup; <it>B</it>, and <math>A \setminus B</math> are decidable.</entry>
<entry level="1" type="bullet">

 If <it>A</it> and <it>B</it> are decidable sets then <it>A</it> &amp;times; <it>B</it> is decidable; this is the set of pairs (<it>x</it>,<it>y</it>) such that <it>x</it> is in <it>A</it> and <it>y</it> is in <it>B</it>. Moreover, the image of <it>A</it> &amp;times; <it>B</it> under the <link xlink:type="simple" xlink:href="../848/1145848.xml">
Cantor pairing function</link> is decidable.</entry>
<entry level="1" type="bullet">

The <link xlink:type="simple" xlink:href="../311/579311.xml">
preimage</link> of a decidable set under a <link xlink:type="simple" xlink:href="../577/23577.xml">
total</link> <link xlink:type="simple" xlink:href="../338/1139338.xml">
computable function</link> is a decidable set.</entry>
<entry level="1" type="bullet">

 The image of a decidable set under a total computable <link xlink:type="simple" xlink:href="../942/3942.xml">
bijection</link> is decidable.</entry>
</list>

Sets of strings have additional closure properties. If <it>L</it> and <it>P</it> are two decidable languages, then the following languages are also decidable:
<list>
<entry level="1" type="bullet">

 The <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/16750.xml">
Kleene star</link></language>
 <it>L</it>&amp;lowast;. A string is in this set if and only if it can be obtained by concatenating zero or more elements of <it>L</it>, with repetition allowed.</entry>
<entry level="1" type="bullet">

 The concatenation <it>L</it>&#8728; <it>P</it>. A string is in this set if and only if it can be written as an element of <it>L</it> followed by an element of <it>P</it>.</entry>
</list>
</p>
<p>

Several characterizations of decidable sets are known. 
<list>
<entry level="1" type="bullet">

 A set <it>A</it> is decidable if and only if both <it>A</it> and the <link xlink:type="simple" xlink:href="../347/54347.xml">
complement</link> of <it>A</it> are <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable set</link>s.</entry>
<entry level="1" type="bullet">

 A set of natural numbers is decidable if and only if it is at level <math>\Delta^0_1</math> of the <link xlink:type="simple" xlink:href="../475/186475.xml">
arithmetical hierarchy</link>. </entry>
<entry level="1" type="bullet">

 A set of natural numbers is decidable if and only if it is either the range of a nondecreasing total computable function or is the empty set. Conversely, the image of a decidable set under a nondecreasing total computable function is decidable.</entry>
</list>
</p>

</sec>
<sec>
<st>
Decidable languages</st>

<p>

A <b>decidable language</b> in <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematics</link>, <link xlink:type="simple" xlink:href="../225/3729225.xml">
logic</link> and <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, is a type of <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link> which is also called <b>recursive</b> or <b>Turing-decidable</b>. The class of all decidable languages is often called <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../763/3106763.xml">
R</link></group>
</collection>
</class>
</b>, although this name is also used for the class <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../771/54771.xml">
RP</link></group>
</collection>
</class>
.  All decidable languages are <link xlink:type="simple" xlink:href="../789/54789.xml">
recursively enumerable</link>, and all <link xlink:type="simple" xlink:href="../723/25723.xml">
regular</link>, <link xlink:type="simple" xlink:href="../867/6867.xml">
context-free</link> and <link xlink:type="simple" xlink:href="../212/6212.xml">
context-sensitive</link> languages are decidable. </p>
<p>

This type of language was not defined in the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky hierarchy</link></language>
 of  <cite class="inline">(<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFChomsky1959%22])">
Chomsky 1959</link>)</cite>, and there is no simple class of <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>s that capture the decidable languages.</p>

</sec>
<sec>
<st>
 Undecidability </st>

<p>

A <b><link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link></b> is, informally, a problem whose solution is either "yes" or "not". Each such problem is characterized by the set of inputs whose solution is "yes". As a result, decision problems are formally defined as being sets, either of strings or of natural numbers: any such set defines the problem of deciding whether a given object belongs to the set.</p>
<p>

A decision problem <it>A</it> is called <b>decidable</b> or <b>effectively solvable</b> if <it>A</it> is a <link xlink:type="simple" xlink:href="../264/332264.xml">
recursive set</link>, that is, there exists an algorithm for establishing the presence of the element in the set. A problem is called <b>partially decidable</b>, <b>semidecidable</b>, <b>solvable</b>, or <b>provable</b> if <it>A</it> is a <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable set</link>.  Partially decidable problems and any other problems that are not decidable are called <b>undecidable</b>.</p>

<ss1>
<st>
The halting problem </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../668/13668.xml">
Halting problem</link></it>
</indent>

In <link xlink:type="simple" xlink:href="../136/442136.xml">
computability theory</link>, the <b>halting problem</b> is a <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link> which can be stated as follows:</p>
<p>

<indent level="1">

<it>Given a description of a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link> and a finite input, decide whether the program eventually halts when started with that input, or whether it runs forever..</it>
</indent>

<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
 proved in 1936 that a general <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> to solve the halting problem for <it>all</it> possible program-input pairs cannot exist; the set of pairs (<it>e</it>,<it>n</it>) such that the program with description <it>e</it> halts on input <it>n</it> is undecidable.</p>

</ss1>
<ss1>
<st>
 Decidability of logical theories </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../118/913118.xml">
Decidability (logic)</link></it>
</indent>

In <link xlink:type="simple" xlink:href="../636/19636.xml">
mathematical logic</link>, a <b><link xlink:type="simple" xlink:href="../103/3512103.xml">
theory</link></b> is a set of formal sentences that is closed under <link xlink:type="simple" xlink:href="../361/3674361.xml">
logical consequence</link> (essentially, any sentence that can be proved from sentences in the theory is itself in the theory). Important examples are the set of all <link xlink:type="simple" xlink:href="../005/25005.xml">
arithmetical sentences</link> that are satisfied by the set of <link xlink:type="simple" xlink:href="../474/21474.xml">
natural numbers</link>, and the set of arithmetical sentences provable from the axioms of <link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link>.  </p>
<p>

Many formal theories have been studied in the context of decidability. For example, the theory of the real numbers (in the <link xlink:type="simple" xlink:href="../156/7788156.xml">
signature</link> of <link xlink:type="simple" xlink:href="../603/10603.xml">
fields</link>) is decidable, while the <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order</link> theory of the natural numbers is not.  <link>
GÃ¶del's incompleteness theorem</link> implies that no first-order theory capable of interpreting a sufficient amount of the theory of the natural numbers can be decidable.</p>

</ss1>
</sec>
<sec>
<st>
List of undecidable problems</st>

<p>

In <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability theory</link>, an <b>undecidable problem</b> is a problem whose language is not a <link xlink:type="simple" xlink:href="../264/332264.xml">
recursive set</link>. More informally, such problems cannot be solved in general by computers; see <link xlink:type="simple" xlink:href="../118/913118.xml">
decidability</link>. This is a list of undecidable problems. Note that there are <link xlink:type="simple" xlink:href="../248/32248.xml">
uncountably</link> many undecidable problems, so this list is necessarily incomplete. Though undecidable languages are not recursive languages, they may be a <link xlink:type="simple" xlink:href="../631/27631.xml">
subset</link> of <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Turing</link></scientist>
</person>
 recognizable languages.</p>

<ss1>
<st>
 Problems related to <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link>s </st>

<p>

<list>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link> (determining whether a specified machine halts or runs forever).</entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../911/67911.xml">
busy beaver</link> problem (determining the length of the longest halting computation among machines of a specified size).</entry>
<entry level="1" type="bullet">

 <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../852/25852.xml">
Rice's theorem</link></proposition>
</theorem>
</message>
</statement>
 states that for all non-trivial properties of partial functions, it is undecidable whether a machine computes a partial function with that property.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Other problems </st>

<p>

<list>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../685/64685.xml">
Post correspondence problem</link>.</entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../563/33563.xml">
word problem for groups</link>.</entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../742/1180742.xml">
word problem</link> for certain <link xlink:type="simple" xlink:href="../939/10939.xml">
formal languages</link>.</entry>
<entry level="1" type="bullet">

 The problem of determining if a given set of <link xlink:type="simple" xlink:href="../798/65798.xml">
Wang tile</link>s can tile the plane.</entry>
<entry level="1" type="bullet">

 The problem whether a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../891/308891.xml">
Tag system</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 halts.</entry>
<entry level="1" type="bullet">

 The problem of determining the <link xlink:type="simple" xlink:href="../635/1635.xml">
Kolmogorov complexity</link> of a string.</entry>
<entry level="1" type="bullet">

 Determination of the solvability of a Diophantine equation, known as <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../851/101851.xml">
Hilbert's tenth problem</link></mathematical_statement>
</equation>
</message>
</statement>
</entry>
<entry level="1" type="bullet">

 Determining whether two finite <link xlink:type="simple" xlink:href="../686/252686.xml">
simplicial complexes</link> are homeomorphic</entry>
<entry level="1" type="bullet">

 Determining whether the <link xlink:type="simple" xlink:href="../004/11004.xml">
fundamental group</link> of a finite simplicial complex is trivial</entry>
<entry level="1" type="bullet">

 Determining if a <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link> generates all possible strings, or if it is ambiguous.</entry>
<entry level="1" type="bullet">

 Given two context-free grammars, determining whether they generate the same set of strings, or whether one generates a subset of the strings generated by the other, or whether there is any string at all that both generate.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Chomsky, Noam&#32;(1959).&#32;"On certain formal properties of grammars". <it>Information and Control</it>&#32;<b>2</b>&#32;(2): 137â167. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2FS0019-9958%2859%2990362-6">
10.1016/S0019-9958(59)90362-6</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite id="CITEREFCutland.2C_N.1980" style="font-style:normal">Cutland, N.&#32;(1980),&#32;<it>Computability.</it>, Cambridge University Press, ISBN ISBN 0-521-29465-7</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="CITEREFRogers1987" style="font-style:normal">Rogers, Hartley&#32;(1987),&#32;<it>The Theory of Recursive Functions and Effective Computability</it>, First MIT press paperback edition, ISBN 978-0-262-68052-3</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Michael Sipser</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(1997).&#32;"Decidability", Introduction to the Theory of Computation.&#32;PWS Publishing,&#32;151â170. ISBN 0-534-94728-X.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="CITEREFSoare1987" style="font-style:normal">Soare, R.&#32;(1987),&#32;<it>Recursively Enumerable Sets and Degrees</it>, Berlin, New York: <link xlink:type="simple" xlink:href="../949/1418949.xml">
Springer-Verlag</link></cite>&nbsp;</entry>
</list>
</p>

<p>

<table style=";width:auto;" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../356/103356.xml">
Automata theory</link>: <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>s and <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;background:transparent;color:inherit;" class="navbox-list navbox-odd">
<table style="text-align:left;width:100%;" class="navbox-columns-table" cellspacing="0">
<row>
<col colspan="1" style="" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky
hierarchy</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../716/18020716.xml">
Grammars</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><link xlink:type="simple" xlink:href="../939/10939.xml">
Languages</link></b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b>Minimal
<link xlink:type="simple" xlink:href="../931/10931.xml">
automaton</link></b></col>
</row>
<row style="height:2px;">

</row>
<row style="vertical-align:top;">
<col style="padding:0px;text-align: center;;;;width:10em;">
Type-0 n/a Type-1 n/a n/a Type-2 n/a Type-3 n/a</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../174/4906174.xml">
Unrestricted</link></language>
(no common name) <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../211/6211.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/12656637.xml">
Indexed</link></language>
<model wordnetid="105890249" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<hypothesis wordnetid="105888929" confidence="0.8">
<link xlink:type="simple" xlink:href="../555/567555.xml">
Tree-adjoining</link></hypothesis>
</concept>
</idea>
</model>
 etc.<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../759/6759.xml">
Context-free</link></language>
</subject>
</message>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/10609024.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../855/25855.xml">
Regular</link></language>
n/a</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../789/54789.xml">
Recursively enumerable</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../874/53874.xml">
Recursive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/6212.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../284/7324284.xml">
Indexed</link></language>
(<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/13026226.xml">
Mildly context-sensitive</link></language>
)<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/6867.xml">
Context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../589/7962589.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../723/25723.xml">
Regular</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../792/4922792.xml">
Star-free</link></language>
</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/1352564.xml">
Decider</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../962/1811962.xml">
Linear-bounded</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../447/9791447.xml">
Nested stack</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../961/14345961.xml">
Embedded pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../510/24510.xml">
Nondeterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../656/3972656.xml">
Deterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<link xlink:type="simple" xlink:href="../931/10931.xml">
Finite</link><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../149/17995149.xml">
Aperiodic finite</link></language>
</p>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
Each category of languages or grammars is a <link xlink:type="simple" xlink:href="../631/27631.xml">
proper subset</link>of the category directly above it; and any automaton in each category has an equivalent automaton in the category directly above it.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</language>
</article>
