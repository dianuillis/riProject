<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:21:22[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<operation  confidence="0.8" wordnetid="114008806">
<state  confidence="0.8" wordnetid="100024720">
<action  confidence="0.8" wordnetid="114006945">
<header>
<title>Tree decomposition</title>
<id>159023</id>
<revision>
<id>239830395</id>
<timestamp>2008-09-20T18:30:12Z</timestamp>
<contributor>
<username>MapsMan</username>
<id>222151</id>
</contributor>
</revision>
<categories>
<category>Graph operations</category>
<category>Trees (graph theory)</category>
</categories>
</header>
<bdy>

<image width="240px" src="Tree_decomposition.svg" type="thumb">
<caption>

A graph with eight vertices, and a tree decomposition of it onto a tree with six nodes. Each graph edge connects two vertices that are listed together at some tree node, and each graph vertex is listed at the nodes of a contiguous subtree of the tree. Each tree node lists at most three vertices, so the width of this decomposition is two.
</caption>
</image>

In <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link>, a <b>tree decomposition</b> is a mapping of a <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link> into a <link xlink:type="simple" xlink:href="../560/48560.xml">
tree</link> that can be used to speed up solving certain problems on the original graph. The <b>treewidth</b> measures the number of graph vertices mapped onto any tree node in an optimal tree decomposition.
While it is <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
 to determine the treewidth of a graph, many <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
 combinatorial problems on graphs are solvable in polynomial time when restricted to graphs of bounded treewidth.<p>

In <link xlink:type="simple" xlink:href="../488/233488.xml">
machine learning</link>, tree decompositions are also called <b>junction trees</b>, <b>clique trees</b>, or <b>join trees</b>; they
play an important role in problems like <link xlink:type="simple" xlink:href="../010/800010.xml">
probabilistic inference</link>, <link xlink:type="simple" xlink:href="../966/949966.xml">
constraint satisfaction</link>, <link xlink:type="simple" xlink:href="../761/3480761.xml">
query optimization</link>, and <link xlink:type="simple" xlink:href="../873/253873.xml">
matrix decomposition</link>.</p>
<p>

The concept of tree decompositions and treewidth was introduced by <link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFRobertsonSeymour1984%22])">
Robertson &amp; Seymour (1984)</link> and has since been studied by many other authors.</p>

<sec>
<st>
Definition</st>
<p>

Intuitively, a tree decomposition represents the vertices of the given graph as subtrees of a tree, in such a way that vertices are adjacent only when the corresponding subtrees intersect. Thus, the graph forms a <link>
subgraph</link> of the <link xlink:type="simple" xlink:href="../759/7726759.xml">
intersection graph</link> of the subtrees. The full intersection graph is a <link xlink:type="simple" xlink:href="../165/744165.xml">
chordal graph</link>.</p>
<p>

Each subtree associates a graph vertex with a set of tree nodes. To define this formally, we represent each tree node as the set of vertices associated with it.
Thus, given a graph <it>G</it> = (<it>V</it>, <it>E</it>), a tree decomposition is a pair (<it>X</it>, <it>T</it>), where <it>X</it> = {<it>X</it>1, ..., <it>Xn</it>} is a family of subsets of <it>V</it>, and <it>T</it> is a tree whose nodes are the subsets <it>Xi</it>, satisfying the following properties<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>:</p>
<p>

<list>
<entry level="1" type="number">

 The union of all sets <it>Xi</it> equals <it>V</it>. That is, each graph vertex is associated with at least one tree node.</entry>
<entry level="1" type="number">

 For every edge (<it>v</it>, <it>w</it>) in the graph, there is a subset <it>Xi</it> that contains both <it>v</it> and <it>w</it>. That is, vertices are adjacent in the graph only when the corresponding subtrees have a node in common.</entry>
<entry level="1" type="number">

 If <it>Xi</it> and <it>Xj</it> both contain a vertex <it>v</it>, then all nodes <it>Xz</it> of the tree in the (unique) path between <it>Xi</it> and <it>Xj</it> contain <it>v</it> as well. That is, the nodes associated with vertex <it>v</it> form a connected subset of <it>T</it>.</entry>
</list>
</p>
<p>

The tree decomposition of a graph is far from unique; for example, a trivial tree decomposition contains all vertices of the graph in its single root node.</p>

</sec>
<sec>
<st>
Treewidth</st>
<p>

The <it>width</it> of a tree decomposition is the size of its largest set <it>Xi</it> minus one.   The <b>treewidth</b> tw(<it>G</it>) of a graph <it>G</it> is the minimum width among all possible tree decompositions of <it>G</it>. In this definition, the size of the largest set is diminished by one in order to make the treewidth of a tree equal to one. Equivalently, the treewidth of <it>G</it> is one less than the size of the largest <link xlink:type="simple" xlink:href="../466/524466.xml">
clique</link> in any <link xlink:type="simple" xlink:href="../165/744165.xml">
chordal graph</link> containing <it>G</it>. Treewidth can also be characterized in terms of certain <link xlink:type="simple" xlink:href="../398/3857398.xml">
pursuit-evasion</link> games on the graph.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

The graphs with treewidth at most <it>k</it> are also called <b>partial <it>k</it></b><b>-trees</b>.</p>
<p>

It is NP-complete to determine whether a given graph <it>G</it> has treewidth at most a given variable <it>k</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
However, when <it>k</it> is any fixed constant, the graphs with treewidth <it>k</it> can be recognized, and a width <it>k</it> tree decomposition constructed for them, in linear time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> The time dependence of this algorithm on <it>k</it> is exponential.</p>

</sec>
<sec>
<st>
Graph minors</st>
<p>

<image width="150px" src="Partial_3-tree_forbidden_minors.svg" type="thumb">
<caption>

Forbidden minors for partial 3-trees
</caption>
</image>

For any fixed constant <it>k</it>, the partial <it>k</it>-trees are closed under the operation of <link xlink:type="simple" xlink:href="../042/353042.xml">
graph minor</link>s, and therefore, by the <link>
Robertson–Seymour theorem</link>, this family can be characterized in terms of a finite set of <link xlink:type="simple" xlink:href="../826/13547826.xml">
forbidden minors</link>. For partial 1-trees (that is, forests), the single forbidden minor is a triangle, and for the partial 2-trees the single forbidden minor is the <link xlink:type="simple" xlink:href="../816/85816.xml">
complete graph</link> on four vertices. However, the number of forbidden minors increases for larger values of <it>k</it>: for partial 3-trees there are four forbidden minors, the complete graph on five vertices, the <link xlink:type="simple" xlink:href="../458/22458.xml">
octahedral graph</link> with six vertices, the <link>
Möbius ladder</link> with eight vertices, and the <link xlink:type="simple" xlink:href="../659/2859659.xml">
pentagonal prism</link> with ten vertices.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>
<p>

The <link xlink:type="simple" xlink:href="../314/24314.xml">
planar graph</link>s do not have bounded treewidth, because the <it>n</it> &amp;times; <it>n</it> <link xlink:type="simple" xlink:href="../053/3353053.xml">
grid graph</link> is a planar graph with treewidth <it>n</it>. Therefore, if <it>F</it> is a minor-closed graph family with bounded treewidth, it cannot include all planar graphs. Conversely, if some planar graph cannot occur as a minor for graphs in family <it>F</it>, then there is a constant <it>k</it> such that all graphs in <it>F</it> have treewidth at most <it>k</it>. That is, the following three conditions are equivalent to each other:<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
<list>
<entry level="1" type="number">

<it>F</it> is a minor-closed family of bounded-treewidth graphs;</entry>
<entry level="1" type="number">

One of the finitely many forbidden minors characterizing <it>F</it> is planar;</entry>
<entry level="1" type="number">

<it>F</it> is a minor-closed graph family that does not include all planar graphs.</entry>
</list>
</p>
<p>

Families of graphs with bounded treewidth include the <link xlink:type="simple" xlink:href="../209/9944209.xml">
cactus graph</link>s, <link xlink:type="simple" xlink:href="../542/13511542.xml">
pseudoforest</link>s, <link xlink:type="simple" xlink:href="../559/9938559.xml">
series-parallel graph</link>s, <link xlink:type="simple" xlink:href="../314/24314.xml">
outerplanar graph</link>s, and <link xlink:type="simple" xlink:href="../548/19658548.xml">
Halin graph</link>s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> The <link xlink:type="simple" xlink:href="../653/43653.xml">
control flow graph</link>s arising in the <link xlink:type="simple" xlink:href="../739/5739.xml">
compilation</link> of <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../695/27695.xml">
structured programs</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 also have bounded treewidth, which allows certain tasks such as <link xlink:type="simple" xlink:href="../122/485122.xml">
register allocation</link> to be performed efficiently on them.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</sec>
<sec>
<st>
Dynamic programming</st>
<p>

As several authors independently observed in the late 1980s,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> many algorithmic problems that are <link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link> for arbitrary graphs may be solved efficiently by <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> for graphs of bounded treewidth, using the tree-decompositions of these graphs.</p>
<p>

As an example, consider the problem of finding the <link xlink:type="simple" xlink:href="../501/524501.xml">
maximum independent set</link> in a graph of treewidth <it>k</it>. To solve this problem, first choose one of the nodes of the tree decomposition to be the root, arbitrarily. For a node <it>Xi</it> of the tree decomposition, let <it>Di</it> be the union of the sets <it>Xj</it> descending from <it>Xi</it>. Let <it>A</it>(<it>S</it>,<it>i</it>), for an independent set <it>S</it>&nbsp;⊂&nbsp;<it>Xi</it>, denote the size of the largest independent subset <it>I</it> of <it>Di</it> such that <it>I</it>&nbsp;∩&nbsp;<it>Xi</it>&nbsp;=&nbsp;<it>S</it>. Similarly, for an adjacent pair of nodes <it>Xi</it> and <it>Xj</it>, with <it>Xi</it> farther from the root of the tree than <it>Xj</it>, and an independent set <it>S</it>&nbsp;⊂&nbsp;<it>Xi</it>&nbsp;∩&nbsp;<it>Xj</it>, let <it>B</it>(<it>S</it>,<it>i</it>,<it>j</it>) denote the size of the largest independent subset <it>I</it> of <it>Di</it> such that <it>I</it>&nbsp;∩&nbsp;<it>Xi</it>&nbsp;∩&nbsp;<it>Xj</it>&nbsp;=&nbsp;<it>S</it>. We may calculate these <it>A</it> and <it>B</it> values by a bottom-up traversal of the tree:
<indent level="1">

<math>A(S,i)=|S| + \sum_{j} \left(B(S\cap X_j, j,i) - |S\cap X_j|\right)</math>
</indent>
:<math>B(S,i,j)=\max_{S'\subset X_i\atop S=S'\cap X_j} A(S',i)</math>
where the sum in the calculation of <math>A(S,i)</math> is over the children of node <math>X_i</math>.</p>
<p>

At each node or edge, there are at most 2<it>k</it> sets <it>S</it> for which we need to calculate these values, so if <it>k</it> is a constant then the whole calculation takes constant time per edge or node. The size of the maximum independent set is the largest value stored at the root node, and the maximum independent set itself can be found (as is standard in dynamic programming algorithms) by backtracking through these stored values starting from this largest value. Thus, in graphs of bounded treewidth, the maximum independent set problem may be solved in linear time. Similar algorithms apply to many other graph problems.</p>
<p>

This dynamic programming approach is used in <link xlink:type="simple" xlink:href="../488/233488.xml">
machine learning</link> via the <link xlink:type="simple" xlink:href="../682/4855682.xml">
junction tree algorithm</link> for <link xlink:type="simple" xlink:href="../010/800010.xml">
belief propagation</link> in graphs of bounded treewidth. It also plays a key role in algorithms for computing the treewidth and constructing tree decompositions: typically, such algorithms have a first step that <link xlink:type="simple" xlink:href="../105/563105.xml">
approximates</link> the treewidth, constructing a tree decomposition with this approximate width, and then a second step that performs dynamic programming in the approximate tree decomposition to compute the exact value of the treewidth.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>

</sec>
<sec>
<st>
Treewidth of cliques</st>
<p>

In any tree decomposition <math>(T, X)</math> of a graph containing a <link xlink:type="simple" xlink:href="../466/524466.xml">
clique</link> there is a node <it>i</it> in <it>T</it> such that <math>X_i</math> contains all the  nodes of the clique. This is shown by <link xlink:type="simple" xlink:href="../881/18881.xml">
induction</link> on the size of the clique. The base cases are cliques of size 1 and 2, which follow from the conditions 1 and 2 on a tree decomposition. The inductive case is a graph containing a clique of size <it>k</it>+1, where <it>k</it> is 2 or greater. Let <it>C</it> be the set of nodes in the clique. Since <math>k+1 \geq 3</math>, there are at least three nodes in the clique, call them <it>x</it>, <it>y</it> and <it>z</it>. We know from the induction hypothesis that there are nodes <it>a</it>, <it>b</it> and <it>c</it> in the tree decomposition where 
<indent level="1">

<math>X_a \supseteq C-\{x\}</math>, <math>X_b \supseteq C-\{y\}</math>, <math>X_c \supseteq C-\{z\}</math>.
</indent>
In a <graph wordnetid="107000195" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../560/48560.xml">
tree</link></graph>
 there is exactly one path between any two nodes. A second property of trees is that the three paths between a, b and c have a non-empty intersection. Let v be a node in this intersection. From condition 3 on a tree decomposition we get that 
<indent level="1">

<math>X_v \supseteq X_a \cap X_b \supseteq C - \{ x, y \}</math>
</indent>
:<math>X_v \supseteq X_b \cap X_c \supseteq C - \{ y, z \}</math>
<indent level="1">

<math>X_v \supseteq X_a \cap X_c \supseteq C - \{ x, z \}</math>
</indent>
This implies that <math>X_v \supseteq C</math>.</p>
<p>

It follows from this that the treewidth of a <it>k</it>-clique is <it>k</it>-1.</p>

</sec>
<sec>
<st>
Treewidth of trees</st>
<p>

A connected graph has treewidth 1 if and only if it is a tree. This can be shown in two steps, first that a tree has treewidth 1, second, that a connected graph with treewidth 1 is a tree. </p>
<p>

To show the former, use <link xlink:type="simple" xlink:href="../881/18881.xml">
induction</link> on the number of nodes in the tree to show that it has a tree decomposition with no bag with size larger than two. The base cases are trees with one or two nodes, in which case the tree decomposition with one single node is sufficient. The inductive case is a tree <math>G</math> with <math>k+1</math> nodes, where <math>k</math> is any integer greater than <math>1</math>. If we remove a <link xlink:type="simple" xlink:href="../622/18973622.xml">
leaf</link> <math>v</math> from the graph, we get a tree of size <math>k</math>. From the induction hypothesis we can create a tree decomposition <math>(T, X)</math> of width 1 of this graph. Let <math>u</math> be the unique neighbour of <math>v</math> in <math>G</math> and <math>i</math> some node in <math>T</math> such that <math>u</math> is in <math>X_i</math>. Let <math>T_1</math> be <math>T</math> added a node <math>j</math> with <math>i</math> as its only neighbour and let <math>X'</math> be <math>X</math> with the addition that <math>X'_j = \{ i, j \} </math>. Now <math>(T_1, X')</math> is a tree decomposition of <math>G</math> with width 1.</p>
<p>

Now it remains to show that a connected graph with treewidth 1 is a tree. The <link xlink:type="simple" xlink:href="../497/8556497.xml">
contrapositive</link> statement is that a graph with a cycle does not have treewidth 1. A graph with a cycle has the 3-clique as a minor, which from the statement in the previous section has treewidth 2. Since the partial 2-trees are closed under minors, the graph therefore has treewidth 2 or greater.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../502/16795502.xml">
Clique-width</link></entry>
</list>

</p>
</sec>
<sec>
<st>
Notes</st>

<p>

<reflist>
<entry id="1">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFDiestel%22])">
Diestel ()</link> section 12.3</entry>
<entry id="2">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFSeymourThomas1993%22])">
Seymour &amp; Thomas (1993)</link>.</entry>
<entry id="3">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFArnborgCorneilProskurowski1987%22])">
Arnborg, Corneil &amp; Proskurowski (1987)</link>.</entry>
<entry id="4">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFBodlaender1996%22])">
Bodlaender (1996)</link>.</entry>
<entry id="5">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFBodlaender1998%22])">
Bodlaender (1998)</link>.</entry>
<entry id="6">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFRobertsonSeymour1986%22])">
Robertson &amp; Seymour (1986)</link>.</entry>
<entry id="7">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFThorup1998%22])">
Thorup (1998)</link>.</entry>
<entry id="8">
<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFArnborgProskurowski1989%22])">
Arnborg &amp; Proskurowski (1989)</link>; <link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFBernLawlerWong1987%22])">
Bern, Lawler &amp; Wong (1987)</link>; <link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFBodlaender1988%22])">
Bodlaender (1988)</link>.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFArnborgCorneilProskurowski1987" style="font-style:normal">Arnborg, S.; Corneil, D.&#32;&amp;&#32;Proskurowski, A.&#32;(1987),&#32;"Complexity of finding embeddings in a k-tree",&#32;<it>SIAM Journal on Matrix Analysis and Applications</it>&#32;<b>8</b>(2):  277–284, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137%2F0608024">
10.1137/0608024</weblink></cite>&nbsp;. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFArnborgProskurowski1989" style="font-style:normal">Arnborg, S.&#32;&amp;&#32;Proskurowski, A.&#32;(1989),&#32;"Linear time algorithms for NP-hard problems restricted to partial k-trees",&#32;<it>Discrete Applied Mathematics</it>&#32;<b>23</b>(1):  11–24, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0166-218X%2889%2990031-0">
10.1016/0166-218X(89)90031-0</weblink></cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFBernLawlerWong1987" style="font-style:normal">Bern, M. W.; Lawler, E. L.&#32;&amp;&#32;Wong, A. L.&#32;(1987),&#32;"Linear-time computation of optimal subgraphs of decomposable graphs",&#32;<it>Journal of Algorithms</it>&#32;<b>8</b>(2):  216–235, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0196-6774%2887%2990039-3">
10.1016/0196-6774(87)90039-3</weblink></cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFBodlaender1988" style="font-style:normal">Bodlaender, Hans L.&#32;(1988),&#32;"Dynamic programming on graphs of bounded treewidth",&#32;<it>Proc. 15th International Colloquium on Automata, Languages and Programming</it>, Lecture Notes in Computer Science, <b>317</b>, Springer-Verlag, pp. 105–118</cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFBodlaender1996" style="font-style:normal">Bodlaender, Hans L.&#32;(1996),&#32;"A linear time algorithm for finding tree-decompositions of small treewidth",&#32;<it>SIAM Journal on Computing</it>&#32;<b>25</b>(6):  1305–1317, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137%2FS0097539793251219">
10.1137/S0097539793251219</weblink></cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFBodlaender1998" style="font-style:normal">Bodlaender, Hans L.&#32;(1998),&#32;"A partial k-arboretum of graphs with bounded treewidth",&#32;<it>Theoretical Computer Science</it>&#32;<b>209</b>(1–2):  1–45, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2FS0304-3975%2897%2900228-4">
10.1016/S0304-3975(97)00228-4</weblink></cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFDiestel" style="font-style:normal">Diestel, Reinhard,&#32;<it><weblink xlink:type="simple" xlink:href="http://www.math.uni-hamburg.de/home/diestel/books/graph.theory/GraphTheoryIII.pdf">
Graph Theory</weblink></it>, </cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFRobertsonSeymour1984" style="font-style:normal"><link>
Robertson, Neil</link>&#32;&amp;&#32;<link>
Seymour, Paul D.</link>&#32;(1984),&#32;"Graph minors III: Planar tree-width",&#32;<it>Journal of Combinatorial Theory, Series B</it>&#32;<b>36</b>:  49–64</cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFRobertsonSeymour1986" style="font-style:normal"><link>
Robertson, Neil</link>&#32;&amp;&#32;<link>
Seymour, Paul D.</link>&#32;(1986),&#32;"Graph minors V: Excluding a planar graph",&#32;<it>Journal of Combinatorial Theory, Series B</it>&#32;<b>41</b>(1):  92–114, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0095-8956%2886%2990030-4">
10.1016/0095-8956(86)90030-4</weblink></cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFSeymourThomas" style="font-style:normal"><link>
Seymour, Paul D.</link>&#32;&amp;&#32;Thomas, Robin,&#32;"Graph Searching and a Min-Max Theorem for Tree-Width.",&#32;<it>Journal of Combinatorial Theory, Series B</it>&#32;<b>58</b>(1):  22–33, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1006%2Fjctb.1993.1027">
10.1006/jctb.1993.1027</weblink></cite>&nbsp;.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFThorup1998" style="font-style:normal">Thorup, Mikkel&#32;(1998),&#32;"All structured programs have small tree width and good register allocation",&#32;<it>Information and Computation</it>&#32;<b>142</b>(2):  159–181, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1006%2Finco.1997.2697">
10.1006/inco.1997.2697</weblink></cite>&nbsp;.</entry>
</list>
</p>


</sec>
</bdy>
</action>
</state>
</operation>
</article>
