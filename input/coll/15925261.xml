<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 03:30:50[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Fingerprint (computing)</title>
<id>15925261</id>
<revision>
<id>242396065</id>
<timestamp>2008-10-02T01:53:01Z</timestamp>
<contributor>
<username>Jorge Stolfi</username>
<id>48742</id>
</contributor>
</revision>
<categories>
<category>Identifiers</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>fingerprinting algorithm</b> is a procedure that maps an arbitrarily large <link xlink:type="simple" xlink:href="../040/18985040.xml">
data</link> item (such as a computer <link xlink:type="simple" xlink:href="../077/7077.xml">
file</link>) to a much shorter <link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link> string, its <b>fingerprint</b>, that uniquely identifies the original data for all practical purposes
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.  <p>

Fingerprints are typically used to avoid the comparison and transmission of bulky data.  For instance, a <link xlink:type="simple" xlink:href="../173/33173.xml">
web browser</link> or <link xlink:type="simple" xlink:href="../768/78768.xml">
proxy server</link> can efficiently check whether a remote file has been modified, by fetching only its fingerprint and comparing it with that of the previously fetched copy
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>  </p>
<p>

Fingerprint functions are related to (and sometimes confused with) <link xlink:type="simple" xlink:href="../538/7538.xml">
checksum</link>s, <link xlink:type="simple" xlink:href="../790/13790.xml">
hash function</link>s, <link xlink:type="simple" xlink:href="../526/439526.xml">
cryptographic hash function</link>s, and <link xlink:type="simple" xlink:href="../644/59644.xml">
digital signatures</link>.  While these concepts overlap to some extent, each has distinct uses and properties.  For example, <link xlink:type="simple" xlink:href="../533/1841533.xml">
audio fingerprint</link> algorithms are more properly called hash functions than fingerprints, since they are designed with different goals.</p>

<sec>
<st>
Fingerprint properties</st>

<ss1>
<st>
Virtual uniqueness</st>
<p>

To serve its intended purposes, a fingerprinting algorithm must be able to capture the identity of a file with virtual certainty.  In other words, the probability of a collision --- two files yielding the same fingerprint --- must be negligible, compared to the probability of other unavoidable causes of fatal errors (such as the system being destroyed by <link xlink:type="simple" xlink:href="../158/33158.xml">
war</link> or by a <link xlink:type="simple" xlink:href="../937/19937.xml">
meteorite</link>): say, 10-20 or less. </p>
<p>

This requirement is somewhat similar to that of a checksum function, but is much more stringent.  To detect accidental data corruption or transmission errors, it is sufficient that the checksums of the original file and any corrupted version will differ with near certainty, given some statistical model for the errors.  In typical situations, this goal is easily achieved with 16- or 32-bit checksums.  In contrast, file fingerprints need to be at least 64-bit long to guarantee virtual uniqueness in large file systems (see <link xlink:type="simple" xlink:href="../369/189369.xml">
birthday attack</link>).</p>
<p>

When proving the above requirement, one must take into account that files are generated by highly non-random processes that create complicated dependencies among files.  For instance, in a typical business network, one usually finds many pairs or clusters of documents that differ only by minor edits or other slight modifications.  A good fingerprinting algorithm must ensure that such "natural" processes generate distinct fingerprints, with the desired level of certainty.</p>

</ss1>
<ss1>
<st>
Compounding</st>
<p>

Computer files are often combined in various ways, such as concatenation (as in <link xlink:type="simple" xlink:href="../677/2332677.xml">
archive file</link>s) or symbolic inclusion (as with the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../835/231835.xml">
C preprocessor</link></language>
's #include directive).  Some fingerprinting algorithms allow the fingerprint of a composite file to be computed from the fingerprints of its constituent parts.  This "compounding" property may be useful in some applications, such as detecting when a program needs to be recompiled.</p>

</ss1>
</sec>
<sec>
<st>
Fingerprinting algorithms</st>

<ss1>
<st>
Rabin's algorithm</st>
<p>

<link xlink:type="simple" xlink:href="../488/9209488.xml">
Rabin's fingerprinting algorithm</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> is the prototype of the class.  It is fast and easy to implement, allows compounding, and comes with a mathematically precise analysis of the probability of collision.  Namely, the probability of two strings <it>r</it> and <it>s</it> yielding the same <it>w</it>-bit fingerprint does not exceed max(|<it>r</it>|,|<it>s</it>|)/2<it>w</it>-1, where |<it>r</it>| denotes the length of <it>r</it> in bits.  The algorithm requires the previous choice of a <it>w</it>-bit internal "key", and this guarantee holds as long as the strings <it>r</it> and <it>s</it> are chosen without knowledge of the key.</p>
<p>

Rabin's method is not secure against malicious attacks.  An adversary agent can easily discover the key and use it to modify files without changing their fingerprint.</p>

</ss1>
<ss1>
<st>
Cryptographic hash functions</st>
<p>

Cryptographic grade hash functions generally serve as good fingerprint functions, with the advantage that they are believed to be safe against malicious attacks.</p>
<p>

However, cryptographic hash algorithms such as <function wordnetid="113783816" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../826/18826.xml">
MD5</link></function>
 and <link xlink:type="simple" xlink:href="../672/26672.xml">
SHA</link> are considerably more expensive than Rabin's fingerprints, and lack proven guarantees on the probability of collision.  Some of them, notably <function wordnetid="113783816" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../826/18826.xml">
MD5</link></function>
 are no longer recommended for secure fingerprinting. However they still may be useful as an error checking mechanism, where purposeful data tampering isn't a primary concern.</p>

</ss1>
</sec>
<sec>
<st>
Application examples</st>
<p>

<link xlink:type="simple" xlink:href="../888/21888.xml">
NIST</link> distributes a software reference library, the American <link xlink:type="simple" xlink:href="../506/1411506.xml">
National Software Reference Library</link>, that uses cryptographic hash functions to fingerprint files and map them to software products.  The <link xlink:type="simple" xlink:href="../816/6114816.xml">
HashKeeper</link> database, maintained by the <administrative_unit wordnetid="108077292" confidence="0.8">
<agency wordnetid="108337324" confidence="0.8">
<link xlink:type="simple" xlink:href="../013/1712013.xml">
National Drug Intelligence Center</link></agency>
</administrative_unit>
, is a repository of fingerprints of "known to be good" and "known to be bad" computer files, for use in law enforcement applications (e.g. analyzing the contents of seized disk drives).</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../375/10375.xml">
Error correcting code</link></entry>
<entry level="1" type="bullet">

 <link>
Randomizing function</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
A. Z. Broder. Some applications of Rabin's fingerprinting method. In Sequences II: Methods in Communications, Security, and Computer Science, pages 143--152. Springer-Verlag, 1993</entry>
<entry id="2">
Detecting duplicate and near-duplicate files. US Patent 6658423 Issued on <link xlink:type="simple" xlink:href="../356/8356.xml">
December 2</link> <link xlink:type="simple" xlink:href="../163/36163.xml">
2003</link></entry>
<entry id="3">
A. Z. Broder, "On the Resemblance and Containment of Documents," Proceedings of Compression and Complexity of Sequences 1997, pp. 21-27, IEEE Computer Society (1988)</entry>
<entry id="4">
S. Brin et al., "Copy Detection Mechanisms for Digital Documents," Proceedings of the ACM SIGMOD Annual Conference, San Jose 1995 (May 1995)</entry>
<entry id="5">
L. Fan, P. Cao, J. Almeida and A. Broder, Summary Cache: A Scalable Wide-Area Web Cache Sharing Protocol, IEEE/ACM Transactions on Networking, vol. 8, No. 3 (2000)</entry>
<entry id="6">
 U. Manber, Finding Similar Files in a Large File System. Proceedings of the USENIX Winter Technical Conf. (1994)</entry>
<entry id="7">
M. O. Rabin Fingerprinting by random polynomials. Center for Research in Computing Technology Harvard University Report TR-15-81 (1981)</entry>
</reflist>
</p>

</sec>
</bdy>
</article>
