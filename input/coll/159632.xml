<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:21:25[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<protocol  confidence="0.8" wordnetid="106665108">
<event  confidence="0.8" wordnetid="100029378">
<direction  confidence="0.8" wordnetid="106786629">
<rule  confidence="0.8" wordnetid="106652242">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Link-state routing protocol</title>
<id>159632</id>
<revision>
<id>242828679</id>
<timestamp>2008-10-03T20:58:49Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Routing protocols</category>
<category>Routing algorithms</category>
</categories>
</header>
<bdy>

A <b>link-state routing protocol</b> is one of the two main classes of <link xlink:type="simple" xlink:href="../059/10123059.xml">
routing protocol</link>s used in <link xlink:type="simple" xlink:href="../339/43339.xml">
packet-switched network</link>s for <link xlink:type="simple" xlink:href="../652/5652.xml">
computer communication</link>s.  Examples of link-state routing protocols include <link xlink:type="simple" xlink:href="../388/43388.xml">
OSPF</link> and <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/39219.xml">
IS-IS</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
.<p>

The link-state protocol is performed by every <it>switching node</it> in the network (i.e. nodes which are prepared to forward packets; in the <link xlink:type="simple" xlink:href="../539/14539.xml">
Internet</link>, these are called <link xlink:type="simple" xlink:href="../748/25748.xml">
router</link>s). The basic concept of link-state routing is that every node constructs a <it>map</it> of the connectivity of the network, in the form of a <link xlink:type="simple" xlink:href="../401/12401.xml">
graph</link> showing which nodes are connected to which other nodes.</p>
<p>

The link-state routing requires each switching node in the network to send its information about its neighbors to the entire internetwork.</p>
<p>

Each node then independently calculates the best <it>next hop</it> from it for every possible destination in the network. (It does this using only its local copy of the map, and without communicating in any other way with any other node.) The collection of best next hops forms the <link xlink:type="simple" xlink:href="../043/48043.xml">
routing table</link> for the node.</p>
<p>

This contrasts with <link xlink:type="simple" xlink:href="../228/159228.xml">
distance-vector routing protocol</link>s, which work by having each node share its <b>routing table</b> with its neighbors. In a link-state protocol, the only information passed between the nodes is information used to construct the connectivity maps.</p>

<sec>
<st>
History</st>

<p>

The first Link-state routing was invented in <link xlink:type="simple" xlink:href="../753/34753.xml">
1978</link> by John McQuillan (then at <link xlink:type="simple" xlink:href="../539/252539.xml">
Bolt, Beranek and Newman</link>) as a mechanism that would calculate routes more quickly when network conditions changed, and thus lead to more stable routing.</p>
<p>

Later work at BBN showed how to use the link-state technique in a hierarchical system, i.e. one in which the network was divided into areas, so that each switching node does not need a map of the entire network, only the area(s) in which it is included.</p>
<p>

The technique was later adapted for use in the contemporary link-state routing protocols <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/39219.xml">
IS-IS</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 and <link xlink:type="simple" xlink:href="../388/43388.xml">
OSPF</link>.  Cisco's <link xlink:type="simple" xlink:href="../544/51544.xml">
EIGRP</link> shares characteristics with Link-state routing, specifically it doesn't flood its entire routing table with to its neighbors, but is built on the IGRP <link xlink:type="simple" xlink:href="../228/159228.xml">
distance-vector routing protocol</link>.  This functionality is referred to as "hybrid" in Cisco and third party literature.  </p>
<p>

More recently, this hierarchical technique was applied to <link xlink:type="simple" xlink:href="../497/713497.xml">
wireless mesh network</link>s using the <link xlink:type="simple" xlink:href="../183/976183.xml">
optimized link state routing protocol</link>.
Where a connection can have varying quality, the quality of a connection can be used to select better connections. This is used in some <link xlink:type="simple" xlink:href="../563/142563.xml">
routing protocols</link> that use radios.</p>

</sec>
<sec>
<st>
Distributing maps</st>

<p>

This description covers only the simplest configuration; i.e. one with no areas, so that all nodes do have a map of the entire network. The hierarchical case is somewhat more complex; see the various protocol specifications.</p>
<p>

As previously mentioned, the first main stage in the link-state algorithm is to give a map of the network to every node. This is done with several simple subsidiary steps.</p>

<ss1>
<st>
Determining the neighbors of each node</st>

<p>

First, each node needs to determine what other ports it is connected to, over fully-working links; it does this using a simple <it>reachability protocol</it> which it runs separately with each of its directly-connected neighbors.</p>

</ss1>
<ss1>
<st>
Distributing the information for the map</st>

<p>

Next, each node periodically makes up a short message, the <it>link-state advertisement</it>, which:</p>
<p>

<list>
<entry level="1" type="bullet">

 Identifies the node which is producing it.</entry>
<entry level="1" type="bullet">

 Identifies all the other nodes to which it is directly connected.</entry>
<entry level="1" type="bullet">

 Includes a <it>sequence number</it>, which increases every time the source node makes up a new version of the message.</entry>
</list>
</p>
<p>

This message is then <it>flooded</it> throughout the network. As a necessary precursor, each node in the network remembers, for every other node in the network, the sequence number of the last link-state message which it received from that node. With that in hand, the method used is simple.</p>
<p>

Starting with the node which originally produced the message, it sends a copy to all of its neighbors. When a link-state advertisement is received at a node, the node looks up the sequence number it has stored for the source of that link-state message. If this message is newer (i.e. has a higher sequence number), it is saved, and a copy is sent in turn to each of that node's neighbors.</p>
<p>

This procedure rapidly gets a copy of the latest version of each node's link-state advertisement to every node in the network.</p>

</ss1>
<ss1>
<st>
Creating the map  </st>
<p>

Finally, with the complete set of link-state advertisements (one from each node in the network) in hand, it is obviously easy to produce the graph for the map of the network.</p>
<p>

The algorithm simply iterates over the collection of link-state advertisements; for each one, it makes links on the map of the network, from the node which sent that message, to all the nodes which that message indicates are neighbors of the sending node.</p>
<p>

No link is considered to have been correctly reported unless the two ends agree; i.e. if one node reports that it is connected to another, but the other node does not report that it is connected to the first, there is a problem, and the link is not included on the map.</p>

</ss1>
<ss1>
<st>
Notes about this stage</st>

<p>

The link-state message giving information about the neighbors is recomputed, and then flooded throughout the network, whenever there is a change in the connectivity between the node and its neighbors, e.g. when a link fails. Any such change will be detected by the reachability protocol which each node runs with its neighbors.</p>

</ss1>
</sec>
<sec>
<st>
Calculating the routing table</st>

<p>

As initially mentioned, the second main stage in the link-state algorithm is to produce routing tables, by inspecting the maps. This is again done with several steps.</p>

<ss1>
<st>
Calculating the shortest paths</st>

<p>

Each node independently runs an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> over the map to determine the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link>
shortest path</link></difficulty>
</problem>
</state>
</condition>
 from itself to every other node in the network; generally some variant of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is used.</p>
<p>

Basically, a node maintains two data structures: a <link xlink:type="simple" xlink:href="../806/30806.xml">
tree</link> containing nodes which are "done", and a list of <it>candidates</it>. The algorithm starts with both structures empty; it then adds to the first one the node itself. The algorithm then repetitively:</p>
<p>

<list>
<entry level="1" type="bullet">

 Adds to the second (candidate) list all nodes which are connected to the node just added to the tree (excepting of course any nodes which are already in either the tree or the candidate list).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Of the nodes in the candidate list, moves to the tree (attaching it to the appropriate neighbor node already there) the one which is the closest to any of the nodes already in the tree.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Repeat as long as there are any nodes left in the candidate list. (When there are none, all the nodes in the network will have been added to the tree.)</entry>
</list>
</p>
<p>

This procedure ends with the tree containing all the nodes in the network, with the node on which the algorithm is running as the <it>root</it> of the tree. The shortest path from that node to any other node is indicated by the list of nodes one traverses to get from the root of the tree, to the desired node in the tree.</p>

</ss1>
<ss1>
<st>
Filling the routing table</st>

<p>

With the shortest paths in hand, filling in the routing table is trivial.</p>
<p>

For any given destination node, the best next hop for that destination is the node which is the first step from the root node, down the branch in the shortest-path tree which leads toward the desired destination node.</p>
<p>

To create the routing table, it is only necessary to walk the tree, remembering the identity of the node at the head of each branch, and filling in the routing table entry for each node one comes across with that identity.</p>
<p>

In a link state algorithm, routers regularly exchange link state messages – sometimes known as HELLO PACKETS – with their neighbors. These messages are small and consume little bandwidth. Routers ‘learn’ who their neighboring routers are. Routing updates are sent to all known routers- by unicast rather than broadcast. Although the algorithm is not as straightforward as in the distance-vector case, if a router ‘knows’ its neighboring routers and then gets to learn about their neighboring routers, it will learn about the existence of all the routers.</p>
<p>

Routing updates are sent only when there is a change in topology- except for infrequent periodic updates. Networks running link state algorithms can also be segmented into hierarchies which limit the scope of route changes. These features mean that link state algorithms scale better to larger networks.</p>
<p>

Link state algorithms are sometimes characterized by the phrase ‘Each router tells the world about its neighbors’.</p>

</ss1>
<ss1>
<st>
Optimizations to the algorithm</st>

<p>

The algorithm described above was made as simple as possible, to aid in ease of understanding. In practice, there are a number of optimizations which are used.</p>
<p>

Most importantly, whenever a change in the connectivity map happens, it is necessary to recompute the shortest-path tree, and then recreate the routing table. The BBN work discovered how to recompute only that part of the tree which could have been affected by a given change in the map.</p>
<p>

Also, the routing table would normally be filled in as the shortest-path tree is computed, instead of making it a separate operation.</p>

</ss1>
</sec>
<sec>
<st>
Failure modes</st>

<p>

If all the nodes are not working from <b>exactly</b> the same map, <it>routing loops</it> can form. (These are situations in which, in the simplest form, two neighboring nodes each think the other is the best next hop to a given destination. Any packet headed to that destination arriving at either node will loop between the two, hence the name. Routing loops involving more than two nodes are also possible.)</p>
<p>

The reason is fairly simple: since each node computes its shortest-path tree and its routing table without interacting in any way with any other nodes, then if two nodes start with different maps, it is easy to have scenarios in which routing loops are created.</p>

</sec>
<sec>
<st>
Advantages and disadvantages of link-state routing</st>

<p>

See <link xlink:type="simple" xlink:href="../750/25750.xml#xpointer(//*[./st=%22Comparison_of_routing_algorithms%22])">
Comparison of routing algorithms</link>.</p>

</sec>
<sec>
<st>
References</st>
<p>
   
<list>
<entry level="1" type="bullet">

 John M. McQuillan, Isaac Richer and Eric C. Rosen, <it>ARPANet Routing Algorithm Improvements</it>, BBN Report No. 3803, Cambridge, April 1978   </entry>
<entry level="1" type="bullet">

 John M. McQuillan, Isaac Richer and Eric C. Rosen, <it>The New Routing Algorithm for the ARPANet</it>, <link xlink:type="simple" xlink:href="../938/56938.xml">
IEEE</link> Trans. on Comm., 28(5), pp. 711-719, 1980   </entry>
<entry level="1" type="bullet">

 Josh Seeger and Atul Khanna, <it>Reducing Routing Overhead in a Growing DDN</it>, MILCOMM '86, IEEE, 1986  </entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</rule>
</direction>
</event>
</protocol>
</message>
</article>
