<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:22:51[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Interactive proof system</title>
<id>160255</id>
<revision>
<id>234756663</id>
<timestamp>2008-08-28T10:37:13Z</timestamp>
<contributor>
<username>SpBot</username>
<id>7016748</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, an <b>interactive proof system</b> is an <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link> that models <link xlink:type="simple" xlink:href="../926/5926.xml">
computation</link> as the exchange of messages between two parties. The parties, the verifier and the prover, interact by exchanging messages in order to ascertain whether a given string belongs to a <link xlink:type="simple" xlink:href="../939/10939.xml">
language</link> or not. The prover is all-powerful, with unlimited computational resources while the verifier has bounded computation power. Messages are sent between the verifier and prover until the verifier has an answer to the problem and has "convinced" itself that it is correct.<p>

All interactive proof systems have two requirements:
<list>
<entry level="1" type="bullet">

 <b>Completeness</b>: if the statement is true, the honest verifier (that is, one following the protocol properly) will be convinced of this fact by an honest prover.</entry>
<entry level="1" type="bullet">

 <b>Soundness</b>: if the statement is false, no prover, even if it doesn't follow the protocol, can convince the honest verifier that it is true, except with some small probability.</entry>
</list>
</p>
<p>

Notice that we don't care what happens if the verifier is dishonest; we trust the verifier.</p>
<p>

The specific nature of the system, and so the <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link> of languages it can recognize, depends on what sort of bounds are put on the verifier, as well as what abilities it is given &mdash; for example, most interactive proof systems depend critically on the verifier's ability to make random choices. It also depends on the nature of the messages exchanged &mdash; how many and what they can contain. Interactive proof systems have been found to have some surprisingly profound implications for traditional complexity classes defined using only one machine. The main complexity classes (really, hierarchies of complexity classes) defined using interactive proof systems are <b><link xlink:type="simple" xlink:href="../203/663203.xml">
AM</link></b>, <b><link xlink:type="simple" xlink:href="../203/663203.xml">
MA</link></b>, <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP</link></group>
</collection>
</class>
</b>, and <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../509/504509.xml">
PCP</link></group>
</collection>
</class>
</b>. </p>

<sec>
<st>
 NP </st>

<p>

The familiar complexity class <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
 may be viewed as a very simple interactive proof system. In this system, the verifier is a deterministic, polynomial-time machine (a <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
 machine). The protocol is:
<list>
<entry level="1" type="bullet">

 The prover looks at the input and computes the solution using its unlimited power and returns a polynomial-size proof certificate.</entry>
<entry level="1" type="bullet">

 The verifier verifies that the certificate is valid in deterministic polynomial time. If it is valid, it accepts; otherwise, it rejects.</entry>
</list>
</p>
<p>

In the case where a valid proof certificate exists, the prover is always able to make the verifier accept by giving it that certificate. In the case where there is no valid proof certificate, however, the input is not in the language, and no prover, however malicious it is, can convince the verifier otherwise, because any proof certificate will be rejected.</p>

</sec>
<sec>
<st>
 Arthur-Merlin and Merlin-Arthur protocols </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../203/663203.xml">
Arthur-Merlin protocol</link></it>
</indent>
Although NP may be viewed as using interaction, it wasn't until 1985 that the concept of computation through interaction was conceived<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> It was then that <link>
László Babai</link> published "Trading group theory for randomness", a paper defining the <it>Arthur-Merlin</it> (<b>AM</b>) class hierarchy. In this presentation, Arthur (the verifier) is a <link xlink:type="simple" xlink:href="../812/197812.xml">
probabilistic</link>, polynomial-time machine, while Merlin (the prover) has unbounded resources.</p>
<p>

The class <b>MA</b> in particular is a simple generalization of the NP interaction above in which the verifier is probabilistic instead of deterministic. Also, instead of requiring that the verifier always accept valid certificates and reject invalid certificates, we are more lenient:
<list>
<entry level="1" type="bullet">

 <b>Completeness:</b> if the string is in the language, the prover must be able to give a certificate such that the verifier will accept with probability at least 2/3 (depending on the verifier's random choices).</entry>
<entry level="1" type="bullet">

 <b>Soundness:</b> if the string is not in the language, no prover, however malicious, will be able to convince the verifier to accept the string with probability exceeding 1/3.</entry>
</list>
</p>
<p>

This machine is potentially more powerful than an ordinary NP interaction protocol, and the certificates are no less practical to verify, since <b>BPP</b> algorithms are practical (see <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
). We'll come back to Babai's other classes later.</p>

</sec>
<sec>
<st>
 Public coins versus private coins </st>

<p>

Shortly after Babai defined his proof system for <b>MA</b>, Shafi Goldwasser et al. published a draft of a paper defining the interactive proof system <b>IP</b>[''f''(''n'')]. This has the same machines as the <b>MA</b> protocol, except that <it>f</it>(<it>n</it>) <it>rounds</it> are allowed for an input of size <it>n</it>. In each round, the verifier performs computation and passes a message to the prover, and the prover performs computation and passes information back to the verifier. At the end the verifier must make its decision. For example, in an <b>IP</b>[3] protocol, the sequence would be VPVPVPV, where V is a verifier turn and P is a prover turn.</p>
<p>

In Arthur-Merlin protocols, Babai defined a similar class <b>AM</b>[''f''(''n'')] which allowed <it>f</it>(<it>n</it>) rounds, but he put one extra condition on the machine: the verifier must show the prover all the random bits it uses in its computation. The result is that the verifier cannot "hide" anything from the prover, because the prover is powerful enough to simulate everything the verifier does if it knows what random bits it used. We call this a <it>public coin</it> protocol, because the random bits ("coin flips") are visible to both machines. The <b>IP</b> approach is called a <it>private coin</it> protocol by contrast.</p>
<p>

The essential problem with public coins is this: if the prover wishes to maliciously convince the verifier to accept a string which is not in the language, it seems like the verifier might be able to thwart its plans if it can hide its internal state from it. This was a primary motivation in defining the <b>IP</b> proof systems.</p>
<p>

In 1986, Goldwasser and Sipser showed a surprising result: the verifier's ability to hide coin flips from the prover does it little good after all, in that an Arthur-Merlin public coin protocol with only two more rounds can recognize all the same languages. The result is that public-coin and private-coin protocols are roughly equivalent.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>  In fact, as Babai shows in 1988, <b>AM</b>[''k'']=<b>AM</b> for all constant <it>k</it>, so the <b>IP</b>[''k''] have no advantage over <b>AM</b>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</sec>
<sec>
<st>
 IP </st>

<p>

<indent level="1">

<it>Main article: <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP (complexity)</link></group>
</collection>
</class>
</it>
</indent>
Private coins may not be helpful, but more turns are: if we allow the probabilistic verifier machine and the all-powerful prover to interact for a polynomial number of rounds, we can solve the class of problems <b>IP</b>.</p>
<p>

To demonstrate the power of the class IP, consider the <link>
graph isomorphism problem</link>, the problem of determining whether it is possible to permute the vertices of one graph so that it is identical to another graph. This problem is in <b>NP</b>, since the proof certificate is the permutation which makes the graphs equal. Of course this problem is in <b>IP</b>, since  <b>NP</b> is even contained in <b>MA</b>. Much more surprising was <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../314/57314.xml">
Adi Shamir</link></scientist>
</person>
's discovery of an <b>IP</b> algorithm to solve the <link xlink:type="simple" xlink:href="../955/1929955.xml">
complement</link> of the graph isomorphism problem, a co-<b>NP</b> problem not known or believed to be in <b>NP</b>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>
<p>

Not only can such a machine solve many problems not believed to be in <b>NP</b>, but under practical assumptions about the existence of <link xlink:type="simple" xlink:href="../890/363890.xml">
one-way function</link>s, it is able to determine whether many problems have solutions without ever giving the verifier information about the solution. These are important when the verifier cannot be trusted with the full solution.  At first it seems impossible that the verifier could be convinced that there is a solution when it has not seen it, but these so-called <link xlink:type="simple" xlink:href="../541/450541.xml">
zero-knowledge proof</link>s are in fact believed to exist for all problems in <b>NP</b> and are valuable in <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>. Zero-knowledge proofs were invented in the original paper on <b>IP</b> by Goldwasser et al., but the extent of their power was shown by Oded Goldreich.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>
<p>

So many problems seemed to topple before this powerful machine that an effort was made to establish just how much it could do. In 1992, Adi Shamir revealed in one of the central results of complexity theory that in fact, <b>IP</b> = <b><mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
</b>, the class of problems solvable by an ordinary <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link> in polynomial space.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> This strong relationship between a probabilistic interactive protocol and a classical deterministic space-bounded machine gave a concept of the power and the limitations of interactive proof systems and established valuable ties between the two subfields. See <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP</link></group>
</collection>
</class>
 for details.</p>

</sec>
<sec>
<st>
 MIP </st>

<p>

One goal of <b>IP</b>'s designers was to create the most powerful possible interactive proof system, and at first it seems like it cannot be made more powerful without making the verifier more powerful and so impractical. Goldwasser et al. overcame this in their 1988 "Multi prover interactive proofs[...]", which defines a new version of <b>IP</b> called <b>MIP</b> in which there are <it>two</it> independent provers.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>
<p>

The two provers cannot communicate once the verifier has begun sending messages to them. Just as it's easier to tell if a criminal is lying if he and his partner are interrogated in separate rooms, it's considerably easier to detect a malicious prover trying to trick the verifier into accepting a string not in the language if there is another prover it can double-check with.</p>
<p>

In fact, this is so helpful that Babai, Fortnow, and Lund were able to show a result as astonishing as <b>IP</b> = <b>PSPACE</b>: that <b>MIP</b> = <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../657/663657.xml">
NEXPTIME</link></group>
</collection>
</class>
</b>, the class of all problems solvable by a <link>
nondeterministic</link> machine in <it>exponential time</it>, a very large class.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> Adding a constant number of additional provers beyond two does not enable recognition of any more languages. This result would prove an inspiration to the designer of <b>PCP</b>, described next, who sought a "scaled-down" version that would relate an interactive proof system to <b>NP</b>.</p>
<p>

<b>MIP</b> also has the helpful property that zero-knowledge proofs for every language in <b>NP</b> can be described without the assumption of one-way functions that <b>IP</b> must make. This has bearing on the design of provably unbreakable cryptographic algorithms.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> Moreover, a <b>MIP</b> protocol can recognize all languages in <b>IP</b> in only a constant number of rounds, and if a third prover is added, it can recognize all languages in <b>NEXPTIME</b> in a constant number of rounds, showing again its power over <b>IP</b>.</p>

</sec>
<sec>
<st>
 PCP </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../509/504509.xml">
Probabilistically checkable proof</link></it>
</indent>
While the designers of <b>IP</b> considered generalizations of Babai's interactive proof systems, others considered restrictions. Perhaps the most useful of these was <b>PCP</b>(<it>f</it>(<it>n</it>), <it>g</it>(<it>n</it>)), which is a restriction of <b>MA</b> where Arthur can only use <it>f</it>(<it>n</it>) random bits and can only examine <it>g</it>(<it>n</it>) bits of the proof certificate sent by Merlin (essentially using <link xlink:type="simple" xlink:href="../612/25612.xml">
random access</link>). Designed by Sanjeev Arora and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../029/15875029.xml">
Shmuel Safra</link></scientist>
, the insight behind <b>PCP</b> is the idea that we can trade off full knowledge of the proof string for randomness without losing too much power.</p>
<p>

There are a number of easy-to-prove results about various <b>PCP</b> classes. <b>PCP</b>(0,<it>poly</it>) (no randomness) is just <b>NP</b>, and <b>PCP</b>(<it>poly</it>,0) (no looking at the proof) is just <b>co-<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../771/54771.xml">
RP</link></group>
</collection>
</class>
</b>. Arora and Safra's first major result was that <b>PCP</b>(<it>log</it>, <it>log</it>) = <b>NP</b>; put another way, if you take the verifier in the <b>NP</b> protocol and tell it that it can only choose <it>log n</it> bits of the proof certificate to look at, this won't make any difference as long as you also give it <it>log n</it> random bits to use.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></p>
<p>

But there's more: although Arora and Safra knew they could not asymptotically lower both the number of random bits and the number of accesses, they believed they could lower <it>one</it> of them. Arora et al. eventually managed to show the <link xlink:type="simple" xlink:href="../241/3001241.xml">
PCP theorem</link>, another major complexity theory result asserting that the number of proof accesses could be brought all the way down to a constant. That is, <b>NP</b> = <b>PCP</b>(<it>log</it>, O(1)).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> They used this valuable characterization of <b>NP</b> to prove that <link xlink:type="simple" xlink:href="../105/563105.xml">
approximation algorithm</link>s do not exist for the optimization versions of certain <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 problems unless <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../115/6115.xml">
P = NP</link></group>
</collection>
</difficulty>
</problem>
</class>
</state>
</condition>
.</p>

</sec>
<sec>
<st>
 References </st>


<p>

<reflist>
<entry id="1">
László Babai. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=22192">
Trading group theory for randomness</weblink>. <it>Proceedings of the Seventeenth Annual Symposium on the Theory of Computing</it>, ACM. 1985.</entry>
<entry id="2">
 Shafi Goldwasser, Silvio Micali, and Charles Rackoff. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=63434">
The Knowledge complexity of interactive proof-systems</weblink>. <it>Proceedings of 17th Symposium on the Theory of Computation</it>, Providence, Rhode Island. 1985. <weblink xlink:type="simple" xlink:href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1985-stoc.pdf">
Extended abstract</weblink></entry>
<entry id="3">
 László Babai and Shlomo Moran. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=49987">
Arthur-Merlin games: a randomized proof system, and a hierarchy of complexity classes</weblink>. <it>Journal of Computer and System Sciences</it>, 36: p.254-276. 1988.</entry>
<entry id="4">
 Shafi Goldwasser and Michael Sipser. <weblink xlink:type="simple" xlink:href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1986-stoc.pdf">
Private coins versus public coins in interactive proof systems</weblink>. <it>Proceedings of ACM STOC'86</it>, p.58-68. 1986.</entry>
<entry id="5">
O. Goldreich, S. Micali, A. Wigderson. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=116852">
Proofs that yield nothing but their validity</weblink>. <it>Journal of the ACM</it>, volume 38, issue 3, p.690-728. July 1991.</entry>
<entry id="6">
 Adi Shamir. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=146585.146609">
IP = PSPACE</weblink>. <it>Journal of the ACM</it>, volume 39, issue 4, p.869-877. October 1992.</entry>
<entry id="7">
 M. Ben-or, Shafi Goldwasser, J. Kilian, and A. Wigderson. <weblink xlink:type="simple" xlink:href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1988-stoc-bgkw.pdf">
Multi prover interactive proofs: How to remove intractability assumptions</weblink>. <it>Proceedings of the 20th ACM Symposium on Theory of Computing</it>, p.113-121. 1988.</entry>
<entry id="8">
 László Babai, L. Fortnow, and C. Lund. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/15039.html">
Non-deterministic exponential time has two-prover interactive protocols</weblink>. <it>Computational Complexity</it>, volume 1, p.3-40. 1991.</entry>
<entry id="9">
 M. Ben-or, Shafi Goldwasser, J. Kilian, and A. Wigderson. <weblink xlink:type="simple" xlink:href="http://theory.lcs.mit.edu/~cis/pubs/shafi/1988-stoc-bgkw.pdf">
Multi prover interactive proofs: How to remove intractability assumptions</weblink>. <it>Proceedings of the 20th ACM Symposium on Theory of Computing</it>, p.113-121. 1988.</entry>
<entry id="10">
 Sanjeev Arora and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../029/15875029.xml">
Shmuel Safra</link></scientist>
. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/arora92probabilistic.html">
Probabilistic Checking of Proofs: A New Characterization of NP</weblink>. <it>Journal of the ACM</it>, volume 45, issue 1, p.70-122. January 1998.</entry>
<entry id="11">
 Sanjeev Arora, C. Lund, R. Motwani, M. Sudan, and M. Szegedy. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/376426.html">
Proof Verification and the Hardness of Approximation Problems</weblink>. Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science, p.13-22. 1992.</entry>
</reflist>
</p>

<ss1>
<st>
 Additional references </st>

<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Michael Sipser</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(1997). Introduction to the Theory of Computation.&#32;PWS Publishing. ISBN 0-534-94728-X.</cite>&nbsp; Section 10.4: Interactive Proof Systems, pp.354&ndash;366.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../428/3509428.xml">
Christos Papadimitriou</link></scholar>
</writer>
</causal_agent>
</academician>
</alumnus>
</laureate>
</communicator>
</associate>
</educator>
</recipient>
</professional>
</adult>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</peer>
</physical_entity>
&#32;(1993). Computational Complexity, 1st edition,&#32;Addison Wesley. ISBN 0-201-53082-1.</cite>&nbsp; Section 19.2: Games against nature and interactive protocols, pp.469&ndash;480.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 Dexter Kozen. <weblink xlink:type="simple" xlink:href="http://www.cs.cornell.edu/Courses/cs682/2004sp/Lectures/l15-ip.pdf">
Interactive Proofs</weblink>. CS682 Spring 2004 lecture notes. Department of Computer Science, Cornell University.</entry>
<entry level="1" type="bullet">

 Complexity Zoo:</entry>
<entry level="2" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#ma">
MA</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#maprime">
MA'</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#maexp">
MAEXP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#mae">
MAE</weblink></entry>
<entry level="2" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#am">
AM</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#amexp">
AMEXP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#amicoam">
AM intersect co-AM</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#ampolylog">
AM[polylog]</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#coam">
coAM</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#bpnp">
BP•NP</weblink></entry>
<entry level="2" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qma">
QMA</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qma+">
QMA+</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qma2">
QMA(2)</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qmalog">
QMAlog</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qmam">
QMAM</weblink></entry>
<entry level="2" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#ip">
IP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#mip">
MIP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#ipp">
IPP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qip">
QIP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#qip2">
QIP(2)</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#compip">
compIP</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#frip">
frIP</weblink></entry>
<entry level="2" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#pcp">
PCP(r(n),q(n))</weblink></entry>
<entry level="1" type="bullet">

 Larry Gonick. "<weblink xlink:type="simple" xlink:href="http://www.cs.uchicago.edu/groups/theory/merlin/">
Proof Positive?</weblink>". A comic strip about interactive proof systems.</entry>
</list>
</p>


</sec>
</bdy>
</article>
