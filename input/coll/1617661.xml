<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:44:46[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Booth&apos;s multiplication algorithm</title>
<id>1617661</id>
<revision>
<id>243809096</id>
<timestamp>2008-10-08T03:06:44Z</timestamp>
<contributor>
<username>Polbot</username>
<id>4477315</id>
</contributor>
</revision>
<categories>
<category>Multiplication</category>
<category>Computer arithmetic</category>
</categories>
</header>
<bdy>

<b>Booth's multiplication algorithm</b>  is a <link xlink:type="simple" xlink:href="../411/57411.xml">
multiplication algorithm</link> that multiplies two signed <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> numbers in <link xlink:type="simple" xlink:href="../145/307145.xml">
two's complement notation</link>.
<sec>
<st>
Procedure</st>

<p>

Booth's algorithm involves repeatedly adding one of two predetermined values <it>A</it> and <it>S</it> to a product <it>P</it>, then performing a rightward <link xlink:type="simple" xlink:href="../725/40725.xml">
arithmetic shift</link> on <it>P</it>.  Let <b>x</b> and <b>y</b> be the multiplicand and multiplier, respectively; and let <it>x</it> and <it>y</it> represent the number of bits in <b>x</b> and <b>y</b>.</p>
<p>

<list>
<entry level="1" type="number">

 Determine the values of <it>A</it> and <it>S</it>, and the initial value of <it>P</it>.  All of these numbers should have a length equal to (<it>x</it>&nbsp;+&nbsp;<it>y</it>&nbsp;+&nbsp;1).</entry>
<entry level="2" type="number">

 A: Fill the most significant (leftmost) bits with the value of <b>x</b>.  Fill the remaining (<it>y</it>&nbsp;+&nbsp;1) bits with zeros.</entry>
<entry level="2" type="number">

 S: Fill the most significant bits with the value of (&amp;minus;<b>x</b>) in two's complement notation.  Fill the remaining (<it>y</it>&nbsp;+&nbsp;1) bits with zeros.</entry>
<entry level="2" type="number">

 P: Fill the most significant <it>x</it> bits with zeros.  To the right of this, append the value of <b>y</b>.  Fill the least significant (rightmost) bit with a zero.</entry>
<entry level="1" type="number">

 Determine the two least significant (rightmost) bits of <it>P</it>.</entry>
<entry level="2" type="number">

 If they are 01, find the value of <it>P</it>&nbsp;+&nbsp;<it>A</it>.  Ignore any overflow.</entry>
<entry level="2" type="number">

 If they are 10, find the value of <it>P</it>&nbsp;+&nbsp;<it>S</it>.  Ignore any overflow.</entry>
<entry level="2" type="number">

 If they are 00 or 11, do nothing.  Use <it>P</it> directly in the next step.</entry>
<entry level="1" type="number">

 Calculate the bit which gets shifted-in using the formula Sin&nbsp;=&nbsp;msb(<it>Q</it>)&nbsp;^&nbsp;msb(<it>P</it>)&nbsp;^&nbsp;carry_out_of(<it>P</it>&nbsp;+&nbsp;<it>Q</it>), where <it>Q</it> represents <it>A</it>, <it>S</it>, or zero depending on what was added to <it>P</it>.</entry>
<entry level="1" type="number">

 <link xlink:type="simple" xlink:href="../725/40725.xml">
Arithmetically shift</link> the value obtained in the 2nd step by a single place to the right.  Let <it>P</it> now equal this new value. The value Sin calculated from the previous step is shifted in leftmost bit.</entry>
<entry level="1" type="number">

 Repeat steps 2 to 4 until they have been done <it>y</it> times.</entry>
<entry level="1" type="number">

 Drop the least significant (rightmost) bit from <it>P</it>.  This is the product of <b>x</b> and <b>y</b>.</entry>
</list>
</p>

</sec>
<sec>
<st>
Example</st>
<p>

Find 3 &amp;times; &amp;minus;4, with <b>x</b> = 3 and <b>y</b> = &amp;minus;4, and <it>x</it> = 4 and <it>y</it> = 4:</p>
<p>

<list>
<entry level="1" type="bullet">

 A = 0011 0000 0</entry>
<entry level="1" type="bullet">

 S = 1101 0000 0</entry>
<entry level="1" type="bullet">

 P = 0000 1100 0</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Perform the loop four times :</entry>
<entry level="2" type="number">

 P = 0000 110<b>0 0</b>.  The last two bits are 00.</entry>
<entry level="3" type="bullet">

 P = 0000 0110 0.  Arithmetic right shift.</entry>
<entry level="2" type="number">

 P = 0000 011<b>0 0</b>. The last two bits are 00.</entry>
<entry level="3" type="bullet">

 P = 0000 0011 0.  Arithmetic right shift.</entry>
<entry level="2" type="number">

 P = 0000 001<b>1 0</b>.  The last two bits are 10.</entry>
<entry level="3" type="bullet">

 P = 1101 0011 0.  P = P + S.</entry>
<entry level="3" type="bullet">

 P = 1110 1001 1.  Arithmetic right shift.</entry>
<entry level="2" type="number">

 P = 1110 100<b>1 1</b>.  The last two bits are 11.</entry>
<entry level="3" type="bullet">

 P = 1111 0100 1.  Arithmetic right shift.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 The product is 1111 0100, which is &amp;minus;12.</entry>
</list>
</p>
<p>

The above mentioned technique is inadequate when the multiplicand is the largest negative number that can be represented (i.e. if the multiplicand has 8 bits then this value is &amp;minus;128). One possible correction to this problem is to add one more bit to the left of A, S and P. Below, we demonstrate the improved technique by multiplying &amp;minus;8 by 2 using 4 bits for the multiplicand and the multiplier:
<list>
<entry level="1" type="bullet">

 A = 1 1000 0000 0</entry>
<entry level="1" type="bullet">

 S = 0 1000 0000 0</entry>
<entry level="1" type="bullet">

 P = 0 0000 0010 0</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Perform the loop four times :</entry>
<entry level="2" type="number">

 P = 0 0000 001<b>0 0</b>. The last two bits are 00.</entry>
<entry level="3" type="bullet">

 P = 0 0000 0001 0. Right shift.</entry>
<entry level="2" type="number">

 P = 0 0000 000<b>1 0</b>. The last two bits are 10.</entry>
<entry level="3" type="bullet">

 P = 0 1000 0001 0. P = P + S.</entry>
<entry level="3" type="bullet">

 P = 0 0100 0000 1. Right shift.</entry>
<entry level="2" type="number">

 P = 0 0100 000<b>0 1</b>. The last two bits are 01.</entry>
<entry level="3" type="bullet">

 P = 1 1100 0000 1. P = P + A.</entry>
<entry level="3" type="bullet">

 P = 1 1110 0000 0. Right shift.</entry>
<entry level="2" type="number">

 P = 1 1110 000<b>0 0</b>. The last two bits are 00.</entry>
<entry level="3" type="bullet">

 P = 0 1111 0000 0. Right shift.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 The product is 11110000 (after discarding the first and the last bit) which is &amp;minus;16.</entry>
</list>
</p>

</sec>
<sec>
<st>
How it works</st>
<p>

Consider a positive multiplier consisting of a block of 1s surrounded by 0s. For example, 00111110. The product is given by : 
<indent level="1">

 <math> M \times \,^{\prime\prime} 0 \; 0 \; 1 \; 1 \; 1 \; 1 \; 1 \; 0 \,^{\prime\prime} = M \times (2^5 + 2^4 + 2^3 + 2^2 + 2^1) =  M \times 62 </math>
</indent>
where M is the multiplicand. The number of operations can be reduced to two by rewriting the same as 
<indent level="1">

 <math> M \times \,^{\prime\prime} 0 \; 1 \; 0 \; 0 \; 0 \; 0 \mbox{-1} \; 0 \,^{\prime\prime} = M \times (2^6 - 2^1) = M \times 62. </math>
</indent>

In fact, it can be shown that any sequence of 1's in a binary number can be broken into the difference of two binary numbers:</p>
<p>

<indent level="1">

 <math> (\ldots 0 \overbrace{1 \ldots 1}^{n} 0 \ldots)_{2} \equiv (\ldots 1 \overbrace{0 \ldots 0}^{n} 0 \ldots)_{2} - (\ldots 0 \overbrace{0 \ldots 1}^{n} 0 \ldots)_2. </math>
</indent>

Hence, we can actually replace the multiplication by the string of ones in the original number by simpler operations, adding the multiplier, shifting the partial product thus formed by appropriate places, and then finally subtracting the multiplier. It is making use of the fact that we do not have to do anything but shift while we are dealing with 0s in a binary multiplier, and is similar to using the mathematical property that 99&nbsp;=&nbsp;100&nbsp;&amp;minus;&nbsp;1 while multiplying by 99.</p>
<p>

This scheme can be extended to any number of blocks of 1s in a multiplier (including the case of single 1 in a block). Thus,</p>
<p>

<indent level="1">

 <math> M \times \,^{\prime\prime} 0 \; 0 \; 1 \; 1 \; 1 \; 0 \; 1 \; 0 \,^{\prime\prime} = M \times (2^5 + 2^4 + 2^3 + 2^1) = M \times 58 </math>
</indent>
: <math> M \times \,^{\prime\prime} 0 \; 1 \; 0 \; 0 \mbox{-1} \; 1 \mbox{-1} \; 0 \,^{\prime\prime} = M \times (2^6 - 2^3 + 2^2 - 2^1) = M \times 58. </math></p>
<p>

Booth's algorithm follows this scheme by performing an addition when it encounters the first digit of a block of ones (0 1) and a subtraction when it encounters the end of the block (1 0).  This works for a negative multiplier as well.  When the ones in a multiplier are grouped into long blocks, Booth's algorithm performs fewer additions and subtractions than the normal multiplication algorithm.</p>

</sec>
<sec>
<st>
History</st>
<p>

The algorithm was invented by <link xlink:type="simple" xlink:href="../195/6591195.xml">
Andrew D. Booth</link> in <link xlink:type="simple" xlink:href="../602/34602.xml">
1951</link> while doing research on <link xlink:type="simple" xlink:href="../794/7794.xml">
crystallography</link> at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../022/704022.xml">
Birkbeck College</link></university>
 in <site wordnetid="108651247" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../897/93897.xml">
Bloomsbury</link></site>
, <village wordnetid="108672738" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../867/17867.xml">
London</link></village>
.  Booth used desk calculators that were faster at <link xlink:type="simple" xlink:href="../725/40725.xml">
shift</link>ing than adding and created the algorithm to increase their speed.  Booth's algorithm is of interest in the study of <link xlink:type="simple" xlink:href="../509/6509.xml">
computer architecture</link>.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<electrical_device wordnetid="103269401" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<circuit wordnetid="103033362" confidence="0.8">
<link xlink:type="simple" xlink:href="../898/285898.xml">
Multiplication ALU</link></circuit>
</device>
</electrical_device>
</instrumentality>
</artifact>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.geoffknagge.com/fyp/booth.shtml">
Radix-4 Booth Encoding</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.russinoff.com/libman/text/node38.html">
Radix-8 Booth Encoding</weblink> in <weblink xlink:type="simple" xlink:href="http://www.russinoff.com/libman/">
A Formal Theory of RTL and Computer Arithmetic</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="number">

 Collin, Andrew. <weblink xlink:type="simple" xlink:href="http://www.cs.man.ac.uk./CCS/res/res05.htm#e">
Andrew Booth's Computers at Birkbeck College</weblink>. <it>Resurrection</it>, Issue 5, Spring 1993. London: Computer Conservation Society.</entry>
<entry level="1" type="number">

 Patterson, David and John Hennessy. <it>Computer Organization and Design: The Hardware/Software Interface, Second Edition</it>. ISBN 1-55860-428-6. San Francisco, California: Morgan Kaufmann Publishers. 1998.</entry>
<entry level="1" type="number">

 Stallings, William. <it>Computer Organization and Architecture: Designing for performance, Fifth Edition</it>. ISBN 0-13-081294-3. New Jersey: Prentice-Hall, Inc.. 2000.</entry>
</list>
</p>

</sec>
</bdy>
</article>
