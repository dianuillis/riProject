<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:46:12[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Pollard&apos;s rho algorithm for logarithms</title>
<id>1630817</id>
<revision>
<id>223731099</id>
<timestamp>2008-07-05T14:19:57Z</timestamp>
<contributor>
<username>Lusum</username>
<id>6741407</id>
</contributor>
</revision>
<categories>
<category>logarithms</category>
</categories>
</header>
<bdy>

<b>Pollard's rho algorithm for logarithms</b> is an algorithm for solving the <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete logarithm</link> problem analogous to <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for solving the <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<premise wordnetid="106753800" confidence="0.8">
<postulate wordnetid="106753299" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/15491.xml">
Integer factorization</link></proposition>
</postulate>
</premise>
</message>
</statement>
 problem.<p>

The goal is to compute <math>\gamma</math> such that <math>\alpha ^ \gamma = \beta(mod N)</math>, where <math>\beta</math> belongs to the <link xlink:type="simple" xlink:href="../447/19447.xml">
group</link> <math>G</math> generated by <math>\alpha</math>. The algorithm computes integers <math>a</math>, <math>b</math>,  <math>A</math>, and <math>B</math> such that <math>\alpha^a \beta^b = \alpha^A \beta^B(mod N)</math>. Assuming, for simplicity, that the underlying group is cyclic of order <math>N</math> and that <math>n = \phi(N)</math>, we can calculate <math>\gamma</math> as a solution of the equation <math>(B-b)\gamma = (a-A) \pmod{n}</math>.</p>
<p>

To find the needed <math>a</math>, <math>b</math>,  <math>A</math>, and <math>B</math> the algorithm uses <link>
Floyd's cycle-finding algorithm</link> to find a cycle in the sequence <math>x_i = \alpha^{a_i} \beta^{b_i}</math>, where the function <math>f: x_i \mapsto x_{i+1}</math> is assumed to be random-looking and thus is likely to enter into a loop after approximately <math>\sqrt{\frac{\pi n}{2}}</math> steps. One way to define such a function is to use the following rules: Divide <math>G</math> into three subsets (not necessarily <link xlink:type="simple" xlink:href="../011/28011.xml">
subgroup</link>s) of approximately equal size: <math>G_0</math>, <math>G_1</math>, and <math>G_2</math>. If <math>x_i</math> is in <math>G_0</math> then double both <math>a</math> and <math>b</math>; if <math>x_i \in G_1</math> then increment <math>a</math>, if <math>x_i \in G_2</math> then increment <math>b</math>.</p>

<sec>
<st>
Algorithm</st>

<p>

Let <math>G</math> be a cyclic group of prime order <math>p</math>, and given <math>a,b\in G</math>, and a partition <math>G = G_0\cup G_1\cup G_2</math>, let <math>f:G\to G</math> be a map</p>
<p>

<math>
f(x) = \left\{\begin{matrix}
b\cdot x &amp; x\in G_0\\
x^2 &amp; x\in G_1\\
a\cdot x &amp; x\in G_2
\end{matrix}\right.
</math></p>
<p>

and define maps <math>g:G\times\mathbb{Z}\to\mathbb{Z}</math> and <math>h:G\times\mathbb{Z}\to\mathbb{Z}</math> by</p>
<p>

<math>
g(x,n) = \left\{\begin{matrix}
n &amp; x\in G_0\\
2n \ (\bmod \ p) &amp; x\in G_1\\
n+1 \ (\bmod \ p) &amp; x\in G_2
\end{matrix}\right.
</math></p>
<p>

<math>
h(x,n) = \left\{\begin{matrix}
n+1 \ (\bmod \ p) &amp; x\in G_0\\
2n \ (\bmod \ p) &amp; x\in G_1\\
n &amp; x\in G_2
\end{matrix}\right.
</math></p>
<p>

<indent level="1">

<b>Inputs</b> <it>a</it> a generator of <it>G</it>, <it>b</it> an element of <it>G</it>
</indent>
:<b>Output</b> An integer <it>x</it> such that <it>ax = b</it>, or failure
<list>
<entry level="2" type="number">

 Initialise <it>a0</it> &amp;larr; 0</entry>
<entry level="4" type="indent">

<it>b0</it> &amp;larr; 0</entry>
<entry level="4" type="indent">

<it>x0</it> &amp;larr; 1 &amp;isin; <it>G''</it></entry>
<entry level="4" type="indent">

<it>i</it> &amp;larr; 1</entry>
<entry level="2" type="number">

 <it>xi</it> &amp;larr; <it>f(xi-1)</it>, <it>ai</it> &amp;larr; <it>g(xi-1,ai-1)</it>, <it>bi</it> &amp;larr; <it>h(xi-1,bi-1)''</it></entry>
<entry level="2" type="number">

<it>x2i</it> &amp;larr; <it>f(f(x2i-2))</it>, <it>a2i</it> &amp;larr; <it>g(f(x2i-2),g(x2i-2,a2i-2))</it>, <it>b2i</it> &amp;larr; <it>h(f(x2i-2),h(x2i-2,b2i-2))''</it></entry>
<entry level="2" type="number">

 If <it>xi</it> = <it>x2i</it> then</entry>
<entry level="3" type="number">

 <it>r</it> &amp;larr; <it>bi</it> - <it>b2i''</it></entry>
<entry level="3" type="number">

 If r = 0 return failure</entry>
<entry level="3" type="number">

 x &amp;larr; <it>r-1</it>(<it>a2i</it> - <it>ai</it>) mod <it>p''</it></entry>
<entry level="3" type="number">

 return x</entry>
<entry level="2" type="number">

 If <it>xi</it> &amp;ne; <it>x2i</it> then <it>i</it> &amp;larr; <it>i+1</it>, and go to step 2.</entry>
</list>
</p>

</sec>
<sec>
<st>
Example</st>

<p>

Consider, for example, the group generated by 2 modulo <math>N=1019</math> (the order of the group is <math>n=1018</math>, 2
generates the group of units modulo 1019). The algorithm is implemented by the following <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 program:</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

const int n = 1018, N = n + 1;  /* N = 1019 -- prime     */
const int alpha = 2;            /* generator             */
const int beta = 5;             /* 2^{10} = 1024 = 5 (N) */</p>
<p>

void new_xab( int&amp; x, int&amp; a, int&amp; b ) {
switch( x%3 ) {
case 0: x = x*x     % N;  a =  a*2  % n;  b =  b*2  % n;  break;
case 1: x = x*alpha % N;  a = (a+1) % n;                  break;
case 2: x = x*beta  % N;                  b = (b+1) % n;  break;
}
}</p>
<p>

int main() {
int x=1, a=0, b=0;
int X=x, A=a, B=b;
for( int i = 1; i  n; ++i ) {
new_xab( x, a, b );
new_xab( X, A, B ); new_xab( X, A, B );
printf( "%3d  %4d %3d %3d  %4d %3d %3d\n", i, x, a, b, X, A, B );
if( x == X ) break;
}
return 0;
}</p>

<p>

The results are as follows (edited):</p>
<p>

i     x   a   b     X   A   B
------------------------------
1     2   1   0    10   1   1
2    10   1   1   100   2   2
3    20   2   1  1000   3   3
4   100   2   2   425   8   6
5   200   3   2   436  16  14
6  1000   3   3   284  17  15
7   981   4   3   986  17  17
8   425   8   6   194  17  19
..............................
48   224 680 376    86 299 412
49   101 680 377   860 300 413
50   505 680 378   101 300 415
51  1010 681 378  1010 301 416</p>
<p>

That is <math>2^{681} 5^{378} = 1010 = 2^{301} 5^{416} \pmod{1019}</math> and so <math>(416-378)\gamma = 681-301 \pmod{1018}</math>, for which <math>\gamma_1=10</math> is a solution as expected. As <math>n=1018</math> is not prime, there is another solution <math>\gamma_2=519</math>, for which <math>2^{519} = 1014 = -5\pmod{1019}</math> holds.</p>

</sec>
<sec>
<st>
Complexity</st>
<p>

The running time is approximately O(<math>\sqrt{n}</math>) for a number <it>n</it>.</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 J. Pollard, <it>Monte Carlo methods for index computation mod p</it>, Mathematics of Computation, Volume 32, 1978.</entry>
<entry level="1" type="bullet">

 Alfred J. Menezes, Paul C. van Oorschot, and Scott A. Vanstone, <weblink xlink:type="simple" xlink:href="http://www.cacr.math.uwaterloo.ca/hac/about/chap3.pdf">
Handbook of Applied Cryptography, Chapter 3</weblink>, 2001.</entry>
</list>
</p>


</sec>
</bdy>
</article>
