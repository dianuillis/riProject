<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:45:36[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Actor model</title>
<id>1637868</id>
<revision>
<id>243885827</id>
<timestamp>2008-10-08T13:40:40Z</timestamp>
<contributor>
<username>Tobias Bergemann</username>
<id>36029</id>
</contributor>
</revision>
<categories>
<category>Wikipedia references cleanup</category>
<category>Actor model</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_style.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 The references used in this article may be clearer with a different or consistent style of <b>, , or </b>.</col>
</row>
</table>

<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>Actor model</b> is a mathematical model of <link xlink:type="simple" xlink:href="../162/145162.xml">
concurrent computation</link> that treats "actors" as the universal primitives of concurrent digital computation: in response to a message that it receives, an actor can make local decisions, create more actors, send more messages, and determine how to respond to the next message received. The Actor model originates in a 1973 paper by <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../592/2055592.xml">
Carl Hewitt</link></person>
, <link>
Peter Bishop</link>, and <link>
Richard Steiger</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> It has been used both as a framework for a <knowledge_domain wordnetid="105999266" confidence="0.8">
<discipline wordnetid="105996646" confidence="0.8">
<mathematics wordnetid="106000644" confidence="0.8">
<science wordnetid="105999797" confidence="0.8">
<link xlink:type="simple" xlink:href="../283/2194283.xml">
theoretical understanding</link></science>
</mathematics>
</discipline>
</knowledge_domain>
 of <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrency</link>, and as the theoretical basis for several <link xlink:type="simple" xlink:href="../320/2194320.xml">
practical implementations</link> of <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrent systems</link>.  The relationship of the model to other work is discussed in <link xlink:type="simple" xlink:href="../863/2681863.xml">
Indeterminacy in concurrent computation</link> and <link xlink:type="simple" xlink:href="../909/2195909.xml">
Actor model and process calculi</link>.</p>

<sec>
<st>
 History </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../964/2627964.xml">
History of the Actor model</link></it>
</indent>

Unlike previous models of computation, the Actor model was inspired by <link xlink:type="simple" xlink:href="../098/39098.xml">
physical law</link>s. It was also influenced by the programming languages <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link>, <speech wordnetid="107109196" confidence="0.8">
<dialect wordnetid="107155661" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<non-standard_speech wordnetid="107155081" confidence="0.8">
<link xlink:type="simple" xlink:href="../513/29513.xml">
Simula</link></non-standard_speech>
</auditory_communication>
</dialect>
</speech>
 and early versions of <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/28319.xml">
Smalltalk</link></programming_language>
, as well as <link xlink:type="simple" xlink:href="../717/539717.xml">
capability-based systems</link> and <link xlink:type="simple" xlink:href="../339/43339.xml">
packet switching</link>. Its development was "motivated by the prospect of highly parallel computing machines consisting of dozens, hundreds or even thousands of independent microprocessors, each with its own local memory and communications processor, communicating via a high-performance communications network."<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> Since that time, the advent of massive concurrency through <link xlink:type="simple" xlink:href="../207/3503207.xml">
multi-core</link> computer architectures has rekindled interest in the Actor model.</p>
<p>

Following Hewitt, Bishop, and Steiger's 1973 publication, Irene Greif developed an <link xlink:type="simple" xlink:href="../062/270062.xml">
operational semantics</link> for the Actors model as part of her doctoral research.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Two years later, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../643/2203643.xml">
Henry Baker</link></research_worker>
</scientist>
</causal_agent>
</person>
</physical_entity>
 and Hewitt published a set of axiomatic laws for Actor systems.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> Other major milestones include William Clinger's dissertation, in 1981, introducing a <link xlink:type="simple" xlink:href="../598/3741598.xml">
denotational semantics</link> based on power domains,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> and <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../743/14959743.xml">
Gul Agha</link></person>
's 1985 dissertation which further developed a transition-based semantic model complementary to Clinger's.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> This resulted in the full development of <link xlink:type="simple" xlink:href="../283/2194283.xml">
actor model theory</link>.</p>
<p>

Major software implementation work was done by Russ Atkinson, Beppe Attardi, Henry Baker, Gerry Barber, Peter Bishop, Peter de Jong, Ken Kahn, Henry Lieberman, Carl Manning, Tom Reinhardt, Richard Steiger, and Dan Theriault, in the Message Passing Semantics Group at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/18879.xml">
Massachusetts Institute of Technology</link></university>
 (MIT).  Research groups led by Chuck Seitz at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../786/5786.xml">
California Institute of Technology</link></university>
 (Caltech) and Bill Dally at MIT constructed computer architectures that further developed the message passing in the model.  See <link xlink:type="simple" xlink:href="../320/2194320.xml">
Actor model implementation</link>.</p>
<p>

Research on the Actor model has been carried out at Caltech Computer Science, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../911/187911.xml">
Kyoto University</link></university>
 Tokoro Laboratory, <link xlink:type="simple" xlink:href="../324/630324.xml">
MCC</link>, <link xlink:type="simple" xlink:href="../274/434274.xml">
MIT Artificial Intelligence Laboratory</link>, <institute wordnetid="108407330" confidence="0.8">
<think_tank wordnetid="108478702" confidence="0.8">
<association wordnetid="108049401" confidence="0.8">
<company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../262/481262.xml">
SRI</link></institution>
</company>
</association>
</think_tank>
</institute>
, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../977/26977.xml">
Stanford University</link></university>
, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../695/384695.xml">
University of Illinois at Urbana-Champaign</link></university>
 <weblink xlink:type="simple" xlink:href="http://osl.cs.uiuc.edu">
Open Systems Laboratory</weblink>, <educational_institution wordnetid="108276342" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../692/84692.xml">
University of Paris</link></institution>
</educational_institution>
 6, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../158/453158.xml">
University of Pisa</link></university>
, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../215/166215.xml">
University of Tokyo</link></university>
 Yonezawa Laboratory and elsewhere.</p>

</sec>
<sec>
<st>
 Fundamental concepts </st>
<p>

The Actor model adopts the philosophy that <it>everything is an actor</it>. This is similar to the <it>everything is an object</it> philosophy used by some <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented programming languages</link>, but differs in that object-oriented software is typically executed sequentially, while the Actor model is inherently concurrent.</p>
<p>

An actor is a computational entity that, in response to a message it receives, can concurrently:
<list>
<entry level="1" type="bullet">

 send a finite number of messages to other actors;</entry>
<entry level="1" type="bullet">

 create a finite number of new actors;</entry>
<entry level="1" type="bullet">

 designate the behavior to be used for the next message it receives.</entry>
</list>
</p>
<p>

There is no assumed sequence to the above actions and they could be carried out in parallel.</p>
<p>

Communications among actors occur asynchronously: that is, the sending actor does not wait until the message is received before proceeding with computation.</p>
<p>

Recipients of messages are identified by address, sometimes called "mailing address". Thus an actor can only communicate with actors whose addresses it has.  It can obtain those from a message it receives, or if the address is for an actor it just created.</p>
<p>

The Actor model is characterized by inherent concurrency of computation within and among actors, dynamic creation of actors, inclusion of actor addresses in messages, and interaction only through direct asynchronous <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link> with no restriction on message arrival order.</p>

</sec>
<sec>
<st>
 Formal systems </st>
<p>

Over the years, several different formal systems have been developed which permit reasoning about systems in the Actor model. These include:</p>
<p>

<list>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../062/270062.xml">
Operational semantics</link></language>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></entry>
<entry level="1" type="bullet">

 Laws for Actor systems<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> </entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../275/55275.xml">
Denotational semantics</link></language>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></entry>
<entry level="1" type="bullet">

 Transition semantics<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></entry>
</list>
</p>
<p>

There are also formalisms that are not fully faithful to the Actor model in that they do not formalize the guaranteed delivery of messages including the following:
<list>
<entry level="1" type="bullet">

 Several different Actor algebras<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></entry>
<entry level="1" type="bullet">

 Linear logic<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></entry>
</list>
</p>

</sec>
<sec>
<st>
Applications</st>

<p>

The Actors model can be used as a framework for modelling, understanding, and reasoning about, a wide range of <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrent systems</link>. For example:</p>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../738/9738.xml">
Electronic mail</link> (e-mail) can be modeled as an Actor system.  Accounts are modeled as Actors and <link xlink:type="simple" xlink:href="../032/295032.xml">
email addresses</link> as Actor addresses.  </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../483/93483.xml">
Web Services</link> can be modeled with <link xlink:type="simple" xlink:href="../215/29215.xml">
SOAP</link> endpoints modeled as Actor addresses.  </entry>
<entry level="1" type="bullet">

 Objects with <link xlink:type="simple" xlink:href="../593/244593.xml">
lock</link>s (<it>e.g.</it> as in <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
) can be modeled as a <b>Serializer</b>, provided that their implementations are such that messages can continually arrive (perhaps by being stored in an internal queue). A serializer is an important kind of Actor defined by the property that it is continually available to the arrival of new messages; every message sent to a serializer is guaranteed to arrive.  </entry>
<entry level="1" type="bullet">

 Testing and Test Control Notation (<message wordnetid="106598915" confidence="0.8">
<proposal wordnetid="107162194" confidence="0.8">
<recommendation wordnetid="106671637" confidence="0.8">
<advice wordnetid="106671484" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/780024.xml">
TTCN</link></advice>
</recommendation>
</proposal>
</message>
), both TTCN-2 and <link xlink:type="simple" xlink:href="../682/16604682.xml">
TTCN-3</link>, follows Actor model rather closely. In TTCN, Actor is a test component: either parallel test component (PTC) or main test component (MTC). Test components can send and receive messages to and from remote partners (peer test components or test system interface), the latter being identified by its address. Each test component has a behaviour tree bound to it; test components run in parallel and can be dynamically created by parent test components. Builtin language constructs allow to define actions to be taken when an expected message is received from the internal message queue, like sending a message to another peer entity or creating new test components.</entry>
</list>
</p>

</sec>
<sec>
<st>
Models prior to the Actor model</st>
<p>

The Actor model builds on previous models of computation.</p>

<ss1>
<st>
Lambda calculus</st>
<p>

The <link xlink:type="simple" xlink:href="../203/18203.xml">
lambda calculus</link> of <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Alonzo Church</link></scientist>
 can be viewed as the earliest <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link> <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> (see Hewitt, Bishop, and Steiger 1973; <link xlink:type="simple" xlink:href="../368/82368.xml">
Abelson and Sussman 1985</link>).  For example the lambda expression below implements a tree data structure when supplied with parameters for a leftSubTree and rightSubTree.  When such a tree is given a parameter message "getLeft", it returns leftSubTree and likewise when given the message "getRight" it returns rightSubTree.</p>
<p>

λ(leftSubTree,rightSubTree)
λ(message)
<it>if</it> (message == "getLeft") <it>then</it> leftSubTree
<it>else if</it> (message == "getRight") <it>then</it> rightSubTree</p>
<p>

However, the semantics of the lambda calculus were expressed using <link xlink:type="simple" xlink:href="../636/19636.xml">
variable substitution</link> in which the values of parameters were substituted into the body of an invoked lambda expression.  The substitution model is unsuitable for concurrency because it does not allow the capability of <link xlink:type="simple" xlink:href="../431/2041431.xml">
sharing</link> of changing resources.  Inspired by the lambda calculus, the <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreter</link> for the programming language <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link> made use of a data structure called an environment so that the values of parameters did not have to be substituted into the body of an invoked lambda expression.  This allowed for sharing of the <link xlink:type="simple" xlink:href="../519/29519.xml">
effects</link> of updating shared data structures but did not provide for concurrency.</p>

</ss1>
<ss1>
<st>
Simula</st>
<p>

<link xlink:type="simple" xlink:href="../513/29513.xml">
Simula 67</link> pioneered using message passing for computation, motivated by discrete event simulation applications. These applications had become large and unmodular in previous simulation languages.  At each time step, a large central program would have to go through and update the state of each simulation object that changed depending on the state of which ever simulation objects that it interacted with on that step.  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../741/72741.xml">
Kristen Nygaard</link></scientist>
</person>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../188/64188.xml">
Ole-Johan Dahl</link></scientist>
</person>
 developed the idea (first described in an IFIP workshop in 1967) of having <link xlink:type="simple" xlink:href="../817/232817.xml">
methods</link> on each <link xlink:type="simple" xlink:href="../665/169665.xml">
object</link> that would update its own local state based on messages from other objects.  In addition they introduced a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../392/7392.xml">
class structure</link></concept>
</idea>
 for objects with <link xlink:type="simple" xlink:href="../746/2617746.xml">
inheritance</link>.  Their innovations considerably improved the modularity of programs. </p>
<p>

However, Simula used <link xlink:type="simple" xlink:href="../800/243800.xml">
coroutine</link> control structure instead of true concurrency.</p>

</ss1>
<ss1>
<st>
Smalltalk</st>
<p>
 
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../449/1449.xml">
Alan Kay</link></scientist>
</person>
 was influenced by message passing in the pattern-directed invocation of <link xlink:type="simple" xlink:href="../143/46143.xml">
Planner</link> in developing <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/28319.xml">
Smalltalk</link></programming_language>
-71.  Hewitt was intrigued by Smalltalk-71 but was put off by the complexity of communication that included invocations with many fields including <it>global</it>, <it>sender</it>, <it>receiver</it>, <it>reply-style</it>, <it>status</it>, <it>reply</it>, <it>operator selector</it>, <it>etc.</it></p>
<p>

In 1972 Kay visited MIT and discussed some of his ideas for Smalltalk-72 building on the <link xlink:type="simple" xlink:href="../334/18334.xml">
Logo</link> work of <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/27802.xml">
Seymour Papert</link></scientist>
</person>
 and the "little person" model of computation used for teaching children to program.   However, the message passing of Smalltalk-72 was quite complex.  Code in the language was viewed by the interpreter as simply a stream of tokens.  As <link xlink:type="simple" xlink:href="../608/1337608.xml">
Dan Ingalls</link> later described it:</p>
<p>

<indent level="1">

<it>The first (token) encountered (in a program) was looked up in the dynamic context, to determine the receiver of the subsequent message. The name lookup began with the class dictionary of the current activation. Failing there, it moved to the sender of that activation and so on up the sender chain.  When a binding was finally found for the token, its value became the receiver of a new message, and the interpreter activated the code for that object's class.</it>
</indent>

This led some to believe that a new mathematical model of concurrent computation based on message passing should be simpler than Smalltalk-72.</p>
<p>

Subsequent versions of the Smalltalk language largely followed the path of using the virtual <link xlink:type="simple" xlink:href="../817/232817.xml">
methods</link> of Simula in the message passing structure of programs.  However Smalltalk-72 made primitives such as integers, floating point numbers, <it>etc.</it> into <link xlink:type="simple" xlink:href="../665/169665.xml">
objects</link>.  The authors of Simula had considered making such primitives into objects but refrained largely for efficiency reasons.  <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 at first used the expedient of having both primitive and object versions of integers, floating point numbers, <it>etc.</it> The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 programming language (and later versions of Java, starting with Java 1.5) adopted the more elegant solution of using <it><link>
boxing</link></it> and <it>unboxing</it>, a variant of which had been used earlier in some <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link> implementations.</p>
<p>

The Smalltalk system went on to become very influential, innovating in bitmap displays, personal computing, the class browser interface, and many other ways. For details see Kay's <it>The Early History of Smalltalk</it><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref>.  Meanwhile the Actor efforts at MIT remained focused on developing the science and engineering of higher level concurrency.  (See the paper by Jean-Pierre Briot for ideas that were developed later on how to incorporate some kinds of Actor concurrency into later versions of Smalltalk.)</p>

</ss1>
<ss1>
<st>
Petri nets</st>
<p>

Prior to the development of the Actor model, <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../192/225192.xml">
Petri net</link></language>
s were widely used to model concurrent computation. However, they were widely acknowledged to have an important limitation:  they modeled control flow but not data flow.  Consequently they were not readily composable thereby limiting their modularity.  Hewitt pointed out another difficulty with Petri nets:  simultaneous action.  <it>I.e.</it>, the atomic step of computation in Petri nets is a transition in which  tokens <it>simultaneously</it> disappear from the input places of a transition and appear in the output places.  The physical basis of using a primitive with this kind of simultaneity seemed questionable to him. Despite these apparent difficulties, Petri nets continue to be a popular approach to modelling concurrency, and are still the subject of active research.</p>

</ss1>
</sec>
<sec>
<st>
Message-passing semantics</st>
<p>

The Actor model is about the semantics of message passing.</p>

<ss1>
<st>
 Unbounded nondeterminism controversy </st>

<p>

Arguably, the first concurrent programs were <link xlink:type="simple" xlink:href="../824/638824.xml">
interrupt handler</link>s.  During the course of its normal operation, a computer needed to be able to receive information from outside (characters from a keyboard, packets from a network, <it>etc</it>.).  So when the information arrived execution of the computer was "interrupted" and special code called an interrupt handler was called to <it>put</it> the information in a <link xlink:type="simple" xlink:href="../183/2406183.xml">
buffer</link> where it could be subsequently <it>gotten</it>.</p>
<p>

In the early 1960s, interrupts began to be used to simulate the concurrent execution of several programs on a single processor.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> Having concurrency with <link xlink:type="simple" xlink:href="../653/825653.xml">
shared memory</link> gave rise to the problem of <link xlink:type="simple" xlink:href="../356/217356.xml">
concurrency control</link>. Originally, this problem was conceived as being one of <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> on a single computer.  <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> developed <link xlink:type="simple" xlink:href="../557/164557.xml">
semaphores</link> and later, between 1971 and 1973<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref>, <link xlink:type="simple" xlink:href="../434/39434.xml">
Tony Hoare</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref> and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Per Brinch Hansen</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref> developed <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../789/1367789.xml">
monitors</link></concept>
</idea>
 to solve the mutual exclusion problem. However, neither of these solutions provided a programming language construct that encapsulated access to shared resources. This encapsulation was later accomplished by the <link>
serializer construct</link> ([Hewitt and Atkinson 1977, 1979] and [Atkinson 1980]).</p>
<p>

The first models of computation (<it>e.g.</it> <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machines</link>, Post productions, the <link xlink:type="simple" xlink:href="../203/18203.xml">
lambda calculus</link>, <it>etc.</it>) were based on mathematics and made use of a global state to represent a computational <it>step</it> (later generalized in [McCarthy and Hayes 1969] and [Dijkstra 1976] see <link xlink:type="simple" xlink:href="../964/2627964.xml#xpointer(//*[./st=%22Event_orderings_versus_global_state%22])">
Event orderings versus global state</link>).  Each computational step was from one global state of the computation to the next global state.  The global state approach was continued in <link xlink:type="simple" xlink:href="../356/103356.xml">
automata theory</link> for <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/10931.xml">
finite state</link></method>
</know-how>
 machines and <link xlink:type="simple" xlink:href="../078/510078.xml">
push down stack</link> machines, including their <link xlink:type="simple" xlink:href="../198/452198.xml">
nondeterministic</link> versions.  Such nondeterministic automata have the property of <link xlink:type="simple" xlink:href="../475/2647475.xml">
bounded nondeterminism</link>; that is, if a machine always halts when started in its initial state, then there is a bound on the number of states in which it halts.</p>
<p>

<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> further developed the nondeterministic global state approach.  Dijkstra's model gave rise to a controversy concerning <it>unbounded nondeterminism.</it> <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../475/2647475.xml">
Unbounded nondeterminism</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 (also called <it>unbounded indeterminacy</it>), is a property of <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrency</link> by which the amount of delay in servicing a request can become unbounded as a result of arbitration of contention for shared resources <it>while still guaranteeing that the request will eventually be serviced</it>. Hewitt argued that the Actor model should provide the guarantee of service. In Dijkstra's model, although there could be an unbounded amount of time between the execution of sequential instructions on a computer, a (parallel) program that started out in a well defined state could terminate in only a bounded number of states [Dijkstra 1976]. Consequently, his model could not provide the guarantee of service.  Dijkstra argued that it was impossible to implement unbounded nondeterminism.</p>
<p>

Hewitt argued otherwise: there is no bound that can be placed on how long it takes a computational circuit called an <link xlink:type="simple" xlink:href="../226/2827226.xml">
<it>arbiter''</it></link> to settle (see <link xlink:type="simple" xlink:href="../871/2277871.xml">
metastability in electronics</link>).  Arbiters are used in computers to deal with the circumstance that computer clocks operate asynchronously with input from outside, <it>e.g.</it> keyboard input, disk access, network input, <it>etc.</it>  So it could take an unbounded time for a message sent to a computer to be received and in the meantime the computer could traverse an unbounded number of states.</p>
<p>

The Actor Model features unbounded nondeterminism which was captured in a mathematical model by Will Clinger using <link xlink:type="simple" xlink:href="../077/325077.xml">
domain theory</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>  There is no global state in the Actor model.</p>

</ss1>
<ss1>
<st>
Direct communication and asynchrony</st>
<p>

Messages in the Actor model are not necessarily buffered. This was a sharp break with previous approaches to models of concurrent computation.  The lack of buffering caused a great deal of misunderstanding at the time of the development of the Actor model and is still a controversial issue.  Some researchers argued that the messages are buffered in the "ether" or the "environment".  Also, messages in the Actor model are simply sent (like <unit_of_measurement wordnetid="113583724" confidence="0.8">
<definite_quantity wordnetid="113576101" confidence="0.8">
<link xlink:type="simple" xlink:href="../734/43734.xml">
packets</link></definite_quantity>
</unit_of_measurement>
 in <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/15323.xml">
IP</link></rule>
</direction>
</protocol>
</message>
); there is no requirement for a synchronous handshake with the recipient.</p>

</ss1>
<ss1>
<st>
Actor creation plus addresses in messages means variable topology</st>
<p>

A natural development of the Actor model was to allow addresses in messages. Influenced by <link xlink:type="simple" xlink:href="../339/43339.xml">
packet switched networks</link> [1961 and 1964], Hewitt proposed the development of a new model of concurrent computation in which communications would not have any required fields at all: they could be empty. Of course, if the sender of a communication desired a recipient to have access to addresses which the recipient did not already have, the address would have to be sent in the communication.</p>
<p>

A computation might need to send a message to a recipient from which it would later receive a response. The way to do this is to send a communication which has the message along with the address of another actor called the <it>resumption</it> (sometimes also called <link xlink:type="simple" xlink:href="../189/505189.xml">
continuation</link> or <link>
stack frame</link>) along with the message.  The recipient could then cause a response message to be sent to the resumption.</p>
<p>

Actor creation plus the inclusion of the addresses of actors in messages means that Actors have a potentially variable topology in their relationship to one another much as the objects in Simula also had a variable topology in their relationship to one another.</p>

</ss1>
<ss1>
<st>
Inherently concurrent</st>
<p>

As opposed to the previous approach based on composing sequential processes, the Actor model was developed as an inherently concurrent model.  In the Actor model sequentiality was a special case that derived from concurrent computation as explained in <knowledge_domain wordnetid="105999266" confidence="0.8">
<discipline wordnetid="105996646" confidence="0.8">
<mathematics wordnetid="106000644" confidence="0.8">
<science wordnetid="105999797" confidence="0.8">
<link xlink:type="simple" xlink:href="../283/2194283.xml">
Actor model theory</link></science>
</mathematics>
</discipline>
</knowledge_domain>
.</p>

</ss1>
<ss1>
<st>
No requirement on order of message arrival</st>
<p>

Hewitt argued against adding the requirement that messages must arrive in the order in which they are sent to the Actor model. If output message ordering is desired then it can be modeled  by a queue Actor that provides this functionality.  Such a queue Actor would queue the messages that arrived so that they could be retrieved in <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/11347.xml">
FIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 order. So if an Actor X sent a message M1 to an Actor Y and in response to a subsequent message that X received, it sent another message M2 to Y, there is no requirement that M1 arrives at Y before M2.</p>
<p>

In this respect the Actor model mirrors <link xlink:type="simple" xlink:href="../339/43339.xml">
packet switching</link> systems which do not guarantee that packets must be received in the order sent. Not providing the order of delivery guarantee allows packet switching to buffer packets, use multiple paths to send packets, resend damaged packets, and to provide other optimizations.</p>
<p>

For example, Actors are allowed to pipeline the processing of messages.  What this means is that in the course of processing a message M1, an Actor can designate the behavior to be used to process the next message, and then in fact begin processing another message M2 before it has finished processing M1.  Just because an Actor is allowed to pipeline the processing of messages does not mean that it <it>must</it> pipeline the processing.  Whether a message is pipelined is an engineering tradeoff.  How would an external observer know whether the processing of a message by an Actor has been pipelined?  There is no ambiguity in the definition of an Actor created by the possibility of pipelining.  Of course, it is possible to perform the pipeline optimization incorrectly in some implementations, in which case unexpected behavior may occur.</p>

</ss1>
<ss1>
<st>
Locality</st>
<p>

Another important characteristic of the Actor model is locality.</p>
<p>

Locality means that in processing a message: an Actor can send messages only to addresses that it receives in the message, addresses that it already had before it received the message and addresses for Actors that it creates while processing the message.  (But see <link xlink:type="simple" xlink:href="../868/1637868.xml#xpointer(//*[./st=%22Synthesizing+addresses+of+Actors%22])">
Synthesizing Addresses of Actors</link>.)</p>
<p>

Also locality means that there is no simultaneous change in multiple locations.  In this way it differs from some other models of concurrency, <it>e.g.</it>, the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../192/225192.xml">
Petri net</link></language>
 model in which tokens are simultaneously removed from multiple locations and placed in other locations.</p>

</ss1>
<ss1>
<st>
Composing actors</st>
<p>

The idea of composing Actor systems into larger ones is an important aspect of <link xlink:type="simple" xlink:href="../133/939133.xml">
modularity</link> that was developed in Gul Agha's doctoral dissertation,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>, developed later by Gul Agha, Ian Mason, Scott Smith, and Carolyn Talcott.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>

</ss1>
<ss1>
<st>
Behaviors</st>
<p>

A key innovation was the introduction of <it>behavior</it> specified as a mathematical function to express what an Actor does when it processes a message including specifying a new behavior to process the next message that arrives.  Behaviors provided a mechanism to mathematically model the sharing in concurrency.</p>
<p>

Behaviors also freed the Actor model from implementation details, <it>e.g.</it>, the Smalltalk-72 token stream interpreter. However, it is critical to understand that the efficient implementation of systems described by the Actor model require <it>extensive</it> optimization. See <link xlink:type="simple" xlink:href="../320/2194320.xml">
Actor model implementation</link> for details.</p>

</ss1>
<ss1>
<st>
 Representation theorem </st>
<p>

There is a representation theorem for concurrent systems in the <link xlink:type="simple" xlink:href="../868/1637868.xml">
Actor model</link> by which the mathematical denotation denoted by a system S is found by constructing increasingly better approximations from an initial behavior called ⊥S using a behavior approximating function <b>progression</b>S to construct a denotation (meaning ) for S as follows [Hewitt 2006b; Clinger 1981]:
<indent level="2">

<b>Denote</b>S ≡ ∨i∈ω <b>progression</b>Si(⊥S).
</indent>

Since the Actor model is very general, the Representation Theorem applies to the other main stream models as well.  For example it applies to <link xlink:type="simple" xlink:href="../192/225192.xml">
petri net</link> and <link xlink:type="simple" xlink:href="../240/853240.xml">
process calculi</link> models via a <link xlink:type="simple" xlink:href="../850/787850.xml">
two-phase commit protocol</link> protocol to handle the synchronization.</p>

</ss1>
<ss1>
<st>
Relationship to mathematical logic</st>
<p>

The development of the Actor model has an interesting relationship to mathematical logic.  One of the key motivations for its development was to understand and deal with the control structure issues that arose in development of the <link xlink:type="simple" xlink:href="../143/46143.xml">
Planner programming language</link>.  Once the Actor model was initially defined, an important challenge was to understand  the power of the model relative to Kowalski's thesis that "computation can be subsumed by deduction".  Kowalski's thesis turned out to be false for the concurrent computation in the Actor model (see <link xlink:type="simple" xlink:href="../863/2681863.xml">
Indeterminacy in concurrent computation</link>).  This result is still somewhat controversial and it reversed previous expectations because Kowalski's thesis is true for sequential computation and even some kinds of parallel computation, <it>e.g.</it> the lambda calculus.</p>
<p>

Nevertheless attempts were made to extend <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic programming</link> to concurrent computation.  However, Hewitt and Agha [1991] claimed that the resulting systems were not deductive in the following sense: computational steps of the concurrent logic programming systems do not follow deductively from previous steps (see <link xlink:type="simple" xlink:href="../863/2681863.xml">
Indeterminacy in concurrent computation</link>).</p>

</ss1>
<ss1>
<st>
Migration</st>
<p>

Migration in the Actor model is the ability of Actors to change locations.  <it>E.g.</it>, in his dissertation, Aki Yonezawa modeled a post office that customer Actors could enter, change locations within while operating, and exit.  An Actor that can migrate can be modeled by having a location Actor that changes when the Actor migrates.  However the faithfulness of this modeling is controversial and the subject of research.</p>

</ss1>
<ss1>
<st>
Security</st>
<p>

The security of Actors can be protected in the following ways:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../414/10840414.xml">
hardwiring</link> in which Actors are physically connected</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../615/13615.xml">
hardware</link> as in Burroughs B5000, <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<digital_computer wordnetid="103196324" confidence="0.8">
<workstation wordnetid="104603399" confidence="0.8">
<link xlink:type="simple" xlink:href="../123/18123.xml">
Lisp machine</link></workstation>
</digital_computer>
</machine>
</device>
</instrumentality>
</artifact>
</computer>
, <it>etc.''</it></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../353/32353.xml">
virtual machines</link> as in <link xlink:type="simple" xlink:href="../389/16389.xml">
Java virtual machine</link>, <link xlink:type="simple" xlink:href="../003/46003.xml">
Common Language Runtime</link>, <it>etc.''</it></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../194/22194.xml">
operating systems</link> as in <link xlink:type="simple" xlink:href="../717/539717.xml">
capability-based systems</link></entry>
<entry level="1" type="bullet">

 <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../644/59644.xml">
signing</link></writing>
</written_communication>
</document>
 and/or <link xlink:type="simple" xlink:href="../294/10294.xml">
encryption</link> of Actors and their addresses</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Synthesizing addresses of actors</st>
<p>

A delicate point in the Actor model is the ability to synthesize the address of an Actor.  In some cases security can be used to prevent the synthesis of addresses  (see <link xlink:type="simple" xlink:href="../868/1637868.xml#xpointer(//*[./st=%22Security%22])">
Security</link>).  However, if an Actor address is simply a bit string then clearly it can be synthesized although it may be difficult or even infeasible to guess the address of an Actor if the bit strings are long enough.  <link xlink:type="simple" xlink:href="../215/29215.xml">
SOAP</link> uses a <link xlink:type="simple" xlink:href="../277/32277.xml">
URL</link> for the address of an endpoint where an Actor can be reached.  Since a <link xlink:type="simple" xlink:href="../277/32277.xml">
URL</link> is a character string, it can clearly be synthesized although encryption can make it impossible to guess.</p>
<p>

Synthesizing the addresses of Actors is usually modeled using mapping.  The idea is to use an Actor system to perform the mapping to the actual Actor addresses.  For example, on a computer the memory structure of the computer can be modeled as an Actor system that does the mapping.  In the case of <link xlink:type="simple" xlink:href="../215/29215.xml">
SOAP</link> addresses, it's modeling the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../339/8339.xml">
DNS</link></rule>
</direction>
</protocol>
</message>
 and rest of the <link xlink:type="simple" xlink:href="../277/32277.xml">
URL</link> mapping.</p>

</ss1>
<ss1>
<st>
Contrast with other models of message-passing concurrency</st>
<p>

<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../547/93547.xml">
Robin Milner</link></scientist>
</person>
's initial published work on concurrency<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref> was also notable in that it was not based on composing sequential processes.  His work differed from the Actor model because it was based on a fixed number of processes of fixed topology communicating numbers and strings using synchronous communication.  The original <link>
Communicating Sequential Processes</link> model<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref> published by <link xlink:type="simple" xlink:href="../434/39434.xml">
Tony Hoare</link> differed from the Actor model because it was based on the parallel composition of a fixed number of sequential processes connected in a fixed topology, and communicating using synchronous message-passing based on process names (see <link xlink:type="simple" xlink:href="../309/3434309.xml#xpointer(//*[./st=%22Early_work%22])">
Actor model and process calculi history</link>). Later versions of CSP abandoned communication based on process names in favor of anonymous communication via channels, an approach also used in Milner's work on the <link xlink:type="simple" xlink:href="../372/420372.xml">
Calculus of Communicating Systems</link> and the <link xlink:type="simple" xlink:href="../373/420373.xml">
π-calculus</link>.  </p>
<p>

These early models by Milner and Hoare both had the property of bounded nondeterminism.  Modern, theoretical <link xlink:type="simple" xlink:href="../370/247370.xml">
CSP</link> ([Hoare 1985] and [Roscoe 2005]) explicitly provides unbounded nondeterminism.</p>

</ss1>
</sec>
<sec>
<st>
Current importance</st>
<p>

Forty years after the publication of <link xlink:type="simple" xlink:href="../418/39418.xml">
Moore's Law</link>, hardware development is furthering local and nonlocal massive concurrency.  Local concurrency is enabled by new hardware for <link xlink:type="simple" xlink:href="../285/148285.xml">
64-bit</link> <link xlink:type="simple" xlink:href="../743/1259743.xml">
multi-core</link> (<weblink xlink:type="simple" xlink:href="http://www.intel.com/technology/techresearch/idf/platform-2015-keynote.htm">
Platform 2015 Unveiled at IDF Spring 2005</weblink>) microprocessors, multi-chip modules, and high performance <link xlink:type="simple" xlink:href="../082/346082.xml">
interconnect</link>. Nonlocal concurrency is being enabled by new hardware for wired and <link xlink:type="simple" xlink:href="../868/185868.xml">
wireless</link> <link xlink:type="simple" xlink:href="../184/147184.xml">
broadband</link> <link xlink:type="simple" xlink:href="../339/43339.xml">
packet switched</link> communications (see <link xlink:type="simple" xlink:href="../973/63973.xml">
Wi-Fi</link> and <link xlink:type="simple" xlink:href="../428/166428.xml">
Ultra wideband</link>).  Both local and nonlocal storage capacities are growing exponentially.</p>
<p>

According to Hewitt [2006], the Actor model faces issues in computer and communications architecture, <link xlink:type="simple" xlink:href="../162/145162.xml">
concurrent programming language</link>s, and <link xlink:type="simple" xlink:href="../483/93483.xml">
Web Services</link> including the following:
<list>
<entry level="1" type="bullet">

 <b><link xlink:type="simple" xlink:href="../529/185529.xml">
scalability</link>:</b> the challenge of scaling up concurrency both locally and nonlocally.</entry>
<entry level="1" type="bullet">

 <b><link xlink:type="simple" xlink:href="../091/351091.xml">
transparency</link>:</b>  bridging the chasm between local and nonlocal concurrency.  Transparency is currently a controversial issue. Some researchers have advocated a strict separation between local concurrency using concurrent programming languages (e.g. <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
) from nonlocal concurrency using <link xlink:type="simple" xlink:href="../215/29215.xml">
SOAP</link> for <link xlink:type="simple" xlink:href="../483/93483.xml">
Web services</link>.  Strict separation produces a lack of transparency that causes problems when it is desirable/necessary to change between local and nonlocal access to Web Services (see <link xlink:type="simple" xlink:href="../501/8501.xml">
distributed computing</link>).</entry>
<entry level="1" type="bullet">

 <b><link xlink:type="simple" xlink:href="../802/75802.xml">
inconsistency</link>:</b> Inconsistency is the norm because all very large knowledge systems about human information system interactions are inconsistent.  This inconsistency extends to the documentation and specifications of very large systems (e.g. Microsoft Windows software, etc.), which are internally inconsistent.</entry>
</list>
</p>
<p>

Many of the ideas introduced in the Actor model are now also finding application in <link xlink:type="simple" xlink:href="../833/938833.xml">
multi-agent systems</link> for these same reasons [Hewitt 2006b 2007b]. The key difference is that agent systems (in most definitions) impose extra constraints upon the Actors, typically requiring that they make use of commitments and goals.</p>
<p>

The Actor model is also being applied to client  <link xlink:type="simple" xlink:href="../494/19541494.xml">
cloud computing</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref>.</p>

</sec>
<sec>
<st>
Actor researchers</st>
<p>

Important contributions to the semantics of Actors have been made by: Gul Agha, Beppe Attardi, Henry Baker, Will Clinger, Irene Grief, Carl Manning, Ian Mason, Ugo Montanari, Maria Simi, Scott Smith, Carolyn Talcott, Prasanna Thati, and Aki Yonezawa.</p>
<p>

Important contributions to the implementation of Actors have been made by: Bill Athas, Russ Atkinson, Beppe Attardi, Henry Baker, Gerry Barber, Peter Bishop, Nanette Boden, Jean-Pierre Briot, Bill Dally, Peter de Jong, Jessie Dedecker, Ken Kahn, Henry Lieberman, Carl Manning, Tom Reinhardt, Chuck Seitz, Richard Steiger, Dan Theriault, Mario Tokoro, Darrell Woelk, and Carlos Varela.</p>

<ss1>
<st>
 Programming with Actors </st>
<p>

A number of different programming languages employ the Actor model or some variation of it. These languages include:</p>
<p>

<list>
<entry level="1" type="bullet">

 Act 1, 2 and 3 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2220%22])">20</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../046/1377046.xml">
E programming language</link></entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../646/9646.xml">
Erlang</link></programming_language>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interpreter wordnetid="110212501" confidence="0.8">
<mediator wordnetid="109624559" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<negotiator wordnetid="110351874" confidence="0.8">
<link xlink:type="simple" xlink:href="../636/8069636.xml">
Gambit-C</link></negotiator>
</writer>
</causal_agent>
</compiler>
</mediator>
</interpreter>
</person>
</communicator>
</physical_entity>
 (with Termite)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../340/323340.xml">
Io language</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../630/4536630.xml">
Ptolemy Project</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../175/5999175.xml">
Rebeca Modeling Language</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../513/2344513.xml">
SALSA</link></entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/3254510.xml">
Scala</link></programming_language>
 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref></entry>
</list>
</p>
<p>

Actor libraries or frameworks have also been implemented to permit actor-style programming in languages that don't have actors built-in. Among these frameworks are:
<list>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<rug wordnetid="104118021" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<furnishing wordnetid="103405265" confidence="0.8">
<covering wordnetid="103122748" confidence="0.8">
<floor_cover wordnetid="103366823" confidence="0.8">
<link xlink:type="simple" xlink:href="../884/1094884.xml">
Kilim</link></floor_cover>
</covering>
</furnishing>
</instrumentality>
</rug>
</artifact>
 - a message-passing framework for <link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref></entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../364/864364.xml">
Data flow</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../962/26962.xml">
Special relativity</link> (specifically, <process wordnetid="105701363" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../142/3406142.xml">
Relativity of simultaneity</link></higher_cognitive_process>
</theory>
</explanation>
</thinking>
</process>
) and <link xlink:type="simple" xlink:href="../202/25202.xml">
Quantum physics</link>, for some physical motivation for the <knowledge_domain wordnetid="105999266" confidence="0.8">
<discipline wordnetid="105996646" confidence="0.8">
<mathematics wordnetid="106000644" confidence="0.8">
<science wordnetid="105999797" confidence="0.8">
<link xlink:type="simple" xlink:href="../283/2194283.xml">
Actor model theory</link></science>
</mathematics>
</discipline>
</knowledge_domain>
</entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../833/938833.xml">
Multi-agent system</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

 <link>
Neural networks</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../995/2058995.xml">
Scientific Community Metaphor</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
Carl Hewitt;&#32;Peter Bishop and Richard Steiger&#32;(1973).&#32;"<it><weblink xlink:type="simple" xlink:href="http://dli.iiit.ac.in/ijcai/IJCAI-73/PDF/027B.pdf">
A Universal Modular Actor Formalism for Artificial Intelligence</weblink></it>". &#32;IJCAI.</entry>
<entry id="2">
<link xlink:type="simple" xlink:href="../454/5435454.xml">
William Clinger</link>&#32;(June 1981).&#32;"<it>[https://dspace.mit.edu/handle/1721.1/6935 Foundations of Actor Semantics]</it>". &#32;Mathematics Doctoral Dissertation.&#32;MIT.</entry>
<entry id="3">
<link>
Irene Greif</link>&#32;(August 1975).&#32;"<it>Semantics of Communicating Parallel Processes</it>". &#32;EECS Doctoral Dissertation.&#32;MIT.</entry>
<entry id="4">
<link xlink:type="simple" xlink:href="../214/5687214.xml">
Henry Baker</link>;&#32;<person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../592/2055592.xml">
Carl Hewitt</link></person>
&#32;(August 1977).&#32;"<it>Laws for Communicating Parallel Processes</it>". &#32;IFIP.</entry>
<entry id="5">
Gul Agha&#32;(1986).&#32;"<it>[https://dspace.mit.edu/handle/1721.1/6952 Actors: A Model of Concurrent Computation in Distributed Systems]</it>". &#32;Doctoral Dissertation.&#32;MIT Press.</entry>
<entry id="6">
 <cite style="font-style:normal">Gul Agha; Ian Mason, Scott Smith, and Carolyn Talcott&#32;(January 1993).&#32;"A Foundation for Actor Computation". <it>Journal of Functional Programming</it>.</cite>&nbsp;</entry>
<entry id="7">
<person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../592/2055592.xml">
Carl Hewitt</link></person>
&#32;(2006-04-27).&#32;"<it><weblink xlink:type="simple" xlink:href="http://www.pcs.usp.br/~coin-aamas06/10_commitment-43_16pages.pdf">
What is Commitment? Physical, Organizational, and Social</weblink></it>". &#32;COIN@AAMAS.</entry>
<entry id="8">
Mauro Gaspari;&#32;Gianluigi Zavattaro&#32;(May 1997).&#32;"<it>An Algebra of Actors</it>". &#32;Technical Report UBLCS-97-4.&#32;University of Bologna.</entry>
<entry id="9">
M. Gaspari;&#32;G. Zavattaro&#32;(1999).&#32;"<it>An Algebra of Actors</it>". &#32;Formal Methods for Open Object Based Systems.</entry>
<entry id="10">
<link xlink:type="simple" xlink:href="../807/14959807.xml">
Gul Agha</link>;&#32;Prasanna Thati&#32;(2004).&#32;"<it><weblink xlink:type="simple" xlink:href="http://formal.cs.uiuc.edu/papers/ATactors_festschrift.pdf">
An Algebraic Theory of Actors and Its Application to a Simple Object-Based Language</weblink></it>". &#32;From OO to FM (Dahl Festschrift) LNCS 2635.</entry>
<entry id="11">
John Darlington;&#32;Y. K. Guo&#32;(1994).&#32;"<it>Formalizing Actors in Linear Logic</it>". &#32;International Conference on Object-Oriented Information Systems.</entry>
<entry id="12">
 <cite style="font-style:normal"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../449/1449.xml">
Kay, Alan</link></scientist>
</person>
&#32;(March 1993).&#32;"<weblink xlink:type="simple" xlink:href="http://www.smalltalk.org/downloads/papers/SmalltalkHistoryHOPL.pdf">
The Early History of Smalltalk</weblink>". <it>ACM SIGPLAN</it>&#32;<b>28</b>&#32;(3): 69–75. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F155360.155364">
10.1145/155360.155364</weblink>.</cite>&nbsp;</entry>
<entry id="13">
 <cite style="font-style:normal" class="book">Brinch-Hansen, Per&#32;(2002). The Origins of Concurrent Programming: From Semaphores to Remote Procedure Calls.&#32;Springer. ISBN 978-0387954011.</cite>&nbsp;</entry>
<entry id="14">
Per Brinch Hansen, <it>Monitors and Concurrent Pascal: A Personal History</it>, Comm. ACM 1996, pp 121-172</entry>
<entry id="15">
<link xlink:type="simple" xlink:href="../434/39434.xml">
C.A.R. Hoare</link>, <it>Monitors: An Operating System Structuring Concept</it>, Comm. ACM Vol. 17, No. 10. October 1974, pp. 549-557</entry>
<entry id="17">
Robin Milner. Processes: A Mathematical Model of Computing Agents in Logic Colloquium 1973.</entry>
<entry id="16">
Brinch Hansen, P.,  <it>Operating System Principles</it>, Prentice-Hall, July 1973.</entry>
<entry id="19">
 <cite style="font-style:normal">Carl Hewitt&#32;(September/October 2008).&#32;"ORGs for Scalable, Robust, Privacy-Friendly Client Cloud Computing". <it>IEEE Internet Computing</it>&#32;<b>12</b>&#32;(5).</cite>&nbsp; </entry>
<entry id="18">
C.A.R. Hoare. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=359585&amp;dl=GUIDE&amp;coll=GUIDE&amp;CFID=19884966&amp;CFTOKEN=55490895">
Communicating sequential processes</weblink> CACM. August 1978.</entry>
<entry id="21">
Henry Lieberman.&#32;"<it>Thinking About Lots of Things at Once without Getting Confused: Parallelism in Act 1</it>". &#32;MIT AI memo 626.</entry>
<entry id="20">
Henry Lieberman.&#32;"<it>A Preview of Act 1</it>". &#32;MIT AI memo 625.</entry>
<entry id="23">
Philipp Haller and Martin Odersky.&#32;"<it><weblink xlink:type="simple" xlink:href="http://lamp.epfl.ch/~phaller/doc/haller07coord.pdf">
Actors that Unify Threads and Events</weblink></it>". &#32;Technical report LAMP 2007.</entry>
<entry id="22">
Philipp Haller and Martin Odersky.&#32;"<it><weblink xlink:type="simple" xlink:href="http://lampwww.epfl.ch/~odersky/papers/jmlc06.pdf">
Event-Based Programming without Inversion of Control</weblink></it>". &#32;Proc. JMLC 2006.</entry>
<entry id="24">
 <cite style="font-style:normal">Srinivasan, Sriram;&#32;Alan Mycroft&#32;(2008). "<weblink xlink:type="simple" xlink:href="http://www.malhar.net/sriram/kilim/kilim_ecoop08.pdf">
Kilim: Isolation-Typed Actors for Java</weblink>".&#32;<it>European Conference on Object Oriented Programming ECOOP 2008</it>. Retrieved on <link>
2008-07-24</link>.</cite>&nbsp;. </entry>
</reflist>
</p>

</sec>
<sec>
<st>
Further reading</st>

<p>

<list>
<entry level="1" type="bullet">

Paul Baran. <b>On Distributed Communications Networks</b> <link>
IEEE Transactions on Communications Systems</link>. March 1964.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../085/661085.xml">
Peter Landin</link>.  <b>A Generalization of Jumps and Labels</b>  Report.  UNIVAC Systems Programming Research.  August 1965.  Reprinted in Higher Order and Symbolic Computation.  1998.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> <b>Solution of a Problem in Concurrent Programming Control</b> <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
CACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
. 1965.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../765/974765.xml">
Jack Dennis</link></associate>
</creator>
</originator>
</scientist>
</causal_agent>
</colleague>
</engineer>
</pioneer>
</person>
</peer>
</physical_entity>
 and <link>
Earl Van Horn</link>. <b>Programming Semantics for Multiprogrammed Computations</b> CACM.  March 1966.</entry>
<entry level="1" type="bullet">

<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../188/64188.xml">
Ole-Johan Dahl</link></scientist>
</person>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../741/72741.xml">
Kristen Nygaard</link></scientist>
</person>
. <b>Class and subclass declarations</b> IFIP TC2 Conference on Simulation Programming Languages. May 1967.</entry>
<entry level="1" type="bullet">

<person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../592/2055592.xml">
Carl Hewitt</link></person>
. <b>PLANNER: A Language for Proving Theorems in Robots</b> IJCAI 1969</entry>
<entry level="1" type="bullet">

William A. Woods. <b>Transition network grammars for natural language analysis</b> CACM. 1970.</entry>
<entry level="1" type="bullet">

Terry Winograd. <b>Procedures as a Representation for Data in a Computer Program for Understanding Natural Language</b>  MIT AI TR-235.  January 1971.</entry>
<entry level="1" type="bullet">

Carl Hewitt. <b>Procedural Embedding of Knowledge In Planner</b> IJCAI 1971. </entry>
<entry level="1" type="bullet">

G.M. Birtwistle, Ole-Johan Dahl, B. Myhrhaug and Kristen Nygaard. <b>SIMULA Begin</b> Auerbach Publishers Inc, 1973.</entry>
<entry level="1" type="bullet">

Daniel Bobrow: <b>A Model for Control Structures for Artificial Intelligence Programming Languages</b> IJCAI 1973. </entry>
<entry level="1" type="bullet">

Carl Hewitt, <it>et al.</it> <b>Actor Induction and Meta-evaluation</b> Conference Record of ACM Symposium on Principles of Programming Languages, January 1974.</entry>
<entry level="1" type="bullet">

Carl Hewitt, <it>et al.</it> <b>Behavioral Semantics of Nonrecursive Control Structure</b>   Proceedings of Colloque sur la Programmation, April 1974.</entry>
<entry level="1" type="bullet">

Irene Greif and Carl Hewitt.  <b>Actor Semantics of PLANNER-73</b> Conference Record of ACM Symposium on Principles of Programming Languages. January 1975.</entry>
<entry level="1" type="bullet">

Carl Hewitt. <b>How to Use What You Know</b> IJCAI. September, 1975.</entry>
<entry level="1" type="bullet">

Alan Kay and Adele Goldberg.  <b>Smalltalk-72 Instruction Manual</b>  Xerox PARC Memo SSL-76-6.  May 1976.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link>. <b>A discipline of programming</b> Prentice Hall. 1976. </entry>
<entry level="1" type="bullet">

Carl Hewitt and Henry Baker <b><weblink xlink:type="simple" xlink:href="http://www.lcs.mit.edu/publications/pubs/pdf/MIT-LCS-TR-194.pdf">
Actors and Continuous Functionals</weblink></b>  Proceeding of IFIP Working Conference on Formal Description of Programming Concepts. August 1-5, 1977.</entry>
<entry level="1" type="bullet">

Henry Baker and Carl Hewitt <b>The Incremental Garbage Collection of Processes</b> Proceeding of the Symposium on Artificial Intelligence Programming Languages. SIGPLAN Notices 12, August 1977.</entry>
<entry level="1" type="bullet">

Gilles Kahn and David MacQueen. <b>Coroutines and networks of parallel processes</b> IFIP. 1977</entry>
<entry level="1" type="bullet">

Aki Yonezawa <b>Specification and Verification Techniques for Parallel Programs Based on Message Passing Semantics</b> MIT EECS Doctoral Dissertation. December 1977.</entry>
<entry level="1" type="bullet">

Carl Hewitt. <b>Viewing Control Structures as Patterns of Passing Messages</b> Journal of Artificial Intelligence. June 1977.</entry>
<entry level="1" type="bullet">

Henry Baker. <b>Actor Systems for Real-Time Computation</b> MIT EECS Doctoral Dissertation. January 1978.</entry>
<entry level="1" type="bullet">

Carl Hewitt and Russ Atkinson.  <b><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=512975&amp;coll=portal&amp;dl=ACM">
Synchronization in Actor Systems</weblink></b> Proceedings of the 4th ACM SIGACT-SIGPLAN symposium on Principles of programming languages. 1977</entry>
<entry level="1" type="bullet">

Carl Hewitt and Russ Atkinson.  <b>Specification and Proof Techniques for Serializers</b> IEEE Journal on Software Engineering. January 1979.</entry>
<entry level="1" type="bullet">

Ken Kahn. <b>A Computational Theory of Animation</b> MIT EECS Doctoral Dissertation. August 1979.</entry>
<entry level="1" type="bullet">

Carl Hewitt, Beppe Attardi, and Henry Lieberman.  <b>Delegation in Message Passing</b> Proceedings of First International Conference on Distributed Systems Huntsville, AL. October 1979.</entry>
<entry level="1" type="bullet">

Nissim Francez, C.A.R. Hoare, Daniel Lehmann, and <link>
Willem-Paul de Roever</link>.  <b>Semantics of nondetermiism, concurrency, and communication</b>  Journal of Computer and System Sciences.  December 1979.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../216/6029216.xml">
George Milne</link> and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../547/93547.xml">
Robin Milner</link></scientist>
</person>
.  <b>Concurrent processes and their syntax</b>  JACM.  April 1979.</entry>
<entry level="1" type="bullet">

Russ Atkinson.  <b>Automatic Verification of Serializers</b> MIT Doctoral Dissertation. June, 1980.</entry>
<entry level="1" type="bullet">

Bill Kornfeld and Carl Hewitt.  <b>The Scientific Community Metaphor</b> IEEE Transactions on Systems, Man, and Cybernetics.  January 1981.</entry>
<entry level="1" type="bullet">

Bill Kornfeld.  <b>Parallelism in Problem Solving</b> MIT EECS Doctoral Dissertation. August 1981.</entry>
<entry level="1" type="bullet">

Daniel Theriault.  <b>A Primer for the Act-1 Language</b>  MIT AI memo 672. April 1982.</entry>
<entry level="1" type="bullet">

Daniel Theriault.  <b>Issues in the Design and Implementation of Act 2</b>  MIT AI technical report 728. June 1983.</entry>
<entry level="1" type="bullet">

Henry Lieberman.  <b>An Object-Oriented Simulator for the Apiary</b> Conference of the American Association for Artificial Intelligence, Washington, D. C., August 1983</entry>
<entry level="1" type="bullet">

Carl Hewitt and Peter de Jong.  <b>Analyzing the Roles of Descriptions and Actions in Open Systems</b> Proceedings of the National Conference on Artificial Intelligence. August 1983.</entry>
<entry level="1" type="bullet">

Carl Hewitt and Henry Lieberman.  <b>Design Issues in Parallel Architecture for Artificial Intelligence</b> MIT AI memo 750.  Nov. 1983.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../608/1337608.xml">
Daniel Ingalls</link>.  <b>The Evolution of the Smalltalk Virtual Machine</b> in Smalltalk-80:  Bits of History, Words of Advice.  Addison Wesley.  1983.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../535/382535.xml">
Hal Abelson</link></research_worker>
</scholar>
</mathematician>
</causal_agent>
</academician>
</alumnus>
</computer_user>
</associate>
</educator>
</professional>
</adult>
</scientist>
</engineer>
</colleague>
</intellectual>
</programmer>
</specialist>
</interior_designer>
</person>
</expert>
</peer>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/96431.xml">
Gerald Jay Sussman</link></research_worker>
</mathematician>
</causal_agent>
</academician>
</computer_user>
</associate>
</educator>
</professional>
</adult>
</scientist>
</engineer>
</colleague>
</programmer>
</specialist>
</interior_designer>
</person>
</peer>
</expert>
</physical_entity>
 and Julie Sussman, <b>Structure and Interpretation of Computer Programs</b> MIT Press and McGraw-Hill, 1985.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../434/39434.xml">
C.A.R. Hoare</link>.  <b><weblink xlink:type="simple" xlink:href="http://www.usingcsp.com/">
Communicating Sequential Processes</weblink></b>  Prentice Hall.  1985.</entry>
<entry level="1" type="bullet">

Carl Hewitt. <b>The Challenge of Open Systems</b> Byte Magazine. April 1985.  Reprinted in <it>The foundation of artificial intelligence---a sourcebook</it> Cambridge University Press. 1990.</entry>
<entry level="1" type="bullet">

Carl Manning. <b>Traveler: the actor observatory</b> ECOOP 1987. Also appears in <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<series wordnetid="108457976" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../159/2578159.xml">
Lecture Notes in Computer Science</link></publication>
</group>
</periodical>
</ordering>
</arrangement>
</artifact>
</creation>
</series>
</product>
</work>
, vol. 276.</entry>
<entry level="1" type="bullet">

William Athas and Charles Seitz <b>Multicomputers:  message-passing concurrent computers</b> IEEE Computer August 1988.</entry>
<entry level="1" type="bullet">

William Athas and Nanette Boden <b>Cantor: An Actor Programming System for Scientific Computing</b> in Proceedings of the NSF Workshop on Object-Based Concurrent Programming.  1988.  Special Issue of SIGPLAN Notices.</entry>
<entry level="1" type="bullet">

Jean-Pierre Briot.  <b>From objects to actors: Study of a limited symbiosis in Smalltalk-80</b> Rapport de Recherche 88-58, RXF-LITP, Paris, France, September 1988</entry>
<entry level="1" type="bullet">

William Dally and Wills, D. <b>Universal mechanisms for concurrency</b> PARLE 1989.</entry>
<entry level="1" type="bullet">

W. Horwat, A. Chien, and W. Dally. <b>Experience with CST:  Programming and Implementation</b> PLDI. 1989.  </entry>
<entry level="1" type="bullet">

Carl Hewitt.  <b>Towards Open Information Systems Semantics</b> Proceedings of 10th International Workshop on Distributed Artificial Intelligence. October 23-27, 1990. Bandera, Texas.</entry>
<entry level="1" type="bullet">

Akinori Yonezawa, Ed. <b>ABCL: An Object-Oriented Concurrent System</b> MIT Press. 1990.</entry>
<entry level="1" type="bullet">

 K. Kahn and Vijay A. Saraswat, "<weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/97946.97955">
Actors as a special case of concurrent constraint (logic) programming</weblink>", in SIGPLAN <it>Notices</it>, October 1990.  Describes <link xlink:type="simple" xlink:href="../771/4051771.xml">
Janus</link>.</entry>
<entry level="1" type="bullet">

Carl Hewitt.  <b>Open Information Systems Semantics</b> Journal of Artificial Intelligence. January 1991.</entry>
<entry level="1" type="bullet">

Carl Hewitt and Jeff Inman.  <b>DAI Betwixt and Between:  From "Intelligent Agents" to Open Systems Science</b> IEEE Transactions on Systems, Man, and Cybernetics.  Nov./Dec. 1991.</entry>
<entry level="1" type="bullet">

Carl Hewitt and Gul Agha.  <b>Guarded Horn clause languages: are they deductive and Logical?</b> International Conference on Fifth Generation Computer Systems, Ohmsha 1988. Tokyo.  Also in <it>Artificial Intelligence at MIT</it>, Vol. 2. MIT Press 1991. </entry>
<entry level="1" type="bullet">

William Dally, <it>et al.</it> <b>The Message-Driven Processor: A Multicomputer Processing Node with Efficient Mechanisms</b> <link>
IEEE Micro</link>. April 1992.</entry>
<entry level="1" type="bullet">

S. Miriyala, G. Agha, and Y.Sami. <b>Visulatizing actor programs using predicate transition nets</b> Journal of Visual Programming. 1992.</entry>
<entry level="1" type="bullet">

Alan Kay.  <b><weblink xlink:type="simple" xlink:href="http://www.smalltalk.org/smalltalk/TheEarlyHistoryOfSmalltalk_Abstract.html">
The Early History of Smalltalk</weblink></b> The second ACM conference on history of programming languages.  1993.</entry>
<entry level="1" type="bullet">

Carl Hewitt and Carl Manning.  <b>Negotiation Architecture for Large-Scale Crisis Management</b> AAAI-94 Workshop on Models of Conflict Management in Cooperative Problem Solving. Seattle, WA. Aug. 4, 1994.</entry>
<entry level="1" type="bullet">

Darrell Woelk.   <b>Developing InfoSleuth Agents Using Rosette: An Actor Based Language</b> Proceedings of the CIKM '95 Workshop on Intelligent Information Agents.  1995.</entry>
<entry level="1" type="bullet">

Carl Hewitt and Carl Manning.  <b>Synthetic Infrastructures for Multi-Agency Systems</b> Proceedings of ICMAS '96. Kyoto, Japan. December 8&ndash;13, 1996.</entry>
<entry level="1" type="bullet">

S. Frolund. <b>Coordinating Distributed Objects: An Actor-Based Approach for Synchronization</b> MIT Press. November 1996.</entry>
<entry level="1" type="bullet">

W. Kim. <b>ThAL: An Actor System for Efficient and Scalable Concurrent Computing</b> PhD thesis. University of Illinois at Urbana Champaign. 1997.</entry>
<entry level="1" type="bullet">

Jean-Pierre Briot. <b>Acttalk: A framework for object-oriented concurrent programming-design and experience</b> 2nd France-Japan workshop. 1999.</entry>
<entry level="1" type="bullet">

N. Jamali, P. Thati, and G. Agha. <b>An actor based architecture for customizing and controlling agent ensembles</b> IEEE Intelligent Systems. 14(2). 1999.</entry>
<entry level="1" type="bullet">

Don Box, David Ehnebuske, Gopal Kakivaya, Andrew Layman, Noah Mendelsohn, Henrik Nielsen, Satish Thatte, Dave Winer. <b>Simple Object Access Protocol (SOAP) 1.1</b> <link xlink:type="simple" xlink:href="../434/33434.xml">
W3C</link> Note. May 2000.</entry>
<entry level="1" type="bullet">

M. Astley, D. Sturman, and G. Agha. <b>Customizable middleware for modular distributed software</b> CACM. 44(5) 2001.</entry>
<entry level="1" type="bullet">

Carlos Varela. <b>Worldwide Computing with Universal Actors: Linguistic Abstractions for Naming, Migration, and Coordination</b> PhD thesis. U. of Illinois at Urbana-Champaign. 2001.</entry>
<entry level="1" type="bullet">

N. Venkatasubramanian, C. Talcott, and G. Agha. <b>A formal model for reasoning about adaptive QoS-enabled middleware</b> Formal Methods Europe (FME).  2001.</entry>
<entry level="1" type="bullet">

Edward Lee, S. Neuendorffer, and M. Wirthlin. <weblink xlink:type="simple" xlink:href="http://ptolemy.eecs.berkeley.edu/papers/02/actorOrientedDesign/newFinal.pdf">
<b>Actor-oriented design of embedded hardware and software systems</b></weblink> Journal of circuits, systems, and computers. 2002.</entry>
<entry level="1" type="bullet">

P. Thati, R. Ziaei, and G. Agha. <b>A Theory of May Testing for Actors</b> Formal Methods for Open Object-based Distributed Systems. March 2002.</entry>
<entry level="1" type="bullet">

P. Thati, R. Ziaei, and G. Agha. <b>A theory of may testing for asynchronous calculi with locality and no name matching</b> Algebraic Methodology and Software Technology. Springer Verlag. September 2002. LNCS 2422.</entry>
<entry level="1" type="bullet">

Gul Agha and Carlos Varela. <b>Worldwide Computing Middleware</b> Practical Handbook on Internet Computing. CRC Press, 2004.</entry>
<entry level="1" type="bullet">

Stephen Neuendorffer.  <weblink xlink:type="simple" xlink:href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2005/ERL-05-1.pdf">
<b>Actor-Oriented Metaprogramming</b></weblink> PhD Thesis. University of California, Berkeley. December, 2004</entry>
<entry level="1" type="bullet">

Carl Hewitt (2006a)  <b>The repeated demise of logic programming and why it will be reincarnated</b>   What Went Wrong and Why: Lessons from AI Research and Applications.  Technical Report SS-06-08. AAAI Press.  March 2006.</entry>
<entry level="1" type="bullet">

Carl Hewitt (2006b) <weblink xlink:type="simple" xlink:href="http://www.pcs.usp.br/~coin-aamas06/10_commitment-43_16pages.pdf">
<it>What is Commitment? Physical, Organizational, and Social''</it></weblink>  COIN@AAMAS.  April 27, 2006b.</entry>
<entry level="1" type="bullet">

Carl Hewitt (2007a) <b>What is Commitment? Physical, Organizational, and Social (Revised)</b> Pablo Noriega .et al. editors. LNAI 4386. Springer-Verlag. 2007.</entry>
<entry level="1" type="bullet">

Carl Hewitt (2007b) <b>Large-scale Organizational Computing requires Unstratified Paraconsistency and Reflection</b> COIN@AAMAS'07.</entry>
</list>
</p>


</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 A now dated set of speculations by Paul Mackay can be found at <weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~nd/surprise_97/journal/vol2/pjm2/">
<it>Why has the actor model not succeeded?''</it></weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.irit.fr/PERSONNEL/SMAC/arcangeli/JavAct.html">
JavAct</weblink> - a Java library for programming concurrent, distributed, and mobile applications using the actor model (and open implementation principles).</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://functionaljava.org/">
Functional Java</weblink> - a Java library of that includes an implementation of concurrent actors with code examples in standard Java and Java 7 BGGA style.</entry>
</list>
</p>


</sec>
</bdy>
</article>
