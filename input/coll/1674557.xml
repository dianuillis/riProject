<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:49:41[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Meta-Process Modeling</title>
<id>1674557</id>
<revision>
<id>237412989</id>
<timestamp>2008-09-10T01:49:56Z</timestamp>
<contributor>
<username>Mdd</username>
<id>113850</id>
</contributor>
</revision>
<categories>
<category>Software development process</category>
<category>Unified Modeling Language</category>
<category>Systems engineering</category>
</categories>
</header>
<bdy>

<b>Meta-process modeling</b> is a type of <link xlink:type="simple" xlink:href="../626/1674626.xml">
metamodeling</link> used in <link xlink:type="simple" xlink:href="../010/27010.xml">
software engineering</link> and <link xlink:type="simple" xlink:href="../764/27764.xml">
systems engineering</link> for the analysis and construction of models applicable and useful some predefined problems. Meta-process support the effort of creating flexible <link xlink:type="simple" xlink:href="../621/1674621.xml">
process model</link>s. The purpose of process models is to document and communicate processes and to enhance the reuse of processes. Thus, processes can be better taught and executed. Results of using meta-process models are an increased productivity of process engineers and an improved quality of the models they produce .
<sec>
<st>
 Overview </st>
<p>

<image location="right" width="350px" src="meta-levels.png" type="thumb">
<caption>

Abstraction level for processes <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.
</caption>
</image>

Meta-process modeling focuses on and supports the process of construction <link xlink:type="simple" xlink:href="../621/1674621.xml">
Process Model</link>s. Its main concern is to improve process models and to make them evolve, which in turn, will support the development of systems <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. This is important due to the fact that “<link xlink:type="simple" xlink:href="../766/4746766.xml">
Processes</link> change with time and so do the <link xlink:type="simple" xlink:href="../621/1674621.xml">
Process Model</link>s underlying them. Thus, new processes and models may have to be built and existing ones improved” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. “The focus has been to increase the level of formality of process models in order to make possible their enactment in process-centred software environments” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> referring to <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>.</p>
<p>

A process meta-model is a <link xlink:type="simple" xlink:href="../626/1674626.xml">
meta model</link>, “a description at the type level of a process model. A process model is, thus, an instantiation of a process meta-model. [..] A meta-model can be instantiated several times in order to define various process models. A process meta-model is at the meta-type level with respect to a process.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>
There exists standards for several domains:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../010/27010.xml">
Software Engineering</link></entry>
<entry level="1" type="bullet">

 Software Process Engineering Metamodel (SPEM) which is defined as a <link xlink:type="simple" xlink:href="../365/7789365.xml">
Profile (UML)</link> by the <link xlink:type="simple" xlink:href="../637/22637.xml">
Object Management Group</link>.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Topics in metadata modeling </st>
<p>

There are different techniques for constructing process models. “Construction techniques used in the <link xlink:type="simple" xlink:href="../495/237495.xml">
Information Systems</link> area have developed independently of those in <link xlink:type="simple" xlink:href="../010/27010.xml">
Software Engineering</link>. In information systems, construction techniques exploit the notion of a meta-model and the two principal techniques used are those of <it>instantiation</it> and <it>assembly</it>. In software engineering the main construction technique used today is language-based. However, early techniques in both, information systems and software engineering were based on the experience of process engineers and were, therefore, <it>ad-hoc</it> in nature.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

<ss1>
<st>
 Ad-hoc </st>
<p>

“Traditional process models are expressions of the experiences of their developers. Since this experience is not formalised and is, consequently, not available as a fund of knowledge, it can be said that these process models are the result of an ad-hoc construction technique. This has two major consequences: it is not possible to know how these process models were generated, and they become dependent on the domain of experience. If process models are to be domain independent and if they are to be rapidly generable and modifiable, then we need to go away from experience based process model construction. Clearly, generation and modifiability relate to the process management policy adopted (see Usage World). Instantiation and assembly, by promoting modularization, facilitate the capitalisation of good practice and the improvement of given process models.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

</ss1>
<ss1>
<st>
 Assembly </st>
<p>

The assembly technique is based on the idea of a process repository from which process components can be selected. Rolland 1998 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> lists two selection strategies:
<list>
<entry level="1" type="number">

Promoting a <it>global</it> analysis of the project on hand based on contingency criteria (Example Van Slooten 1996 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>)</entry>
<entry level="1" type="number">

Using the notion of descriptors <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> as a means to describe process chunks. This eases the retrieval of components meeting the requirements of the user / matching with the situation at hand. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></entry>
</list>

(Example Plihon 1995 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> in NATURE () and repository of scenario based approaches accessible on Internet in the CREWS project <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref>)</p>
<p>

“For the assembly technique to be successful, it is necessary that process models are modular. If the assembly technique is combined with the instantiation technique then the meta-model must itself be modular.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

</ss1>
<ss1>
<st>
 Instantiation </st>
<p>

For reusing processes a meta-process model identifies “the common, generic features of process models and represents them in a system of concepts. Such a representation has the potential to 'generate' all process models that share these features. This potential is realised when a generation technique is defined whose application results in the desired process model.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

Process models are then derived from the process meta-models through <it>instantiation</it>. Rolland <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> associates a number of advantages with the instantiation approach:
<list>
<entry level="1" type="number">

The exploitation of the meta-model helps to define a wide range of process models.</entry>
<entry level="1" type="number">

It makes the activity of defining process models systematic and versatile.</entry>
<entry level="1" type="number">

It forces to look for and introduce, in the process meta-model, generic solutions to problems and this makes the derived process models inherit the solution characteristics.</entry>
</list>
</p>
<p>

“The instantiation technique has been used, for example, in NATURE <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref>, Rolland 1993 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, Rolland 1994 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref>, and Rolland 1996 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref>. The process engineer must define the instances of contexts and relationships that comprise the process model of interest.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>.</p>

</ss1>
<ss1>
<st>
 Language </st>
<p>

Rolland 1998 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> lists numerous languages for expressing process models used by the software engineering community:
<list>
<entry level="1" type="bullet">

E3 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></entry>
<entry level="1" type="bullet">

various Prolog dialects for EPOS <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref>, Oikos <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>, and PEACE <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></entry>
<entry level="1" type="bullet">

PS-Algol for PWI <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>)</entry>
</list>

as well as further computational paradigms:
<list>
<entry level="1" type="bullet">

Petri nets in EPOS <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref> and SPADE <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref></entry>
<entry level="1" type="bullet">

rule based paradigm in MERLIN <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref></entry>
<entry level="1" type="bullet">

ALF <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref></entry>
<entry level="1" type="bullet">

Marvel <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref></entry>
<entry level="1" type="bullet">

EPOS <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></entry>
<entry level="1" type="bullet">

triggers in ADELE <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2220%22])">20</ref> and MVP-L <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>). </entry>
</list>
</p>
<p>

“Languages are typically related to process programs whereas instantiation techniques have been used to construct process scripts.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

</ss1>
<ss1>
<st>
 Tool support </st>
<p>

The Meta-modeling process is often supported through software tools, called <link>
CAME</link> tools (Computer Aided Method Engineering) or <link>
Meta-CASE</link> tools (Computer Assisted Software Engineering tools on a Meta-level).
Often the instantiation technique “has been utilised to build the repository of Computer Aided Method Engineering environments” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> (referring to <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref>, <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref>, <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref>, <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref>). </p>
<p>

Example tools for meta-process modeling are <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2225%22])">25</ref>. :
<list>
<entry level="1" type="bullet">

Maestro II <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../262/6221262.xml">
MetaEdit+</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref></entry>
<entry level="1" type="bullet">

Mentor <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref></entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Example: “Multi-model view”</st>
<p>

Colette Rolland (1999 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>) provides an example of a meta-process model which utilizes the instantiation and assembly technique. In the paper the approach is called “Multi-model view” and was applied on the CREWS-L’Ecritoire method. The CREWS-L’Ecritoire method represents a methodical approach for <link xlink:type="simple" xlink:href="../449/522449.xml">
Requirements Engineering</link>, “the part of the IS development that involves investigating problems and requirements of the users community and developing a specification of the future system, the so-called conceptual schema.” (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, referring to <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2226%22])">26</ref> and <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2227%22])">27</ref>).</p>
<p>

Besides the CREWS-L’Ecritoire approach, the multi-model view has served as a basis for representing <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>:
(a) the three other requirements engineering approaches developed within the CREWS project (Real World Scenes approach <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2228%22])">28</ref>, SAVRE approach for scenario exceptions discovery <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2229%22])">29</ref>,  and the scenario animation approach <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2230%22])">30</ref>) 
(b) for integrating approaches (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2231%22])">31</ref> one with the other and with the OOSE approach <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2232%22])">32</ref>)</p>
<p>

Furthermore, the CREWS-L’Ecritoire utilizes <link xlink:type="simple" xlink:href="../621/1674621.xml">
Process Model</link>s and <link>
Meta-Process Model</link>s in order to achieve flexibility for the situation at hand. The approach is based on the notion of a labelled graph of intentions and strategies called a <it>map</it> as well as its associated <it>guidelines</it> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>. Together, map (process model) and the guidelines form the method.
The main source of this explanation is the elaboration of Colette Rolland in <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>.</p>

<ss1>
<st>
Process model / Map</st>
<p>

The map is “a navigational structure which supports the dynamic selection of the intention to be achieved next and the appropriate strategy to achieve it”; it is “a process model in which a nondeterministic ordering of intentions and strategies has been included. It is a labelled directed graph with intentions as nodes and strategies as edges between intentions. The directed nature of the graph shows which intentions can follow which one.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

The map of the CREWS-L’Ecritoire method looks as follow:</p>
<p>

<image width="600px" src="process-model.png" type="thumb">
<caption>

Process model of the CREWS-L’Ecritoire method <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
</caption>
</image>
</p>
<p>

The map consists of goals / <it>intentions</it> (marked with ovals) which are connected by <it>strategies</it> (symbolized through arrows). An <it>intention</it> is a goal, an objective that the application engineer has in mind at a given point of time. A <it>strategy</it> is an approach, a manner to achieve an intention. The connection of two goals with a strategy is also called <it>section</it>. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

A map “allows the application engineer to determine a path from Start intention to Stop intention. The map contains a finite number of paths, each of them prescribing a way to develop the product, i.e. each of them is a process model. Therefore the map is a multi-model. It embodies several process models, providing a multi-model view for modelling a class of processes. None of the finite set of models included in the map is recommended ‘a priori’. Instead the approach suggests a dynamic construction of the actual path by navigating in the map. In this sense the approach is sensitive to the specific situations as they arise in the process. The next intention and strategy to achieve it are selected dynamically by the application engineer among the several possible ones offered by the map. Furthermore, the approach is meant to allow the dynamic adjunction of a path in the map, i.e. adding a new strategy or a new section in the actual course of the process. In such a case guidelines that make available all choices open to handle a given situation are of great convenience. The map is associated to such guidelines” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>.</p>

</ss1>
<ss1>
<st>
 Guidelines </st>
<p>

A guideline “helps in the operationalisation of the selected intention” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>; it is “a set of indications on how to proceed to achieve an objective or perform an activity” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2233%22])">33</ref>. The description of the guidelines is based on the NATURE project’s contextual approach <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref>, <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2234%22])">34</ref>, <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2235%22])">35</ref> and its corresponding enactment mechanism <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2236%22])">36</ref>.</p>
<p>

Three types of guidelines can be distinguished:
<list>
<entry level="1" type="bullet">

<b>Intention Selection Guidelines (ISG)</b> identify the set of intentions that can be achieved in the next step and selects the corresponding set of either IAGs (only one choice for an intention) or SSGs (several possible intentions).</entry>
<entry level="1" type="bullet">

<b>Strategy Selection Guidelines (SSG)</b> guide the selection of a strategy, thereby leading to the selection of the corresponding IAG.</entry>
<entry level="1" type="bullet">

<b>Intention Achievement Guidelines (IAG)</b> aim at supporting the application engineer in the achievement of an intention according to a strategy, are concerned with the tactics to implement these strategies, might offer several tactics, and thus may contain alternative operational ways to fulfil the intention.</entry>
</list>
</p>
<p>

In our case, the following guidelines – which correspond with the map displayed above – need to be defined:</p>
<p>

<b>Intention Selection Guidelines (ISG)</b></p>
<p>

<list>
<entry level="1" type="number">

ISG-1	Progress from Elicit a goal</entry>
<entry level="1" type="number">

ISG-2	Progress from Conceptualize a Scenario</entry>
<entry level="1" type="number">

ISG-3	Progress from Write a scenario</entry>
<entry level="1" type="number">

ISG-4	Progress from Start</entry>
</list>
</p>
<p>

The following graph displays the details for the Intention Selection Guideline 1 (ISG-1).</p>
<p>

<image location="left" width="300px" src="ISG1.png" type="thumb">
<caption>

Example of an Intention Selection Guideline 1 (ISG-1) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
</caption>
</image>
</p>
<p>

<b>Strategy Selection Guidelines (SSG)</b></p>
<p>

<list>
<entry level="1" type="number">

SSG-1	Progress to Elicit a goal</entry>
<entry level="1" type="number">

SSG-2	Progress to Conceptualize a Scenario</entry>
<entry level="1" type="number">

SSG-3	Progress to Write a scenario</entry>
<entry level="1" type="number">

SSG-4	Progress to Elicit a goal</entry>
<entry level="1" type="number">

SSG-5	Progress to Stop</entry>
</list>
</p>
<p>

The following graph displays the details for the Strategy Selection Guideline 1 (SSG-1).</p>
<p>

<image location="left" width="400px" src="SSG1.png" type="thumb">
<caption>

Example of an Strategy Selection Guideline 1 (SSG-1) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
</caption>
</image>
</p>
<p>

<b>Intention Achievement Guidelines (IAG)</b></p>
<p>

<list>
<entry level="1" type="number">

IAG-1	Elicit a goal with case-based strategy</entry>
<entry level="1" type="number">

IAG-2	Elicit a goal with composition strategy</entry>
<entry level="1" type="number">

IAG-3	Elicit a goal with alternative strategy</entry>
<entry level="1" type="number">

IAG-4	Elicit a goal with refinement strategy</entry>
<entry level="1" type="number">

IAG-5	Elicit a goal with linguistic strategy</entry>
<entry level="1" type="number">

IAG-6	Elicit a goal with template-driven strategy</entry>
<entry level="1" type="number">

IAG-7	Write a scenario with template-driven strategy</entry>
<entry level="1" type="number">

IAG-8	Write a scenario in free prose</entry>
<entry level="1" type="number">

IAG-9	Conceptualize a Scenario with computer support strategy</entry>
<entry level="1" type="number">

IAG-10	Conceptualize a Scenario manually</entry>
<entry level="1" type="number">

IAG-11	Stop with completeness strategy</entry>
</list>

The following graph displays the details for the Intention Achievement Guideline 8 (IAG-8).</p>
<p>

<image location="left" width="400px" src="IAG8.png" type="thumb">
<caption>

Example of an Intention Achievement Guideline 8 (IAG-8) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
</caption>
</image>
</p>


</ss1>
<ss1>
<st>
 Meta-process map </st>
<p>

In the multi-model view as presented in the paper of C. Rolland, the meta-process (the instance of the meta-process model) is “a process for the generation of a path from the map and its instantaneous enactment for the application at hand.” <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

While the meta-process model can be represented in many different ways, a map was chosen again as a means to do so. It is not to be mixed up with the map for the process model as presented above.</p>
<p>

<image location="right" width="400px" src="meta-process-model.png" type="thumb">
<caption>

Meta-process model of the CREWS-L’Ecritoire method <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
</caption>
</image>
</p>
<p>

Colette Rolland describes the meta-model as follow <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>:
(Meta-intentions are in bold, meta-strategies in italic – in green in the map).</p>
<p>

“The <b>Start</b> meta-intention starts the construction of a process by selecting a section in the method map which has map intention Start as source. The <b>Choose Section</b> meta-intention results in the selection of a method map section. The <b>Enact Section</b> meta-intention causes the execution of the method map section resulting from <b>Choose Section</b>. Finally, the <b>Stop</b> meta-intention stops the construction of the application process. This happens when the <b>Enact Section</b> meta-intention leads to the enactment of the method map section having Stop as the target. 
As already explained in the previous sections, there are two ways in which a section of a method map can be selected, namely by selecting an intention or by selecting a strategy. Therefore, the meta-intention <b>Choose Section</b> has two meta-strategies associated with it, <it>select intention</it> and <it>select strategy</it> respectively. Once a method map section has been selected by <b>Choose Section</b>, the IAG to support its enactment must be retrieved; this is represented in [the graph] by associating the meta-strategy <it>automated support</it> with the meta-intention, <b>Enact Section</b>.”</p>


</ss1>
<ss1>
<st>
 Sample process </st>
<p>

The sample process "Eliciting requirements of a Recycling Machine" is about a method for designing the requirements of recycling facilities. The recycling facilities are meant for customers of a supermarket. The adequate method is obtained though instantiation of the meta-process model on the process model.</p>
<p>

The following table displays the stepwise trace of the process to elicit requirements for the recycling machine (from <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>):</p>

<p>

<table cellpadding="0" border="0" cellspacing="5">
<row>
<col valign="top">
Step</col>
<col valign="top">
Guideline</col>
<col valign="top">
Meta-process</col>
<col valign="top">
Process</col>
<col valign="top">
Product (Goal = Gxx)</col>
</row>
<row>
<col valign="top">
1.1</col>
<col valign="top">
SSG-4</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
SSG4 suggests two strategies. The template-driven strategy is chosen because it is the most appropriate way to become familiar with the goal formalisation proposed by the CREWS-L’Ecritoire method</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
1.2</col>
<col valign="top">
IAG-6</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG6 displays a goal statement template and explains the meaning of each parameter. The requirement Engineer (RE) chooses a loose statement having only a verb and a target</col>
<col valign="top">
G1: Provideverb (Recycling Facilities*) target *RF</col>
</row>
<row>
<col valign="top">
2.1</col>
<col valign="top">
ISG-1</col>
<col valign="top">
Choose section with select intention</col>
<col valign="top">
ISG1 provides RE with arguments to advise him on choosing one of the two possible intentions from <it>
Elicit a Goal</it>, namely to <it>Elicit a Goal</it> or to <it>Write a Scenario</it>. The former is selected so as to generate alternative design solutions</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
2.2</col>
<col valign="top">
IAG-1</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG1 uses the goal statement structure and parameter values supplied to generate alternative goals. This leads to 21 alternative goals to G1 which are ORed to G1. After discussion with stakeholders, G4 is selected</col>
<col valign="top">
G2: Provide bottle RF to our customers with a card-based machine; G3: Provide paper RF to our customers with a card-based machine; G4: Provide bottle and box RR to our customers with a card-based machine;  . . . G22: Provide bottle RF to all customers with money return machine</col>
</row>
<row>
<col valign="top">
3.1</col>
<col valign="top">
SSG-3</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
SSG3 offers two strategies from which the template-driven strategy is chosen. This is because there is uncertainty about what a scenerio should be. The templates lead to some certainty</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
3.2</col>
<col valign="top">
IAG-7</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG7 proposes a template to be filled in. The template corresponds to a service scenario and contains actions that express services expected from the system</col>
<col valign="top">
SC4: If the customer gets a card, he recycles objects</col>
</row>
<row>
<col valign="top">
4.1</col>
<col valign="top">
SSG-2</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
SSG2 offers two strategies to conceptualise a Scenario. Among the two strategies, manual and computer based, the former is chosen since the service scenario (SC4) is very simple and can be handled manually</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
4.2</col>
<col valign="top">
IAG-10</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG10 suggests two things: (1) to avoid anaphoric references such as he, she, etc. (2) to express atomic actions in an explicit ordering (3) to avoid ambiguities The scenario is rewritten accordingly</col>
<col valign="top">
SC4: 1. The customer gets a card; 2. The customer recycles boxes and bottles</col>
</row>
<row>
<col valign="top">
5.1</col>
<col valign="top">
SSG-1</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
The RE knows that he wants to analyse the scenario SC4 to discover a new goal. Thus, he knows the target intention ‘Elicit a Goal’ and SSG1 is displayed. SSG1 offers three strategies to discover new goals from scenario analysis. The refinement strategy, is chosen because there is a need to discover the functional requirements of recycling machine</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
5.2</col>
<col valign="top">
IAG-4</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG4 guides in transforming actions of the service scenario SC4 into goals which express functional requirements. Two goals are generated and related together to G4 with an AND relationship. G24 is selected for further processing</col>
<col valign="top">
G23: Get card from supermarket; G24: Recycle bottles and boxes from RM</col>
</row>
<row>
<col valign="top">
6.1</col>
<col valign="top">
SSG-3</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
The RE knows his target intention, namely ‘Write a Scenario’. Thus SSG3 is displayed to help the RE in selecting the right strategy. The free prose strategy is selected because the text is likely to be long and the free prose facilitates this</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
6.2</col>
<col valign="top">
IAG-8</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG8 provides style and contents guidelines adapted to the type of scenario at hand, namely system interaction scenario</col>
<col valign="top">
SC24-1: The customer inserts his card in the RM. The RM checks if the card is valid and then a prompt is given. The customer inputs the bottles and/or boxes in the RM. If the objects are not blocked, the RM ejects the card and prints a receipt</col>
</row>
<row>
<col valign="top">
7.1</col>
<col valign="top">
SSG-2</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
SSG2 is displayed. The automated support strategy is selected to take advantage of the powerful linguistic devices and obtain a scenario formulation which will be the basis for automated reasoning</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
7.2</col>
<col valign="top">
IAG-9</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG9 semi-automatically transforms the initial prose into a structured text whose semantics conform to the scenario model. The transformation includes disambiguation, completion and mapping onto the linguistic structures associated to the concepts of the scenario model. SC24-2 is the result of the transformation of SC24-1. (Underlined statements result of the transformation)</col>
<col valign="top">
SC24-2: 1.&nbsp; The customer inserts the customer card in the RM, 2.&nbsp; The RM checks if the card is valid, 3.&nbsp; If the card is valid, 4.&nbsp; A prompt is given to the customer, 5.&nbsp; The customer inputs the bottles and the boxes in the RM, 6.&nbsp; The RM checks if the bottles and the boxes are not blocked, 7.&nbsp; If the bottles and the boxes are not blocked, 8.&nbsp; The RM ejects the card to the customer, 9.&nbsp; The RM prints a receipt to the customer</col>
</row>
<row>
<col valign="top">
8.1</col>
<col valign="top">
SSG-1</col>
<col valign="top">
Choose section with select strategy</col>
<col valign="top">
Of the three strategies proposed by SSG1, the alternative discovery strategy is chosen. This strategy suits the need to investigate variations and exceptions of the normal course of actions described in SC242</col>
<col valign="top">
&nbsp;</col>
</row>
<row>
<col valign="top">
8.2</col>
<col valign="top">
IAG-3</col>
<col valign="top">
Enact section with automated support</col>
<col valign="top">
IAG3 proposes several tactics to discover alternative goals to G24. The one based on the analysis of conditions in the scenario is selected. This leads to discover G25 and G26</col>
<col valign="top">
G25: Recycle box and bottles from RM with invalid card; G26: Recycle box and bottles with a deblocking phase</col>
</row>
</table>
</p>


</ss1>
</sec>
<sec>
<st>
 See also </st>

<p>

<table style="background:transparent; width:100%;" cellpadding="0" class=" multicol" cellspacing="0">
<row>
<col align="left" width="33.33%" valign="top">
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../403/4671403.xml">
Model Driven Engineering</link>  (MDE)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../239/519239.xml">
Domain Specific Language</link>  (DSL)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../169/401169.xml">
Model-driven architecture</link>  (MDA)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../720/2140720.xml">
Domain-specific modelling</link> (DSM)</entry>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../781/346781.xml">
Modeling language</link></language>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../917/4080917.xml">
Data transformation</link> </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../200/957200.xml">
Transformation language</link> (TL)</entry>
<entry level="1" type="bullet">

 <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../737/253737.xml">
XML transformation language</link></system_of_measurement>
</standard>
 (XTL)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../563/4773563.xml">
Model Transformation Language</link> (MTL)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../894/2994894.xml">
Semantic translation</link> </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../147/3219147.xml">
Vocabulary-based transformation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../853/1862853.xml">
Data mapping</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../632/18933632.xml">
Metadata</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../689/2990689.xml">
Modeling perspectives</link></entry>
</list>
</col>
<col align="left" width="33.33%" valign="top">
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../866/1343866.xml">
Model-based testing</link> (MBT) </entry>
<entry level="1" type="bullet">

 <environment wordnetid="113934596" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<situation wordnetid="113927383" confidence="0.8">
<link xlink:type="simple" xlink:href="../958/216958.xml">
Eclipse</link></situation>
</state>
</environment>
 <weblink xlink:type="simple" xlink:href="http://www.eclipse.org/gmt/">
GMT Project</weblink></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../713/4672713.xml">
MOF Queries/Views/Transformations</link> (QVT)</entry>
<entry level="1" type="bullet">

 <standard wordnetid="107260623" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/145438.xml">
MOF</link></system_of_measurement>
</language>
</standard>
</entry>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../801/4852801.xml">
KM3</link></language>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../235/1493235.xml">
Language oriented programming</link> (LOP)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../035/1118035.xml">
Generative programming</link> (GP)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../014/2311014.xml">
Intentional Programming</link> (IP)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../858/9806858.xml">
Code generation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../875/3019875.xml">
Software factory</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../626/1674626.xml">
Metamodel</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../626/1674626.xml">
Metamodeling</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../626/1674626.xml">
Metamodeling technique</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../239/519239.xml">
Domain Specific Language</link>(DSL)</entry>
</list>
</col>
<col align="left" width="33.33%" valign="top">
 
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../094/145094.xml">
XMI</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../984/2613984.xml">
Object-oriented analysis and design</link> (OOAD) </entry>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../781/346781.xml">
Modeling language</link></language>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../769/2372769.xml">
Semantic spectrum</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../046/891046.xml">
Class-Responsibility-Collaboration card</link> (CRC)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../169/32169.xml">
UML</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../394/1894394.xml">
UML tool</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../061/1496061.xml">
List of UML tools</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../006/409006.xml">
Object Constraint Language</link> (OCL)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../993/3799993.xml">
Glossary of Unified Modeling Language terms</link></entry>
</list>
</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 C. Rolland. Modeling the Requirements Engineering Process, 3rd European-Japanese Seminar on Information Modelling and Knowledge Bases, Budapest, Hungary, June 1993. </entry>
<entry id="2">
 C. Rolland. A Comprehensive View of Process Engineering. Proceedings of the 10th International Conference CAiSE'98, B. Lecture Notes in Computer Science 1413, Pernici, C. Thanos (Eds), Springer. Pisa, Italy, June 1998. </entry>
<entry id="3">
 C. Rolland, N. Prakash, A. Benjamen. A Multi-Model View of Process Modelling. Requirements Engineering. Volume 4, Number 4. Springer-Verlag London Ltd , 1999 </entry>
<entry id="4">
 A. Finkelstein, J. Kramer, B. Nuseibeh (eds). Software process modelling and technology. Wiley, New York, 1994 </entry>
<entry id="5">
 K. Van Slooten, B. Hodes, Characterising IS development project, IFIP WG 8.1 Conf. on Method Engineering, Chapman and Hall, pp 29-44, 1996</entry>
<entry id="6">
 V. De Antonellis, B. Pernici, P. Samarati. F-ORM METHOD: A methodology for reusing specifications. In Object Oriented Approach in Information Systems. Van Assche F., Moulin B., Rolland C. (eds), North Holland, 1991</entry>
<entry id="7">
C. Rolland, N. Prakash, A proposal for context-specific method engineering, IFIP WG 8.1 Conf. on Method Engineering, Chapman and Hall, pp 191-208, 1996</entry>
<entry id="8">
V. Plihon, C. Rolland, Modelling Ways-of-Working, Proc 7th Int. Conf. on Advanced Information Systems Engineering (CAISE), Springer Verlag, 1995</entry>
<entry id="9">
<weblink xlink:type="simple" xlink:href="http://sunsite.informatik.rwth-aachen.de/CREWS">
CREWS project homepage (Cooperative Requirements Engineering With Scenarios)</weblink></entry>
<entry id="10">
C. Rolland, C. Ben Achour, C. Cauvet, J. Ralyté, A. Sutcliffe, N.A.M. Maiden, M. Jarke, P. Haumer, K. Pohl, Dubois, P. Heymans, A proposal for a scenario classification framework. To appear in Requirements Engineering Journal 3:1, 1998</entry>
<entry id="11">
 <weblink xlink:type="simple" xlink:href="http://www-i5.informatik.rwth-aachen.de/PROJEKTE/NATURE/nature.html">
NATURE project homepage (Novel Approaches to Theories Underlying Requirements Engineering)</weblink></entry>
<entry id="12">
 C. Rolland, A Contextual Approach to modeling the Requirements Engineering Process 6th Intl. Conf. on Software Engineering and Knowledge Engineering, Jurmala, Latvia, June, 1994</entry>
<entry id="13">
 C. Rolland, V. Plihon, Using generic chunks to generate process models fragments in Proc. of 2nd IEEE Int. Conf. on Requirements Engineering, ICRE'96, Colorado Spring, 1996</entry>
<entry id="14">
L. Jacherri, J. O. Larseon, R. Conradi, Software Process Modelling and Evolution in EPOS, in Proc. of the 4th Int. Conf. on Software Engineering and Knowledge Engineering (SEKE'92), Capri, Italy, 1992, pp574-589.</entry>
<entry id="15">
V. Ambriola, M. L. Jaccheri, Definition and Enactment of Oikos software entities, Proc. of the First European Workshop on Software Process Modeling, Milan, Italy, 1991</entry>
<entry id="17">
W. Emmerich, G. Junkermann, W Schafer, MERLIN : knowledge-based process modeling, Proc. of the First European Workshop on Software Process Modeling, Milan, Italy, 1991.</entry>
<entry id="16">
S. Bandinelli, A. Fugetta, S. Grigoli, Process Modelling in the large with SLANG, Proc. of the 2nd Int. Conf. on Software Process, Berlin, Germany, 1993, pp 75-93.</entry>
<entry id="19">
G. E. Kaiser, N. S. Barghouti, P. H. Feiler, R. W. Schwanke, Database Support for Knowledge-Based Engineering Environments, IEEE Expert, 3(2), 1988, pp18-32.</entry>
<entry id="18">
K. Benali, N. Boudjlida, F. Charoy, J. C. Derniame, C. Godart, Ph. Griffiths, V. Gruhn, Ph. Jamart, D. Oldfield, F. Oquendo, Presentation of the ALF project, Proc. Int. Conf. on System Development Environments and Factories, 1989.</entry>
<entry id="21">
S. Kelly, K. Lyyttinen, M. Rossi. Meta Edit+: A fully configurable, multi-user and multi-tool CASE and CAME environment, Proc. CAiSE'96 Conf., Springer Verlag, 1996</entry>
<entry id="20">
N. Belkhatir, W. L. Melo, Supporting Software Development Processes in Adele2, In the Computer Journal, vol 37, N°7, 1994, pp 621-628.</entry>
<entry id="23">
G. Merbeth. Maestro II- das intergrierte CASE-system von Softlab, CASE systeme and Werkzeuge (Ed. H. Balzert) BI Wissenschaftsverlag, pp 319-336, 1991</entry>
<entry id="22">
F. Harmsen, S. Brinkkemper, Design and implementation of a method base management system for situational CASE environment. Proc. 2nd APSEC Conf., IEEE Computer Society Press, pp 430-438, 1995</entry>
<entry id="25">
 C. Rolland. A Primer for Method Engineering. Proceedings of the INFORSID Conference (INFormatique des ORganisations et Systemes d'Information et de Decision), Toulouse, France, June 10-13, 1997. </entry>
<entry id="24">
S. Si Said. Guidance for requirements engineering processes. In: Proceedings of the 8th international conference and workshop on ‘database and experts system application’, DEXA’97, Toulouse, 1–5 September 1997</entry>
<entry id="27">
E. Dubois, J. Hagelstein, A. Rifaut. Formal Requirements Engineering with ERAE, Philips Journal Research, Vol. &amp; 43, No 4, 1989</entry>
<entry id="26">
J. Hagelstein. Declarative Approach to Information Systems Requirements. In Knowledge-Based Systems, Vol. &amp; No 4, 1988</entry>
<entry id="29">
A.G. Sutcliffe, N.A.M. Maiden, S. Minocha, D. Manuel. Supporting scenario-based requirements engineering. Trans Software Eng (Special Issue on Scenario Management) 1998</entry>
<entry id="28">
P. Haumer, K. Pohl, K. Weidenhaupt. Requirements elicitation and validation with real world scenes. IEEE Trans Software Eng (Special Issue on Scenario Management) 1998;24(12)</entry>
<entry id="31">
J. Ralyté, C. Rolland, V. Plihon. Method enhancement by scenario based techniques. In: Proceedings of the 11th conference on advanced information systems engineering, Heidelberg, Germany, June 1999</entry>
<entry id="30">
E. Dubois, P. Heymans. Scenario-based techniques for supporting the elaboration and the validation of formal requirements. Requirement Eng J 1998;3(3–4):202–218</entry>
<entry id="34">
C. Rolland , C. Souveyet, M. Moreno. An approach for defining ways-of-working. Inform Syst J 1995;20(4)337–359</entry>
<entry id="35">
G. Grosz, C. Rolland, S. Schwer et al.. Modelling and engineering the requirements engineering process: an overview of the NATURE approach. Requirements Eng J 1997;2:115–131</entry>
<entry id="32">
I. Jacobson, M. Christerson, P. Jonsson, G. Oevergaard. Object oriented software engineering: a use case driven approach. Addison-Wesley, Reading, MA, 1992</entry>
<entry id="33">
Le Petit Robert French Dictionary, Dictionnaires Le Robert, France, 1995</entry>
<entry id="36">
S. Si Said. Guidance for requirements engineering processes. In: Proceedings of the 8th international conference and workshop on ‘database and experts system application’, DEXA’97, Toulouse, 1–5 September 1997</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Articles </st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="ftp://ftp.informatik.uni-stuttgart.de/pub/library/medoc.ustuttgart_fi/DIP-2787/DIP-2787.pdf">
Meta-process modeling for goal-oriented business processes (IBM)</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
