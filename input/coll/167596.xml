<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:24:26[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Protected mode</title>
<id>167596</id>
<revision>
<id>243660687</id>
<timestamp>2008-10-07T14:37:15Z</timestamp>
<contributor>
<username>Lightmouse</username>
<id>4469495</id>
</contributor>
</revision>
<categories>
<category>Programming language implementation</category>
<category>X86 operating modes</category>
</categories>
</header>
<bdy>

<table style="margin-left: 15px;" align="right" class="toccolours">
<row>
<col colspan="2" align="center" bgcolor="#ccccff">
 <b><link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> <link xlink:type="simple" xlink:href="../553/19553.xml">
processor</link>modes</b></col>
</row>
<row>
<col>
<b>Mode</b></col>
<col>
<b>First supported</b></col>
</row>
<row>
<col>
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../823/79823.xml">
Real mode</link></entry>
</list>
</col>
<col align="right">
 <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link> <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../063/15063.xml">
8086</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</col>
</row>
<row>
<col>
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../596/167596.xml">
Protected mode</link></entry>
</list>
</col>
<col align="right">
 Intel <link xlink:type="simple" xlink:href="../054/15054.xml">
80286</link></col>
</row>
<row>
<col>
<list>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<merchandise wordnetid="103748886" confidence="0.8">
<commodity wordnetid="103076708" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/641324.xml">
Virtual 8086 mode</link></commodity>
</merchandise>
</artifact>
</entry>
</list>
</col>
<col align="right">
 Intel <link xlink:type="simple" xlink:href="../070/15070.xml">
80386</link></col>
</row>
<row>
<col>
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../083/894083.xml">
Unreal mode</link></entry>
</list>
</col>
<col align="right">
 Intel <link xlink:type="simple" xlink:href="../070/15070.xml">
80386</link></col>
</row>
<row>
<col>
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../916/3362916.xml">
System Management Mode</link></entry>
</list>
</col>
<col align="right">
 Intel <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/15070.xml#xpointer(//*[./st=%22i386SL%22])">
386SL</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</col>
</row>
<row>
<col>
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../691/2556691.xml">
Long mode</link></entry>
</list>
</col>
<col align="right">
 <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
AMD</link> <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../237/165237.xml">
Opteron</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</col>
</row>
</table>
<p>

In computing, <b>protected mode</b>, also called <b>protected virtual address mode</b>,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> is an operational mode of <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>-compatible <link xlink:type="simple" xlink:href="../218/5218.xml">
central processing unit</link>s (CPU). It was first added to the <link xlink:type="simple" xlink:href="../198/34198.xml">
x86 architecture</link> in 1982,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> with the release of <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>'s <link xlink:type="simple" xlink:href="../054/15054.xml">
80286</link> (286) processor and later extended with the release of the <link xlink:type="simple" xlink:href="../070/15070.xml">
80386</link> (386) in 1985.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Protected mode allows <link xlink:type="simple" xlink:href="../021/189021.xml">
system software</link> to utilize features such as <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link>, <link xlink:type="simple" xlink:href="../193/311193.xml">
paging</link>, <it>safe</it> <link xlink:type="simple" xlink:href="../126/20126.xml">
multi-tasking</link>, and other features designed to increase an operating system's control over <link xlink:type="simple" xlink:href="../746/454746.xml">
application software</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>
<p>

When a processor that supports x86 protected mode is powered on, it begins executing instructions in real mode, in order to maintain <link xlink:type="simple" xlink:href="../459/4459.xml">
backwards compatibility</link> with earlier x86 processors.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> Protected mode may only be entered after the system software sets up several descriptor tables and enables the Protection Enable (PE) <link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link> in the Control Register 0 (CR0).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>
<p>

Due to the enhancements added by protected mode, it has become widely adopted and has become the foundation for all subsequent enhancements to the x86 architecture.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>

<sec>
<st>
History</st>
<p>

The <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../063/15063.xml">
8086</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, the predecessor to the 286, was originally designed with a 20-<link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link> <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> <link xlink:type="simple" xlink:href="../773/382773.xml">
address bus</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> This allowed the processor to access 220 <link xlink:type="simple" xlink:href="../365/3365.xml">
bytes</link> of memory, equivalent to 1 <link xlink:type="simple" xlink:href="../918/19918.xml">
megabyte</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> At the time, 1 megabyte was considered a relatively large amount of memory,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> so the designers of the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/15032.xml">
IBM Personal Computer</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 reserved the first 640 <link xlink:type="simple" xlink:href="../794/16794.xml">
kilobytes</link> for application and the operating system usage and the remaining 384 kilobytes were reserved for the <generic wordnetid="107899976" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../473/Form_4473.xml">
Basic Input/Output System</link></generic>
 (BIOS) and memory for <link xlink:type="simple" xlink:href="../ago/Austin=2C_C$hicago.xml">
add-on devices</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>
<p>

As time progressed, the cost of memory continuously decreased and utilization increased. The 1 MB limitation eventually became a significant problem. <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link> intended to solve this limitation along with others with the release of the 286.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>

<ss1>
<st>
The 286</st>


<p>

<indent level="1">

<it>For more details on this topic, see <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../054/15054.xml">
Intel 80286</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
.</it>
</indent>
The initial protected mode, released with the 286, was not widely used.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> Several shortcomings such as the inability to access the BIOS and the inability to switch back to real mode without resetting the processor prevented widespread usage.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref> This was hampered by the fact that the 286 only allowed memory access in 16 bit segments, meaning only 216 bytes, equivalent to 64 <link xlink:type="simple" xlink:href="../794/16794.xml">
kilobyte</link>s, could be accessed at a time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>
<p>

The 286 maintained backwards compatibility with the previous 8086 by initially entering real mode on power up.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> Real mode functions identically to the 8086 allowed older <link xlink:type="simple" xlink:href="../309/5309.xml">
software</link> to run unmodified on the newer 286. To access the extended functionality of the 286, the operating system would set the processor into protected mode. This enabled 24 bit addressing which allowed the processor to access 224 bytes of memory, equivalent to 16 <link xlink:type="simple" xlink:href="../918/19918.xml">
megabyte</link>s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></p>

</ss1>
<ss1>
<st>
The 386</st>
<p>

<image width="150px" src="Ic-photo-intel-A80386DX-33-IV-(386DX).png" type="thumb">
<caption>

An Intel 80386 microprocessor
</caption>
</image>
</p>
<p>

<indent level="1">

<it>For more details on this topic, see <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/15070.xml">
Intel 80386</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
.</it>
</indent>
With the release of the 386 in 1985,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> many of the issues preventing widespread adoption of the previous protected mode were addressed.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>
<p>

The 386 was released with an address bus size of 32 bits, which allows for 232 bytes of memory accessing, equivalent to 4 <link xlink:type="simple" xlink:href="../570/12570.xml">
gigabytes</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> The segment sizes were also increased to 32 bits, meaning that the full address space of 4 gigabytes could be accessed without the need to switch between multiple segments.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> In addition to the increased size of the address bus and segment registers, many other new features were added with the intention of increasing operational security and stability.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></p>
<p>

Protected mode is now used in virtually all modern <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s which run on the x86 architecture, such as <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link>, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
, and many others.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref></p>

</ss1>
</sec>
<sec>
<st>
 386 additions to protected mode </st>
<p>

With the release of the 386, the following additional features were added to protected mode:<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../733/80733.xml">
32-bit</link> <link xlink:type="simple" xlink:href="../144/507144.xml">
physical and virtual address space</link>*</entry>
<entry level="1" type="bullet">

 32-bit <link xlink:type="simple" xlink:href="../965/149965.xml">
segment</link> offsets</entry>
<entry level="1" type="bullet">

 Ability to switch back to real mode</entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<merchandise wordnetid="103748886" confidence="0.8">
<commodity wordnetid="103076708" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/641324.xml">
Virtual 8086 mode</link></commodity>
</merchandise>
</artifact>
</entry>
</list>
</p>
<p>

*The 32-bit physical address space is not present on the <link xlink:type="simple" xlink:href="../070/15070.xml">
80386SX</link>, and other 386 processor variants which use the older 286 bus.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref></p>

</sec>
<sec>
<st>
Entering and exiting protected mode</st>
<p>

Until the release of the 386, protected mode did not offer a direct method to switch back into real mode once protected mode was entered. <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 created a workaround which involved resetting the CPU and saving the system registers, <link xlink:type="simple" xlink:href="../105/1718105.xml">
stack pointer</link> and often the interrupt mask in the real-time clock chip's RAM. This allowed the BIOS to restore the CPU to a similar state and begin executing code before the reset.</p>
<p>

To enter protected mode, the <link xlink:type="simple" xlink:href="../872/4118872.xml">
Global Descriptor Table</link> (GDT) must first be created with a minimum of three entries: a null descriptor, a code segment descriptor and data segment descriptor. The <link xlink:type="simple" xlink:href="../659/263659.xml">
21st address line</link> (A20 line) also must be enabled to allow the use of all the address lines so that the CPU can access beyond 1 megabyte of memory (only the first 20 are allowed to be used after power-up to guarantee compatibility with older software). After performing those two steps, the PE bit must be set in the CR0 register and a far jump must be made to clear the <link xlink:type="simple" xlink:href="../822/439822.xml">
prefetch input queue</link>.</p>
<p>

<list>
<entry level="1" type="definition">

 set PE bit</entry>
</list>

mov eax, cr0
or eax, 1
mov cr0, eax</p>
<p>

<list>
<entry level="1" type="definition">

 far jump (cs = selector of code segment)</entry>
</list>

jmp cs:@pm</p>
<p>

@pm:
<list>
<entry level="1" type="definition">

 Now we are in PM.</entry>
</list>
</p>
<p>

With the release of the 386, protected mode could be exited by loading the segment registers with real mode values, disabling the A20 line and clearing the PE bit in the CR0 register, without the need to perform the initial setup steps required with the 286.</p>

</sec>
<sec>
<st>
Features</st>
<p>

Protected mode has a number of features designed to enhance an operating system's control over application software, in order to increase security and system stability.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> These additions allow the operating system to function in a way that would be otherwise significantly more difficult or even impossible without proper hardware support.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref>
</p>
<ss1>
<st>
 Privilege levels </st>

<p>

<indent level="1">

<it>For more details on this topic, see <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/3446185.xml">
Ring (computer security)</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
.</it>
</indent>
<image location="right" width="250px" src="Priv_rings.svg" type="thumb">
<caption>

Example of privilege ring usage in a typical operating system.
</caption>
</image>

In protected mode, there are four privilege levels or <link xlink:type="simple" xlink:href="../185/3446185.xml">
ring</link>s, numbered from 0 to 3, with ring 0 being the most privileged and 3 being the least. The use of rings allows for system software to restrict tasks from accessing data, <link xlink:type="simple" xlink:href="../844/6054844.xml">
call gate</link>s or executing privileged instructions.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref></p>
<p>

In most environments, the operating system and some <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>s run in ring 0 and applications run in ring 3.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref></p>

</ss1>
<ss1>
<st>
 Real mode application compatibility </st>
<p>

According to the  <it>Intel 80286 Programmer's Reference Manual</it>,
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref> 
<table style="margin:auto; border-collapse:collapse; border-style:none; background-color:transparent; " class="cquote">
<row>
<col style="color:#B2B7F2;font-size:35px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;padding:10px 10px;" width="20" valign="top">
“</col>
<col style="padding:4px 10px;" valign="top">
...the 80286 remains upwardly compatible with most 8086 and 80186 application programs. Most 8086 applications programs can be re-compiled or re-assembled and executed on the 80286 in Protected Mode.</col>
<col style="color:#B2B7F2;font-size:36px;font-family:'Times New Roman',serif;font-weight:bold;text-align:right;padding:10px 10px;" width="20" valign="bottom">
”</col>
</row>
</table>
</p>
<p>

For the most part, the binary compatibility with real-mode code, the ability to access up to 16 MB of physical memory, and 1 GB of <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link>, were the most apparent changes to application programmers.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref> This was not without its limitations, if an application utilized or relied on any of the techniques below it wouldn't run:<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2220%22])">20</ref></p>
<p>

<list>
<entry level="1" type="bullet">

 Segment arithmetic</entry>
<entry level="1" type="bullet">

 Privileged instructions</entry>
<entry level="1" type="bullet">

 Direct hardware access</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../647/217647.xml">
Writing to a code segment</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../836/2225836.xml">
Executing data</link></entry>
<entry level="1" type="bullet">

 Overlapping segments</entry>
<entry level="1" type="bullet">

 Use of BIOS functions, due to the BIOS interrupts being reserved by Intel<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref></entry>
</list>
</p>
<p>

In reality, almost all <link xlink:type="simple" xlink:href="../146/8146.xml">
DOS</link> application programs violated these rules.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref> Due to these limitations, <link xlink:type="simple" xlink:href="../324/641324.xml">
virtual 8086 mode</link> was created and released with the 386. Despite such potential setbacks, <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../719/167719.xml">
Windows 3.x</link></version>
 and its successors can take advantage of the binary compatibility with real mode to run many <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<explanation wordnetid="106738281" confidence="0.8">
<interpretation wordnetid="107170753" confidence="0.8">
<version wordnetid="107173585" confidence="0.8">
<link xlink:type="simple" xlink:href="../028/3372028.xml">
Windows 2.x</link></version>
</interpretation>
</explanation>
</message>
</statement>
 applications, which run in real mode in Windows 2.x, in protected mode.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref></p>

</ss1>
<ss1>
<st>
 Virtual 8086 mode </st>

<p>

<indent level="1">

<it>Main article: <artifact wordnetid="100021939" confidence="0.8">
<merchandise wordnetid="103748886" confidence="0.8">
<commodity wordnetid="103076708" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/641324.xml">
Virtual 8086 mode</link></commodity>
</merchandise>
</artifact>
</it>
</indent>
With the release of the 386, protected mode offers what the Intel manuals call <b>virtual 8086 mode</b>. Virtual 8086 mode is designed to allow code previously written for the 8086 to run unmodified and concurrently with other tasks, without compromising security or system stability.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref> Virtual 8086 mode although is not completely backwards compatible with all programs. Programs that require segment manipulation, privileged instructions, direct hardware access, or use <link xlink:type="simple" xlink:href="../647/217647.xml">
self-modifying code</link>, will generate an <link xlink:type="simple" xlink:href="../231/59231.xml">
exception</link> and not be <link xlink:type="simple" xlink:href="../392/217392.xml">
executable</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2225%22])">25</ref> In addition, applications running in virtual 8086 mode generate a <link xlink:type="simple" xlink:href="../447/7380447.xml">
trap</link> with the use of instructions that involve <link xlink:type="simple" xlink:href="../558/14558.xml">
input/output</link> (I/O), which can negatively impact performance.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2226%22])">26</ref></p>
<p>

Due to these limitations, many programs originally designed to run on the 8086 can not be run in virtual 8086 mode. As a result, system software is forced to either compromise system security or backwards compatibility when dealing with <link xlink:type="simple" xlink:href="../295/18295.xml">
legacy software</link>. An example of such a compromise can be seen with the release of <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/33438.xml">
Windows NT</link></family>
, which dropped backwards compatibility for many DOS applications.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2227%22])">27</ref></p>

</ss1>
<ss1>
<st>
 Segment addressing </st>
<p>

<image width="250px" src="080810-protected-286-segments.PNG" type="thumb">
<caption>

virtual segments of 80286
</caption>
</image>

In real mode each logical address points directly into physical memory location,
every logical address consists of two 16 bit part:</p>
<p>

The segment part of the logical address contains the base address of a segment with a granularity of 16 bits,
i.e. a segments may start at physical address 0, 16, 32, ..., 216-16.</p>
<p>

The offset part of the logical address contains an offset inside the segment,
i.e. the physical address can be calculated as
physical_address := segment_part &amp;times; 16 + offset (if the address line A20 is enabled),
respectively (segment_part &amp;times; 16 + offset) mod 216 (if A20 is off)</p>
<p>

Every segment has a size of 216 bytes.</p>

<ss2>
<st>
 Protected mode </st>
<p>

In protected mode the segment_part is replaced by a 16 bit <b>selector</b>,
the 13 upper bits (bit 3 to bit 15) of the selector contains the index of an <b>entry</b> inside a <b>descriptor table</b>.</p>
<p>

The descriptor table entry contains
the real <it>linear</it> address of the segment
a limit value for the segment size
some attribute bits (flags)</p>


</ss2>
<ss2>
<st>
 286 </st>
<p>

The segment address inside the descriptor table entry has a length of 24 bits
so every byte of the physical memory can be defined as bound of the segment.</p>
<p>

The limit value inside the descriptor table entry has a length of 16 bits
so segment length can be between 1 byte and 216 byte.</p>
<p>

The calculated linear address equals the physical memory address.</p>

</ss2>
<ss2>
<st>
 386 </st>
<p>

The segment address inside the descriptor table entry is expanded to 32 bits
so every byte of the physical memory can be defined as bound of the segment.</p>
<p>

The limit value inside the descriptor table entry is expanded to 20 bits
and completed with a granularity flag (shortly: G-bit):
if G-bit is zero limit has a granularity of 1 byte, i.e. segment size may be 1, 2, ..., 220 bytes.
if G-bit is on limit has a granularity of 212 bytes, i.e. segment size may be 1 &amp;times; 212, 2 &amp;times; 212, ..., 220 &amp;times; 212 bytes.</p>
<p>

If paging (see below) is off the calculated linear address equals the physical memory address.</p>
<p>

If paging is on the calculated linear address is used as input of paging.</p>
<p>

The 386 processor also uses 32 bit values for the address offset.
For maintainig compatibility with 286 protected mode a new default flag (shortly D-bit) was added.
If D-bit of a code segment is off all commands inside this segment will be interpreted as 16 bit commands.</p>

</ss2>
<ss2>
<st>
 Structure of segment descriptor entry </st>

<p>

<table >
<row>
<header>
B</header>
<header>
bits</header>
<header>
80286</header>
<header>
80386</header>
<header>
B</header>
</row>
<row>
<header>
0</header>
<col>
00..07,0..7</col>
<col rowspan="2">
limit</col>
<col rowspan="2">
bits 0..15 of limit</col>
<header>
0</header>
</row>
<row>
<header>
1</header>
<col>
08..15,0..7</col>
<header>
1</header>
</row>
<row>
<header>
2</header>
<col>
16..23,0..7</col>
<col rowspan="3">
base address</col>
<col rowspan="3">
bits 0..23 of base address</col>
<header>
2</header>
</row>
<row>
<header>
3</header>
<col>
24..31,0..7</col>
<header>
3</header>
</row>
<row>
<header>
4</header>
<col>
32..39,0..7</col>
<header>
4</header>
</row>
<row>
<header>
5</header>
<col>
40..47,0..7</col>
<col colspan="2">
attribute flags #1</col>
<header>
5</header>
</row>
<row>
<header rowspan="2">
6</header>
<col>
48..51,0..3</col>
<col rowspan="3">
unused</col>
<col>
bits 16..19 of limit</col>
<header rowspan="2">
6</header>
</row>
<row>
<col>
52..55,4..7</col>
<col>
attribute flags #2</col>
</row>
<row>
<header>
7</header>
<col>
56..63,0..7</col>
<col>
bits 24..31 of base address</col>
<header>
7</header>
</row>
</table>
</p>
<p>

Columns <b>B</b>: Byte offset inside entry
Column <b>bits</b>, first range: Bit offset inside entry
Column <b>bits</b>, second range: Bit offset inside byte</p>

<p>

<table >
<row>
<header colspan="3">
attribute flags #2</header>
</row>
<row>
<col>
52</col>
<col>
4</col>
<col>
unused, available for operating system</col>
</row>
<row>
<col>
53</col>
<col>
5</col>
<col>
reserved, should be zero</col>
</row>
<row>
<col>
54</col>
<col>
6</col>
<col>
default flag / D-bit</col>
</row>
<row>
<col>
55</col>
<col>
7</col>
<col>
granularity flag / G-bit</col>
</row>
</table>
</p>


</ss2>
</ss1>
<ss1>
<st>
Paging</st>
<p>

<image width="250px" src="Virtual_address_space_and_physical_address_space_relationship.svg" type="thumb">
<caption>

Common method of using paging to create a virtual address space.
</caption>
</image>

<image width="250px" src="080810-protected-386-paging.PNG" type="thumb">
<caption>

paging ( intel 80386 ) with page size of 4K
</caption>
</image>
</p>
<p>

<indent level="1">

<it>For more details on this topic, see <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link>.</it>
</indent>
In addition to adding virtual 8086 mode, the 386 also added <b>paging</b> to protected mode.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2228%22])">28</ref> Through paging, system software can restrict and control a task's access to pages, which are sections of memory. In many operating systems, paging is used to create an independent virtual address space for each task. This prevents one task from manipulating the memory of another. Paging also allows for pages to be moved out of <link>
primary storage</link> and onto a slower and larger <link xlink:type="simple" xlink:href="../248/88248.xml">
secondary storage</link>, such as a <link xlink:type="simple" xlink:href="../777/13777.xml">
hard disk</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2229%22])">29</ref> This allows for more memory to be used than physically available in primary storage.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2229%22])">29</ref> The x86 architecture allows control of pages through two <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>s: page directories and <link xlink:type="simple" xlink:href="../962/674962.xml">
page table</link>s.</p>
<p>

Originally, a page directory was the size of one page, 4 kilobytes, and contained 1,024 page directory entries (PDE), although subsequent enhancements to the x86 architecture have added the ability to use larger page sizes. Each PDE contained a <link xlink:type="simple" xlink:href="../018/459018.xml">
pointer</link> to a page table. A page table was also originally 4 kilobytes in size and contained 1,024 page table entries (PTE). Each PTE contained a pointer to the actual page's physical address and are only used when 4 kilobyte pages are used. At any given time, only one page directory may be in active use.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2230%22])">30</ref></p>

</ss1>
<ss1>
<st>
Multitasking</st>

<p>

<indent level="1">

<it>For more details on this topic, see <link xlink:type="simple" xlink:href="../857/6857.xml">
Computer multitasking</link>.</it>
</indent>
Through the use of the rings, privileged call gates, and the <link xlink:type="simple" xlink:href="../061/6300061.xml">
Task State Segment</link> (TSS), introduced with the 286, <link xlink:type="simple" xlink:href="../566/2204566.xml">
preemptive</link> <link xlink:type="simple" xlink:href="../857/6857.xml">
multitasking</link> was made possible on the x86 architecture. The TSS allows general-purpose registers, segment selector fields, and stacks to all be modified without affecting those of another task. The TSS also allows a task's privilege level, and I/O port permissions to be independent of another task's.</p>
<p>

In many operating systems, the full features of the TSS are not used.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2231%22])">31</ref> This is commonly due to portability concerns or due to the performance issues created with hardware task switches.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2231%22])">31</ref> As a result many operating systems use both hardware and software to create a multitasking system.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2232%22])">32</ref></p>

</ss1>
</sec>
<sec>
<st>
Operating Systems</st>
<p>

Operating systems like <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../409/22409.xml">
OS/2</link></O>
 1.x try to switch the processor between protected and real modes. This is both slow and unsafe, because a real mode program can easily <abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../631/279631.xml">
crash</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
 a computer. OS/2 1.x defines restrictive programming rules allowing a <it>Family API</it> or <it>bound</it> program to run in either real or protected mode.</p>
<p>

Some early <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 operating systems, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../409/22409.xml">
OS/2</link></O>
 1.x, and Windows used this mode. <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/168400.xml">
Windows 3.0</link></version>
 was able to run real mode programs in 16-bit protected mode. <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/168400.xml">
Windows 3.0</link></version>
, when switching to protected mode, decided to preserve the single privilege level model that was used in real mode, which is why Windows applications and DLLs can hook interrupts and do direct hardware access. That lasted through the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../486/454486.xml">
Windows 9x</link></O>
 series. If a Windows 1.x or 2.x program is written properly and avoids segment arithmetic, it will run the same way in both real and protected modes. Windows programs generally avoid segment arithmetic because Windows implements a software virtual memory scheme, moving program code and data in memory when programs are not running, so manipulating absolute addresses is dangerous; programs should only keep <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../861/319861.xml">
handle</link></kind>
</type>
</category>
</concept>
</idea>
s to memory blocks when not running. Starting an old program while Windows 3.0 is running in protected mode triggers a warning dialog, suggesting to either run Windows in real mode or to obtain an updated version of the application. Updating well-behaved programs using the MARK utility with the MEMORY parameter avoids this dialog. It is not possible to have some GUI programs running in 16-bit protected mode and other GUI programs running in real mode. In <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<window wordnetid="104587648" confidence="0.8">
<supporting_structure wordnetid="104361095" confidence="0.8">
<framework wordnetid="103391770" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/168311.xml">
Windows 3.1</link></framework>
</supporting_structure>
</window>
</artifact>
</structure>
 real mode disappeared.</p>
<p>

Today, 16-bit protected mode is still used for running legacy <it>applications</it>, eg. <link xlink:type="simple" xlink:href="../195/420195.xml">
DPMI</link> compatible <link xlink:type="simple" xlink:href="../676/1595676.xml">
DOS extender</link> programs (through <link xlink:type="simple" xlink:href="../173/1501173.xml">
virtual DOS machine</link>s) or Windows 3.x applications (through the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../788/1648788.xml">
Windows on Windows</link></part>
</component>
</concept>
</idea>
 subsystem) and certain classes of <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>s in OS/2 2.0 and later, all under control of a 32-bit kernel.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../368/1368.xml">
Assembly language</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link></entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/3446185.xml">
Ring (computer security)</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../948/214948.xml">
x86 assembly language</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.x86.org/articles/pmbasics/tspec_a1_doc.htm">
Protected Mode Basics</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.internals.com/articles/protmode/introduction.htm">
Introduction to Protected-Mode</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.intel.com/design/intarch/papers/exc_ia.htm">
Overview of the Protected Mode Operations of the Intel Architecture</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel® 64 and IA-32 Architectures Software Developer's Manuals</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.turboirc.com/asm">
TurboIRC.COM tutorial to enter protected mode from DOS</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.viralpatel.net/taj/tutorial/protectedmode.php">
Protected Mode Overview and Tutorial</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
"<weblink xlink:type="simple" xlink:href="http://www.patentstorm.us/patents/5483646-claims.html">
Memory access control method and system for realizing the same - US Patent 5483646</weblink>"&#32;(Patent)&#32;(23).&#32;Retrieved on <link>
2007-07-14</link>.&nbsp;"The memory access control system according to claim 4, wherein said first address mode is a real address mode, and said second address mode is a protected virtual address mode."
</entry>
<entry id="2">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"2.1.2 The Intel 286 Processor (1982)", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;34.</cite>&nbsp;
</entry>
<entry id="3">
"<weblink xlink:type="simple" xlink:href="http://www.intel.com/intel/finance/gcr03/39-years_of_innovation.htm">
Intel Global Citizenship Report 2003</weblink>"&#32;(Timeline).&#32;Retrieved on <link>
2007-07-14</link>.&nbsp;"1985 Intel launches Intel386™ processor"
</entry>
<entry id="4">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"2.1.3 The Intel 386 Processor (1985)", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;35.</cite>&nbsp;
</entry>
<entry id="5">
"<weblink xlink:type="simple" xlink:href="http://www.delorie.com/djgpp/doc/ug/basics/protected.html">
Guide: What does protected mode mean?</weblink>"&#32;(Guide).&#32;  Delorie software&#32;(14).&#32;Retrieved on <link>
2007-07-14</link>.&nbsp;"The purpose of protected mode is not to protect your program. The purpose is to protect everyone else (including the operating system) from your program."
</entry>
<entry id="6">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"3.1 Modes of Operation", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;59.</cite>&nbsp;
</entry>
<entry id="7">
Collins, Robert&#32;(2007).&#32;"<weblink xlink:type="simple" xlink:href="http://www.x86.org/articles/pmbasics/tspec_a1_doc.htm">
Protected Mode Basics</weblink>"&#32;(Guide).&#32;  Dr. Dobb's Microprocessor Resources.&#32;Retrieved on <link>
2007-07-14</link>.
</entry>
<entry id="8">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"2.1 Brief History of the IA-32 Architecture", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;31.</cite>&nbsp;
</entry>
<entry id="9">
"<weblink xlink:type="simple" xlink:href="http://www.brainbell.com/tutors/A+/Hardware/PC_Microprocessor_Developments_and_Features.htm">
A+ - Hardware - PC Microprocessor Developments and Features Tutorials</weblink>"&#32;(Tutorial/Guide).&#32;  BrainBell.com.&#32;Retrieved on <link>
2007-07-24</link>.
</entry>
<entry id="10">
&#32;(23).&#32;"<weblink xlink:type="simple" xlink:href="http://www.pcmech.com/show/processors/35/">
A CPU History</weblink>"&#32;(Article).&#32;  PCMechanic.&#32;Retrieved on <link>
2007-07-24</link>.&nbsp;"What is interesting is that the designers of the time never suspected anyone would ever need more than 1 MB of RAM."
</entry>
<entry id="11">
Kaplan, Yariv&#32;(1997).&#32;"<weblink xlink:type="simple" xlink:href="http://www.internals.com/articles/protmode/introduction.htm">
Introduction to Protected-Mode</weblink>"&#32;(Article).&#32;  Internals.com.&#32;Retrieved on <link>
2007-07-24</link>.
</entry>
<entry id="12">
 <cite id="Reference-Mueller-2006" style="font-style:normal" class="book">&#32;(24).&#32;"<weblink xlink:type="simple" xlink:href="http://www.informit.com/articles/article.aspx?p=481859&amp;seqNum=13">
P2 (286) Second-Generation Processors</weblink>", <weblink xlink:type="simple" xlink:href="http://www.informit.com/store/product.aspx?isbn=0789734044">
Upgrading and Repairing PCs, 17th Edition</weblink>&#32;(Book), 17,&#32;Que. ISBN 0-7897-3404-4. Retrieved on <link xlink:type="simple" xlink:href="../650/9518650.xml">
July 2007</link>.</cite>&nbsp;
</entry>
<entry id="13">
 <cite style="font-style:normal" class="book">&#32;(1986)&#32;"2.1 Memory Organization and Segmentation", Intel 80386 Programmer's Reference Manual 1986&#32;(Manual),&#32;Santa Clara, CA:&#32;Intel.</cite>&nbsp;
</entry>
<entry id="14">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"3.1 Modes of Operation", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;55.</cite>&nbsp;
</entry>
<entry id="15">
 <cite id="Reference-Hyde-2004" style="font-style:normal" class="book">Hyde, Randall&#32;(November 2004).&#32;"12.10. Protected Mode Operation and Device Drivers", <weblink xlink:type="simple" xlink:href="http://safari.oreilly.com/1593270038/ns1593270038-CHP-12-SECT-10">
Write Great Code</weblink>.&#32;O'Reilly. ISBN 1-59327-003-8.</cite>&nbsp;
</entry>
<entry id="17">
 <cite style="font-style:normal" class="book">&#32;(1986)&#32;"7 Multitasking", Intel 80386 Programmer's Reference Manual 1986&#32;(Manual),&#32;Santa Clara, CA:&#32;Intel.</cite>&nbsp;
</entry>
<entry id="16">
Shvets, Gennadiy&#32;(3).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cpu-world.com/CPUs/80386/index.html">
Intel 80386 processor family</weblink>"&#32;(Article).&#32;Retrieved on <link>
2007-07-24</link>.&nbsp;"80386SX - low cost version of the 80386. This processor had 16 bit external data bus and 24-bit external address bus."
</entry>
<entry id="19">
 <cite style="font-style:normal" class="book">&#32;(1987)&#32;"1.3.1 Memory Management", Intel 80286 Programmer's Reference Manual 1987&#32;(Manual),&#32;Santa Clara, CA:&#32;Intel.</cite>&nbsp;
</entry>
<entry id="18">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"6.3.5 Calls to Other Privilege Levels", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;162.</cite>&nbsp;
</entry>
<entry id="21">
"<weblink xlink:type="simple" xlink:href="http://www.freepatentsonline.com/6105101.html">
Memory access control method and system for realizing the same - US Patent 5483646</weblink>"&#32;(Patent)&#32;(6).&#32;Retrieved on <link>
2007-07-25</link>.&nbsp;"This has been impossible to-date and has forced BIOS development teams to add support into the BIOS for 32 bit function calls from 32 bit applications."
</entry>
<entry id="20">
 <cite style="font-style:normal" class="book">&#32;(1987)&#32;"Appendix C  8086/8088 Compatibility Considerations", Intel 80286 Programmer's Reference Manual 1987&#32;(Manual),&#32;Santa Clara, CA:&#32;Intel.</cite>&nbsp;
</entry>
<entry id="23">
Robinson, Tim&#32;(26).&#32;"<weblink xlink:type="simple" xlink:href="http://osdev.berlios.de/v86.html">
Virtual 8086 Mode</weblink>"&#32;(Guide).&#32;  berliOS.&#32;Retrieved on <link>
2007-07-25</link>.
</entry>
<entry id="22">
Robinson, Tim&#32;(26).&#32;"<weblink xlink:type="simple" xlink:href="http://osdev.berlios.de/v86.html">
Virtual 8086 Mode</weblink>"&#32;(Guide).&#32;  berliOS.&#32;Retrieved on <link>
2007-07-25</link>.&nbsp;"...secondly, protected mode was also incompatible with the vast amount of real-mode code around at the time."
</entry>
<entry id="25">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"15.2.7 Sensitive Instructions", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;568.</cite>&nbsp;
</entry>
<entry id="24">
 <cite style="font-style:normal" class="book">&#32;(May 2007)&#32;"15.2 Virtual 8086 Mode", <weblink xlink:type="simple" xlink:href="http://www.intel.com/products/processor/manuals/index.htm">
Intel 64 and IA-32 Architectures Software Developer's Manual</weblink>.&#32;<link xlink:type="simple" xlink:href="../522/8522.xml">
Denver</link>, <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/5399.xml">
Colorado</link></country>
</district>
</location>
</administrative_district>
</region>
:&#32;<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>,&#32;560.</cite>&nbsp;
</entry>
<entry id="27">
 <cite id="Reference-Dabak-1999" style="font-style:normal" class="book">;&#32;Millind Borate&#32;(October 1999). Undocumented Windows NT&#32;(Book),&#32;Hungry Minds. ISBN 0764545698.</cite>&nbsp;
</entry>
<entry id="26">
Robinson, Tim&#32;(26).&#32;"<weblink xlink:type="simple" xlink:href="http://osdev.berlios.de/v86.html">
Virtual 8086 Mode</weblink>"&#32;(Guide).&#32;  berliOS.&#32;Retrieved on <link>
2007-07-25</link>.&nbsp;"A downside to using V86 mode is speed: every IOPL-sensitive instruction will cause the CPU to trap to kernel mode, as will I/O to ports which are masked out in the TSS."
</entry>
<entry id="29">
"<weblink xlink:type="simple" xlink:href="http://technet2.microsoft.com/windowsserver/en/library/efc41320-713f-4004-bc81-ddddfc8552651033.mspx?mfr=true">
What Is PAE X86?</weblink>"&#32;(Article).&#32;  Microsoft TechNet&#32;(28).&#32;Retrieved on <link>
2007-07-29</link>.&nbsp;"The paging process allows the operating system to overcome the real physical memory limits. However, it also has a direct impact on performance because of the time necessary to write or retrieve data from disk."
</entry>
<entry id="28">
"<weblink xlink:type="simple" xlink:href="http://www.deinmeister.de/x86modes.htm#c1">
ProtectedMode overview [deinmeister.de</weblink>]"&#32;(Website).&#32;Retrieved on <link>
2007-07-29</link>.
</entry>
<entry id="31">
"<weblink xlink:type="simple" xlink:href="http://neworder.box.sk/newsread.php?newsid=10562">
NewOrer - news: Multitasking for x86 explained #1</weblink>"&#32;(Article).&#32;  NewOrder&#32;(2).&#32;Retrieved on <link>
2007-07-29</link>.&nbsp;"The reason why software task switching is so popular is that it can be faster than hardware task switching. Intel never actually developed the hardware task switching, they implemented it, saw that it worked, and just left it there. Advances in multitasking using software have made this form of task switching faster (some say up to 3 times faster) than the hardware method. Another reason is that the Intel way of switching tasks isn't portable at all"
</entry>
<entry id="30">
Gareau, Jean.&#32;"<weblink xlink:type="simple" xlink:href="http://www.embedded.com/98/9806fe2.htm">
Advanced Embedded x86 Programming: Paging</weblink>"&#32;(Guide).&#32;  Embedded.com.&#32;Retrieved on <link>
2007-07-29</link>.&nbsp;"Only one page directory may be active at a time, indicated by the CR3 register."
</entry>
<entry id="32">
"<weblink xlink:type="simple" xlink:href="http://neworder.box.sk/newsread.php?newsid=10562">
NewOrer - news: Multitasking for x86 explained #1</weblink>"&#32;(Article).&#32;  NewOrder&#32;(2).&#32;Retrieved on <link>
2007-07-29</link>.&nbsp;"...both rely on the Intel processors ability to switch tasks, they rely on it in different ways."
</entry>
</reflist>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../194/22194.xml">
Operating system</link></header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
General</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../395/55395.xml">
History</link>&nbsp;·  <record wordnetid="106647206" confidence="0.8">
<chronology wordnetid="106503224" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<timeline wordnetid="106504965" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../968/247968.xml">
Timeline</link></written_record>
</timeline>
</evidence>
</indication>
</chronology>
</record>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/229119.xml">
Developement</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../531/981531.xml">
List</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../394/50394.xml">
Kernel</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
General</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../023/20023.xml">
Microkernel</link>&nbsp;·  <link xlink:type="simple" xlink:href="../023/20023.xml#xpointer(//*[./st=%22Nanokernel%22])">
Nanokernel</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Types</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../825/20825.xml">
monolithic</link>&nbsp;·  <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/4345041.xml">
hybrid</link></kernel>
</natural_object>
</plant_part>
&nbsp;·  <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../757/95757.xml">
exokernel</link></kernel>
</natural_object>
</plant_part>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Components</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../467/93467.xml">
Kernel space</link>&nbsp;·  <link xlink:type="simple" xlink:href="../658/371658.xml">
Loadable kernel module</link>&nbsp;·  <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>&nbsp;·  <link xlink:type="simple" xlink:href="../467/93467.xml">
User space</link>&nbsp;·  <link xlink:type="simple" xlink:href="../109/555109.xml">
Userland</link></col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../806/15395806.xml">
Process management</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../178/45178.xml">
Process</link>&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Multiprogramming</link>&nbsp;·  <link xlink:type="simple" xlink:href="../289/15289.xml">
Interrupt</link>&nbsp;·  Modes: (<link xlink:type="simple" xlink:href="../596/167596.xml">
Protected mode</link>&nbsp;·  <link>
Supervisor mode</link>)&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Computer multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../920/231920.xml">
Scheduling</link>&nbsp;·  <link xlink:type="simple" xlink:href="../904/6904.xml">
Context switch</link>&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Cooperative multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../566/2204566.xml">
Preemptive multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../954/3991954.xml">
CPU modes</link>&nbsp;·  <link xlink:type="simple" xlink:href="../303/45303.xml">
Thread (computer science)</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Memory management</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../373/515373.xml">
Memory protection</link>&nbsp;·  <link xlink:type="simple" xlink:href="../131/1323131.xml">
Segmentation</link>&nbsp;·  <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link>&nbsp;·  <link xlink:type="simple" xlink:href="../112/177112.xml">
Memory management unit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../803/28803.xml">
Segmentation fault</link>&nbsp;·  <link xlink:type="simple" xlink:href="../943/573943.xml">
General protection fault</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Examples</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../304/18933304.xml">
AmigaOS</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../801/4801.xml">
BeOS</link>&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../409/22409.xml">
IBM OS/2</link></O>
&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../027/20027.xml">
MS-DOS</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../890/18890.xml">
Windows</link>&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link>&nbsp;·  <link xlink:type="simple" xlink:href="../658/1178658.xml">
OpenSolaris</link>&nbsp;·  <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>&nbsp;·   <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../889/360889.xml">
ReactOS</link></O>
&nbsp;·  <it><link xlink:type="simple" xlink:href="../916/71916.xml">
more…</link>''</it></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Miscellaneous concepts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../679/6885679.xml">
Boot loader</link>&nbsp;·  <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../253/432253.xml">
PXE</link></system_of_measurement>
</standard>
&nbsp;·  <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/351131.xml">
Virtual file system</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../071/2550071.xml">
Virtual tape library</link>&nbsp;·  <link xlink:type="simple" xlink:href="../592/4122592.xml">
Computer network</link>&nbsp;·  <link xlink:type="simple" xlink:href="../293/12293.xml">
GUI</link>&nbsp;·  <link xlink:type="simple" xlink:href="../511/425511.xml">
HAL</link></col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</article>
