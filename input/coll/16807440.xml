<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 03:52:24[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Kochanski multiplication</title>
<id>16807440</id>
<revision>
<id>204162974</id>
<timestamp>2008-04-08T06:09:41Z</timestamp>
<contributor>
<username>Michael Hardy</username>
<id>4626</id>
</contributor>
</revision>
<categories>
<category>Modular arithmetic</category>
<category>Cryptographic algorithms</category>
</categories>
</header>
<bdy>

<b>Kochanski multiplication</b><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that allows <link xlink:type="simple" xlink:href="../087/20087.xml">
modular arithmetic</link> (multiplication or operations based on it, such as <link xlink:type="simple" xlink:href="../032/903032.xml">
exponentiation</link>) to be performed efficiently when the modulus is large (typically several hundred bits). This has particular application in <link xlink:type="simple" xlink:href="../527/21527.xml">
number theory</link> and in <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>: for example, in the <link xlink:type="simple" xlink:href="../385/25385.xml">
RSA</link> cryptosystem and <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../903/7903.xml">
Diffie-Hellman key exchange</link></rule>
</direction>
</protocol>
</message>
.<p>

The commonest way of implementing large-integer multiplication in hardware is to express the multiplier in <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> and enumerate its bits, one bit at a time, starting with the most significant bit, perform the following operations on an <link>
accumulator</link>:Double the contents of the accumulator (if the accumulator stores numbers in binary, as is usually the case, this is a simple "shift left" that requires on actual computation).If the current bit of the multiplier is 1, add the multiplicand into the accumulator; if it is 0, do nothing.</p>
<p>

For an <it>n</it>-bit multiplier, this will take <it>n</it> clock cycles (where each cycle does either a shift or a shift-and-add).</p>
<p>

To convert this into an algorithm for modular multiplication, with a modulus <it>r</it>, it is necessary to subtract <it>r</it> conditionally at each stage:</p>
<p>

Double the contents of the accumulator.If the result is greater than or equal to <it>r</it>, subtract <it>r</it>. (Equivalently, subtract <it>r</it> from the accumulator and store the result back into the accumulator if and only if it is non-negative).If the current bit of the multiplier is 1, add the multiplicand into the accumulator; if it is 0, do nothing.If the result of the addition is greater than or equal to <it>r</it>, subtract <it>r</it>. If no addition took place, do nothing.</p>
<p>

This algorithm works. However, it is critically dependent on the speed of addition.</p>
<p>

Addition of long integers suffers from the problem that <link>
carries</link> have to be propagated from right to left and the final result is not known until this process has been completed. Carry propagation can be speeded up with <link xlink:type="simple" xlink:href="../739/2737739.xml">
carry look-ahead</link> logic, but this still makes addition very much slower than it needs to be (for 512-bit addition, addition with carry look-ahead is 32 times slower than addition without carries at all).</p>
<p>

Non-modular multiplication can make use of <link xlink:type="simple" xlink:href="../178/4337178.xml">
carry-save adders</link>, which save time by storing the carries from each digit position and using them later: for example, by computing 111111111111+000000000010 as 111111111121 instead waiting for the carry to propagate through the whole number to yield the true binary value 1000000000001. That final propagation still has to be done to yield a binary result but this only needs to be done once at the very end of the multiplication.</p>
<p>

Unfortunately the modular multiplication method outlined above needs to know the magnitude of the accumulated value at every step, in order to decide whether to subtract <it>r</it>: for example, if it needs to know whether the value in the accumulator is greater than 1000000000000, the carry-save representation 111111111121 is useless and needs to be converted to its true binary value for the comparison to be made.</p>
<p>

It therefore seems that one can have <it>either</it> the speed of carry-save <it>or</it> modular multiplication, but not both.</p>

<sec>
<st>
Outline of the algorithm</st>

<p>

The principle of the Kochanski algorithm is one of making guesses as to whether or not <it>r</it> should be subtracted, based on the most significant few bits of the carry-save value in the accumulator. Such a guess will be wrong some of the time, since there is no way of knowing whether latent carries in the less significant digits (which have not been examined) might not invalidate the result of the comparison. Thus:</p>
<p>

A subtraction may not have been made when one was required. In that case the result in the accumulator is greater than <it>r</it> (although the algorithm doesn't know it yet), and so after the next shift left, 2<it>r</it> will need to be subtracted from the accumulator.</p>
<p>

A subtraction may have been made when one was not required. In that case the result in the accumulator is less than 0 (although the algorithm doesn't know it yet), and so after the next shift left, <it>r</it> or even 2<it>r</it> will need to be added back to the accumulator to make it positive again.</p>
<p>

What is happening is essentially a race between the errors that result from wrong guesses, which double with every shift left, and the corrections made by adding or subtracting multiples of <it>r</it> based on a guess of what the errors may be.</p>
<p>

It turns out<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> that examining the most significant 4 bits of the accumulator is sufficient to keep the errors within bounds and that the only values that need to be added to the accumulator are -2<it>r</it>, -<it>r</it>, 0, +<it>r</it>, and +2<it>r</it>, all of which can be generated instantaneously by simple shifts and negations.</p>
<p>

At the end of a complete modular multiplication, the true binary result of the operation has to be evaluated and it is possible that an additional addition or subtraction of <it>r</it> will be needed as a result of the carries that are then discovered; but the cost of that extra step is small when amortized over the hundreds of shift-and-add steps that dominate the overall cost of the multiplication.</p>

</sec>
<sec>
<st>
Alternatives</st>

<p>

Brickell<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> has published a similar algorithm that requires greater complexity in the electronics for each digit of the accumulator.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../378/904378.xml">
Montgomery multiplication</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is an alternative algorithm that processed the multiplier "backwards" (least significant digit first) and uses the least significant digit of the accumulator to control whether or not the modulus should be added/subtracted. This avoids the need for carries to propagate. However, the algorithm is impractical for single modular multiplications, since two or three additional Montgomery steps have to be performed to convert the operands into a special form before processing and to convert the result back into conventional binary at the end.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
M.J. Kochanski, "Developing an RSA Chip", in <it>Advances in Cryptology: Proceedings of CRYPTO 85</it>, Springer-Verlag, Berlin (1985), 3-540-16463-4.</entry>
<entry id="2">
M.J. Kochanski, <weblink xlink:type="simple" xlink:href="http://www.nugae.com/encryption/bin/design.pdf">
A New Method of Serial Modular Multiplication</weblink> describes the algorithm in full detail.</entry>
<entry id="3">
Ernest F. Brickell, "A Fast Modular Multiplication Algorithm with Applications to Two Key Cryptography", in <it>Advances in Cryptology: Proceedings of CRYPTO '82</it>, Plenum, New York (1983), pp. 51-60.</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nugae.com/encryption/fap4.htm">
Creating the FAP4 Chip</weblink> Informal explanation and motivation of the algorithm, with details of an actual hardware implementation.</entry>
</list>


</p>
</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
