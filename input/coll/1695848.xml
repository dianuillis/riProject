<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:51:02[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<information  confidence="0.8" wordnetid="106634376">
<electronic_database  confidence="0.8" wordnetid="106588511">
<lexical_database  confidence="0.8" wordnetid="106638868">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<wordnet  confidence="0.8" wordnetid="106639428">
<database  confidence="0.8" wordnetid="106637824">
<header>
<title>Spring (operating system)</title>
<id>1695848</id>
<revision>
<id>222210215</id>
<timestamp>2008-06-28T02:49:18Z</timestamp>
<contributor>
<username>NapoliRoma</username>
<id>1741963</id>
</contributor>
</revision>
<categories>
<category>Sun Microsystems software</category>
<category>Operating systems</category>
<category>Microkernels</category>
</categories>
</header>
<bdy>

<b>Spring</b> was an experimental <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link>-based <link xlink:type="simple" xlink:href="../757/22757.xml">
object oriented</link> <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> developed at <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../980/26980.xml">
Sun Microsystems</link></institution>
</company>
 in the early 1990s. Using technology substantially similar to concepts developed in the <link xlink:type="simple" xlink:href="../028/21028.xml">
Mach kernel</link>, Spring concentrated on providing a richer programming environment supporting <link xlink:type="simple" xlink:href="../550/19550.xml">
multiple inheritance</link> and other features. Spring was also more cleanly separated from the operating systems it would host, divorcing it from its <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 roots and even allowing several OSes to be run at the same time. Development faded out in the mid-1990s, but several ideas and some code from the project was later re-used in the <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java programming language</link></request>
</message>
 libraries and the <link xlink:type="simple" xlink:href="../145/46145.xml">
Solaris operating system</link>.
<sec>
<st>
History</st>
<p>

<image location="right" width="200px" src="Spring_OS_1.0_cover.jpg" type="thumb">
<caption>

Spring Research Distribution 1.0 CD cover
</caption>
</image>

Spring started in a roundabout fashion in 1987, as part of Sun and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../269/17555269.xml">
AT&amp;T</link></company>
's collaboration to create a <link xlink:type="simple" xlink:href="../445/598445.xml">
merged UNIX</link>, both companies decided it was also a good opportunity to "reimplement UNIX in an object-oriented fashion".<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> However, after only a few meetings, this part of the project died.</p>
<p>

Sun decided to keep their team together and instead explore a system on the <link xlink:type="simple" xlink:href="../265/1774265.xml">
leading edge</link>. In addition to combining Unix flavours, the new system would also be able to run just about any other system as well, and do so in a distributed fashion. The system was first running in a "complete" fashion in 1993, and produced a series of research papers. In 1994 a "research quality" release was made under a non-commercial license, but it is unclear how widely this was used. The team broke up and moved to other projects within Sun, using some of the Spring concepts on a variety of other projects.</p>

</sec>
<sec>
<st>
Background</st>
<p>

The Spring project started soon after the release of Mach 3. In earlier versions Mach was simply a modified version of existing <link xlink:type="simple" xlink:href="../622/18932622.xml">
BSD Unix</link> kernels, but in Mach 3 the Unix services were separated out and run as a user-space program like any other, a concept Mach referred to as a <it>server</it>. Data which would normally be private in the kernel under a traditional Unix system was now passed between the servers and user programs using an <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> (IPC) system, ending in <it>ports</it> which both programs held. Mach implemented these ports in the kernel, using <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> to move data from program to program, relying on the <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link> (MMU) and the <link xlink:type="simple" xlink:href="../603/407603.xml">
copy on write</link> algorithm to do so with reasonable performance.</p>
<p>

In its ultimate development, an OS on Mach would consist of a number of such servers, each handling a specific task. Examples would include the <link xlink:type="simple" xlink:href="../280/1010280.xml">
file system</link> or <link xlink:type="simple" xlink:href="../882/23882.xml">
network stack</link>. The operating system server in such a system would be quite small, providing services unique to that OS, and forwarding most other calls to other servers. Since the OS was running on top of single set of common servers, several OS servers could be run at the same time, allowing a single system to "natively" support <link xlink:type="simple" xlink:href="../146/8146.xml">
DOS</link>, Unix and other operating systems at the same time.</p>
<p>

This capability was particularly exciting to companies like <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
, who were already supporting several different systems, and saw Mach as a way to combine these with common underlying code. In fact this was not so easy. Mach made several decisions at a low-level which made any system running on it Unix-like to some degree. Most notable was a security system which was modelled on fairly inflexible inherited model of Unix programs. Additionally the IPC system proved to be a major performance problem, although the nature of this issue didn't become clear until later. The performance was so poor that many commercial projects to port existing operating systems to Mach, notably <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
's <link xlink:type="simple" xlink:href="../497/1044497.xml">
Workplace OS</link>, were eventually abandoned.</p>

</sec>
<sec>
<st>
Rationale</st>
<p>

Although Sun was also interested in supporting multiple operating systems, their needs were nowhere as pressing as IBM or Apple. By this point in time they had already moved platforms from their early <link xlink:type="simple" xlink:href="../826/64826.xml">
68k</link>-based machines to their <link xlink:type="simple" xlink:href="../954/36954.xml">
SPARC</link>-based lineup, and their UNIX System V-based Solaris operating system was taking over from their BSD-based SunOS. Sun's concerns were somewhat more subtle: keeping developers interested in Sun's version of Unix; and, allowing their system to scale downwards onto smaller devices such as <link xlink:type="simple" xlink:href="../580/29580.xml">
set-top box</link>es. A microkernel-based system would be particularly useful in this latter role.</p>
<p>

Spring concentrated on "programmability"; making the system easier to develop on. The primary addition in this respect was the development of a rich <link xlink:type="simple" xlink:href="../224/160224.xml">
interface definition language</link> (IDL), which exported interfaces with considerably more information than the one used in Mach. In addition to functions and their parameters, Spring's interfaces also included information about what errors can be raised and the <it>namespace</it> they belong to. Given a proper language, programs, including operating system servers, could import multiple interfaces and combine them as if they were objects native to that language &mdash; notably <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
. Some time later the Spring IDL was adopted with minor changes as the <link xlink:type="simple" xlink:href="../799/4096799.xml">
CORBA IDL</link>.</p>
<p>

Spring also explored a number of specific software advances in file systems, virtual memory and IPC performance. The result was a single Unix-like system with much better performance than Mach. Some of these changes are detailed below.</p>

</sec>
<sec>
<st>
Description</st>
<p>

It should be noted that the Sun engineers used non-standard terminology for a number of common components, which makes discussing the system somewhat confusing. For instance, Mach <it>tasks</it> are referred to as <it>domains</it>, <it>ports</it> as <it>doors</it>, and the <it>kernel</it> as the <it>nucleus</it>.</p>

<ss1>
<st>
The nucleus</st>
<p>

The Spring kernel was divided into two parts: a virtual memory system and the <it>nucleus</it>. Although the nucleus is equivalent to only one portion of the Mach kernel, the kernels of each OS are analogous enough to be considered to perform the same function.</p>
<p>

The Spring kernel includes only the most basic functionality and state needed to support user-side applications. Primarily this includes state to maintain lists of running programs (<it>domains</it>) and their threads, as well as the communications links between them (<it>doors</it>).</p>
<p>

The Spring kernel is not multi-threaded. Normally this would preclude it from use in <link xlink:type="simple" xlink:href="../130/2728130.xml">
realtime</link> settings, but it is not clear that is the case. Normally kernels need to be threaded in order to ensure a long-running task such as disk <link xlink:type="simple" xlink:href="../558/14558.xml">
I/O</link> won't tie up the system and prevent a subsequent call from being serviced in time; under Spring the kernel almost immediately hands off the vast majority of requests to the servers, so under this model it is only the servers which, in theory, need to be threaded.</p>

</ss1>
<ss1>
<st>
IPC model</st>
<p>

One major difference between Mach and Spring was the IPC system. In Mach, the system was arranged as a set of one-way asynchronous pipes (<it>ports</it>) between programs, a concept derived from <link xlink:type="simple" xlink:href="../117/1236117.xml">
Unix pipes</link>. In programming, however, the most common method of communications is the <link xlink:type="simple" xlink:href="../988/40988.xml">
procedure call</link>, or call/return, which Mach did not support directly. Call/return semantics could only be supported via additional code in higher-level libraries based on the underlying ports mechanism, thereby adding complexity.</p>
<p>

Spring instead directly supported call/return semantics in the basic communications system. This resulted in a change of terminology from <it>ports</it> in Mach, to <it>doors</it> in Spring. Doors were known to the kernel only; programs were handed a "handle" to the door with an identifier which was unique to that program. The system worked similarly to ports for the initial message; messages sent to a door were examined by the nucleus in order to find the target application and translate the door handle, but the nucleus then recorded small amounts of information from the caller in order to be able to return data quickly. This sped up the return by about 40%.</p>
<p>

Additionally, the Mach model was asynchronous &mdash; the call would return if and when the server had data. This followed the original Unix model of pipes, which allowed other programs to run if the server was busy. However for a call/return system this has serious drawbacks, because the task scheduler has to run to select the next program to be serviced. Hopefully this was the server the call was requesting data from, but it this was not guaranteed. Under Spring, IPC is synchronous; control is immediately passed to the server without running the scheduler, improving the round trip time in the common case when the server can immediately return.</p>
<p>

Under Mach, the <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> system, supported by the <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link> (MMU), was expected to provide a lightweight solution to copying data, by simply mapping the same data in memory into the two programs. In reality this solution was not at all efficient, as many MMUs had design features which made this mapping slow or even impossible.</p>
<p>

Unlike Mach's one-size-fits-all solution to IPC, Spring used a variety of methods to physically pass data between programs. One of these, the <it>bulk-path</it>, was basically identical to Mach's ports and messages, but in practice the bulk-path was the least common message type. For smaller messages Spring provided the <it>vanilla-path</it>, which directly copied the data from one space to another, something which proved to be faster than memory mapping in the real world for less than 5k of data.</p>
<p>

Most interesting of all was the <it>fast-path</it>, which allowed for extremely fast invocations &mdash; at least when running on <link xlink:type="simple" xlink:href="../954/36954.xml">
SPARC</link>-based platforms. The fast-path used a unique "half-trap" to avoid much of the <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>ing overhead which plagued Mach systems. Instead of saving out all of the processor state—the normal procedure in the case of a trap into the kernel—Spring only saved out the top 16 SPARC registers, a number which was defined by specific implementation details of the SPARC architecture. The other portions of the register stack were rendered invisible to the receiver using the SPARC's WIM instruction, providing some level of security. The fast-path strongly resembles a classic procedure call within a single application, which uses <link xlink:type="simple" xlink:href="../380/480380.xml">
register window</link>s on the SPARC, adding some MMU work to move the context from one program to another.</p>
<p>

The fast-path was only available for calls passing simple values which didn't have to be translated (no door references, for instance) with up to 16 values in total. Although this would seem to be quite limiting, the fast-path is actually used by the vast majority of calls in Spring—generally over 80% of the calls and about 60% of the returns. Returns often respond with large blocks of data, for instance, a disk block, explaining why the returns more often used the other IPC systems.</p>
<p>

On 32-bit SPARC V8 systems, a complete round-trip call using the fast-path took just over 100 instructions, making it many times faster than a typical Mach call. It remains unclear whether or not the fast-path could be implemented on other machines, so the overall performance improvement of Spring is difficult to compare with Mach, which was typically measured on <link xlink:type="simple" xlink:href="../046/15046.xml">
IA-32</link> systems. Specifically, a full syscall took under 20 µsec on a 486DX-50 for existing <link xlink:type="simple" xlink:href="../622/18932622.xml">
BSD Unix</link> systems, and 114 µsec under Mach. This led to a performance hit of 50% or more, and doomed most Mach projects. In contrast, Spring using the fast-path boasted an IPC time of only 11 µsec on a <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<digital_computer wordnetid="103196324" confidence="0.8">
<workstation wordnetid="104603399" confidence="0.8">
<link xlink:type="simple" xlink:href="../667/7322667.xml">
SPARCstation 2</link></workstation>
</digital_computer>
</machine>
</device>
</instrumentality>
</artifact>
</computer>
.</p>

</ss1>
<ss1>
<st>
Virtual memory</st>
<p>

Another key area of improvement in Spring was the implementation of the <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> (VM) system, also part of the kernel. Virtual memory is a system which ties together the physical <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link> in a machine, the MMU, and the disk system to create the illusion that every program on the system has its own block of RAM equal to the maximum the machine and operating system can support.  The most prevalent memory addressing model in computers and operating systems in use in the 1980s and 1990s was 32 bits, providing access to a theoretical limit of 4 <link xlink:type="simple" xlink:href="../000/147000.xml">
GiB</link> of memory, but until the early 2000s, only relatively expensive computers would have that much physical RAM. The VM system creates the illusion of more by using the <link xlink:type="simple" xlink:href="../777/13777.xml">
hard disk</link> as a <link>
backing store</link>, an area of much slower memory used to offload inactive portions of RAM.</p>
<p>

In traditional Unix systems VM is a part of the kernel, as are the disk and memory handlers it ties together. Under Mach the decision of where to place the VM system is not so obvious—although the kernel is in control of RAM and the MMU, the disk handlers are part of external client programs. To solve this problem Mach 3 introduced a new two-layer VM system, with control of the actual VM system in the kernel, which would then ask an external client-space <it>pager</it> to interact with the disk system to physically copy memory around. Unfortunately this proved to be a serious performance issue, requiring several trips in and out of the kernel (with resulting context switches along with it) as the various layers of the VM system called each other.</p>
<p>

The Spring team had the advantage of being able to examine what went wrong with the Mach model and fix it. The result was a much more cleanly separated system of <it>address spaces</it> in programs, mapped by the VM into various <it>memory</it> objects, which were in turn managed by a <it>pager</it> for backing store handling. When a program made a request for data the request was passed to the VM system in the kernel, which would find the appropriate pager and ask it to create and set up an appropriate memory object. In exchange the pager was passed a <it>cache manager</it> from the VM, which was responsible for keeping track of clean/dirty status of the local cache of that memory object. Implementation details added considerable complexity to this model, but most of this was hidden. In the end the basic system had pagers which were in charge of the memory, and address spaces which were in charge of the caches. The two had well-defined interfaces allowing them to pass commands back and forth to keep their data in sync.</p>
<p>

This split in duties led to one very real performance improvement. Since programs could share the memory objects, and microkernel systems like Spring are based on the idea of copying memory around, Spring allowed programs sharing memory in this fashion to share it in the VM system as well. Thus under Mach if a network file server is handing data to a program <it>both</it> programs will end up using up memory in the VM system, whereas under Spring the two would <it>naturally</it> share the same memory objects, as the pager implementing that memory object would simply return another handle to the same memory. Only inside the VM would they be considered different objects, and would be handled by separate cache managers. Therefore the <it>data</it> would only be cached in RAM once. In theory this could lead to considerably better real-world RAM usage.</p>
<p>

Additionally, the use of external pagers with a well defined API allowed the system to be cleanly separated when this was needed. Spring also allowed programs themselves to state which pager would be best suited to their needs, including themselves, allowing Spring programs to easily implement private VM systems for known workloads. For applications like <link xlink:type="simple" xlink:href="../151/41151.xml">
file server</link>s, <link xlink:type="simple" xlink:href="../455/33455.xml">
web server</link>s and <link xlink:type="simple" xlink:href="../513/8513.xml">
database management system</link>s, custom VMs and file systems often lead to dramatically improved performance.</p>

</ss1>
<ss1>
<st>
Name service</st>
<p>

Most operating systems include a variety of <it>naming services</it>. The most basic example is a file system, in which the files are internally referred to by a "handle", a small number, while a separate directory gives the files names with which the users interact. The same kind of name/identifier dichotomy occurs many other parts of the typical Unix system; printers are named in the etc/printcap file, small numbers and strings in the environment variables, and network locations in DNS. Each of these systems provided its own names, with a custom <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link>, making the different objects appear completely different even in concept.</p>
<p>

Other systems had attempted to add naming systems to existing Unix systems, but generally these were "covers" over the existing functionality which simply collected up all the names from these various services and presented them in one collection. Due to the fact they relied on knowing about the underlying system layout they tended to be rather inflexible, not making it easy for new services to be added. These seem to have seen little use.</p>
<p>

Only in a completely new operating system could one hope to provide a universal service. For instance, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../226/24226.xml">
Plan 9</link></O>
 used the file system as a universal naming service; everything from printers to windows could be accessed by name through the file system. This is an extension of the original Unix concept, one which had slowly disappeared as more and more functionality had been added over the years.</p>
<p>

Interestingly Mach did not have a naming service of any sort for its ports. This proved to be a serious problem, because programs had to know in advance what servers they had to call in order to ask the kernel to provide a port. This meant that replacing functionality was much more difficult than it should have been; a new printer server needed to sit on the same ports as the old one for instance: there would be no way to run two side by side for development. If ports were instead referred to by name, servers could sit on different ports and simply use the same name. Needless to say, the addition of a name server was considered highly important under Spring.</p>
<p>

Spring's approach essentially inverted the Plan 9 system: under Spring the file system was one example of a server which used the single unified name service. The same service could be used to name files on disk, environment variables, hardware devices, programs and even objects inside programs. The system was hierarchical, only the system namespace was directly supported, by a server which started at boot time. Other servers would then "bind" the names they knew into the system, the printer server would produce a list of printers, the file system would bind in the directories of attached disks. In this way a mapping of all the objects on the system was built up, potentially at runtime, and could be accessed in a file-like fashion very similar to Plan 9. All of these could be accessed using a single API, although the system also provided a variety of stub libraries to make it appear as classical services as well, notably in the Unix emulation server.</p>
<p>

The name service was also the central location for security and permissioning. Since doors, the real accessors in Spring, were handed out by the name service, the server included a complete <link xlink:type="simple" xlink:href="../589/61589.xml">
access control list</link>-based permission checking system. So in addition to providing permissions on the file system, under Spring any object could be controlled using the same set of permissions and user interface. Contrast this with <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/33438.xml">
Windows NT</link></family>
 for instance, which includes about a dozen permissioning systems (file system, DCOM, SQL access, IIS, etc.), all of which have to be set up separately. In order to improve performance, the system included the concept of trust, allowing nameservers to assume requests from other servers were valid. For instance, if a user asked the file server to access a file, the system nameserver would pass along the request to the file system, which would immediately honor it. However since the user was not known, the ACL's would be check against the file being accessed.</p>
<p>

Groups of related names were known as <it>contexts</it>. Contexts were also names, and thus similar to the file system concept of a directory. Users could build their own contexts out of seemingly unrelated objects; printers using completely separate drivers (servers) could be collected into a single list, a file could have different names in different places (or for different users), or more interestingly a single domain could be built up containing every personal file in it for searching purposes. In this manner Spring allowed file directories to be "unioned", a useful feature lacking from traditional Unixen.</p>
<p>

Spring did not include a built-in <link xlink:type="simple" xlink:href="../788/19632788.xml">
object persistence</link> system, but the name service was persistent and could be used to find objects in this sort of manner. To some degree the series of servers started during boot time provided a persistent name space which survived boots, as they copied their names into the same server. In theory the system could allow the name server to provide a "lazy launch" system, not starting the networking server until someone requests it for instance, but it does not appear it included this functionality. In fact the separation of name spaces would allow this to be separated out to the service which actually implemented the naming of doors, making implementation considerably easier.</p>

</ss1>
<ss1>
<st>
File system</st>
<p>

As stated earlier, the Spring VM allowed any program to define what pager it should use. Additionally the Spring system was based on a single universal naming system. These two concepts were combined to produce the Spring file system.</p>
<p>

Key to the Spring file system's operation was tight integration with the VM system. Since it was "known" that the VM system would be managing the local cache of the data from the file system, the file system was reduced to a command structure only, and was its own pager. That is, the file system was responsible for loading and saving data from memory objects when needed, but caching of that data would be handled for it by the VM. As mentioned before, this means that under Spring a file only exists in RAM in one place, no matter how it is being shared by the programs in the system.</p>
<p>

Spring used two sorts of file systems, a <it>local file system</it> which was similar to most common Unix systems, as well as a <it>caching file system</it> for network devices. The caching system demonstrates the utility of Spring's VM/pager split, using the same physical memory from the VM which it would have to use normally, the CFS short-circuited all read requests to the local cache, and did lazy write-backs every 30 seconds to the source file system. This would be particularly notable if common Unix directories were being loaded over the network, the normal setup for labs of <link xlink:type="simple" xlink:href="../181/68181.xml">
workstation</link>s. Most Unix systems use similar caching mechanisms for the same performance reasons, but would end up using RAM twice, once in the cache, and again in the programs using it. The CFS also cached names from the remote system, making the initial directory traversal and open requests much faster.</p>
<p>

The Spring file system is also a name service context provider, lazily mapping directories from the on-disk structure into new contexts in the name service. These could then be accessed using the universal naming API, or alternately via a Unix emulation library which presented them as a traditional unix file system.</p>
<p>

Note that Spring's use of the term <it>file system</it> is somewhat confusing. In normal usage the term refers to a particular way to physically store files on a disk.</p>

</ss1>
<ss1>
<st>
Unix emulation</st>
<p>

Spring also needed to support existing Unix applications, the basis of Sun's business. To do this, Spring also shipped with two key extensions: a Unix process server which mimicked a full Unix, and a re-write of the standard <it>libc</it> library called <it>libue</it> which redirected Unix kernel requests to various servers.
For instance, a Unix application which required file or network services would be directed to the associated Spring server, while one which wanted to list the currently running programs would be directed to the Unix process server. The process server was also responsible for handling <it>signals</it>, a concept which had no analog under Spring &mdash; nor was it really needed other than for backward compatibility, since signals are essentially an inflexible single-purpose IPC mechanism.</p>
<p>

Running a Unix application under Spring required that it be re-linked against <it>libue</it>; the system shipped with the majority of basic Unix utilities and an X11 server relinked and ready to use. However this method of compatibility was neither invisible nor guaranteed to work; Spring documents note that "many" applications will run unmodified (presumably other than relinking), but fail to mention what sort of problem areas the developer should expect if they do not.</p>

</ss1>
<ss1>
<st>
Subcontracts</st>
<p>

Although not directly related to Spring per se, the Sun engineers working on the project found that existing mechanisms for supporting different flavors of calls were not well defined. In order to provide a richer interface, they developed the concepts of <it>subcontracts</it>.</p>

</ss1>
</sec>
<sec>
<st>
Other systems</st>
<p>

Sun have added a "Unixified" version of <link xlink:type="simple" xlink:href="../455/6642455.xml">
Doors</link> to Solaris.</p>
<p>

In the years since the Spring system work ended, work on operating systems in general has essentially ended. With the market quickly stratifying into a world dominated by Windows and Unix-like operating systems, there appear to be only niche markets open for any other system. Additionally, the poor performance of Mach 3 seems to have taken the wind out of the sails of many projects.</p>
<p>

Nevertheless there have been some newer systems. One in particular, the <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel</link>, shares a number of features with Spring's kernel. In particular it also uses a synchronous call/return system for IPC, and has a similar VM model. L4 has, so far, concentrated almost solely on the kernel itself; there is nothing analogous to Spring's naming service, security model or file system.</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../982/14831982.xml">
Jim Mitchell</link></scientist>
</person>
&#32;(2001).&#32;"<weblink xlink:type="simple" xlink:href="http://research.sun.com/features/tenyears/volcd/papers/mitchell.htm">
Introduction to "An Overview of the Spring System"</weblink>".&#32;<it>Sun Microsystems Laboratories: 10 Years of Impact</it>.&#32;  Sun Microsystems, Inc..&#32;Retrieved on <link>
2008-06-28</link>.</entry>
</reflist>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://research.sun.com/features/tenyears/volcd/papers/Mitchell.pdf">
An Overview of the Spring System</weblink> (PDF)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://research.sun.com/techrep/1993/smli_tr-93-14.pdf">
The Spring Nucleus: A Microkernel for Objects</weblink> (PDF)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://research.sun.com/techrep/1993/smli_tr-93-16.ps">
 The Spring Name Service</weblink> (PostScript)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://research.sun.com/techrep/1993/smli_tr-93-9.pdf">
The Spring Virtual Memory System</weblink> (PDF)</entry>
</list>
</p>


</sec>
</bdy>
</database>
</wordnet>
</entity>
</lexical_database>
</electronic_database>
</information>
</message>
</article>
