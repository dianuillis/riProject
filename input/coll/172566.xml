<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:23:57[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<header>
<title>Rete algorithm</title>
<id>172566</id>
<revision>
<id>239275047</id>
<timestamp>2008-09-18T13:36:10Z</timestamp>
<contributor>
<username>Andy Dingley</username>
<id>3606755</id>
</contributor>
</revision>
<categories>
<category>Expert systems</category>
<category>Decision theory</category>
<category>Pattern matching</category>
</categories>
</header>
<bdy>

The <b>Rete algorithm</b> is an efficient <link xlink:type="simple" xlink:href="../688/279688.xml">
pattern matching</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for implementing <link xlink:type="simple" xlink:href="../457/3157457.xml">
production rule system</link>s.  The Rete algorithm was designed by Dr <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/476022.xml">
Charles L. Forgy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 of <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../093/48093.xml">
Carnegie Mellon University</link></university>
, first published in a working paper in <link xlink:type="simple" xlink:href="../654/34654.xml">
1974</link>, and later elaborated in his <link xlink:type="simple" xlink:href="../754/34754.xml">
1979</link> Ph.D. thesis and a <link xlink:type="simple" xlink:href="../756/34756.xml">
1982</link> paper (see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22References%22])">
References</link>). Rete has become the basis for many popular expert systems, including <link xlink:type="simple" xlink:href="../603/418603.xml">
CLIPS</link>, <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../091/37091.xml">
Jess</link></machine>
</device>
</motor>
</engine>
</instrumentality>
</artifact>
</system>
, <link>
JBoss Rules</link>, and <link xlink:type="simple" xlink:href="../751/729751.xml">
Soar</link>. <p>

A <link>
naïve implementation</link> of an expert system might check each <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/252311.xml">
rule</link></rule>
</concept>
</idea>
 against the known <link xlink:type="simple" xlink:href="../617/58617.xml">
fact</link>s in the <link xlink:type="simple" xlink:href="../497/239497.xml">
Knowledge base</link>, firing that rule if necessary, then moving on to the next rule (and looping back to the first rule when finished).  For even moderate sized rules and facts knowledge-bases, this naïve approach performs far too slowly.</p>
<p>

The Rete algorithm (usually pronounced either 'REET', 'REE-tee' or, in Europe, 're-tay' after the Latin pronunciation, from the <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../730/17730.xml">
Latin</link></language>
 'rete' for net, or ) provides the basis for a more efficient implementation of an expert system.  A Rete-based expert system builds a network of <link xlink:type="simple" xlink:href="../899/638899.xml">
node</link>s, where each node (except the root) corresponds to a pattern occurring in the left-hand-side (the condition part) of a rule.  The path from the <link>
root node</link> to a <link xlink:type="simple" xlink:href="../228/18228.xml">
leaf node</link> defines a complete rule left-hand-side.  Each node has a memory of facts which satisfy that pattern. This structure is essentially a generalized <link xlink:type="simple" xlink:href="../274/31274.xml">
Trie</link>.</p>
<p>

As new facts are asserted or modified, they propagate along the network, causing nodes to be annotated when that fact matches that pattern.  When a fact or combination of facts causes all of the patterns for a given rule to be satisfied, a leaf node is reached and the corresponding rule is triggered.</p>
<p>

The Rete algorithm is designed to sacrifice <link xlink:type="simple" xlink:href="../847/25847.xml">
memory</link> for increased speed.  In most cases, the speed increase over naïve implementations is several orders of magnitude (because Rete performance is theoretically independent of the number of rules in the system).  In very large expert systems, however, the original Rete algorithm tends to run into memory consumption problems.  Other algorithms, both novel and Rete-based, have since been designed which require less memory.</p>

<sec>
<st>
 Description </st>
<p>

The Rete algorithm provides a generalized logical description of an implementation of functionality responsible for matching data <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
 (‘facts’) against <link>
productions</link> (‘<link xlink:type="simple" xlink:href="../066/242066.xml">
rules</link>’) in a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link>
pattern-matching</link></concept>
</idea>
 <link xlink:type="simple" xlink:href="../457/3157457.xml">
production system</link> (a category of <link xlink:type="simple" xlink:href="../853/1867853.xml">
rule engine</link>).   A <link>
production</link> consists of one or more conditions and a set of actions which may be undertaken for each complete set of facts that match the conditions.   Conditions test fact <link>
attributes</link>, including fact type specifiers/identifiers.   The Rete algorithm exhibits the following major characteristics:</p>
<p>

<list>
<entry level="1" type="bullet">

	It reduces or eliminates certain types of redundancy through the use of node sharing.</entry>
<entry level="1" type="bullet">

	It stores partial matches when performing <link>
joins</link> between different fact types.   This, in turn, allows production systems to avoid complete re-evaluation of all facts each time changes are made to the production system’s working memory.   Instead, the production system needs only to evaluate the changes (deltas) to working memory.</entry>
<entry level="1" type="bullet">

	It allows for efficient removal of memory elements when facts are retracted from working memory.</entry>
</list>

The Rete algorithm is widely used to implement matching functionality within pattern-matching engines that exploit a match-resolve-act cycle to support <link xlink:type="simple" xlink:href="../962/568962.xml">
forward chaining</link> and <link xlink:type="simple" xlink:href="../465/317465.xml">
inferencing</link>.</p>
<p>

Retes are <family wordnetid="108078020" confidence="0.8">
<link>
directed acyclic graphs</link></family>
 that represent higher-level rule sets.   They are generally represented at run-time using a network of in-memory objects.   These networks match rule conditions (patterns) to facts (relational data tuples).  Rete networks act as a type of relational query processor, performing <link>
projections</link>, <link>
selections</link> and <link>
joins</link> conditionally on arbitrary numbers of data <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
. </p>
<p>

<link>
Productions</link> (<link xlink:type="simple" xlink:href="../066/242066.xml">
rules</link>) are typically captured and defined by <link>
analysts</link> and <link>
developers</link> using some high-level rules language.     They are collected into rule sets which are then translated, often at run time, into an executable Rete.</p>
<p>

When facts are ‘asserted’ to working memory, the engine creates ‘working memory elements’ (WMEs) for each fact.   Facts are <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
n-tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
, and may therefore contain an arbitrary number of data items.   Each WME may hold an entire <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
n-tuple</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
, or, alternatively, each fact may be represented by a set of WMEs where each WME contains a fixed-length <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
.   In this case, <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
 are typically triplets (<series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
3-tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
).</p>
<p>

Each WME enters the Rete network at a single root node.  The root node passes each WME on to its child nodes, and each WME may then be propagated through the network, possibly being stored in intermediate memories, until it arrives at a terminal node.</p>

<ss1>
<st>
 Alpha Network </st>
<p>

The ‘left’ (alpha) side of the node graph forms a discrimination network responsible for selecting individual WMEs based on simple conditional tests which match WME attributes against constant values.  Nodes in the discrimination network may also perform tests that compare two or more <link>
attributes</link> of the same WME.  If a WME is successfully matched against the conditions represented by one node, it is passed to the next node.   In most engines, the immediate child nodes of the root node are used to test the entity identifier or fact type of each WME.   Hence, all the WMEs which represent the same <link xlink:type="simple" xlink:href="../176/42176.xml">
entity</link> type typically traverse a given branch of nodes in the discrimination network.</p>
<p>

Within the discrimination network, each branch of alpha nodes (also called 1-input nodes) terminates at a memory, called an ‘alpha’ memory.   These memories store collections of WMEs that match each condition in each node in a given node branch.   WMEs that fail to match at least one condition in a branch are not materialised within the corresponding alpha memory.   Alpha node branches may fork in order to minimise condition redundancy.</p>
<p>

A possible variation is to introduce additional memories for each intermediate node in the discrimination network.   This increases the overhead of the Rete, but may have advantages in situations where rules are dynamically added to or removed from the Rete, making it easier to vary the topography of the discrimination network dynamically.</p>
<p>

An alternative implementation is described by <weblink xlink:type="simple" xlink:href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf">
Doorenbos</weblink>.    In this case, the discrimination network is replaced by a set of memories and an <link>
index</link>.    The <link>
index</link> may be implemented using a <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link>.   Each memory holds WMEs that match a single conditional pattern, and the <link>
index</link> is used to reference memories by their pattern.   This approach is only practical when WMEs represent fixed-length <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
, and the length of each <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
 is short (e.g., <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
3-tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
).   In addition, the approach only applies to conditional patterns that perform <link>
equality</link> tests against <link xlink:type="simple" xlink:href="../818/32818.xml#xpointer(//*[./st=%22Constants%22])">
constant</link> values.   When a WME enters the Rete, the <link>
index</link> is used to locate a set of memories whose conditional pattern matches the WME <link>
attributes</link>, and the WME is then added directly to each of these memories.   In itself, this implementation contains no 1-input nodes.   However, in order to implement non-equality tests, the Rete may contain additional 1-input node networks through which WMEs are passed before being placed in a memory.   Alternatively, non-equality tests may be performed in the beta network described below.</p>

</ss1>
<ss1>
<st>
 Beta Network </st>
<p>

The ‘right’ (beta) side of the graph chiefly performs <link>
joins</link> between different WMEs.    It is optional, and is only included if required.   It consists of 2-input nodes where each node has a ‘left’ and a ‘right’ input.   Each beta node sends its output to a ‘beta’ memory.</p>
<p>

Beta nodes process tokens.   A token is a unit of storage within a memory and also a unit of exchange between memories and nodes.  In many implementations, tokens are introduced within alpha memories where they are used to hold single WMEs.   These tokens are then passed to the beta network.</p>
<p>

Each beta node performs its work and, as a result, may create new tokens to hold a list of WMEs representing a partial match.   These extended tokens are then stored in beta memories, and passed to subsequent beta nodes.   In this case, the beta nodes typically pass lists of WMEs through the beta network by copying existing WME lists from each received token into new tokens and then adding a further WMEs to the lists as a result of performing a <link>
join</link> or some other action.   The new tokens are then stored in the output memory.</p>
<p>

A common variation is to build <link>
linked lists</link> of tokens where each token holds a single WME.   In this case, lists of WMEs for a partial match are represented by the <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link> of tokens.   This approach may be more optimal because it eliminates the need to copy lists of WMEs from one token to another.   Instead, a beta node needs only to create a new token to hold a WME it wishes to join to the partial match list, and then link the new token to a parent token stored in the input beta memory.   The new token now forms the head of the token list, and is stored in the output beta memory.</p>
<p>

In descriptions of Rete, it is common to refer to token passing within the beta network.   In this article, however, we will describe data propagation in terms of WME lists, rather than tokens, in recognition of different implementation options and the underlying purpose and use of tokens.    As any one WME list passes through the beta network, new WMEs may be added to it, and the list may be stored in beta memories.     A WME list in a beta memory represents a partial match for the conditions in a given <link>
production</link>.</p>
<p>

WME lists that reach the end of a branch of beta nodes represent a complete match for a single <link>
production</link>, and are passed to terminal nodes.   These nodes are sometimes called ‘p-nodes’, where ‘p’ stands for ‘<link>
production</link>’.   Each terminal node represents a single <link>
production</link>, and each WME list that arrives at a terminal node represents a complete set of matching WMEs for the conditions in that <link>
production</link>.   For each WME list it receives, a production node will ‘activate’ a new <link>
production</link> instance on the ‘agenda’.   Agendas are typically implemented as <link>
prioritised queues</link>.</p>
<p>

Beta nodes typically perform joins between WME lists stored in beta memories and individual WMEs stored in alpha memories.   Each beta node is associated with two input memories.    An alpha memory holds WM and performs ‘right’ activations on the beta node each time it stores a new WME.    A beta memory holds WME lists and performs ‘left’ activations on the beta node each time it stores a new WME list.  When a join node is right-activated, it compares one or more attributes of the newly stored WME from its input alpha memory against given attributes of specific WMEs in each WME list contained in the input beta memory.   When a join node is left-activated it traverses a single newly stored WME list in the beta memory, retrieving specific attribute values of given WMEs.   It compares these values with attribute values of each WME in the alpha memory.</p>
<p>

Each beta node outputs WME lists which are either stored in a beta memory or sent directly to a terminal node.   WME lists are stored in beta memories whenever the engine will perform additional left activations on subsequent beta nodes.</p>
<p>

Logically, a beta node at the head of a branch of beta nodes is a special case because it takes no input from any beta memory higher in the network.    Different engines handle this issue in different ways. Some engines use specialised adapter nodes to connect alpha memories to the left input of beta nodes. Other engines allow beta nodes to take input directly from two alpha memories, treating one as a ‘left’ input and the other as a ‘right’ input.   In both cases, ‘head’ beta nodes take their input from two alpha memories.</p>
<p>

In order to eliminate node redundancies, any one alpha or beta memory may be used to perform activations on multiple beta nodes.   As well as join nodes, the beta network may contain additional node types, some of which are described below.   If a Rete contains no beta network, alpha nodes feed tokens, each containing a single WME, directly to p-nodes.   In this case, there may be no need to store WMEs in alpha memories.</p>

</ss1>
<ss1>
<st>
 Conflict Resolution </st>
<p>

During any one match-resolve-act cycle, the engine will find all possible matches for the facts currently asserted to working memory.   Once all the current matches have been found, and corresponding production instances have been activated on the agenda, the engine determines an order in which the production instances may be ‘fired’.    This is termed ‘conflict resolution’, and the list of activated production instances is termed the ‘conflict set’.  The order may be based on rule priority (salience), rule order, the time at which facts contained in each instance were asserted to the working memory, the complexity of each production or some other criteria.   Many engines allow rule developers to select between different conflict resolution strategies or to chain a selection of multiple strategies.</p>
<p>

Conflict resolution is not defined as part of the Rete algorithm, but is used alongside the algorithm.    Some specialised <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link>
production systems</link></instrumentality>
</artifact>
</system>
 do not perform conflict resolution.</p>

</ss1>
<ss1>
<st>
 Production Execution</st>
<p>

Having performed conflict resolution, the engine now ‘fires’ the first production instance, executing a list of actions associated with the <link>
production</link>. The actions act on the data represented by the production instance’s WME list.</p>
<p>

By default, the engine will continue to fire each production instance in order until all production instances have been fired.   Each production instance will fire only once, at most, during any one match-resolve-act cycle.   This characteristic  is termed ‘refraction’.   However, the sequence of production instance firings may be interrupted at any stage by performing changes to the working memory.   Rule actions can contain instructions to assert or retract WMEs from the ‘working memory’ of the engine. Each time any single production instance performs one or more such changes, the engine immediately enters a new match-resolve-act cycle.   This includes ‘updates’ to WMEs currently in the working memory.   Updates are represented by retracting and then re-asserting the WME.   The engine undertakes matching of the changed data which, in turn, may result in changes to the list of production instances on the agenda.  Hence, after the actions for any one specific production instance have been executed, previously activated instances may have been de-activated and removed from the agenda, and new instances may have been activated.</p>
<p>

As part of the new match-resolve-act cycle, the engine performs conflict resolution on the agenda and then executes the current first instance.  The engine continues to fire production instances, and to enter new match-resolve-act cycles, until no further production instances exist on the agenda.  At this point the rule engine is deemed to have completed its work, and halts.</p>
<p>

Some engines support advanced refraction strategies in which certain production instances executed in a previous cycle are not re-executed in the new cycle, even though they may still exist on the agenda.</p>
<p>

It is possible for the engine to enter into never-ending loops in which the agenda never reaches the empty state.   For this reason, most engines support explicit ‘halt’ verbs that can be invoked from production action lists.  They may also provide automatic <link xlink:type="simple" xlink:href="../279/670279.xml">
loop detection</link> in which never-ending loops are automatically halted after a given number of iterations.   Some engines support a model in which, instead of halting when the agenda is empty, the engine enters a wait state until new facts are asserted externally. </p>
<p>

As for conflict resolution, the firing of activated production instances is not a feature of the Rete algorithm.   However, it is a central feature of engines that use Rete networks. Some of the optimisations offered by Rete networks are only useful in scenarios where the engine performs multiple match-resolve-act cycles.</p>

</ss1>
<ss1>
<st>
 Existential and Universal Quantifications </st>
<p>

Conditional tests are most commonly used to perform <link>
selections</link> and <link>
joins</link> on individual <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
.   However, by implementing additional beta node types, it is possible for Rete networks to perform <link xlink:type="simple" xlink:href="../806/228806.xml">
quantifications</link>.    <link xlink:type="simple" xlink:href="../420/91420.xml">
Existential quantification</link> involves testing for the existence of at least one set of matching WMEs in working memory.   <link xlink:type="simple" xlink:href="../174/76174.xml">
Universal quantification</link> involves testing that an entire set of WMEs in working memory meets a given condition.    A variation of <link xlink:type="simple" xlink:href="../174/76174.xml">
universal quantification</link> might test that a given number of WMEs, drawn from a set of WMEs, meets a given criteria.   This might be in terms of testing for either an exact number or a minimum number of matches.</p>
<p>

<link xlink:type="simple" xlink:href="../806/228806.xml">
Quantification</link> is not universally implemented in Rete engines, and, where it is supported, several variations exist.   A variant of <link xlink:type="simple" xlink:href="../420/91420.xml">
existential quantification</link> referred to as ‘negation’ is widely, though not universally, supported, and is described in seminal documents.   Existentially negated conditions and <link>
conjunctions</link> involve the use of specialised beta nodes that test for non-existence of matching WMEs or sets of WMEs.   These nodes propagate WME lists only when no match is found.   The exact implementation of negation varies.   In one approach,  the node maintains a simple count on each WME list it receives from its left input.   The count specifies the number of matches found with WMEs received from the right input.   The node only propagates WME lists whose count is zero.   In another approach, the node maintains an additional memory on each WME list received from the left input.   These memories are a form of beta memory, and store WME lists for each match with WMEs received on the right input.   If a WME list does not have any WME lists in its memory, it is propagated down the network.   In this approach, negation nodes generally activate further beta nodes directly, rather than storing their output in an additional beta memory.   Negation nodes provide a form of '<link xlink:type="simple" xlink:href="../537/2526537.xml">
negation as failure</link>'.</p>
<p>

When changes are made to working memory, a WME list that previously matched no WMEs may now match newly asserted WMEs.   In this case, the propagated WME list and all its extended copies need to be retracted from beta memories further down the network.   The second approach described above is often used to support efficient mechanisms for removal of WME lists.   When WME lists are removed, any corresponding production instances are de-activated and removed from the agenda.</p>
<p>

<link xlink:type="simple" xlink:href="../420/91420.xml">
Existential quantification</link> can be performed by combining two negation beta nodes.   This represents the semantics of <link xlink:type="simple" xlink:href="../143/194143.xml">
double negation</link> (e.g., ‘If NOT NOT any matching WMEs, then…’).   This is a common approach taken by several <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link>
production systems</link></instrumentality>
</artifact>
</system>
.</p>

</ss1>
<ss1>
<st>
 Memory Indexing </st>
<p>

The Rete algorithm does not mandate any specific approach to indexing the working memory.   However, most modern production systems provide <link>
indexing</link> mechanisms.   In some cases, only beta memories are indexed, whilst in others, indexing is used for both alpha and beta memories.   A good indexing strategy is a major factor in deciding the overall performance of a <link xlink:type="simple" xlink:href="../457/3157457.xml">
production system</link>, especially when executing rule sets that result in highly combinatorial <link xlink:type="simple" xlink:href="../688/279688.xml">
pattern matching</link> (i.e., intensive use of beta join nodes), or, for some engines, when executing rules sets that perform a significant number of WME retractions during multiple match-resolve-act cycles.   Memories are often implemented using combinations of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link>
hash tables</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, and hash values are used to perform conditional <link>
joins</link> on subsets of WME lists and WMEs, rather than on the entire contents of memories.   This, in turn, often significantly reduces the number of evaluations performed by the Rete network.</p>

</ss1>
<ss1>
<st>
 Removal of WMEs and WME lists </st>
<p>

When a WME is retracted from working memory, it must be removed from every alpha memory in which it is stored.   In addition, WME lists that contain the WME must be removed from beta memories, and activated production instances for these WME lists must be de-activated and removed from the agenda.   Several implementation variations exist, including tree-based and rematch-based removal.   Memory indexing may be used in some cases to optimise removal.</p>

</ss1>
<ss1>
<st>
 Handling OR’ed conditions </st>
<p>

When defining productions in a rule set, it is common to allow conditions to be grouped using an ‘OR’ <link>
connective</link>.    In many <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link>
production systems</link></instrumentality>
</artifact>
</system>
, this is handled by interpreting a single <link>
production</link> containing multiple OR’ed patterns as the equivalent of multiple <link>
productions</link>.   The resulting Rete network contains sets of terminal nodes which, together, represent single <link>
productions</link>.   This approach disallows any form of short-circuiting of the OR’ed conditions.    It can also, in some cases, lead to duplicate production instances being activated on the agenda where the same set of WMEs match multiple internal productions.   Some engines provide agenda de-duplication in order to handle this issue.</p>

</ss1>
<ss1>
<st>
 Diagram </st>
<p>

The following diagram illustrates the basic Rete topography, and shows the associations between different node types and memories.</p>
<p>

<image location="center" width="150px" src="Rete.JPG" type="thumb">
<caption>

Illustrates the basic Rete.
</caption>
</image>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Most implementations use type nodes to perform the first level of selection on n-tuple working memory elements.   Type nodes can be considered as specialized select nodes.   They discriminate between different tuple relation types.</entry>
<entry level="1" type="bullet">

 The diagram does not illustrate the use of specialized nodes types such as negated conjunction nodes.   Some engines implement several different node specialisations in order to extend functionality and maximise optimisation.</entry>
<entry level="1" type="bullet">

 The diagram provides a logical view of the Rete.   Implementations may differ in physical detail.   In particular, the diagram shows ‘dummy’ inputs providing right activations at the head of beta node branches.  Engines may implement other approaches, such as adapters that allow alpha memories to perform right activations directly.</entry>
<entry level="1" type="bullet">

 The diagram does not illustrate all node-sharing possibilities.</entry>
</list>
</p>
<p>

For a more detailed and complete description of the Rete algorithm, see chapter 2 of Production Matching for Large Learning Systems by Robert Doorenbos (see link below).</p>

</ss1>
</sec>
<sec>
<st>
 Miscellaneous Considerations </st>
<p>

Although not defined by the Rete algorithm, some engines provide extended functionality to support greater control of <link>
truth maintenance</link>.   For example, when a match is found for one <link xlink:type="simple" xlink:href="../457/3157457.xml">
production</link>, this may result in the assertion of new WMEs which, in turn, match the conditions for another production.  If a subsequent change to working memory causes the first match to become invalid, it may be that this implies that the second match is also invalid. The Rete <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> does not define any mechanism to define and handle these logical truth dependencies automatically.  Some engines, however, support additional functionality in which truth dependencies can be automatically maintained.  In this case, the retraction of one WME may lead to the automatic retraction of additional WMEs in order to maintain logical truth assertions.</p>
<p>

The Rete <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> does not define any approach to justification.   Justification refers to mechanisms commonly required in <link>
expert</link> and decision systems in which, at its simplest, the system reports each of the inner decisions used to reach some final conclusion.   For example, an <link>
expert system</link> might justify a conclusion that an animal is an elephant by reporting that it is large, grey, has big ears, a trunk and tusks.   Some engines provide built-in justification systems in conjunction with their implementation of the Rete <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>.</p>
<p>

This article does not provide an exhaustive description of every possible variation or extension of the Rete algorithm.   Other considerations and innovations exist.    For example, engines may provide specialised support within the Rete network in order to apply <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link>
pattern-matching</link></concept>
</idea>
 <link xlink:type="simple" xlink:href="../066/242066.xml">
rule</link> processing to specific <link xlink:type="simple" xlink:href="../817/93817.xml">
data types</link> and sources such as <link>
programmatic objects</link>, <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../138/34138.xml">
XML</link></format>
 data or <link>
relational data tables</link>.   Another example concerns additional time-stamping facilities provided by many engines for each WME entering a Rete network, and the use these time-stamps in conjunction with conflict resolution strategies.   Engines exhibit significant variation in the way they allow programmatic access to the engine and its working memory, and may extend the basic Rete model to support forms of parallel and distributed processing.</p>

</sec>
<sec>
<st>
 Optimisation and Performance </st>
<p>

Several optimisations for Rete have been identified and described in academic literature. Several of these, however, apply only in very specific scenarios, and therefore often have little or no application in a general-purpose rules engine.  In addition, alternative <link xlink:type="simple" xlink:href="../775/775.xml">
algorithms</link> such as TREAT and LEAPS have been formulated which may provide additional performance improvements.   There are currently very few commercial or open source examples of <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link>
productions systems</link></instrumentality>
</artifact>
</system>
 that support these alternative <link xlink:type="simple" xlink:href="../775/775.xml">
algorithms</link>.</p>
<p>

The Rete <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is orientated to scenarios where <link xlink:type="simple" xlink:href="../962/568962.xml">
forward chaining</link> and ‘<link xlink:type="simple" xlink:href="../465/317465.xml">
inferencing</link>’ is used to calculate new facts from existing facts, or to filter and discard facts in order to arrive at some conclusion. It is also exploited as a reasonably efficient mechanism for performing highly combinatorial evaluations of facts where large numbers of joins must be performed between fact <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
tuples</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
. Other approaches to performing rule evaluation, such as the use of <link xlink:type="simple" xlink:href="../602/232602.xml">
decision trees</link>, or the implementation of sequential engines, may be more appropriate for simple scenarios, and should be considered as possible alternatives.</p>

</sec>
<sec>
<st>
Rete II</st>
<p>

In the 1980s Charles L. Forgy developed a successor to the Rete algorithm named <b>Rete II</b> <weblink xlink:type="simple" xlink:href="http://www.pst.com/rete2.htm">
http://www.pst.com/rete2.htm</weblink>. Unlike the original Rete (which is public domain) this algorithm was not disclosed. Rete II claims better performance for more complex problems (even <weblink xlink:type="simple" xlink:href="http://www.pst.com/benchcr2.htm">
orders of magnitude</weblink>), and is officially implemented in CLIPS/R2.</p>
<p>

Rete II can be characterized by two areas of improvement; specific optimizations relating to the general performance of the Rete network (including the use of hashed memories in order to increase performance with larger sets of data), and the inclusion of a <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../967/568967.xml">
backward chaining</link></instrumentality>
</artifact>
</system>
 algorithm tailored to run on top of the Rete network.  Backward chaining alone can account for the most extreme changes in benchmarks relating to Rete vs. Rete II.</p>
<p>

Jess (at least versions 5.0 and later) also adds a backward chaining algorithm on top of the Rete network, but it cannot be said to fully implement Rete II, in part due to the fact that no full specification is publicly available.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/476022.xml">
Charles Forgy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, "A network match routine for production systems." Working Paper, 1974.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/476022.xml">
Charles Forgy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, "On the efficient implementation of production systems." Ph.D. Thesis, Carnegie-Mellon University, 1979.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/476022.xml">
Charles Forgy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, "Rete: A Fast Algorithm for the Many Pattern/Many Object Pattern Match Problem", <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../092/5841092.xml">
Artificial Intelligence</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>, 19, pp 17-37, 1982</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../373/5033373.xml">
Action selection mechanism</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../136/10136.xml">
Expert system</link></entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../609/418609.xml">
Inference engine</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/475829.xml">
OPS5</link></language>
</instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../457/3157457.xml">
Production system</link></instrumentality>
</artifact>
</system>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://reports-archive.adm.cs.cmu.edu/anon/1995/CMU-CS-95-113.pdf">
Production Matching for Large Learning Systems - R Doorenbos</weblink>Detailed and accessible description of Rete, also describes a variant named Rete/UL, optimised for large systems (PDF)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cut-the-knot.org/classes/Last.shtml">
According to the Rules</weblink> (A short introduction from <link xlink:type="simple" xlink:href="../167/3259167.xml">
cut-the-knot</link>)</entry>
</list>
</p>


</sec>
</bdy>
</instrumentality>
</artifact>
</system>
</article>
