<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:52:12[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Boyer–Moore–Horspool algorithm</title>
<id>1753472</id>
<revision>
<id>229806902</id>
<timestamp>2008-08-04T17:07:20Z</timestamp>
<contributor>
<username>Giftlite</username>
<id>37986</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Articles with example C code</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>Boyer–Moore–Horspool algorithm</b> or <b>Horspool's algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for finding <link xlink:type="simple" xlink:href="../560/2696560.xml">
substring</link>s in <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link>.  <p>

It is a simplification of the <link xlink:type="simple" xlink:href="../709/684709.xml">
Boyer-Moore algorithm</link> which is related to the <link xlink:type="simple" xlink:href="../227/253227.xml">
Knuth-Morris-Pratt algorithm</link>. The algorithm trades space for time in order to obtain an <link xlink:type="simple" xlink:href="../952/15383952.xml">
average-case complexity</link> of O(N) on random text, although it has O(MN) in the <link xlink:type="simple" xlink:href="../956/37956.xml">
worst case</link>.  The length of the pattern is M and the length of the search string is N.</p>

<sec>
<st>
Example implementation</st>
<p>

Here is an example implementation of the Boyer-Moore-Horspool algorithm, written in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
.</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

/* The constant UCHAR_MAX is assumed to contain the maximum
<list>
<entry level="1" type="bullet">

 value of the input character type. Typically it's 255.</entry>
<entry level="1" type="bullet">

 size_t is an unsigned type for representing sizes.</entry>
<entry level="1" type="bullet">

 If your system doesn't have it, substitute with</entry>
<entry level="1" type="bullet">

 unsigned int.</entry>
<entry level="1" type="bullet">

/</entry>
</list>
</p>
<p>

/* Returns a pointer to the first occurrence of "needle"
<list>
<entry level="1" type="bullet">

 within "haystack", or NULL if not found. Works like </entry>
<entry level="1" type="bullet">

 memmem().</entry>
<entry level="1" type="bullet">

/</entry>
</list>

const unsigned char *
boyermoore_horspool_memmem(const unsigned char* haystack, size_t hlen,
const unsigned char* needle,   size_t nlen)
{
size_t scan = 0;
size_t bad_char_skip[UCHAR_MAX + 1]; /* Officially called:
<list>
<entry level="1" type="bullet">

 bad character shift */</entry>
</list>
</p>
<p>

/* Sanity checks on the parameters */
if (nlen = 0 || !haystack || !needle)
return NULL;</p>
<p>

/* ---- Preprocess ---- */
/* Initialize the table to default value */
/* When a character is encountered that does not occur
<list>
<entry level="1" type="bullet">

 in the needle, we can safely skip ahead for the whole</entry>
<entry level="1" type="bullet">

 length of the needle.</entry>
<entry level="1" type="bullet">

/</entry>
</list>

for (scan = 0; scan = UCHAR_MAX; scan = scan + 1)
bad_char_skip[scan] = nlen;</p>
<p>

/* C arrays have the first byte at [0], therefore:
<list>
<entry level="1" type="bullet">

 [nlen - 1] is the last byte of the array. */</entry>
</list>

size_t last = nlen - 1;</p>
<p>

/* Then populate it with the analysis of the needle */
for (scan = 0; scan  last; scan = scan + 1)
bad_char_skip[needle[scan]] = last - scan;</p>
<p>

/* ---- Do the matching ---- */</p>
<p>

/* Search the haystack, while the needle can still be within it. */
while (hlen &amp;gt;= nlen)
{
/* scan from the end of the needle */
for (scan = last; haystack[scan] == needle[scan]; scan = scan - 1)
if (scan == 0) /* If the first byte matches, we've found it. */
return haystack;</p>
<p>

/* otherwise, we need to skip some bytes and start again. 
Note that here we are getting the skip value based on the last byte
of needle, no matter where we didn't match. So if needle is: "abcd"
then we are skipping based on 'd' and that value will be 4, and
for "abcdd" we again skip on 'd' but the value will be only 1.
The alternative of pretending that the mismatched character was 
the last character is slower in the normal case (Eg. finding 
"abcd" in "...azcd..." gives 4 by using 'd' but only 
4-2==2 using 'z'. */
hlen     -= bad_char_skip[haystack[last]];
haystack += bad_char_skip[haystack[last]];
}</p>
<p>

return NULL;
}</p>

</sec>
<sec>
<st>
Performance</st>

<p>

The algorithm performs best with long needle strings, when it consistently hits a non-matching character at or near the final byte of the current position in the haystack and the final byte of the needle doesn't occur elsewhere within the needle. For instance a 32 byte needle ending in "z" searching through a 255 byte haystack which doesn't have a 'z' byte in it would take up to 224 byte comparisons.</p>
<p>

The best case is the same as for the <link xlink:type="simple" xlink:href="../709/684709.xml">
Boyer-Moore algorithm</link> in <link xlink:type="simple" xlink:href="../578/44578.xml">
big O notation</link>, although the constant overhead of initialization and for each loop is less.</p>
<p>

The worst case behavior happens when the bad character skip is consistently low (with the lower limit of 1 byte movement) and a large portion of the needle matches the haystack. The bad character skip is only low, on a partial match, when the final character of the needle also occurs elsewhere within the needle. With 1 byte movement happening when the same byte is in both of the last two positions.</p>
<p>

The canonical degenerate case similar to the above "best" case is a needle of an 'a' byte followed by 31 'z' bytes in a haystack consisting of 255 'z' bytes. This will do 31 successful byte comparisons, a 1 byte comparison that fails and then move forward 1 byte. This process will repeat 223 more times (255 - 32), bringing the total byte comparisons to 7,168 (32 * 224).</p>
<p>

The worst case is significantly higher than for the <link xlink:type="simple" xlink:href="../709/684709.xml">
Boyer-Moore algorithm</link>, although obviously  this is hard to achieve in normal use cases. It is also worth noting that this worst case is also the worst case for the naive (but usual) memmem() algorithm, although the implementation of that tends to be significantly optimized (and is more cache friendly).</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Boyer–Moore string search algorithm</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-igm.univ-mlv.fr/%7Elecroq/string/node18.html">
Description of the algorithm</weblink></entry>
</list>
</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../317/11576317.xml">
FASMLIB</link></room>
</library>
</area>
</artifact>
</structure>
 contains implementation in x86 32bit assembly (procedure "mem.find")</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://movsd.com/bm.htm">
"BMH.ASM"</weblink> is an implementation of the Boyer–Moore–Horspool algorithm in x86 32bit assembly. ("BM.ASM" implements the <link>
Boyer–Moore string search algorithm</link>).</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://johannburkard.de/software/stringsearch/">
StringSearch – high-performance pattern matching algorithms in Java</weblink> – Implementations of many String-Matching-Algorithms in Java (BNDM, Boyer-Moore-Horspool, Boyer-Moore-Horspool-Raita, Shift-Or)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://angusj.com/delphi/">
Boyer-Moore-Horspool implementation for Delphi</weblink> - Non-visual components (TSearch and TFileSearch) which enable very fast data searches using the Boyer-Moore-Horspool search algorithm.</entry>
</list>
</p>
</sec>
</bdy>
</algorithm>
</article>
