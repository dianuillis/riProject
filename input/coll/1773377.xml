<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:55:47[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Cache-oblivious algorithm</title>
<id>1773377</id>
<revision>
<id>237313169</id>
<timestamp>2008-09-09T16:30:15Z</timestamp>
<contributor>
<username>Stevenj</username>
<id>7918</id>
</contributor>
</revision>
<categories>
<category>Theoretical_computer_science</category>
<category>Computational models</category>
<category>Cache</category>
<category>Analysis of algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../213/5213.xml">
computing</link>, a <b>cache-oblivious algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> designed to exploit the <link xlink:type="simple" xlink:href="../181/849181.xml">
CPU cache</link> without having the size of the cache (or the length of the <link xlink:type="simple" xlink:href="../181/849181.xml">
cache line</link>s, etcetera) as an explicit parameter. An <b>optimal cache-oblivious algorithm</b> is a cache-oblivious algorithm that exploits the cache optimally (in an <link xlink:type="simple" xlink:href="../578/44578.xml">
asymptotic</link> sense, ignoring constant factors).  Thus, a cache oblivious algorithm is designed to perform well, without modification, on multiple machines with different cache sizes, or for a <link xlink:type="simple" xlink:href="../146/137146.xml">
memory hierarchy</link> with different levels of cache having different sizes.  The idea (and name) for cache-oblivious algorithms was conceived by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
 as early as 1996 and first published by <link>
Harald Prokop</link> in his master's thesis at the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/18879.xml">
Massachusetts Institute of Technology</link></university>
 in <link xlink:type="simple" xlink:href="../553/34553.xml">
1999</link>.<p>

Optimal cache-oblivious algorithms are known for the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/352702.xml">
Cooley-Tukey FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, <link xlink:type="simple" xlink:href="../280/125280.xml">
matrix multiplication</link>, <link xlink:type="simple" xlink:href="../656/144656.xml">
sorting</link>, <link xlink:type="simple" xlink:href="../844/173844.xml">
matrix transposition</link>, and several other problems.  Because these algorithms are only optimal in an asymptotic sense (ignoring constant factors), further machine-specific tuning may be required to obtain nearly optimal performance in an absolute sense.  The goal of cache-oblivious algorithms is to reduce the amount of such tuning that is required.</p>
<p>

Typically, a cache-oblivious algorithm works by a <link xlink:type="simple" xlink:href="../407/25407.xml">
recursive</link> <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer algorithm</link>, where the problem is divided into smaller and smaller subproblems.  Eventually, one reaches a subproblem size that fits into cache, regardless of the cache size.  For example, an optimal cache-oblivious matrix multiplication is obtained by recursively dividing each matrix into four sub-matrices to be multiplied, multiplying the submatrices in a <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first</link> fashion.</p>

<sec>
<st>
Idealized cache model</st>

<p>

Cache-oblivious algorithms are typically analyzed using an idealized model of the cache, sometimes called the <b>cache-oblivious model</b>.  This model is much easier to analyze than a real cache's characteristics (which have complicated associativity, replacement policies, etcetera), but in many cases is provably within a constant factor of a more realistic cache's performance.</p>
<p>

In particular, the cache-oblivious model is an <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link> (i.e. a theoretical model of computation). It is similar to the <link xlink:type="simple" xlink:href="../227/544227.xml">
RAM machine model</link> which replaces the <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
's infinite tape with an infinite array. Each location within the array can be accessed in <math>O(1)</math> time, similar to the <link xlink:type="simple" xlink:href="../847/25847.xml">
Random access memory</link> on a real computer. Unlike the RAM machine model, it also introduces a cache: a second level of storage between the RAM and the CPU. The other differences between the two models are listed below. In the cache-oblivious model:</p>
<p>

<list>
<entry level="1" type="bullet">

Memory is broken into lines of <math>L</math> words each</entry>
<entry level="1" type="bullet">

A load or a store between main memory and a CPU register may now be serviced from the cache.</entry>
<entry level="1" type="bullet">

If a load or a store cannot be serviced from the cache, it is called a <it>cache miss</it>.</entry>
<entry level="1" type="bullet">

A cache miss results in one line being loaded from main memory into the cache. Namely, if the CPU tries to access word <math>w</math> and <math>b</math> is the line containing <math>w</math>, then <math>b</math> is loaded into the cache. If the cache was previously full, then a line will be evicted as well (see replacement policy below).</entry>
<entry level="1" type="bullet">

The cache holds <math>Z</math> words, where <math>Z = \Omega(L^2)</math>. This is also known as the <it>tall cache assumption</it>.</entry>
<entry level="1" type="bullet">

The cache is fully associative: each line can be loaded into any location in the cache.</entry>
<entry level="1" type="bullet">

The replacement policy is optimal. In other words, the cache is assumed to be given the entire sequence of memory accesses during algorithm execution. If it needs to evict a line at time <math>t</math>, it will look into its sequence of future requests and evict the line that is accessed furthest in the future. This can be implemented in practice with the <link xlink:type="simple" xlink:href="../281/954281.xml">
Least Recently Used</link> policy, which is shown to be within a small constant factor of the offline optimal replacement strategy.</entry>
</list>
</p>
<p>

To measure the complexity of an algorithm that executes within the cache-oblivious model, we can measure the familiar (running time) <it>work</it> complexity <math>W(n)</math>. However, we can also measure the <it>cache complexity</it>, <math>Q(n,L,Z)</math>, the number of cache misses that the algorithm will experience.</p>
<p>

The goal for creating a good cache-oblivious algorithm is to match the work complexity of some optimal RAM model algorithm while minimizing <math>Q(n,L,Z)</math>. Furthermore, unlike the <link>
external-memory model</link>, which shares many of the listed features, we would like our algorithm to be independent of cache parameters (<math>L</math> and <math>Z</math>). The benefit of such an algorithm is that what is efficient on a cache-oblivious machine is likely to be efficient across many real machines without fine tuning for particular real machine parameters. Frigo et al. showed that for many problems, an optimal cache-oblivious algorithm will also be optimal for a machine with more than two <link xlink:type="simple" xlink:href="../146/137146.xml">
memory hierarchy</link> levels.</p>

</sec>
<sec>
<st>
Examples</st>

<p>

For example, it is possible to design a variant of <link xlink:type="simple" xlink:href="../267/1035267.xml">
unrolled linked list</link>s which is cache-oblivious and allows list traversal of <math>n</math> elements in <math>n/L</math> time, where <math>b</math> is the cache size. For a fixed <math>L</math>, this is <math>O(n)</math> time. However, the advantage of the algorithm is that it can scale to take advantage of larger cache line sizes (larger values of <math>L</math>).</p>
<p>

The simplest cache-oblivious algorithm presented in Frigo et al. is an out-of-place <link xlink:type="simple" xlink:href="../844/173844.xml">
matrix transpose</link> operation (<link xlink:type="simple" xlink:href="../336/11174336.xml">
in-place algorithms</link> have also been devised for transposition, but are much more complicated for non-square matrices). Given <math>m \times n</math> arrays <math>A</math> and <math>B</math>, we would like to store the transpose of <math>A</math> in <math>B</math>. The naive solution traverses one array in row-major order and another in column-major. The result is that when the matrices are large, we get a cache miss on every step of the column-wise traversal. The total number of cache misses is <math>\Theta(mn)</math>.</p>
<p>

<image location="right" width="150px" src="Matrix_transpose_dc.svg" type="thumb">
<caption>

Principle of cache-oblivious algorithm for matrix transposition using a divide and conquer-approach. The graphic shows the recursive step (<b>a</b> → <b>b</b>) of dividing the matrix and transposing each part individually.
</caption>
</image>

The cache-oblivious algorithm has optimal work complexity <math>O(mn)</math> and optimal cache complexity <math>O(1+mn/L)</math>. The basic idea is to reduce the transpose of two large matrices into the transpose of small (sub)matrices. We do this by dividing the matrices in half along their larger dimension until we just have to perform the transpose of a matrix that will fit into the cache.  Because the cache size is not known to the algorithm, the matrices will continue to be divided recursively even after this point, but these further subdivisions will be in cache.  Once the dimensions <math>m</math> and <math>n</math> are small enough so an <it>input</it> array of size <math>m \times n</math> and an output array of size <math>n \times m</math> fit into the cache, both row-major and column-major traversals result in <math>O(mn)</math> work and <math>O(mn/L)</math> cache misses. By using this divide and conquer approach we can achieve the same level of complexity for the overall matrix.</p>
<p>

(In principle, one could continue dividing the matrices until a base case of size 1&amp;times;1 is reached, but in practice one uses a larger base case (e.g. 16&amp;times;16) in order to <link xlink:type="simple" xlink:href="../683/236683.xml">
amortize</link> the overhead of the recursive subroutine calls.)</p>
<p>

Most cache oblivious algorithms rely on a divide and conquer approach. They reduce the problem, so that it eventually fits in cache no matter how small the cache is, end the recursion at some small size determined by the function-call overhead and similar cache-unrelated optimizations, and then use some cache-efficient access pattern to merge the results of these small, solved problems.</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

Harald Prokop. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/prokop99cacheobliviou.html">
Cache-Oblivious Algorithms</weblink>. Masters thesis, MIT. 1999.</entry>
<entry level="1" type="bullet">

M. Frigo, C.E. Leiserson, H. Prokop, and S. Ramachandran. Cache-oblivious algorithms. In <it>Proceedings of the 40th IEEE Symposium on Foundations of Computer Science</it> (FOCS 99), p.285-297. 1999. <weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/iel5/6604/17631/00814600.pdf?arnumber=814600">
Extended abstract at IEEE</weblink>, <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/307799.html">
at Citeseer</weblink>.</entry>
<entry level="1" type="bullet">

Erik Demaine. <weblink xlink:type="simple" xlink:href="http://theory.csail.mit.edu/classes/6.897/spring03/scribe_notes/L15/lecture15.pdf">
Review of the Cache-Oblivious Model</weblink>. Notes for MIT Computer Science 6.897: Advanced Data Structures.</entry>
<entry level="1" type="bullet">

Piyush Kumar. <weblink xlink:type="simple" xlink:href="http://www.compgeom.com/co-chap/chap.pdf">
Cache-Oblivious Algorithms</weblink>. Algorithms for Memory Hierarchies, LNCS 2625, pages 193-212, Springer Verlag.</entry>
</list>
</p>

</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
