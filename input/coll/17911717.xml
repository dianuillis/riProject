<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 04:26:10[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Block Wiedemann algorithm</title>
<id>17911717</id>
<revision>
<id>222448033</id>
<timestamp>2008-06-29T11:40:45Z</timestamp>
<contributor>
<username>Andreas Kaufmann</username>
<id>72502</id>
</contributor>
</revision>
<categories>
<category>Numerical linear algebra</category>
</categories>
</header>
<bdy>

The <b>Block Wiedemann algorithm</b> for computing kernel vectors of a matrix over a finite field is a generalisation of an algorithm due to <peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<cryptanalyst wordnetid="109981540" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<decoder wordnetid="109995398" confidence="0.8">
<link xlink:type="simple" xlink:href="../090/540090.xml">
Don Coppersmith</link></decoder>
</mathematician>
</employee>
</causal_agent>
</worker>
</associate>
</scientist>
</colleague>
</intellectual>
</cryptanalyst>
</person>
</physical_entity>
</peer>
.
<sec>
<st>
 Coppersmith's algorithm </st>

<p>

Let M be an <math>n\times n</math> square matrix over some finite field F, let <math>x_{\mathrm {base}}</math> be a random vector of length n, and let <math>x = M x_{\mathrm {base}}</math>. Consider the sequence of vectors <math>S = \left[x, Mx, M^2x, \ldots\right]</math> obtained by repeatedly multiplying the vector by the matrix M; let y be any other vector of length n, and consider the sequence of finite-field elements <math>S_y = \left[y \cdot x, y \cdot Mx, y \cdot M^2x \ldots\right]</math></p>
<p>

We know that the matrix M has a <link xlink:type="simple" xlink:href="../678/254678.xml">
minimal polynomial</link>; by the <link xlink:type="simple" xlink:href="../547/173547.xml">
Cayley-Hamilton Theorem</link> we know that this polynomial is of degree (which we will call <math>n_0</math>) no more than n. Say <math>\sum_{r=0}^{n_0} p_rM^r = 0</math>.  Then <math>\sum_{r=0}^{n_0} y \cdot (p_r (M^r x)) = 0</math>; so the minimal polynomial of the matrix annihilates the sequence <math>S</math> and hence <math>S_y</math>.</p>
<p>

But the <link xlink:type="simple" xlink:href="../832/514832.xml">
Berlekamp-Massey algorithm</link> allows us to calculate relatively efficiently some sequence <math>q_0 \ldots q_L</math> with <math>\sum_{i=0}^L q_i S_y[{i+r}]=0 \forall r</math>.  Our hope is that this sequence, which by construction annihilates <math>y \cdot S</math>, actually annihilates <math>S</math>; so we have <math>\sum_{i=0}^L q_i M^i x = 0</math>. We then take advantage of the initial definition of <math>x</math> to say <math>M \sum_{i=0}^L q_i M^i x_{\mathrm {base}} = 0</math> and so <math>\sum_{i=0}^L q_i M^i x_{\mathrm {base}}</math> is a hopefully non-zero kernel vector of <math>M</math>.</p>

</sec>
<sec>
<st>
 The Block Wiedemann algorithm </st>

<p>

The natural implementation of sparse matrix arithmetic on a computer makes it easy to compute the sequence S in parallel for a number of vectors equal to the width of a machine word - indeed, it will normally take no longer to compute for that many vectors than for one.  If you have several processors, you can compute the sequence S for a different set of random vectors in parallel on all the computers.</p>
<p>

It turns out, by a generalisation of the Berlekamp-Massey algorithm to provide a sequence of small matrices, that you can take the sequence produced for a large number of vectors and generate a kernel vector of the original large matrix.  You need to compute <math> y_i \cdot M^t x_j</math> for some <math>i = 0 \ldots i_\max, j=0 \ldots j_\max, t = 0 \ldots t_\max</math> where <math>i_\max, j_\max, t_\max</math> need to satisfy <math>t_\max &amp;gt; \frac{d}{i_\max} + \frac{d}{j_\max} + O(1)</math> and <math>y_i</math> are a series of vectors of length n; but in practice you can take <math>y_i</math> as a sequence of unit vectors and simply write out the first <math>i_\max</math> entries in your vectors at each time t.</p>

</sec>
<sec>
<st>
 References </st>

<p>

Villard's 1997 research report 'A study of Coppersmith's block Wiedemann algorithm using matrix polynomials' (available at <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/cache/papers/cs/4204/ftp:zSzzSzftp.imag.frzSzpubzSzCALCUL_FORMELzSzRAPPORTzSz1997zSzRR975.pdf/villard97study.pdf">
http://citeseer.ist.psu.edu/cache/papers/cs/4204/ftp:zSzzSzftp.imag.frzSzpubzSzCALCUL_FORMELzSzRAPPORTzSz1997zSzRR975.pdf/villard97study.pdf</weblink> - the cover material is in French but the content in English) is a reasonable description.</p>
<p>

Thom√©'s paper 'Subquadratic computation of vector generating polynomials and improvement of the block Wiedemann algorithm' (available at <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/rd/13850609%2C564537%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/27081/http:zSzzSzwww.lix.polytechnique.frzSzLabozSzEmmanuel.ThomezSzpubliszSzjsc.pdf/subquadratic-computation-of-vector.pdf">
http://citeseer.ist.psu.edu/rd/13850609%2C564537%2C1%2C0.25%2CDownload/http://citeseer.ist.psu.edu/cache/papers/cs/27081/http:zSzzSzwww.lix.polytechnique.frzSzLabozSzEmmanuel.ThomezSzpubliszSzjsc.pdf/subquadratic-computation-of-vector.pdf</weblink>) uses a more sophisticated <link xlink:type="simple" xlink:href="../512/11512.xml">
FFT</link>-based algorithm for computing the vector generating polynomials, and describes a practical implementation with <math>i_\max = j_\max = 4</math> used to compute a kernel vector of a 484603x484603 matrix of entries modulo 2607-1, and hence to compute discrete logarithms in the field <math>GF(2^{607})</math>.</p>


</sec>
</bdy>
</article>
