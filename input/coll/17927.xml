<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:29:21[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<paradigm  confidence="0.9511911446218017" wordnetid="113804375">
<header>
<title>Logic programming</title>
<id>17927</id>
<revision>
<id>239654816</id>
<timestamp>2008-09-19T21:17:22Z</timestamp>
<contributor>
<username>Una Smith</username>
<id>3349439</id>
</contributor>
</revision>
<categories>
<category>Semi-protected</category>
<category>Logic programming</category>
<category>1972 introductions</category>
<category>Programming paradigms</category>
</categories>
</header>
<bdy>

<image width="150px" src="">

</image>


<b>Logic programming</b> is, in its broadest sense, the use of mathematical logic for computer programming. In this view of logic programming, which can be traced at least as far back as <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../362/308362.xml">
John McCarthy</link></scientist>
</person>
's [1958] <link xlink:type="simple" xlink:href="../008/8992008.xml">
advice-taker</link> proposal, logic is used as a purely <link xlink:type="simple" xlink:href="../648/210648.xml">
declarative</link> representation language, and a <link>
theorem-prover</link> or model-generator is used as the problem-solver. The problem-solving task is split between the programmer, who is responsible only for ensuring the truth of programs expressed in logical form, and the theorem-prover or model-generator, which is responsible for solving problems efficiently.<p>

However, logic programming, in the narrower sense in which it is more commonly understood, is the use of logic as both a <link xlink:type="simple" xlink:href="../648/210648.xml">
declarative</link> and procedural representation language. It is based upon the fact that a <link xlink:type="simple" xlink:href="../967/568967.xml">
backwards reasoning</link> theorem-prover applied to declarative sentences in the form of implications:</p>
<p>

<indent level="4">

If B1 and … and Bn then H
</indent>

treats the implications as goal-reduction procedures:</p>
<p>

<indent level="4">

to show/solve H, show/solve B1 and … and Bn.
</indent>

For example, it treats the implication:</p>
<p>

<indent level="4">

If you press the alarm signal button, 
</indent>
::::then you alert the driver of the train of a possible emergency</p>
<p>

as the procedure:</p>
<p>

<indent level="4">

To alert the driver of the train of a possible emergency, 
</indent>
::::press the alarm signal button.</p>
<p>

The programmer is responsible, not only for ensuring the truth of programs, but also for ensuring their efficiency. In many cases, to achieve efficiency, the programmer needs to be aware of and to exploit the problem-solving behavior of the theorem-prover. In this respect, logic programming is like conventional <link xlink:type="simple" xlink:href="../847/197847.xml">
imperative programming</link>, using programs to control the behaviour of a program executor. However, unlike imperative programs, which have only a procedural interpretation, logic programs also have a declarative, logical interpretation, which helps to ensure their correctness. Moreover, such programs, being declarative, are at a higher conceptual level than purely imperative programs; and their program executors, being theorem-provers, operate at a higher conceptual level than conventional <link xlink:type="simple" xlink:href="../739/5739.xml">
compilers</link> and <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreters</link>.</p>

<sec>
<st>
History</st>

<p>

Logic programming in the first and wider sense gave rise to a number of implementations, such as those by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../516/113516.xml">
Fischer Black</link></scientist>
</person>
 (1964), James Slagle (1965) and Cordell Green (1969), which were question-answering systems in the spirit of McCarthy's advice-taker. Foster and Elcock's <link>
Absys</link> (1969), on the other hand, was probably the first language to be explicitly developed as an assertional programming language. </p>
<p>

Logic programming in the narrower sense can be traced back to debates in the late 1960s and early 1970s about declarative versus procedural representations of knowledge in Artificial Intelligence. Advocates of declarative representations were notably working at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../977/26977.xml">
Stanford</link></university>
, associated with <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../362/308362.xml">
John McCarthy</link></scientist>
</person>
, Bertram Raphael and Cordell Green, and in <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../395/64395.xml">
Edinburgh</link></university>
, with <skilled_worker wordnetid="110605985" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<exile wordnetid="110071332" confidence="0.8">
<absentee wordnetid="109757653" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../114/8895114.xml">
J. Alan Robinson</link></scholar>
</mathematician>
</causal_agent>
</alumnus>
</worker>
</editor>
</associate>
</absentee>
</exile>
</scientist>
</colleague>
</traveler>
</intellectual>
</person>
</physical_entity>
</peer>
</skilled_worker>
 (an academic visitor from <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../353/29353.xml">
Syracuse University</link></university>
), <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../721/2634721.xml">
 Pat Hayes</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../364/1621364.xml">
 Bob Kowalski</link></scientist>
</person>
. Advocates of procedural representations were mainly centered at <link xlink:type="simple" xlink:href="../061/19061.xml">
MIT</link>, under the leadership of <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/27802.xml">
Seymour Papert</link></scientist>
</person>
. </p>
<p>

Although it was based on logic, <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../143/46143.xml">
Planner</link></language>
, developed at MIT, was the first language to emerge within this proceduralist paradigm [Hewitt, 1969]. Planner featured pattern directed invocation of procedural plans from goals (i.e. <link xlink:type="simple" xlink:href="../962/568962.xml">
forward chaining</link>) and from assertions (i.e. <link xlink:type="simple" xlink:href="../967/568967.xml">
backward chaining</link>).  The most influential implementation of Planner was the subset of Planner, called Micro-Planner, implemented by <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/96431.xml">
Gerry Sussman</link></research_worker>
</mathematician>
</causal_agent>
</academician>
</computer_user>
</associate>
</educator>
</professional>
</adult>
</scientist>
</engineer>
</colleague>
</programmer>
</specialist>
</interior_designer>
</person>
</peer>
</expert>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../678/7398678.xml">
Eugene Charniak</link></scientist>
</causal_agent>
</person>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../786/192786.xml">
Terry Winograd</link></research_worker>
</employee>
</scientist>
</causal_agent>
</worker>
</person>
</physical_entity>
. It was used to implement Winograd's natural-language understanding program <software wordnetid="106566077" confidence="0.8">
<application wordnetid="106570110" confidence="0.8">
<program wordnetid="106568978" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106359877" confidence="0.8">
<code wordnetid="106355894" confidence="0.8">
<coding_system wordnetid="106353757" confidence="0.8">
<link xlink:type="simple" xlink:href="../791/98791.xml">
SHRDLU</link></coding_system>
</code>
</writing>
</written_communication>
</program>
</application>
</software>
, which was a landmark at that time. In order to cope with the very limited memory systems that were available when it was developed, Planner used backtracking control structure so that only one possible computation path had to be stored at a time. From Planner there developed the programming languages QA-4, Popler, Conniver, QLISP, and the concurrent language Ether.</p>
<p>

Hayes and Kowalski in Edinburgh tried to reconcile the logic-based declarative approach to knowledge representation with Planner's procedural approach. Hayes (1973) developed an equational language, Golux, in which different procedures could be obtained by altering the behavior of the theorem prover. Kowalski, on the other hand, showed how SL-resolution treats implications as goal-reduction procedures. Kowalski collaborated with Colmerauer in Marseille, who developed these ideas in the design and implementation of the programming language Prolog. From Prolog there developed, among others, the programming languages  <link xlink:type="simple" xlink:href="../019/11868019.xml">
ALF</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../125/2912125.xml">
Fril</link></programming_language>
, <link>
Gödel</link>, <link xlink:type="simple" xlink:href="../726/19726.xml">
Mercury</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../916/256916.xml">
Oz</link></programming_language>
, Ciao, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../668/1741668.xml">
Visual Prolog</link></software>
, <link xlink:type="simple" xlink:href="../102/4723102.xml">
XSB</link>, and <link>
λProlog</link>, as well as a variety of <link>
concurrent logic programming languages</link>, (see Shapiro (1989) for a survey), <link xlink:type="simple" xlink:href="../442/4249442.xml">
constraint logic programming</link> languages and <link xlink:type="simple" xlink:href="../357/968357.xml">
datalog</link>.</p>
<p>

In 1997, the Association of Logic Programming bestowed to fifteen recognized researchers in logic programming the title <it>Founders of Logic Programming</it> to recognize them as pioneers in the field. The individuals receiving this honor were: <link>
Maurice Bruynooghe</link> (Belgium), <link>
Jacques Cohen</link> (USA), <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../762/371762.xml">
Alain Colmerauer</link></scientist>
</causal_agent>
</specialist>
</interior_designer>
</person>
</expert>
</physical_entity>
 (France), <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/6369702.xml">
Keith Clark</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
 (UK), <link>
Veronica Dahl</link> (Canada/Argentina), <link>
Maarten van Emden</link> (Canada), <link>
Herve Gallaire</link> (France), <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../364/1621364.xml">
Robert Kowalski</link></scientist>
</person>
 (UK), <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../098/11928098.xml">
Jack Minker</link></associate>
</research_worker>
</scholar>
</scientist>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</peer>
</physical_entity>
 (USA), <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<photographer wordnetid="110426749" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<artist wordnetid="109812338" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<link xlink:type="simple" xlink:href="../265/269265.xml">
Fernando Pereira</link></creator>
</artist>
</causal_agent>
</photographer>
</person>
</physical_entity>
 (USA), <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/17062681.xml">
Luis Moniz Pereira</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
 (Portugal), <link xlink:type="simple" xlink:href="../984/2341984.xml">
Ray Reiter</link> (Canada), <skilled_worker wordnetid="110605985" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<exile wordnetid="110071332" confidence="0.8">
<absentee wordnetid="109757653" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../114/8895114.xml">
Alan Robinson</link></scholar>
</mathematician>
</causal_agent>
</alumnus>
</worker>
</editor>
</associate>
</absentee>
</exile>
</scientist>
</colleague>
</traveler>
</intellectual>
</person>
</physical_entity>
</peer>
</skilled_worker>
 (USA), <link>
Peter Szeredi</link> (Hungary), and <link xlink:type="simple" xlink:href="../708/1094708.xml">
David H.D. Warren</link> (UK).</p>

</sec>
<sec>
<st>
Prolog</st>

<p>

<indent level="1">

<it>Main article: <link>
Prolog </link></it>
</indent>

The programming language <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link>  was developed in 1972 by <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../762/371762.xml">
Alain Colmerauer</link></scientist>
</causal_agent>
</specialist>
</interior_designer>
</person>
</expert>
</physical_entity>
. It emerged from a collaboration between Colmerauer in <link xlink:type="simple" xlink:href="../486/71486.xml">
Marseille</link> and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../364/1621364.xml">
Robert Kowalski</link></scientist>
</person>
 in Edinburgh. Colmerauer was working on natural language understanding, using logic to represent semantics and using resolution for question-answering. During the summer of 1971, Colmerauer and Kowalski discovered that the clausal form of logic could be used to represent formal grammars and that resolution theorem provers could be used for parsing. They observed that some theorem provers, like hyper-resolution, behave as bottom-up parsers and others, like <link xlink:type="simple" xlink:href="../091/11594091.xml">
SL-resolution</link> (1971), behave as top-down parsers. </p>
<p>

It was in the following summer of 1972, that Kowalski, again working with Colmerauer, developed the procedural interpretation of implications. This dual declarative/procedural interpretation later became formalised in the Prolog notation </p>
<p>

<indent level="1">

H :- B1, …, Bn.
</indent>

which can be read (and used) both declaratively and procedurally. It also became clear that such clauses could be restricted to definite clauses or <link xlink:type="simple" xlink:href="../824/333824.xml">
Horn clause</link>s, where H, B1, …, Bn are all atomic predicate logic formulae, and that SL-resolution could be restricted (and generalised) to LUSH or <link xlink:type="simple" xlink:href="../091/11594091.xml">
SLD-resolution</link>. Kowalski's procedural interpretation and LUSH were described in a 1973 memo, published in 1974.</p>
<p>

Colmerauer, with Philippe Roussel, used this dual interpretation of clauses as the basis of Prolog, which was implemented in the summer and autumn of 1972. The first Prolog program, also written in 1972 and implemented in Marseille, was a French question-answering system. The use of Prolog as a practical programming language was given great momentum by the development of a compiler by David Warren in Edinburgh in 1977.  Experiments demonstrated that Edinburgh Prolog could compete with the processing speed of other symbolic programming languages such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link></programming_language>
.  Edinburgh Prolog became the <it>de facto</it> standard and strongly influenced the definition of <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../934/14934.xml">
ISO</link></organization>
 standard Prolog. </p>

</sec>
<sec>
<st>
Negation as failure</st>

<p>

<indent level="1">

<it>Main article: <link>
Negation as failure </link></it>
</indent>

Micro-Planner had a construct, called "thnot", which when applied to an expression returns the value true if (and only if) the evaluation of the expression fails. An equivalent operator is normally built-in in modern <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link>'s implementations and has been called "<link xlink:type="simple" xlink:href="../537/2526537.xml">
negation as failure</link>". It is normally written as not(p), where p is an atom whose variables normally have been instantiated by the time not(p) is invoked. A more cryptic (but standard) syntax is \+ p . Negation as failure literals can occur as conditions not(Bi) in the body of program clauses.</p>
<p>

The logical status of negation as failure was unresolved until Keith Clark [1978] showed that, under certain natural conditions, it is a correct (and sometimes complete) implementation of classical negation with respect to the completion of the program. Completion amounts roughly to regarding the set of all the program clauses with the same predicate on the left hand side, say</p>
<p>

<indent level="1">

H :-  Body1.
</indent>
:      …
<indent level="1">

H :-  Bodyk.
</indent>

as a definition of the predicate</p>
<p>

<indent level="1">

H iff (Body1 or … or Bodyk)
</indent>

where "iff" means "if and only if". Writing the completion also requires explicit use of the equality predicate and the inclusion of a set of appropriate axioms for equality. However, the implementation of negation by failure needs only the if-halves of the definitions without the axioms of equality.</p>
<p>

The notion of completion is closely related to McCarthy's <link xlink:type="simple" xlink:href="../917/2634917.xml">
circumscription</link> semantics for default reasoning, and to the <link xlink:type="simple" xlink:href="../582/2526582.xml">
closed world assumption</link>.</p>
<p>

As an alternative to the completion semantics, negation as failure can also be interpreted epistemically, as in the <link xlink:type="simple" xlink:href="../978/4224978.xml">
stable model semantics</link> of <link xlink:type="simple" xlink:href="../211/2386211.xml">
answer set programming</link>. In this interpretation not(Bi) means literally that Bi is not known or not believed. The epistemic interpretation has the advantage that it can be combined very simply with  classical negation, as in "extended logic programming", to formalise such phrases as "the contrary can not be shown", where "contrary" is classical negation and "can not be shown" is the epistemic interpretation of negation as failure.</p>

</sec>
<sec>
<st>
Problem solving</st>

<p>

In the simplified, propositional case in which a logic program and a top-level atomic goal contain no variables, backward reasoning determines an <link xlink:type="simple" xlink:href="../384/12379384.xml">
and-or tree</link>, which constitutes the search space for solving the goal. The top-level goal is the root of the tree. Given any node in the tree and any clause whose head matches the node, there exists a set of child nodes corresponding to the sub-goals in the body of the clause. These child nodes are grouped together by an "and". The alternative sets of children corresponding to alternative ways of solving the node are grouped together by an "or".</p>
<p>

Any search strategy can be used to search this space. Prolog uses a sequential, last-in-first-out, backtracking strategy, in which only one alternative and one sub-goal is considered at a time. Other search strategies, such as parallel search, intelligent backtracking, or best-first search to find an optimal solution, are also possible.</p>
<p>

In the more general case, where sub-goals share variables, other strategies can be used, such as choosing the subgoal that is most highly instantiated or that is sufficiently instantiated so that only one  procedure applies. Such strategies are used, for example, in <link>
concurrent logic programming</link>.</p>
<p>

The fact that there are alternative ways of executing a logic program has been characterised by the equation:</p>
<p>

Algorithm = Logic + Control</p>
<p>

where "Logic" represents a logic program and "Control" represents different theorem-proving strategies.</p>

</sec>
<sec>
<st>
Knowledge representation</st>

<p>

The fact that Horn clauses can be given a procedural interpretation and, vice versa, that goal-reduction procedures can be understood as Horn clauses + backward reasoning means that logic programs combine declarative and procedural representations of <link xlink:type="simple" xlink:href="../920/16920.xml">
knowledge</link>. The inclusion of <link xlink:type="simple" xlink:href="../537/2526537.xml">
negation as failure</link> means that logic programming is a kind of <link xlink:type="simple" xlink:href="../086/341086.xml">
non-monotonic logic</link>.</p>
<p>

Despite its simplicity compared with classical logic, this combination of Horn clauses and negation as failure has proved to be surprisingly expressive. For example, it has been shown to correspond, with some further extensions, quite naturally to the semi-formal language of legislation. It is also a natural language for expressing common-sense laws of cause and effect, as in the <link xlink:type="simple" xlink:href="../109/2256109.xml">
situation calculus</link> and <link xlink:type="simple" xlink:href="../680/2897680.xml">
event calculus</link>.</p>

</sec>
<sec>
<st>
Abductive logic programming</st>

<p>

<link xlink:type="simple" xlink:href="../925/12737925.xml">
Abductive Logic Programming</link> is an extension of normal Logic Programming that allows some predicates, declared as abducible predicates, to be incompletely defined. Problem solving is achieved by deriving hypotheses expressed in terms of the abducible predicates as solutions of problems to be solved. These problems can be either observations that need to be explained (as in classical <link xlink:type="simple" xlink:href="../459/60459.xml">
abductive reasoning</link>) or goals to be achieved (as in normal logic programming). It has been used to solve problems in Diagnosis, Planning, Natural Language and Machine Learning. It has also been used to interpret Negation as Failure as a form of abductive reasoning.</p>

</sec>
<sec>
<st>
Constraint logic programming</st>

<p>

<link xlink:type="simple" xlink:href="../442/4249442.xml">
Constraint logic programming</link> is an extension of normal Logic Programming that allows some predicates, declared as constraint predicates, to occur as literals in the body of clauses. These literals are not solved by goal-reduction using program clauses, but are added to a store of constraints, which is required to be consistent with some built-in semantics of the constraint predicates. </p>
<p>

Problem solving is achieved by reducing the initial problem to a satisfiable set of constraints. Constraint logic programming has been used to solve problems in such fields as <link xlink:type="simple" xlink:href="../ar)/5762_(H$ebrew_year).xml">
civil engineering</link>, <link xlink:type="simple" xlink:href="../528/19528.xml">
mechanical engineering</link>, <link xlink:type="simple" xlink:href="../068/39068.xml">
digital circuit</link> verification, <link>
automated timetabling</link>, <link xlink:type="simple" xlink:href="../563/48563.xml">
air traffic control</link>, and finance. It is closely related to <link xlink:type="simple" xlink:href="../925/12737925.xml">
abductive logic programming</link>.</p>

</sec>
<sec>
<st>
Concurrent logic programming</st>

<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/6369702.xml">
Keith Clark</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
, Steve Gregory, Vijay Saraswat, Udi Shapiro, Kazunori Ueda, etc. developed a family of <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link>-like concurrent message passing systems using unification of shared variables and data structure streams for messages. Efforts were made to base these systems on mathematical logic, and they were used as the basis of the <link xlink:type="simple" xlink:href="../832/347832.xml">
Japanese Fifth Generation Project (ICOT)</link>. However, the Prolog-like concurrent systems were based on message passing and consequently were subject to the same indeterminacy as other concurrent message-passing systems, such as <link xlink:type="simple" xlink:href="../868/1637868.xml">
Actors</link> (see <link xlink:type="simple" xlink:href="../863/2681863.xml">
Indeterminacy in concurrent computation</link>).  Consequently, the ICOT languages were not based on logic in the sense that computational steps could not be logically deduced [Hewitt and Agha, 1988].</p>
<p>

<link xlink:type="simple" xlink:href="../477/4467477.xml">
Concurrent constraint logic programming</link> combines concurrent logic programming and <link xlink:type="simple" xlink:href="../442/4249442.xml">
constraint logic programming</link>, using constraints to control concurrency. A clause can contain a guard, which is a set of constraints that may block the applicability of the clause. When the guards of several clauses are satisfied, concurrent constraint logic programming makes a committed choice to the use of only one.</p>

</sec>
<sec>
<st>
Inductive logic programming</st>

<p>

<link xlink:type="simple" xlink:href="../069/54069.xml">
Inductive logic programming</link> is concerned with generalizing positive and negative examples in the context of background knowledge. Generalizations, as well as the examples and background knowledge, are expressed in logic programming syntax. Recent work in this area, combining logic programming, learning and probability, has given rise to the new field of statistical relational learning and probabilistic inductive logic programming.</p>

</sec>
<sec>
<st>
Higher-order logic programming</st>

<p>

Several researchers have extended logic programming with <link xlink:type="simple" xlink:href="../963/2855963.xml">
higher-order programming</link> features derived from <link xlink:type="simple" xlink:href="../883/562883.xml">
higher-order logic</link>, such as predicate variables. Such languages include the Prolog extensions <link>
HiLog</link> and <link>
λProlog</link>.</p>

</sec>
<sec>
<st>
Linear logic programming</st>

<p>

Basing logic programming within <link xlink:type="simple" xlink:href="../675/579675.xml">
linear logic</link> has resulted in the design of logic programming languages that are considerably more expressive than those based on classical logic.  Horn clause programs can only represent state change by the change in arguments to predicates.  In linear logic programming, one can use the ambient linear logic to support state change.  Some early designs of logic programming languages based on linear logic include LO [Andreoli &amp; Pareschi, 1991], Lolli [Hodas &amp; Miller, 1994], ACL [Kobayashi &amp; Yonezawa, 1994], and Forum [Miller, 1996].  Forum provides a goal-direct interpretation of all of linear logic.</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../442/4249442.xml">
Constraint logic programming</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../357/968357.xml">
Datalog</link></entry>
<entry level="1" type="bullet">

<belief wordnetid="105941423" confidence="0.8">
<doctrine wordnetid="105943300" confidence="0.8">
<link xlink:type="simple" xlink:href="../883/161883.xml">
Formal methods</link></doctrine>
</belief>
</entry>
<entry level="1" type="bullet">

<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
Functional programming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../069/54069.xml">
Inductive logic programming</link></entry>
<entry level="1" type="bullet">


Logic programming languages|Logic programming languages</entry>
<entry level="1" type="bullet">

<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../897/189897.xml">
Programming paradigm</link></subject>
</message>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>


<ss1>
<st>
General introductions</st>

<p>

<list>
<entry level="1" type="bullet">

 Robert Kowalski.  <weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~rak/papers/the%20early%20years.pdf">
<b>The Early Years of Logic Programming</b></weblink> CACM. January 1988.</entry>
<entry level="1" type="bullet">

 J. W. Lloyd.  <b>Foundations of Logic Programming</b> (2nd edition).  Springer-Verlag 1987.</entry>
<entry level="1" type="bullet">

 Carl Hewitt <weblink xlink:type="simple" xlink:href="http://carlhewitt.blogspot.com/2008/08/development-of-logic-programming-what.html">
<b>Development of Logic Programming: What went wrong, What was done about it, and What it might mean for the future</b></weblink>  Proceedings of <it>What Went Wrong and Why: Lessons from AI Research and Applications</it> Mehmet Göker and Daniel Shapiro editors. AAAI Press. 2008.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Other sources</st>

<p>

<list>
<entry level="1" type="bullet">

 Fisher Black.  <b>A deductive question answering system</b>  Harvard University.  Thesis.  1964.  </entry>
<entry level="1" type="bullet">

 J.M. Foster and E.W. Elcock. ABSYS 1: An Incremental Compiler for Assertions: an Introduction, , Machine Intelligence 4, Edinburgh U Press, 1969, pp. 423-429</entry>
<entry level="1" type="bullet">

 Cordell Green. <b>Application of Theorem Proving to Problem Solving</b> IJCAI 1969.  </entry>
<entry level="1" type="bullet">

 Pat Hayes. Computation and Deduction. In Proceedings of the 2nd MFCS Symposium. Czechoslovak Academy of Sciences, 1973, pp. 105-118.</entry>
<entry level="1" type="bullet">

 Carl Hewitt. <b>Planner: A Language for Proving Theorems in Robots</b> IJCAI 1969.</entry>
<entry level="1" type="bullet">

 Joshua Hodas and Dale Miller. <b>Logic Programming in a Fragment of Intuitionistic Linear Logic</b>, Information and Computation, 1994, 110(2), 327-365.</entry>
<entry level="1" type="bullet">

 Naoki Kobayashi and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../531/17002531.xml">
Akinori Yonezawa</link></scientist>
</causal_agent>
</person>
</physical_entity>
.  <b>Asynchronous communication model based on linear logic</b>, Formal Aspects of Computing, 1994, 279-294.</entry>
<entry level="1" type="bullet">

 Robert Kowalski and Donald and Kuehner, <weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~rak/papers/sl.pdf">
<b>Linear Resolution with Selection Function</b></weblink> Artificial Intelligence, Vol. 2, 1971, pp. 227-60.  </entry>
<entry level="1" type="bullet">

 Robert Kowalski <weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~rak/papers/IFIP%2074.pdf">
<b>Predicate Logic as a Programming Language</b></weblink> Memo 70, Department of Artificial Intelligence, Edinburgh University.  1973. Also in Proceedings IFIP Congress, Stockholm, North Holland Publishing Co., 1974, pp. 569-574. </entry>
<entry level="1" type="bullet">

John McCarthy.  <b>Programs with <link xlink:type="simple" xlink:href="../147/5147.xml">
common sense</link></b> Symposium on Mechanization of Thought Processes.  National Physical Laboratory.  Teddington, England.  1958.</entry>
<entry level="1" type="bullet">

Ehud Shapiro (Editor). <b>Concurrent Prolog</b> MIT Press.  1987.</entry>
<entry level="1" type="bullet">

Ehud Shapiro.  <b>The family of concurrent logic programming languages</b> ACM Computing Surveys.  September 1989.</entry>
<entry level="1" type="bullet">

James Slagle.  <b>Experiments with a Deductive Question-Answering Program</b> CACM. December, 1965.</entry>
<entry level="1" type="bullet">

Shunichi Uchida and Kazuhiro Fuchi <b>Proceedings of the FGCS Project Evaluation Workshop</b> Institute for New Generation Computer Technology (ICOT). 1992.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Further reading</st>

<p>

<list>
<entry level="1" type="bullet">

Carl Hewitt. <b>Procedural Embedding of Knowledge In Planner</b> IJCAI 1971.</entry>
<entry level="1" type="bullet">

Carl Hewitt. <b>The repeated demise of logic programming and why it will be reincarnated</b> What Went Wrong and Why: Lessons from AI Research and Applications. Technical Report SS-06-08. AAAI Press. March 2006.</entry>
<entry level="1" type="bullet">

Evgeny Dantsin, Thomas Eiter, Georg Gottlob, Andrei Voronkov: Complexity and expressive power of logic programming. ACM Comput. Surv. 33(3): 374-425 (2001)  </entry>
<entry level="1" type="bullet">

Ulf Nilsson and Jan Maluszynski, <weblink xlink:type="simple" xlink:href="http://www.ida.liu.se/~ulfni/lpp/">
Logic, Programming and Prolog</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://vl.fmnet.info/logic-prog/">
<it>Logic Programming</it> Virtual Library entry</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://liinwww.ira.uka.de/bibliography/LogicProgramming/">
Bibliographies on Logic Programming</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.kuleuven.be/~dtai/projects/ALP/">
Association for Logic Programming (ALP)</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.kuleuven.be/~dtai/projects/ALP/TPLP/">
Theory and Practice of Logic Programming</weblink> journal</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.mpprogramming.com/Cpp/">
Logic programming in C++ with Castor</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.mozart-oz.org/documentation/tutorial/node12.html">
Logic programming in</weblink> <link xlink:type="simple" xlink:href="../916/256916.xml">
Oz</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.pdc.dk/">
Prolog Development Center </weblink></entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
Types of <link xlink:type="simple" xlink:href="../015/23015.xml">
Programming language</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../887/890887.xml">
Array</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../368/1368.xml">
Assembly</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../101/174101.xml">
Compiled</link></subject>
</message>
 &nbsp;·  <link xlink:type="simple" xlink:href="../605/2581605.xml">
Concurrent</link> &nbsp;·  <link xlink:type="simple" xlink:href="../103/560103.xml">
Curly bracket</link> &nbsp;·  <link>
Data-oriented</link> &nbsp;·  <link xlink:type="simple" xlink:href="../378/2468378.xml">
Data-structured</link> &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../396/1079396.xml">
Dataflow</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../648/210648.xml">
Declarative</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../239/519239.xml">
Domain-specific</link> &nbsp;·  <link xlink:type="simple" xlink:href="../398/53398.xml">
Esoteric</link> &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../177/1445177.xml">
Extensible</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
Functional</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../847/197847.xml">
Imperative</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../089/15089.xml">
Interpreted</link> &nbsp;·  <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
Logic</link> &nbsp;·  <link xlink:type="simple" xlink:href="../683/20683.xml">
Machine</link> &nbsp;·  <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../560/20560.xml">
Macro</link></concept>
</idea>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../460/393460.xml">
Metaprogramming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../843/226843.xml">
Multi-paradigm</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../497/365497.xml">
Non-English-based</link> &nbsp;·  <link xlink:type="simple" xlink:href="../758/22758.xml">
Object-oriented</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../595/605595.xml">
Off-side rule</link></subject>
</message>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../467/1780467.xml">
Pipeline</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../801/23801.xml">
Procedural</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../003/61003.xml">
Prototype-based</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../905/314905.xml">
Reflective</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link>
Rule-based</link> &nbsp;·  <link xlink:type="simple" xlink:href="../524/29524.xml">
Scripting</link> &nbsp;·  <link xlink:type="simple" xlink:href="../347/2211347.xml">
Synchronous</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../268/499268.xml">
Visual</link></subject>
</message>
</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</paradigm>
</article>
