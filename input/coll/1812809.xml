<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 18:59:41[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Pseudorandom generator</title>
<id>1812809</id>
<revision>
<id>237374767</id>
<timestamp>2008-09-09T21:54:34Z</timestamp>
<contributor>
<username>CryptoDerk</username>
<id>55783</id>
</contributor>
</revision>
<categories>
<category>Pseudorandomness</category>
<category>Algorithmic information theory</category>
</categories>
</header>
<bdy>

This page is about the formal concept in theoretical computer science. For the common meaning of this term, see <link xlink:type="simple" xlink:href="../524/45524.xml">
Pseudorandom number generator</link>
In <link xlink:type="simple" xlink:href="../392/323392.xml">
theoretical computer science</link>, a <b>pseudorandom generator</b> is a <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic</link> method of generating a large amount of <link xlink:type="simple" xlink:href="../210/23210.xml">
pseudorandom</link>, or apparently <link xlink:type="simple" xlink:href="../523/19196523.xml">
random</link>, data, from a small amount of initial random data. The initial data is commonly known as a <link xlink:type="simple" xlink:href="../259/2503259.xml">
random seed</link>.
<sec>
<st>
Formal definition</st>

<p>

Let <it>G</it> be a <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic</link> <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link> function from <b>N</b> to <b>N</b> with <it>stretch function</it> </p>
<p>

<indent level="1">

<it>l</it>: <b>N</b> &amp;rarr; <b>N</b>, 
</indent>

so that if <it>x</it> has length <it>n</it> then <it>G</it>(<it>x</it>) has length <it>l</it>(<it>n</it>). Then let <it>Gn</it> be the distribution on strings of length <it>l</it>(<it>n</it>) defined by the output of <it>G</it> on a <link xlink:type="simple" xlink:href="../523/19196523.xml">
randomly</link> selected string of length <it>n</it> selected by the <link xlink:type="simple" xlink:href="../835/5509835.xml">
uniform distribution</link>.</p>
<p>

Then <it>G</it> is a <b>pseudorandom generator</b> if </p>
<p>

<indent level="1">

{<it>Gn</it>}<it>n &amp;isin; </it><b>N</b> 
</indent>

is <link xlink:type="simple" xlink:href="../210/23210.xml">
pseudorandom</link>.</p>
<p>

In effect, <it>G</it> translates a random input of length <it>n</it> to a pseudorandom output of length <it>l</it>(<it>n</it>). Assuming </p>
<p>

<indent level="1">

<it>l</it>(<it>n</it>) &amp;gt; <it>n</it>, 
</indent>

this expands a random sequence (and can be applied multiple times, since <it>Gn</it> can be replaced by the distribution of <it>G</it>(<it>G</it>(<it>x</it>))).</p>
<p>

Often, the subject of concern is not with the behavior of <it>G</it> on all strings, but only on strings of some prescribed length.  This case allows a slightly easier definition:</p>
<p>

A function <math>G_l: \left \{0,1\right\}^n \rightarrow \left \{0,1\right\}^m\,</math> with <math>n &amp;lt; m\,</math> is a pseudorandom generator if</p>
<p>

<list>
<entry level="1" type="bullet">

<math>G_l\,</math> can be computed in <math>poly(n)\,</math> time, and</entry>
<entry level="1" type="bullet">

<math>G_l(x)\,</math> is pseudorandom.</entry>
</list>
</p>
<p>

It is an open problem whether or not pseudorandom generators exist.  It is known that if <link xlink:type="simple" xlink:href="../890/363890.xml">
one-way function</link>s or <link xlink:type="simple" xlink:href="../871/1182871.xml">
hard-core predicate</link>s exist, then pseudorandom generators exist.  It is also known that if </p>
<p>

<indent level="1">

<it>l</it>(<it>n</it>) &amp;gt; <it>n</it>, 
</indent>

there is some other pseudorandom generator with </p>
<p>

<indent level="1">

<it>l</it>(<it>n</it>) &amp;gt; <it>p</it>(<it>n</it>) 
</indent>

for any polynomial, <it>p</it>(<it>n</it>). This follows from the following theorem:</p>
<p>

Theorem:  If there is a pseudorandom generator
<indent level="3">

<math>G_l: \left \{0,1\right\}^{n} \rightarrow \left \{0,1\right\}^{n+1}\,</math>
</indent>
then for any <math>m = poly(n) \,</math>, there is a pseudorandom generator
<indent level="3">

<math>G_l: \left \{0,1\right\}^n \rightarrow \left \{0,1\right\}^m\,</math>
</indent>

</p>
</sec>
<sec>
<st>
Applications</st>

<p>

Pseudorandom generators have numerous applications. In <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>, a simple application is providing an efficient analog of `<link xlink:type="simple" xlink:href="../210/22210.xml">
one time pads</link>'. It is well known that in order to encrypt a message m in a way that the cipher text provides no information on the plaintext,
the key k used should be random over strings of length |m|. Then m can be encrypted via <math>c=k\oplus m</math>. This operation is very costly in terms of key length. Key length can be reduced if we compromise on <link xlink:type="simple" xlink:href="../585/960585.xml">
semantic security</link>. Then, given G, which expands by a polynomial <math>n^{c+1}</math>, then a sequence of <math>n^c</math> messages of length n can be encrypted by xor-ing each with the corresponding area of G(k) (inspired the idea of <link xlink:type="simple" xlink:href="../007/49007.xml">
stream cipher</link>s).</p>
<p>

Pseudorandom generators may also be used to construct <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../042/53042.xml">
symmetric key cryptosystems</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, where any polynomial number of messages can be `safely' encrypted under the same key, that is, the polynomial <math>n^c</math> is not apriority known at time of key generation. Such a construction can be based on a generalization of pseudo random generators, called pseudorandom functions. A family of <link xlink:type="simple" xlink:href="../616/3454616.xml">
pseudorandom function</link>s (PRF's) is a collection of efficiently computable keyed functions, which `act randomly' in the scene that no efficient algorithm can distinguish between an oracle to a function corresponding to a random key, and an oracle to a random function. </p>
<p>

It's known that if PRG's exist, then so do PRF's (for more details see <link xlink:type="simple" xlink:href="../616/3454616.xml">
pseudorandom function</link>). One application of PRF's is to understanding learning theory. Loosely speaking, given a sequence of examples <math>(x_1,f(x_1)),(x_2,f(x_2)),\ldots,(x_m,f(x_m)))</math> e.t.c, 
the goal is to efficiently find a succinct representation of a function f out of a given class of functions consistent with the examples. PRF families (if exist) are a natural example of a class of functions with small representation size, but are not learnable.</p>
<p>

Another application is to derandomizing algorithms. A <it>nice</it> pseudorandom generator is a pseudorandom number generator,</p>
<p>

<indent level="1">

<math>G:\{0,1\}^n\rightarrow\{0,1\}^m</math> 
</indent>

with </p>
<p>

<indent level="1">

<math>n=O(\log m)\,</math>.
</indent>

If a nice pseudorandom generator exists, then <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
=<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
.
In fact, this strong derandomization result follows assuming the existence of a weaker type of
pseudorandom generators, Nisan-Wigderson type generator with exponential stretch. Their definition weakens the definition of PRG above in two essential ways. First, it allows <math>G_l</math> to run in exponential in n time. Another important difference is that the output distribution is only required to be indistinguishable from uniform for circuits of size S'(n) for some fixed exponential S' which is smaller than S, as opposed to generators as in the definition above. 
It's easy to see that the existence of <it>nice</it> pseudorandom generators of this kind 
for some polynomial S(n) is sufficient to imply <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
=<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
, and follows from plausible hardness assumptions (that some problems in <link xlink:type="simple" xlink:href="../694/54694.xml">
EXP</link> don't have sub exponential circuits). In a nutshell, the idea is to replace the randomness used by a BPP algorithm A,
by G(s), where s is a short (O(log(n))) random string. By pseudorandomness of G, the behavior
of A on any given x will not change much, so we can count the number of 1's output by A obtained iterating over the s, and answer according to the majority. That is, <math>A(x,\cdot)</math> can be viewed as a non uniform distinguisher of proper size.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
 (describing Bounded-error, Probabilistic, Polynomial time derandomization algorithms)</entry>
</list>
</p>

</sec>
<sec>
<st>
Further reading</st>

<p>

<list>
<entry level="1" type="bullet">

 For more on these and other applications of PRG's, see chapters 10,17 in a draft of a book by Arora and Barak: <weblink xlink:type="simple" xlink:href="http://www.cs.princeton.edu/theory/complexity/">
http://www.cs.princeton.edu/theory/complexity/</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
