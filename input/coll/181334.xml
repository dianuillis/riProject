<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:25:38[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<field  confidence="0.9511911446218017" wordnetid="108569998">
<premise  confidence="0.9511911446218017" wordnetid="106753800">
<header>
<title>Discrete logarithm</title>
<id>181334</id>
<revision>
<id>239337327</id>
<timestamp>2008-09-18T17:43:46Z</timestamp>
<contributor>
<username>Mgnbar</username>
<id>346060</id>
</contributor>
</revision>
<categories>
<category>Modular arithmetic</category>
<category>Group theory</category>
<category>Binary operations</category>
<category>Logarithms</category>
<category>Finite fields</category>
<category>Cryptography</category>
<category>Computational hardness assumptions</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematics</link>, specifically in <link xlink:type="simple" xlink:href="../384/19616384.xml">
abstract algebra</link> and its applications, <b>discrete logarithms</b> are <link xlink:type="simple" xlink:href="../447/19447.xml">
group-theoretic</link> analogues of ordinary <link xlink:type="simple" xlink:href="../860/17860.xml">
logarithm</link>s. In particular, an ordinary logarithm <math>\log_a(b)</math> is a solution of the equation <math>a^x=b</math> over the real or <link>
complex numbers</link>. Similarly, if <math>g</math> and <math>h</math> are elements of a <link xlink:type="simple" xlink:href="../206/2997206.xml">
finite</link> <link xlink:type="simple" xlink:href="../327/52327.xml">
cyclic group</link> <math>G</math> then a solution <math>x</math> of the equation <math>g^x=h</math> is called a discrete logarithm to the base <math>g</math> of <math>h</math> in the group <math>G</math>. 
<sec>
<st>
 Example </st>

<p>

Discrete logarithms are perhaps simplest to understand in the group <group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../234/1195234.xml">
(<b>Z</b><it>p</it>)&amp;times;</link></group>
. This is the set of <link>
congruence classes</link> {1,&nbsp;&amp;hellip;,&nbsp;<it>p</it>&nbsp;&amp;minus;&nbsp;1} under multiplication <link xlink:type="simple" xlink:href="../087/20087.xml">
modulo</link> the <link xlink:type="simple" xlink:href="../666/23666.xml">
prime</link> <it>p</it>.</p>
<p>

If we want to find the <it>k</it>th <link>
 power</link> of one of the numbers in this group, we can do so by finding its <it>k</it>th power as an integer and then finding the remainder after division by <it>p</it>. This process is called <it>discrete exponentiation</it>. For example, consider (<b>Z</b>17)&amp;times;. To compute 34 in this group, we first compute 34 = 81, and then we divide 81 by 17, obtaining a remainder of 13. Thus 34 = 13 in the group (<b>Z</b>17)&amp;times;.</p>
<p>

<it>Discrete logarithm</it> is just the inverse operation. For example, take the equation 3k &amp;equiv; 13 (mod 17) for <it>k</it>. As shown above <it>k</it>=4 is a solution, but it is not the only solution. Since 316 &amp;equiv; 1 (mod 17) it also follows that if <it>n</it> is an integer then 34+16 <it>n</it> &amp;equiv; 13 x 1n  &amp;equiv; 13 (mod 17). Hence the equation has infinitely many solutions of the form 4 + 16<it>n</it>. Moreover, since 16 is the smallest positive integer <it>m</it> satisfying 3<it>m</it> &amp;equiv; 1 (mod 17), i.e. 16 is the <link xlink:type="simple" xlink:href="../542/344542.xml">
order</link> of 3 in (<b>Z</b>17)&amp;times;, these are the only solutions. Equivalently, the solution can be expressed as <it>k</it> &amp;equiv; 4 (mod 16).</p>

</sec>
<sec>
<st>
 Definition </st>

<p>

In general, let <it>G</it> be a finite <link xlink:type="simple" xlink:href="../327/52327.xml">
cyclic group</link> with <it>n</it> elements. We assume that the group is written multiplicatively. Let <it>b</it> be a <link xlink:type="simple" xlink:href="../945/99945.xml">
generator</link> of <it>G</it>; then every element <it>g</it> of <it>G</it> can be written in the form <it>g</it>&nbsp;=&nbsp;<it>bk</it> for some integer <it>k</it>. Furthermore, any two such integers representing <it>g</it> will be congruent <link xlink:type="simple" xlink:href="../087/20087.xml">
modulo</link> <it>n</it>. We can thus define a function</p>
<p>

<indent level="1">

<math>\log_b:\  G\ \rightarrow\ \mathbf{Z}_n</math>
</indent>

(where <b>Z</b><it>n</it> denotes the <link>
ring</link> of integers modulo <it>n</it>) by assigning to <it>g</it> the congruence class of <it>k</it> modulo <it>n</it>. This function is a <link xlink:type="simple" xlink:href="../397/12397.xml">
group isomorphism</link>, called the <b>discrete logarithm</b> to base <it>b</it>.</p>
<p>

The familiar base change formula for ordinary logarithms remains valid: If <it>c</it> is another generator of <it>G</it>, then we have</p>
<p>

<indent level="1">

<math>\log_c (g) = \log_c (b) \cdot \log_b (g).</math>
</indent>

</p>
</sec>
<sec>
<st>
 Algorithms </st>

<p>

No efficient algorithm for computing general discrete logarithms <math>\log_b \; g</math> is known. The naive algorithm is to raise <it>b</it> to higher and higher powers <it>k</it> until the desired <it>g</it> is found; this is sometimes called <it>trial multiplication</it>. This algorithm requires <link xlink:type="simple" xlink:href="../ury/23rd_century.xml">
running time</link> linear in the size of the group <it>G</it> and thus exponential in the number of digits in the size of the group. There exists an efficient quantum algorithm due to Peter Shor however (http://arxiv.org/abs/quant-ph/9508027).</p>
<p>

More sophisticated algorithms exist, usually inspired by similar algorithms for integer factorization. These algorithms run faster than the naive algorithm, but none of them runs in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link>.</p>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../928/563928.xml">
Baby-step giant-step</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../817/1630817.xml">
Pollard's rho algorithm for logarithms</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../899/12928899.xml">
Pollard's lambda algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (aka Pollard's kangaroo algorithm)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../624/1995624.xml">
Pohlig-Hellman algorithm</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../595/1549595.xml">
Index calculus algorithm</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../734/152734.xml">
Number field sieve</link></entry>
<entry level="1" type="bullet">

 <link>
Function field sieve</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 Comparison with integer factorization </st>

<p>

While the problem of computing discrete logarithms and the problem of <link xlink:type="simple" xlink:href="../491/15491.xml">
integer factorization</link> are distinct problems they share some properties
<list>
<entry level="1" type="bullet">

both problems are difficult (no efficient <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s are known for non-<link xlink:type="simple" xlink:href="../220/25220.xml">
quantum computer</link>s),</entry>
<entry level="1" type="bullet">

for both problems efficient algorithms on quantum computers are known,</entry>
<entry level="1" type="bullet">

algorithms from one problem are often adapted to the other, and</entry>
<entry level="1" type="bullet">

the difficulty of both problems has been exploited to construct various <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptographic</link> (code) systems.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Cryptography </st>
<p>

Computing discrete logarithms is apparently difficult.  Not only is no efficient algorithm known for the worst case, but the average-case complexity can be shown to be at least as hard as the worst case using <link xlink:type="simple" xlink:href="../266/3087266.xml">
random self-reducibility</link>.</p>
<p>

At the same time, the inverse problem of discrete exponentiation is not (it can be computed efficiently using <link xlink:type="simple" xlink:href="../237/10237.xml">
exponentiation by squaring</link>, for example).  This asymmetry is analogous to the one between integer factorization and integer <link xlink:type="simple" xlink:href="../845/20845.xml">
multiplication</link>. Both asymmetries have been exploited in the construction of cryptographic systems.</p>
<p>

Popular choices for the group <it>G</it> in discrete logarithm <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link> are the cyclic groups (<b>Z</b><it>p</it>)Ã—; see <link xlink:type="simple" xlink:href="../458/59458.xml">
ElGamal encryption</link>, <link>
Diffie-Hellman</link> key exchange, and the <link xlink:type="simple" xlink:href="../470/59470.xml">
Digital Signature Algorithm</link>.</p>
<p>

Newer cryptography applications use discrete logarithms in cyclic subgroups of <link xlink:type="simple" xlink:href="../225/10225.xml">
elliptic curve</link>s over <link xlink:type="simple" xlink:href="../615/11615.xml">
finite field</link>s; see <link xlink:type="simple" xlink:href="../966/9966.xml">
elliptic curve cryptography</link>.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../048/9210048.xml">
Richard Crandall</link></scientist>
</causal_agent>
</person>
</physical_entity>
; <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../159/2134159.xml">
Carl Pomerance</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
. Chapter 5, <it>Prime Numbers: A computational perspective</it>, 2nd ed., Springer.</entry>
<entry level="1" type="bullet">

 Douglas R. Stinson. <it>Cryptography: Theory and Practice</it>, CRC Press, 2002.</entry>
</list>
</p>


</sec>
</bdy>
</premise>
</field>
</article>
