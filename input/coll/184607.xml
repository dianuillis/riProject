<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:27:30[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Aho-Corasick algorithm</title>
<id>184607</id>
<revision>
<id>223965936</id>
<timestamp>2008-07-06T19:01:40Z</timestamp>
<contributor>
<username>Lightmouse</username>
<id>4469495</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

The <b>Aho-Corasick algorithm</b> is a <link xlink:type="simple" xlink:href="../648/28648.xml">
string searching algorithm</link> created by <link>
Alfred V. Aho</link> and <link xlink:type="simple" xlink:href="../177/9105177.xml">
Margaret J. Corasick</link>.  It is a kind of dictionary-matching algorithm that locates elements of a finite set of strings (the "dictionary") within an input text. It matches all patterns "at once", so the <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity</link> of the algorithm is linear in the length of the patterns plus the length of the searched text plus the number of output matches.  Note that because all matches are found, there can be a quadratic number of matches if every substring matches (e.g. dictionary = a, aa, aaa, aaaa and input string is aaaa).<p>

Informally, the algorithm constructs a <link xlink:type="simple" xlink:href="../274/31274.xml">
trie</link> with <link xlink:type="simple" xlink:href="../679/794679.xml">
suffix tree</link>-like set of links from each node representing a string (e.g. abc) to the node corresponding to the longest proper suffix (e.g. bc if it exists, else c if that exists, else the root).  It also contains links from each node to the longest suffix node that corresponds to a dictionary entry; thus all of the matches may be enumerated by following the resulting linked list.  It then uses the trie at runtime, moving along the input and keeping the longest match, using the suffix links to make sure that computation is linear.  For every node that is in the dictionary and every link along the dictionary suffix linked list, an output is generated.</p>
<p>

When the pattern dictionary is known in advance (e.g. a <link xlink:type="simple" xlink:href="../196/18994196.xml">
computer virus</link> database), the construction of the automaton can be performed once off-line and the compiled automaton stored for later use.  In this case, its run time is linear in the length of the input plus the number of matched entries.</p>
<p>

The Aho-Corasick algorithm formed the basis of the original <link xlink:type="simple" xlink:href="../538/170538.xml">
Unix command</link> <link xlink:type="simple" xlink:href="../642/46642.xml#xpointer(//*[./st=%22egrep+and+fgrep%22])">
fgrep</link>.</p>
<p>

The following is the Aho-Corasick data structure constructed
from the specified dictionary, with each row in the table representing a node in the trie, with the column path indicating the (unique) sequence of characters from the root to the node. </p>


<p>

<table border="1">
<row >
<header colspan="4">
Dictionary { a, ab, bc, bca, c, caa }</header>
</row>
<row >
<header>
Path</header>
<header>
In Dictionary</header>
<header>
Suffix Link</header>
<header>
Dict Suffix Link</header>
</row>
<row >
<col>
()</col>
<col>
-</col>
<col>
&nbsp;</col>
<col>
&nbsp;</col>
</row>
<row >
<col>
(a)</col>
<col>
+</col>
<col>
()</col>
<col>
&nbsp;</col>
</row>
<row >
<col>
(ab)</col>
<col>
+</col>
<col>
(b)</col>
<col>
&nbsp;</col>
</row>
<row >
<col>
(b)</col>
<col>
-</col>
<col>
()</col>
<col>
&nbsp;</col>
</row>
<row >
<col>
(bc)</col>
<col>
+</col>
<col>
(c)</col>
<col>
(c)</col>
</row>
<row >
<col>
(bca)</col>
<col>
+</col>
<col>
(ca)</col>
<col>
(a)</col>
</row>
<row >
<col>
(c)</col>
<col>
+</col>
<col>
()</col>
<col>
&nbsp;</col>
</row>
<row >
<col>
(ca)</col>
<col>
-</col>
<col>
(a)</col>
<col>
(a)</col>
</row>
<row >
<col>
(caa)</col>
<col>
+</col>
<col>
(a)</col>
<col>
(a)</col>
</row>
</table>
</p>

<p>

At each step, the current node is extended by finding its daughter,
and if that doesn't exist, finding its suffix's daughter, and if
that doesn't work, finding its suffix's suffix's daughter, finally
ending in the root node if nothing's seen before.</p>
<p>

Execution on input string <b>abccab</b> yields the following steps:</p>


<p>

<table border="1">
<row >
<header colspan="5">
Analysis of input string abccab</header>
</row>
<row >
<header>
Node</header>
<header>
Remaining String</header>
<header>
Output:End Position</header>
<header>
Transition</header>
<header>
Output</header>
</row>
<row >
<col>
()</col>
<col>
abccab</col>
<col>
&nbsp;</col>
<col>
start at root</col>
<col>
&nbsp;</col>
</row>
<row >
<col>
(a)</col>
<col>
bccab</col>
<col>
a:1</col>
<col>
() to daughter (a)</col>
<col>
Current node</col>
</row>
<row >
<col>
(ab)</col>
<col>
ccab</col>
<col>
ab:2</col>
<col>
(a) to daughter (ab)</col>
<col>
Current node</col>
</row>
<row >
<col>
(bc)</col>
<col>
cab</col>
<col>
bc:3, c:3</col>
<col>
(ab) to suffix (b) to daughter (bc)</col>
<col>
Current Node, Dict suffix node</col>
</row>
<row >
<col>
(c)</col>
<col>
ab</col>
<col>
c:4</col>
<col>
(bc) to suffix (c) to suffix () to daughter (c)</col>
<col>
Current node</col>
</row>
<row >
<col>
(ca)</col>
<col>
b</col>
<col>
a:5</col>
<col>
(c) to daughter (ca)</col>
<col>
Dict suffix node</col>
</row>
<row >
<col>
(ab)</col>
<col>
&nbsp;</col>
<col>
ab:6</col>
<col>
(ca) to suffix (a) to daughter (ab)</col>
<col>
Current node</col>
</row>
</table>
</p>


<p>

In general, more than one dictionary suffix link may need to
be followed, as more than one dictionary entry may end at a
given character in the input.</p>

<sec>
<st>
Sources</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal"><expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../930/140930.xml">
Aho, Alfred V.</link></scholar>
</causal_agent>
</alumnus>
</associate>
</scientist>
</colleague>
</intellectual>
</specialist>
</interior_designer>
</person>
</physical_entity>
</peer>
</expert>
; Margaret J. Corasick&#32;(June 1975).&#32;"Efficient string matching: An aid to bibliographic search". <it>Communications of the ACM</it>&#32;<b>18</b>&#32;(6): 333&ndash;340. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F360825.360855">
10.1145/360825.360855</weblink>.</cite>&nbsp; (Access to the full text may be restricted.)</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-sr.informatik.uni-tuebingen.de/~buehler/AC/AC.html">
Animation of the Aho/Corasick Pattern Matching Automaton</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.uku.fi/~kilpelai/BSA05/lectures/slides04.pdf">
Set Matching and Aho-Corasick Algorithm</weblink> by Pekka Kilpeläinen</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codeproject.com/cs/algorithms/ahocorasick.asp">
Aho-Corasick string matching in C#</weblink> by Tomáš Petříček (<weblink xlink:type="simple" xlink:href="http://www.eeeksoft.net/articles/ahocorasick.aspx">
mirror</weblink>)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/ahoCorasick.html">
Aho-Corasick entry</weblink> in NIST's <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/">
Dictionary of Algorithms and Data Structures</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.dankirsh.com/2008/07/05/aho-corasick-algorithm/">
PHP/Javascript Implementation of Aho/Corasick Algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/search%3fmodule=Algorithm::AhoCorasick">
Perl Implementation of the Aho-Corasick Algorithm</weblink> by Vaclav Barta</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://hkn.eecs.berkeley.edu/~dyoo/python/ahocorasick/">
A Python implementation</weblink> licensed under GPLv2 or any later version</entry>
</list>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
