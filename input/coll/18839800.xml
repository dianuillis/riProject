<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 05:02:59[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Instruction path length</title>
<id>18839800</id>
<revision>
<id>237723611</id>
<timestamp>2008-09-11T15:07:48Z</timestamp>
<contributor>
<username>THEN WHO WAS PHONE?</username>
<id>7456377</id>
</contributor>
</revision>
<categories>
<category>Information technology</category>
<category>Software performance optimization</category>
<category>Analysis of algorithms</category>
</categories>
</header>
<bdy>

<b>Instruction path length</b> is a term frequently used to simply describe the number of <link xlink:type="simple" xlink:href="../683/20683.xml">
machine code</link> instructions required to execute a section of a <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>. The total path length for the entire program could be deemed a measure of the <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s performance on a particular <link xlink:type="simple" xlink:href="../310/5310.xml">
computer hardware</link>. The path length of a simple conditional instruction would normally be considered as equal to 2, one instruction to perform the comparison and another to take a branch if the particular condition is satisfied. The length of time to execute each instruction is not normally considered in determinining path length and so path length is merely an indication of relative performance rather than in any sense absolute.
<sec>
<st>
Assembly programs</st>
<p>

Since there is, typically, a one-to-one relationship between <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly</link> instructions and machine instructions, the instruction path length is frequently taken as the number of assembly instructions required to perform a function or particular section of code. Performing a simple <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../457/356457.xml">
table lookup</link></array>
</group>
</arrangement>
 on a un<link xlink:type="simple" xlink:href="../442/28442.xml">
sort</link>ed list of 1,000 entries might require perhaps 2,000 machine instructions (on average, assuming uniform distribution of input values) , performing the same lookup on a <link xlink:type="simple" xlink:href="../735/82735.xml">
sort</link>ed list using a <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> algorithm might require only about 40 machine instructions, a very considerable saving. Expressed in terms of instruction path length, this <link xlink:type="simple" xlink:href="../658/731658.xml">
metric</link> would be reduced in this instance by a massive factor of 50 - a reason why actual instruction timings might be a secondary consideration compared to a good choice of <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>.</p>

</sec>
<sec>
<st>
High level language (<link xlink:type="simple" xlink:href="../842/189842.xml">
HLL</link>) programs</st>
<p>

Since one statement written in a high level language can produce very many machine instructions, it is not always possible to determine instruction path length without, for example, an <link xlink:type="simple" xlink:href="../791/3076791.xml">
Instruction Set Simulator</link> - that can count the number of 'executed' instructions during simulation. If the high level language supports and optionally produces an 'assembly list', it is sometimes possible to estimate the instruction path length by examining this list. Unfortunately most high levbel language programmers do not have the knowledge to understand the assembly instructions produced and have no way to appreciate the instruction path lengths of their code - except perhaps through anecdote or bad experience.
Therefore choice of particular high level language statements can have dramatic effects on instruction path lengths without the programmer having any means of knowing this in many cases.</p>

</sec>
<sec>
<st>
Factors determining instruction path length</st>
<p>

<list>
<entry level="1" type="bullet">

 in-line code versus function call - function calls require <link xlink:type="simple" xlink:href="../117/547117.xml">
Dynamic memory allocation</link> ,initialization and possibly other overheads</entry>
<entry level="1" type="bullet">

 order of items in unsorted lookup list - most frequently occuring items should be placed first to avoid long searches</entry>
<entry level="1" type="bullet">

 choice of algorithm - <link xlink:type="simple" xlink:href="../386/7602386.xml">
indexed</link>, <link xlink:type="simple" xlink:href="../266/4266.xml">
binary</link> or <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../127/103127.xml">
linear (item-by-item) search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 calculate afresh versus retain earlier calculated (<link xlink:type="simple" xlink:href="../483/723483.xml">
memoization</link>) - may reduce multiple complex <link xlink:type="simple" xlink:href="../833/68833.xml">
iteration</link>s</entry>
<entry level="1" type="bullet">

 read some tables into memory once versus external read afresh each time - avoiding high path length through muliple I/O function calls</entry>
</list>
</p>

</sec>
<sec>
<st>
Use of Instruction path lengths</st>
<p>

From the above, it can be realized that knowledge of instruction path lengths can be used:- 
<list>
<entry level="1" type="bullet">

 to choose an appropriate algorithm to minimize overall path lengths for programs in any language </entry>
<entry level="1" type="bullet">

 to monitor how well a program has been <link xlink:type="simple" xlink:href="../779/225779.xml">
optimized</link> in any language</entry>
<entry level="1" type="bullet">

 to determine how efficient particular HLL statements are for any HLL language</entry>
<entry level="1" type="bullet">

 as an approximate measure of overall performance</entry>
</list>

</p>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../128/145128.xml">
Algorithmic efficiency</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../779/225779.xml">
Optimization (computer science)</link></entry>
</list>
</p>

</sec>
</bdy>
</article>
