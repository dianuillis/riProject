<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:09:27[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Liang-Barsky</title>
<id>1943925</id>
<revision>
<id>192029805</id>
<timestamp>2008-02-17T09:19:16Z</timestamp>
<contributor>
<username>Andreas Kaufmann</username>
<id>72502</id>
</contributor>
</revision>
<categories>
<category>Clipping (computer graphics)</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, the  <b>Liang-Barsky</b> algorithm is a <link xlink:type="simple" xlink:href="../474/1982474.xml">
line clipping</link> algorithm. The Liang-Barsky algorithm uses the parametric equation of a line and inequalities describing the range of the clipping box to determine the intersections between the line and the clipping box. With these intersections it knows which portion of the line should be drawn. This algorithm is significantly more efficient than <link xlink:type="simple" xlink:href="../116/3478116.xml">
Cohen-Sutherland</link>.
<sec>
<st>
The algorithm</st>

<p>

C# implementation for Liang-Barsky algorithm</p>
<p>

internal sealed class LiangBarskyClipping : IClippingAlgorithm {
private Vector2 _clipMin, _clipMax;</p>
<p>

public IEnumerable GetBoundingPolygon() {
yield return _clipMin;
yield return new Vector2(_clipMax.X, _clipMin.Y);
yield return _clipMax;
yield return new Vector2(_clipMin.X, _clipMax.Y);
}</p>
<p>

public void SetBoundingRectangle(Vector2 start, Vector2 end) {
_clipMin = start;
_clipMax = end;
}</p>
<p>

public void SetBoundingPolygon(IEnumerable points) {
throw new NotSupportedException("see Capabilities =)");
}</p>
<p>

private delegate bool ClippingHandler(float p, float q);</p>
<p>

public bool ClipLine(ref Line line) {
Vector2 P = line.End - line.Start;
float tMinimum = 0, tMaximum = 1;</p>
<p>

ClippingHandler pqClip = delegate(float directedProjection,
float directedDistance) {
if (directedProjection == 0) {
if (directedDistance  0) return false;
}
else {
float amount = directedDistance / directedProjection;
if (directedProjection  0) {
if (amount &amp;gt; tMaximum) return false;
else if (amount &amp;gt; tMinimum) tMinimum = amount;
}
else {
if (amount  tMinimum) return false;
else if (amount  tMaximum) tMaximum = amount;
}
}
return true;
};</p>
<p>

if (pqClip(-P.X, line.Start.X - _clipMin.X)) {
if (pqClip(P.X, _clipMax.X - line.Start.X)) {
if (pqClip(-P.Y, line.Start.Y - _clipMin.Y)) {
if (pqClip(P.Y, _clipMax.Y - line.Start.Y)) {
if (tMaximum  1) {
line.End.X = line.Start.X + tMaximum * P.X;
line.End.Y = line.Start.Y + tMaximum * P.Y;
}
if (tMinimum &amp;gt; 0) {
line.Start.X += tMinimum * P.X;
line.Start.Y += tMinimum * P.Y;
}
return true;
}
}
}
}
return false;
}</p>
<p>

public ClippingCapabilities Capabilities {
get {
return ClippingCapabilities.RectangleWindow;
}
}</p>
<p>

public override string ToString() {
return "Liang-Barsky algorithm";
}
}
// This code was implemented by Grishul Eugeny as part of preparation
// to exam in ITMO university</p>


</sec>
<sec>
<st>
See also</st>

<p>

Algorithms used for the same purpose:
<list>
<entry level="1" type="bullet">

 <link>
Cyrus-Beck</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../118/3478118.xml">
Nicholl-Lee-Nicholl</link></entry>
<entry level="1" type="bullet">

 <link>
Fast-Clipping</link></entry>
</list>
</p>

</sec>
</bdy>
</article>
