<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:30:20[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Probabilistic Turing machine</title>
<id>197812</id>
<revision>
<id>232615378</id>
<timestamp>2008-08-18T03:59:22Z</timestamp>
<contributor>
<username>EileenFlammable</username>
<id>7475438</id>
</contributor>
</revision>
<categories>
<category>Computational models</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability theory</link>, a <b>probabilistic Turing machine</b> is a <link xlink:type="simple" xlink:href="../935/21935.xml">
non-deterministic Turing machine</link> which randomly chooses between the available transitions at each point according to some <link xlink:type="simple" xlink:href="../543/23543.xml">
probability distribution</link>. <p>

In the case of equal probabilities for the transitions, it can be defined as a deterministic <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 having an additional  "write" instruction where the value of the write is <link xlink:type="simple" xlink:href="../835/5509835.xml">
uniformly distributed</link> in the Turing Machine's alphabet (generally, an equal likelihood of writing a '1' or a '0' on to the  tape.) Another common reformulation is simply a <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link> with an added tape full of random bits called the <it>random tape</it>.</p>
<p>

As a consequence, a probabilistic Turing machine can (unlike a deterministic Turing Machine) have <link xlink:type="simple" xlink:href="../222/292222.xml">
stochastic</link> results; on a given input and instruction state machine, it may have different run times, or it may not halt at all; further, it may accept an input in one execution and reject the same input in another execution.</p>
<p>

Therefore the notion of acceptance of a string by a probabilistic Turing machine can be defined in different ways. Various polynomial-time randomized <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity classes</link> that result from different definitions of acceptance include <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../771/54771.xml">
RP</link></group>
</collection>
</class>
, Co-RP, <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
 and <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../772/54772.xml">
ZPP</link></group>
</collection>
</class>
. If we restrict the machine to logarithmic space instead of polynomial time, we obtain the analogous <link xlink:type="simple" xlink:href="../535/360535.xml">
RL</link>, Co-RL, <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../708/18449708.xml">
BPL</link></group>
</collection>
</class>
, and <link xlink:type="simple" xlink:href="../975/916975.xml">
ZPL</link>. If we enforce both restrictions, we get <link xlink:type="simple" xlink:href="../206/18415206.xml">
RLP</link>, Co-RLP, <link xlink:type="simple" xlink:href="../708/18449708.xml">
BPLP</link>, and <link>
ZPLP</link>.</p>
<p>

Probabilistic computation is also critical for the definition of most classes of <link xlink:type="simple" xlink:href="../255/160255.xml">
interactive proof system</link>s, in which the verifier machine depends on randomness to avoid being predicted and tricked by the all-powerful prover machine. For example, the class <b>IP</b> equals <b><mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
</b>, but if randomness is removed from the verifier, we are left with only <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
</b>, which is not known but widely believed to be a considerably smaller class.</p>
<p>

One of the central questions of complexity theory is whether randomness adds power; that is, is there a problem which can be solved in polynomial time by a probabilistic Turing machine but not a deterministic Turing machine? Or can deterministic Turing machines efficiently simulate all probabilistic Turing machines with at most a polynomial slowdown? It is currently widely believed by researchers that the latter is the case, which would imply <b>P</b> = <b>BPP</b>. The same question for log space instead of polynomial time (does <b>L</b> = <b>BPLP</b>?) is even more widely believed to be true. On the other hand, the power randomness gives to interactive proof systems and the simple algorithms it creates for difficult problems such as polynomial-time primality testing and log-space graph connectedness testing suggest that randomness may add power.</p>
<p>

A <link xlink:type="simple" xlink:href="../220/25220.xml">
quantum computer</link> is another model of computation that is inherently probabilistic.</p>

<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../383/495383.xml">
Randomized algorithm</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/probablturng.html">
NIST website on probabilistic Turing machines</weblink></entry>
</list>
</p>


</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
