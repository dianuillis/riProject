<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:30:30[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<idea  confidence="0.8" wordnetid="105833840">
<concept  confidence="0.8" wordnetid="105835747">
<header>
<title>Branch predication</title>
<id>199439</id>
<revision>
<id>208893074</id>
<timestamp>2008-04-29T00:53:38Z</timestamp>
<contributor>
<username>Rje</username>
<id>109479</id>
</contributor>
</revision>
<categories>
<category>Conditional constructs</category>
<category>Instruction processing</category>
</categories>
</header>
<bdy>

Not to be confused with <link xlink:type="simple" xlink:href="../129/416129.xml">
Branch prediction</link>.<p>

<b>Branch predication</b> is a strategy in <link xlink:type="simple" xlink:href="../509/6509.xml">
computer architecture</link> design for mitigating the costs usually associated with conditional <link xlink:type="simple" xlink:href="../210/1013210.xml">
branch</link>es, particularly branches to short sections of code. It does this by allowing each instruction to conditionally either perform an operation or do nothing.</p>

<sec>
<st>
 Overview </st>

<p>

Because <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s respond to a user, there is no way around the fact that portions of a program need to be executed conditionally.  As the majority of <link xlink:type="simple" xlink:href="../218/5218.xml">
processor</link>s simply execute the next <link xlink:type="simple" xlink:href="../801/3149801.xml">
instruction</link> encountered, the traditional solution is to insert <it>branch</it> instructions that allow a program to conditionally branch to a different section of code.  This was a good solution until designers began improving performance by <link xlink:type="simple" xlink:href="../314/220314.xml">
instruction pipelining</link>, which is slowed down by branches. For a more thorough description of the problems which arose and a popular solution, see <link xlink:type="simple" xlink:href="../129/416129.xml">
branch prediction</link>.</p>
<p>

Luckily, one of the more common patterns of code that normally relies on branching has a more elegant solution.  Consider the following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>:</p>
<p>

<b>if</b> <it>condition</it>
<it>do this</it>
<b>else</b>
<it>do that</it></p>
<p>

On a system that uses conditional branching, this might translate to <link xlink:type="simple" xlink:href="../683/20683.xml">
machine instructions</link> looking something like this:</p>
<p>

branch if <it>condition</it> to <b>label 1</b>
<it>do that</it>
branch to <b>label 2</b>
<b>label 1:</b>
<it>do this</it>
<b>label 2:</b>
...</p>
<p>

With branch predication, all possible branch paths are executed, the correct path is kept and all others are thrown away. The basic idea is that each instruction is associated with a predicate (the word here used similarly to its usage in <link xlink:type="simple" xlink:href="../970/74970.xml">
predicate logic</link>) and that the instruction will only be executed if the predicate is true.  The machine code for the above example using branch predication might look something like this:</p>
<p>

(<it>condition</it>) do this
(not <it>condition</it>) do that</p>
<p>

Note that besides eliminating branches, less code is needed in total, provided the architecture provides predicated instructions.  While this does not guarantee faster execution in general, it will if the do this and do that blocks of code are short enough.</p>
<p>

Typically, in order to claim a system has branch predication, most or all of the instructions must have this ability to execute conditionally based on a predicate.</p>

</sec>
<sec>
<st>
 Advantages and disadvantages </st>

<p>

The main purpose of predication is to avoid jumps over very small sections of program code, increasing the effectiveness of <link xlink:type="simple" xlink:href="../187/1236187.xml">
pipelined</link> execution and avoiding problems with the <link xlink:type="simple" xlink:href="../181/849181.xml">
cache</link>. It also has a number of more subtle benefits:
<list>
<entry level="1" type="bullet">

 Functions that are traditionally computed using simple arithmetic and <link xlink:type="simple" xlink:href="../399/264399.xml">
bitwise operation</link>s may be quicker to compute using predicated instructions.</entry>
<entry level="1" type="bullet">

 Predicated instructions with different predicates can be mixed with each other and with unconditional code, allowing better <link xlink:type="simple" xlink:href="../199/1113199.xml">
instruction scheduling</link> and so even better performance.</entry>
<entry level="1" type="bullet">

 Elimination of unnecessary branch instructions can make the execution of necessary branches, such as those that make up loops, faster by lessening the load on <link xlink:type="simple" xlink:href="../129/416129.xml">
branch prediction</link> mechanisms.</entry>
</list>

Unfortunately, predication has one strong drawback: encoding space. In typical implementations, every instruction reserves a bitfield for the predicate specifying whether that instruction should have an effect. When available memory is limited, as on <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded devices</link>, this space cost can be prohibitive. However, some architectures such as <link>
Thumb-2</link> are able to avoid this issue.</p>

</sec>
<sec>
<st>
 Examples </st>


<p>

In <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>'s <link xlink:type="simple" xlink:href="../454/15454.xml">
IA-64</link> architecture, almost every instruction in the IA-64 <link xlink:type="simple" xlink:href="../772/47772.xml">
instruction set</link> is predicated.  The predicates themselves are stored in special purpose <link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link>; one of the predicate registers is always true so that <it>unpredicated</it> instructions are simply instructions predicated with the value true. The use of predication is essential in the IA-64 implementation of <link xlink:type="simple" xlink:href="../279/3827279.xml">
software pipelining</link> because it avoids the need for writing separated code for prologs and epilogs.</p>
<p>

On the <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/60558.xml">
ARM architecture</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, almost all instructions can be conditionally executed. Thirteen different predicates are available, each depending on the four flags Carry, Overflow, Zero, and Negative in some way. The ARM's 16-bit Thumb instruction set has no branch predication, in order to save encoding space, but its successor <link>
Thumb-2</link> overcomes this problem using a special instruction which has no effect other than to supply predicates for the next four instructions.</p>
<p>

For a concrete example of code exploiting branch predication, see the ARM assembly example in <link xlink:type="simple" xlink:href="../410/985410.xml">
binary GCD algorithm</link>.</p>

</sec>
</bdy>
</concept>
</idea>
</article>
