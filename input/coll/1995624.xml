<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:17:59[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Pohlig–Hellman algorithm</title>
<id>1995624</id>
<revision>
<id>228816421</id>
<timestamp>2008-07-30T14:38:56Z</timestamp>
<contributor>
<username>CRGreathouse</username>
<id>1077900</id>
</contributor>
</revision>
<categories>
<category>Number theoretic algorithms</category>
</categories>
</header>
<bdy>

In mathematics, the <b>Pohlig–Hellman algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>  for the computation of <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete logarithm</link>s in a <link xlink:type="simple" xlink:href="../742/1110742.xml">
multiplicative group</link> whose order is a <link xlink:type="simple" xlink:href="../039/1035039.xml">
smooth integer</link>. The algorithm is based on the <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../713/7713.xml">
Chinese remainder theorem</link></proposition>
</theorem>
</message>
</statement>
.<p>

The algorithm was discovered by Roland Silver, but first published by <link>
Stephen Pohlig</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<cryptanalyst wordnetid="109981540" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<inventor wordnetid="110214637" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<decoder wordnetid="109995398" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../387/422387.xml">
Martin Hellman</link></scholar>
</decoder>
</employee>
</causal_agent>
</worker>
</alumnus>
</creator>
</inventor>
</scientist>
</intellectual>
</cryptanalyst>
</person>
</physical_entity>
 (independent of Silver).</p>
<p>

We will explain the algorithm in terms of the group formed by taking all the elements of Zp which are <link xlink:type="simple" xlink:href="../556/6556.xml">
coprime</link> to p, and leave it to the advanced reader to extend the algorithm to other groups by using <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link>
Lagrange's Theorem</link></group>
</proposition>
</theorem>
</message>
</statement>
.</p>
<p>

<indent level="1">

<b>Input</b> Integers <it>p</it>, <it>g</it>, <it>e</it>.
</indent>
:<b>Output</b> Integer <it>x</it>, such that <it>e ≡ gx (mod p)</it>.</p>
<p>

<list>
<entry level="2" type="number">

Determine the prime factorization and <link xlink:type="simple" xlink:href="../452/53452.xml">
totient</link> of the order of the group : <math>\varphi(p)= p_1\cdot p_2 \cdot \ldots \cdot p_n</math></entry>
<entry level="2" type="number">

From the <link xlink:type="simple" xlink:href="../168/771168.xml">
remainder theorem</link> we know that <it>x = a1 p1 + b1</it>. We now find the value of <it>b1</it> for which the following equation holds using a fast algorithm such as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../928/563928.xml">
Baby-step giant-step</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 : <math>
\begin{matrix}e^{\varphi(p)/p_1} &amp; \equiv &amp; (g^x)^{\varphi(p)/p_1} \pmod{p} \\
                              &amp; \equiv &amp; (g^{\varphi(p)})^{a_1}g^{b_1\varphi(p)/p_1} \pmod{p} \\
                              &amp; \equiv &amp; (g^{\varphi(p)/p_1})^{b_1} \pmod{p}
\end{matrix}
</math> (using <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../566/69566.xml">
Euler's theorem</link></proposition>
</theorem>
</message>
</statement>
)Note that if <math>g^{\varphi(p)/p_1} \equiv 1 \pmod{p}</math> then the order of <it>g</it> is less than φ(<it>p</it>) and <math>e^{\varphi(p)/p_1} \mod p</math> must be 1 for a solution to exist. In this case there will be more than one solution for <it>x</it> less than φ(<it>p</it>), but since we are not looking for the whole set, we can require that <it>b</it>1=0.The same operation is now performed for <it>p2</it> up to <it>pn</it>.A minor modification is needed where a prime number is repeated. Suppose we are seeing <it>pi</it> for the <it>k+1</it>-th time. Then we already know <it>ci</it> in the equation <it>x = ai pik+1 + bi pik+ci</it>, and we find <it>bi</it> the same way as before.</entry>
<entry level="2" type="number">

We end up with enough simultaneous <link xlink:type="simple" xlink:href="../229/45229.xml">
congruence</link>s so that <it>x</it> can be solved using the <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../713/7713.xml">
Chinese remainder theorem</link></proposition>
</theorem>
</message>
</statement>
.</entry>
</list>
</p>

<sec>
<st>
Complexity</st>
<p>

The time complexity of the Pohlig–Hellman algorithm is <math>O(\sqrt n)</math> for a group of order <it>n</it>, but it is more efficient if the order is smooth.</p>

</sec>
<sec>
<st>
References</st>
<p>
  	 
<list>
<entry level="1" type="number">

S. Pohlig and M. Hellman. "<weblink xlink:type="simple" xlink:href="http://www.dtc.umn.edu/~odlyzko/doc/arch/discrete.logs.pdf">
An Improved Algorithm for Computing Logarithms over GF(p) and its Cryptographic Significance</weblink>", <it>IEEE Transactions on Information Theory</it> <b>24</b> (1978), pp. 106–110.</entry>
</list>
</p>



</sec>
</bdy>
</algorithm>
</article>
