<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:30:00[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Microkernel</title>
<id>20023</id>
<revision>
<id>244524440</id>
<timestamp>2008-10-11T06:37:15Z</timestamp>
<contributor>
<username>Heiser</username>
<id>3993274</id>
</contributor>
</revision>
<categories>
<category>Operating system technology</category>
<category>Microkernels</category>
</categories>
</header>
<bdy>

<image width="450px" src="OS-structure.svg" type="thumb">
<caption>

Structure of monolithic and microkernel-based operating systems, respectively
</caption>
</image>
<p>

A <b>microkernel</b> is a minimal <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link> which, in its purest form, provides no operating-system services at all, only the  <it>mechanisms</it> needed to implement such services, such as low-level <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link> management, <link xlink:type="simple" xlink:href="../303/45303.xml">
thread</link> management, and <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> (IPC). If the hardware has a kernelmode-usermode distinction, the microkernel is the only part of the system executing in a <link>
kernel mode</link>. The actual operating-system services are provided by "<link xlink:type="simple" xlink:href="../185/3446185.xml">
user-mode</link>" <it>servers</it>. These include <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>s, <link xlink:type="simple" xlink:href="../882/23882.xml">
protocol stack</link>s, <link xlink:type="simple" xlink:href="../280/1010280.xml">
file system</link>s and <link xlink:type="simple" xlink:href="../249/45249.xml">
user-interface</link> code.</p>
<p>

This results in a system structure that is drastically different from the <link xlink:type="simple" xlink:href="../825/20825.xml">
monolithic kernel</link>s of the mass market. The latter traditionally have a vertically-layered structure, where applications obtain services by performing a specific <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link> for each service. In contrast, a microkernel-based system features a horizontal structure, where system services are obtained by executing an IPC system call addressed to a particular server.</p>
<p>

Microkernels are closely related to <link xlink:type="simple" xlink:href="../757/95757.xml">
exokernel</link>s. They also have much in common with <link xlink:type="simple" xlink:href="../216/1267216.xml">
hypervisor</link>s, but the latter make no claim to minimality, and are specialized to supporting <link xlink:type="simple" xlink:href="../353/32353.xml">
virtual machine</link>s. The <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel</link> is frequently used as a hypervisor, which indicates that a microkernel is a possible implementation of a hypervisor. The term <link>
nanokernel</link> is historically used to differentiate from earlier microkernels which contained actual system services, but the <it>minimality</it> principle used by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
 in the design of the <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel</link> implies that these terms have the same meaning; microkernel is the modern terminology.</p>

<sec>
<st>
Introduction</st>
<p>

Early operating system kernels were rather small, partly because computer memory was limited. As the capability of computers grew, the number of devices the kernel had to control also grew. Early versions of <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> had kernels of quite modest size, even though those kernels contained device drivers and file system managers. When address spaces increased from 16 to 32 bits, kernel design was no longer cramped by the hardware architecture, and kernels began to grow.  (See <link xlink:type="simple" xlink:href="../642/31642.xml">
History of Unix</link>).</p>
<p>

Berkeley UNIX (<link xlink:type="simple" xlink:href="../807/1223807.xml">
BSD</link>) began the era of big kernels. In addition to operating a basic system consisting of the CPU, disks and printers, BSD started adding additional <link xlink:type="simple" xlink:href="../280/1010280.xml">
file system</link>s, a complete <link xlink:type="simple" xlink:href="../882/23882.xml">
TCP/IP networking system</link>, and a number of "virtual" devices that allowed the existing programs to work invisibly over the network. This growth continued for several decades, resulting in kernels with millions of lines of <link xlink:type="simple" xlink:href="../661/27661.xml">
source code</link>. As a result of this growth, kernels were more prone to bugs and became increasingly difficult to maintain.</p>
<p>

The microkernel was designed to address the increasing growth of kernels and the difficulties that came with them. In theory, the microkernel design allows for easier management of code due to its division into <link xlink:type="simple" xlink:href="../467/93467.xml">
user-space</link> services. This also allows for increased security and stability resulting from the reduced amount of code running in <link>
kernel mode</link>. </p>
<p>

For example, if a networking service crashed due to <link xlink:type="simple" xlink:href="../373/4373.xml">
buffer overflow</link>, only the networking service's memory would be corrupted, leaving the rest of the system still functional. On a traditional monolithic kernel, the overflow could possibly corrupt the memory of other <link xlink:type="simple" xlink:href="../404/197404.xml">
drivers</link> and possibly the kernel itself, which could crash the entire system.</p>

</sec>
<sec>
<st>
Inter-process communication</st>

<p>

<link xlink:type="simple" xlink:href="../106/152106.xml">
Inter-process communication</link> (IPC) is any mechanism which allows separate processes to communicate with each other, usually by sending <link xlink:type="simple" xlink:href="../367/41367.xml">
messages</link>. (<link xlink:type="simple" xlink:href="../653/825653.xml">
Shared memory</link> is strictly speaking also an inter-process communication mechanism, but the acronym IPC usually only refers to message passing, and it is the latter that is particularly relevant to microkernels.)   This allows the operating system to be built from a number of small programs called servers, which are used by other programs on the system, invoked via IPC.  Most or all support for peripheral  hardware is handled in this fashion, with servers for device drivers, network protocol stacks, file systems, graphics, etc.</p>
<p>

IPC can be synchronous or asynchronous. Asynchronous IPC is analogous to network communication: the sender dispatches a message and continues executing. The receiver checks (polls) for the availability of the message by attempting a receive, or is alerted to it via some notification mechanism. Asynchronous IPC requires that the kernel maintains buffers and queues for messages, and deals with buffer overflows; it also requires double copying of messages (sender to kernel and kernel to receiver). In synchronous IPC, the first party (sender or receiver) blocks until the other party is ready to perform the IPC. It does not require buffering or multiple copies, but the implicit rendezvous can make programming tricky. Most programmers prefer asynchronous send and synchronous receive.</p>
<p>

First-generation microkernels typically supported synchronous as well as asynchronous IPC, and suffered from poor IPC performance. <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
 identified design and implementation of the IPC mechanisms as the underlying reason for this poor performance. In his <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel</link> he pioneered techniques that lead to an order-of-magnitude reduction of IPC costs.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> These include an IPC system call that supports a send as well as a receive operation, making all IPC synchronous, and passing as much data as possible in registers. Furthermore, Liedtke introduced the concept of the <it>direct process switch</it>, where during an IPC execution an (incomplete) <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link> is performed from the sender directly to the receiver. If, as in L4, part or all of the message is passed in registers, this transfers the in-register part of the message without any copying at all. Furthermore, the overhead of invoking the scheduler is avoided; this is especially beneficial in the common case where IPC is used in an <link xlink:type="simple" xlink:href="../346/26346.xml">
RPC</link>-type fashion by a client invoking a server. Another optimization, called <it>lazy scheduling</it>, avoids traversing scheduling queues during IPC by leaving threads that block during IPC in the ready queue. Once the scheduler is invoked, it moves such threads to the appropriate waiting queue. As in many cases a thread gets unblocked before the next scheduler invocation, this approach saves significant work. Similar approaches have since been adopted by <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../184/65184.xml">
QNX</link></O>
 and <link xlink:type="simple" xlink:href="../880/5574880.xml">
Minix 3</link>.</p>
<p>

In a client-server system, most communication is essentially synchronous, even if using asynchronous primitives, as the typical operation is a client invoking a server and then waiting for a reply. As it also lends itself to more efficient implementation, modern microkernels generally follow L4's lead and  only provide a synchronous IPC primitive. Asynchronous IPC can be implemented on top by using helper threads. However, versions of L4 deployed in commercial products have found it necessary to add an asynchronous notification mechanism to better support asynchronous communication. This <link xlink:type="simple" xlink:href="../602/938602.xml">
signal</link>-like mechanism does not carry data and therefore does not require buffering by the kernel.</p>
<p>

As synchronous IPC blocks the first party until the other is ready, unrestricted use could easily lead to deadlocks. Furthermore, a client could easily mount a <link xlink:type="simple" xlink:href="../776/39776.xml">
denial-of-service</link> attack on a server by sending a request and never attempting to receive the reply. Therefore synchronous IPC must provide a means to prevent indefinite blocking. Many microkernels provide <link xlink:type="simple" xlink:href="../639/1657639.xml">
timeouts</link> on IPC calls, which limit the blocking time. In practice, choosing sensible timeout values is difficult, and systems almost inevitably use infinite timeouts for clients and zero timeouts for servers. As a consequence, the trend is towards not providing arbitrary timeouts, but only a flag which indicates that the IPC should fail immediately if the partner is not ready. This approach effectively provides a choice of the two timeout values of zero and infinity. Recent versions of L4 and MInix have gone down this path (older versions of L4 used timeouts, as does QNX).</p>

</sec>
<sec>
<st>
Servers</st>
<p>

Microkernel servers are essentially <link xlink:type="simple" xlink:href="../986/458986.xml">
daemon</link> programs like any others, except that the kernel grants some of them privileges to interact with parts of physical memory that are otherwise off limits to most programs. This allows some servers, particularly device drivers, to interact directly with hardware.</p>
<p>

A basic set of servers for a general-purpose microkernel includes file system servers, device driver servers, networking servers, display servers, and user interface device servers.  This set of servers (drawn from <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../184/65184.xml">
QNX</link></O>
) provides roughly the set of services offered by a monolithic UNIX kernel. The necessary servers are started at system startup and provide services, such as file, network, and device access, to ordinary application programs. With such servers running in the environment of a user application, server development is similar to ordinary application development, rather than the build-and-boot process needed for kernel development.</p>
<p>

Additionally, many "crashes" can be corrected for by simply <link xlink:type="simple" xlink:href="../274/1389274.xml">
stopping and restarting the server</link>. (In a traditional system, a crash in any of the kernel-resident code would result in the entire machine crashing, forcing a reboot.) However, part of the system state is lost with the failing server, hence this approach requires applications to cope with failure. A good example is a server responsible for <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/15476.xml">
TCP/IP</link></rule>
</direction>
</protocol>
</message>
 connections: If this server is restarted, applications will experience a "lost" connection, a normal occurrence in networked system. For other services, failure is less expected and may require changes to application code. For QNX, restart capability is offered as the QNX High Availability Toolkit.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

In order to make all servers restartable, some microkernels have concentrated on adding various <link xlink:type="simple" xlink:href="../377/8377.xml">
database</link>-like techniques like <link xlink:type="simple" xlink:href="../953/233953.xml">
transaction</link>s, <link xlink:type="simple" xlink:href="../905/2722905.xml">
replication</link> and <link xlink:type="simple" xlink:href="../765/416765.xml">
checkpointing</link> in order to preserve essential state across single server restarts. An example is <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../461/1206461.xml">
ChorusOS</link></O>
, which was targeted at high-availability applications in the <link xlink:type="simple" xlink:href="../322/30322.xml">
telecommunication</link>s world. Chorus included features to allow any "properly written" server to be restarted at any time, with clients using those servers being paused while the server brought itself back into its original state. However, such kernel features are incompatible with the minimality principle, and are therefore not provided in modern microkernels, which instead rely on appropriate user-level protocols.</p>

</sec>
<sec>
<st>
Device drivers</st>

<p>

<link xlink:type="simple" xlink:href="../101/9101.xml">
Device driver</link>s frequently perform <link xlink:type="simple" xlink:href="../717/57717.xml">
direct memory access</link> (DMA), and therefore can write to arbitrary locations of physical memory, including over kernel data structures. Such drivers must therefore be trusted. It is a common misconception that this means that they must be part of the kernel. In fact, a driver is not inherently more or less trustworthy by being part of the kernel.</p>
<p>

While running a device driver in user mode does not necessarily reduce the damage a misbehaving driver can cause, in practice it is beneficial for system stability in the presence of buggy (rather than malicious) drivers: memory-access violations by the driver code itself (as opposed to the device) may still be caught by the memory-management hardware. Furthermore, many devices are not DMA-capable, their drivers can be made untrusted by running them in user mode. Recently, an increasing number of computers feature <link xlink:type="simple" xlink:href="../181/5313181.xml">
IOMMU</link>s, many of which can be used to restrict a device's access to physical memory.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> (IBM mainframes have had IO MMUs since the <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/7522024.xml">
IBM System/360 Model 67</link></machine>
</device>
</horizontal_surface>
</instrumentality>
</surface>
</artifact>
</platform>
 and <link xlink:type="simple" xlink:href="../785/59785.xml">
System/370</link>.) This also allows user-mode drivers to become untrusted.</p>
<p>

User-mode drivers actually predate microkernels.  The <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../432/148432.xml">
Michigan Terminal System</link></O>
 (MTS), in 1967, supported user-space drivers, the first operating system to be designed with that capability.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>
Historically, drivers were less of a problem, as the number of devices was small and trusted anyway, so having them in the kernel simplified the design and avoided potential performance problems. This led to the traditional driver-in-the-kernel style of UNIX, Linux, and Windows.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>
With the proliferation of various kinds of peripherals, the amount of driver code escalated and in modern operating systems dominates the kernel in terms of code size.</p>

</sec>
<sec>
<st>
Essential components &amp; minimality</st>

<p>

As a microkernel must allow building arbitrary operating-system services on top, it must provide some core functionality. At the least this includes:
<list>
<entry level="1" type="bullet">

 some mechanisms for dealing with <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link>s — this is required for managing memory protection;</entry>
<entry level="1" type="bullet">

 some execution abstraction to manage CPU allocation — typically <link xlink:type="simple" xlink:href="../303/45303.xml">
threads</link> or <link>
scheduler activation</link>s; and</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> — required to invoke servers running in their own address spaces.</entry>
</list>

This minimal design was pioneered by <link xlink:type="simple" xlink:href="../750/863750.xml">
Brinch Hansen</link>'s <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../452/2005452.xml">
Nucleus</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 and the hypervisor of IBM's <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../018/315018.xml">
VM</link></O>
. It has since been formalised in Liedtke's <it>minimality principle</it>: 
A concept is tolerated inside the microkernel only if moving it outside the kernel, i.e., permitting competing implementations, would prevent the implementation of the system's required functionality.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
Everything else can be done in a user program, although device drivers implemented as user programs may require special privileges to access I/O hardware.</p>
<p>

Related to the minimality principle, and equally important for microkernel design, is the <link xlink:type="simple" xlink:href="../645/12155645.xml">
separation of mechanism and policy</link>, it is what enables the construction of arbitrary systems on top of a minimal kernel. Any policy built into the kernel cannot be overwritten at user level and therefore limits the generality of the microkernel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>
Policy implemented in user-level servers can be changed by replacing the servers (or letting the application choose between competing servers offering similar services).</p>
<p>

For efficiency, most microkernels contain schedulers and manage timers, in violation of the minimality principle and the principle of policy-mechanism separation.</p>
<p>

Start up (<link xlink:type="simple" xlink:href="../909/40909.xml">
booting</link>) of a microkernel-based system requires <link xlink:type="simple" xlink:href="../101/9101.xml">
device drivers</link>, which are not part of the kernel. Typically this means that they are packaged with the kernel in the boot image, and the kernel supports a bootstrap protocol that defines how the drivers are located and started. Some microkernels simplify this by placing some key drivers inside the kernel (in violation of the minimality principle), <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../980/867980.xml">
LynxOS</link></O>
 and the original <link xlink:type="simple" xlink:href="../977/18977.xml">
Minix</link> are examples. Some even include a <link xlink:type="simple" xlink:href="../280/1010280.xml">
file system</link> in the kernel to simplify booting.</p>
<p>

A key component of a microkernel is a good <link xlink:type="simple" xlink:href="../106/152106.xml">
IPC</link> system. Since all services are performed by usermode programs, efficient means of communication between programs are essential, far more so than in monolithic kernels. The design of the IPC system makes or breaks a microkernel. To be effective, the IPC system must not only have low overhead, but also interact well with CPU scheduling.</p>

</sec>
<sec>
<st>
Performance</st>
<p>

Obtaining a service is inherently more expensive in a microkernel-based system than a monolithic system.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> In the monolithic system, the service is obtained by a single system call, which requires two <it>mode switches</it> (changes of the processor's <link xlink:type="simple" xlink:href="../500/5519500.xml">
privilege level</link>). In the microkernel-based system, the service is obtained by sending an IPC message to a server, and obtaining the result in another IPC message from the server. This requires a <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link> if the drivers are implemented as processes, or a function call if they are implemented as procedures. In addition, passing actual data to the server and back may incur extra copying overhead, while in a monolithic system the kernel can directly access the data in the client's buffers.</p>
<p>

Performance is therefore a potential issue in microkernel systems. Indeed, the experience of first-generation microkernels such as <link xlink:type="simple" xlink:href="../028/21028.xml">
Mach</link> and Chorus showed that systems based on them performed very poorly.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref>
However, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
 showed that Mach's performance problems were the result of poor design and implementation, and specifically Mach's excessive <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link> footprint.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
Liedtke demonstrated with his own <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel</link> that through careful design and implementation, and especially by following the minimality principle, IPC costs could be reduced by more than an order of magnitude compared to Mach. L4's IPC performance is still unbeaten across a range of architectures.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>
<p>

While these results demonstrate that the poor performance of systems based on first-generation microkernels is not representative for second-generation kernels such as L4, this constitutes no proof that microkernel-based systems can be built with good performance. It has been shown that a monolithic Linux server ported to L4 exhibits only a few percent overhead over native Linux.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref>
However, such a single-server system exhibits few, if any, of the advantages microkernels are supposed to provide by structuring operating-system functionality into separate servers. </p>
<p>

A number of commercial multi-server systems exist, in particular the <link xlink:type="simple" xlink:href="../123/26123.xml">
real-time systems</link> <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../184/65184.xml">
QNX</link></O>
 and <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../562/1370562.xml">
 Integrity</link></O>
. No comprehensive comparison of performance relative to monolithic systems has been published for those multiserver systems. Furthermore, performance does not seem to be the overriding concern for those commercial systems, which instead emphasize simplicity for the sake of robustness. An attempt to build a high-performance multiserver operating system was the IBM Sawmill Linux project.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref>
However, this project was never completed.</p>
<p>

It has been shown in the meantime that user-level device drivers can come close to the performance of in-kernel drivers even for such high-throughput, high-interrupt devices as Gigabit Ethernet.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref> This seems to imply that high-performance multi-server systems are possible.</p>

</sec>
<sec>
<st>
Security</st>
<p>

The security benefits of microkernels have been frequently discussed.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref> In the context of security the minimality principle of microkernels is a direct consequence of the principle of <link xlink:type="simple" xlink:href="../226/1695226.xml">
least privilege</link>, according to which all code should have only the privileges needed to provide required functionality. Minimality requires that a system's <link xlink:type="simple" xlink:href="../826/41826.xml">
trusted computing base</link> (TCB) should be kept minimal. As the kernel (the code that executes in the privileged mode of the hardware) is always part of the TCB, minimizing it is natural in a security-driven design.</p>
<p>

Consequently, microkernel designs have been used for systems designed for high-security applications, including <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../009/1202009.xml">
KeyKOS</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
, <link xlink:type="simple" xlink:href="../077/353077.xml">
EROS</link> and military systems. In fact <link xlink:type="simple" xlink:href="../625/57625.xml">
common criteria</link> (CC) at the highest assurance level (EAL7) has an explicit requirement that the target of evaluation be “simple”, an acknowledgment of the practical impossibility of establishing true trustworthiness for a complex system.</p>
<p>

Recent work on microkernels is focusing on formal specifications of the kernel API, and formal proofs of security properties of the API. The first example of this is a mathematical proof of the confinement mechanisms in EROS, based on a simplified model of the EROS API.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref> More recently, a comprehensive set of machine-checked proofs has been performed of the properties of the protection model of the seL4 version of L4.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref> </p>
<p>

Some projects go even further, aiming at complete formal verification, i.e. a mathematical proof that the kernel's implementation is consistent with its specification, which then provides a guarantee that the properties proved about the API actually hold for the real kernel. This degree of assurance goes beyond even CC EAL7. Such proofs are being attempted for <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../689/3654689.xml">
Coyotos</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 and <weblink xlink:type="simple" xlink:href="http://ertos.org/research/l4.verified">
seL4</weblink>.</p>

</sec>
<sec>
<st>
 Nanokernel </st>
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the term <b>nanokernel</b> or <b>picokernel</b> historically referred to:
<list>
<entry level="1" type="number">

 A kernel where the total amount of kernel code, i.e. code executing in the privileged mode of the hardware, is very small. The term <b>picokernel</b> was sometimes used to further emphasize small size. The term <b>nanokernel</b> was coined by <link>
Jonathan S. Shapiro</link> in the paper <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/135535.html">
<it>The KeyKOS NanoKernel Architecture''</it></weblink>. It was a sardonic response to Mach, which claimed to be a microkernel while being monolithic, essentially unstructured, and <it>slower</it> than the systems it sought to replace. Subsequent reuse of and response to the term, including the picokernel coinage, suggest that the point was largely missed. Both <b>nanokernel</b> and <b>picokernel</b> have subsequently come to have the same meaning expressed by the term <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link>.</entry>
<entry level="1" type="number">

 A virtualization layer underneath an operating system; this is more correctly referred to as a <link xlink:type="simple" xlink:href="../216/1267216.xml">
hypervisor</link>.</entry>
<entry level="1" type="number">

 A <link xlink:type="simple" xlink:href="../511/425511.xml">
hardware abstraction layer</link> that forms the lowest-level part of a kernel, sometimes used to provide <link xlink:type="simple" xlink:href="../767/25767.xml">
real-time</link> functionality to normal OS's, like <link xlink:type="simple" xlink:href="../015/604015.xml">
Adeos</link>.</entry>
</list>
</p>
<p>

There is also at least one case where the term nanokernel is used to refer not to a small kernel, but one that supports a nanosecond clock resolution. <weblink xlink:type="simple" xlink:href="http://www.eecis.udel.edu/~mills/database/papers/nano/nano2.pdf">
http://www.eecis.udel.edu/~mills/database/papers/nano/nano2.pdf</weblink></p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../394/50394.xml">
Kernel (computer science)</link></entry>
<entry level="2" type="bullet">

<plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../757/95757.xml">
Exokernel</link></kernel>
</natural_object>
</plant_part>
, a research kernel architecture with a more minimalist approach to kernel technology.</entry>
<entry level="2" type="bullet">

<plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/4345041.xml">
Hybrid kernel</link></kernel>
</natural_object>
</plant_part>
</entry>
<entry level="2" type="bullet">

<link xlink:type="simple" xlink:href="../825/20825.xml">
Monolithic kernel</link></entry>
<entry level="2" type="bullet">

<link xlink:type="simple" xlink:href="../658/371658.xml">
Modular kernel</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../826/41826.xml">
Trusted computing base</link></activity>
</procedure>
</psychological_feature>
</act>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 Notes </st>

<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Liedtke, Jochen</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
&#32;(December 1993). "<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=168619.168633&amp;coll=portal&amp;dl=ACM&amp;type=series&amp;idx=168619&amp;part=Proceedings&amp;WantType=Proceedings&amp;title=ACM%20Symposium%20on%20Operating%20Systems%20Principles&amp;CFID=18793560&amp;CFTOKEN=54028606">
Improving IPC by kernel design</weblink>".&#32;<it>14th ACM Symposium on Operating System Principles</it>: 175&ndash;88.</cite>&nbsp;</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.qnx.com/download/download/8107/QNX_High_Availability_Toolkit.pdf">
QNX High Availability Toolkit</weblink></entry>
<entry id="3">
 <cite style="font-style:normal">Wong, William&#32;(April 27, 2007).&#32;"<weblink xlink:type="simple" xlink:href="http://www.elecdesign.com/Articles/Index.cfm?AD=1&amp;ArticleID=15350">
I/O, I/O, It's Off to Virtual Work We Go</weblink>". <it>Electronic Design</it>.</cite>&nbsp;</entry>
<entry id="4">
 <cite style="font-style:normal">Alexander, M.T.&#32;(1972).&#32;"Organization and Features of the Michigan Terminal System". <it>AFIPS Conference Proceedings, 1972 Spring Joint Computer Conference</it>&#32;<b>40</b>: 589.</cite>&nbsp;</entry>
<entry id="5">
 <cite style="font-style:normal" class="book">Lions, John&#32;(August 1, 1977). <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../279/38279.xml">
Lions' Commentary on UNIX 6th Edition, with Source Code</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
.&#32;Peer-To-Peer Communications. 1573980137.</cite>&nbsp;</entry>
<entry id="6">
Previously cited</entry>
<entry id="7">
Previously cited</entry>
<entry id="8">
 <cite style="font-style:normal">Chen, Bradley;&#32;Bershad, Brian&#32;(December 1993). "The Impact of Operating System Structure on Memory System Performance".&#32;<it>14th ACM Symposium on Operating System Principles</it>: 120&ndash;33.</cite>&nbsp;</entry>
<entry id="9">
 <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Liedtke, Jochen</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
;&#32;Elphinstone, Kevin; Schönberg, Sebastian; Härtig, Hermann; <person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../382/10400382.xml">
Heiser, Gernot</link></person>
; Islam, Nayeem; Jaeger, Trent&#32;(May 1997). "<weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/xpl/RecentCon.jsp?punumber=4643">
Achieved IPC performance (still the foundation for extensibility)</weblink>".&#32;<it>6th Workshop on Hot Topics in Operating Systems</it>: 28&ndash;31, Cape Cod, MA, USA:&#32;IEEE.</cite>&nbsp;</entry>
<entry id="10">
 <cite style="font-style:normal">Gray, Charles;&#32;Chapman, Matthew; Chubb, Peter; Mosberger-Tang, David; <person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../382/10400382.xml">
Heiser, Gernot</link></person>
&#32;(April 2005). "<weblink xlink:type="simple" xlink:href="http://www.usenix.org/publications/library/proceedings/usenix05/tech/general/gray.html">
Itanium&mdash;a system implementor's tale</weblink>".&#32;<it>USENIX Annual Technical Conference</it>: 264&ndash;278.</cite>&nbsp;</entry>
<entry id="11">
 <cite style="font-style:normal">van Schaik, Carl;&#32;<person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../382/10400382.xml">
Heiser, Gernot</link></person>
&#32;(January 2007). "<weblink xlink:type="simple" xlink:href="http://ertos.nicta.com.au/publications">
High-performance microkernels and virtualisation on ARM and segmented architectures</weblink>".&#32;<it>1st International Workshop on Microkernels for Embedded Systems</it>: 11&ndash;21, Sydney, Australia:&#32;NICTA. Retrieved on <link>
2007-04-01</link>.</cite>&nbsp;</entry>
<entry id="12">
 <cite style="font-style:normal">Härtig, Hermann; Hohmuth, Michael; <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Liedtke, Jochen</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
; Schönberg, Sebastian&#32;(October 1997).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=266660&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
The performance of μ-kernel-based systems</weblink>". <it>Proceedings of the sixteenth ACM symposium on Operating systems principles</it>: 66&ndash;77. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F268998.266660">
10.1145/268998.266660</weblink>. ISBN 0-89791-916-5.</cite>&nbsp;</entry>
<entry id="13">
 <cite style="font-style:normal">Gefflaut, Alain;&#32;Jaeger, Trent; Park, Yoonho; <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Liedtke, Jochen</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
; Elphinstone, Kevin J.; Uhlig, Volkmar; Tidswell, Jonathon E.; Deller, Luke; Reuther, Lars&#32;(2000). "The Sawmill multiserver approach".&#32;<it>9th ACM SIGOPS European Worshop</it>: 109&ndash;114.</cite>&nbsp;</entry>
<entry id="14">
 <cite style="font-style:normal">Leslie, Ben; Chubb, Peter; FitzRoy-Dale, Nicholas; Götz, Stefan; Gray, Charles; Macpherson, Luke; Potts, Daniel; Shen, Yueting; Elphinstone, Kevin; <person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../382/10400382.xml">
Heiser, Gernot</link></person>
&#32;(September 2005).&#32;"User-level device drivers: achieved performance". <it>Journal of Computer Science and Technology</it>&#32;<b>5</b>&#32;(20): 654&ndash;664. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2Fs11390-005-0654-4">
10.1007/s11390-005-0654-4</weblink>.</cite>&nbsp;</entry>
<entry id="15">
<person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Tanenbaum, Andrew S.</link></professor>
</person>
, <weblink xlink:type="simple" xlink:href="http://www.cs.vu.nl/~ast/reliable-os/">
Tanenbaum-Torvalds debate, part II</weblink></entry>
<entry id="17">
 <cite style="font-style:normal"><link>
Shapiro, Jonathan S.</link>;&#32;Weber, Samuel. "<weblink xlink:type="simple" xlink:href="http://www.eros-os.org/papers/oakland2000.ps">
Verifying the EROS Confinement Mechanism</weblink>".&#32;<it>IEEE Conference on Security and Privacy</it>.</cite>&nbsp;</entry>
<entry id="16">
Tanenbaum, A., Herder, J. and Bos, H. (May 2006). </entry>
<entry id="18">
 <cite id="CITEREFElkaduweKleinElphinstone2007" style="font-style:normal">Elkaduwe, Dhammika; Klein, Gerwin&#32;&amp;&#32;Elphinstone, Kevin&#32;(2007),&#32;<it><weblink xlink:type="simple" xlink:href="http://ertos.org/publications/papers/Elkaduwe_GE_07.abstract">
Verified Protection Model of the seL4 Microkernel</weblink></it>, submitted for publication, </cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://citeseer.csail.mit.edu/cs?q=microkernel">
scientific articles about microkernels</weblink> (on <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<facility wordnetid="103315023" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<depository wordnetid="103177349" confidence="0.8">
<archive wordnetid="102735086" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../949/158949.xml">
CiteSeer</link></machine>
</archive>
</depository>
</device>
</motor>
</engine>
</facility>
</instrumentality>
</artifact>
), including:</entry>
<entry level="2" type="bullet">

  <cite style="font-style:normal">Dan Hildebrand&#32;(1992).&#32;"An Architectural Overview of QNX". <it>Proceedings of the Workshop on Micro-kernels and Other Kernel Architectures</it>: 113–126. ISBN 1-880446-42-1.</cite>&nbsp; - the basic QNX reference.</entry>
<entry level="2" type="bullet">

  <cite style="font-style:normal">Tanenbaum, A., Herder, J. and Bos, H.&#32;(May 2006).&#32;"<weblink xlink:type="simple" xlink:href="http://www.computer.org/portal/site/computer/menuitem.eb7d70008ce52e4b0ef1bd108bcd45f3/index.jsp?&amp;pName=computer_level1&amp;path=computer/homepage/0506&amp;file=cover1.xml&amp;xsl=article.xsl">
Can We Make Operating Systems Reliable and Secure?</weblink>". <it>Computer</it>: 44–51.</cite>&nbsp; -the basic reliable reference. </entry>
<entry level="2" type="bullet">

  <cite style="font-style:normal">Black, D.L., Golub, D.B., Julin, D.P., Rashid, R.F., Draves, R.P., Dean, R.W., Forin, A., Barrera, J., Tokuda, H., Malan, G., and Bohman, D.&#32;(March 1992).&#32;"Microkernel Operating System Architecture and Mach". <it>J. of Information Processing</it>&#32;<b>14(4)</b>.</cite>&nbsp; - the basic Mach reference.</entry>
<entry level="2" type="bullet">

  <cite style="font-style:normal">Heiser, Gernot; Uhlig, Volkmar and LeVasseur, Joshua&#32;(January 2006).&#32;"<weblink xlink:type="simple" xlink:href="http://l4ka.org/publications/2006/p95-heiser.pdf">
Are Virtual-Machine Monitors Microkernels Done Right?</weblink>"&#32;(PDF). <it>ACM SIGOPS Operating Systems Review</it>&#32;<b>40</b>&#32;(1): 95–99.&#32;ACM. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F1113361.1113363">
10.1145/1113361.1113363</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://c2.com/cgi/wiki?MicroKernel">
MicroKernel page</weblink> from the <computer wordnetid="103082979" confidence="0.8">
<structure wordnetid="105726345" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../042/452042.xml">
Portland Pattern Repository</link></web_site>
</machine>
</device>
</form>
</instrumentality>
</artifact>
</structure>
</computer>
</entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../911/5087911.xml">
Tanenbaum-Torvalds debate</link></entry>
<entry level="2" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.oreilly.com/catalog/opensources/book/appa.html">
The Tanenbaum-Torvalds Debate, 1992.01.29</weblink></entry>
<entry level="2" type="bullet">

 Tanenbaum, A. S. "<weblink xlink:type="simple" xlink:href="http://www.computer.org/portal/site/computer/menuitem.5d61c1d591162e4b0ef1bd108bcd45f3/index.jsp?&amp;pName=computer_level1_article&amp;TheCat=1005&amp;path=computer/homepage/0506&amp;file=cover1.xml&amp;xsl=article.xsl&amp;">
Can We Make Operating Systems Reliable and Secure?</weblink>".</entry>
<entry level="2" type="bullet">

 Torvalds, L. <weblink xlink:type="simple" xlink:href="http://www.realworldtech.com/forums/index.cfm?action=detail&amp;id=66630&amp;threadid=66595&amp;roomid=11">
Linus Torvalds about the microkernels again, 2006.05.09</weblink></entry>
<entry level="2" type="bullet">

 Shapiro, J. "<weblink xlink:type="simple" xlink:href="http://www.coyotos.org/docs/misc/linus-rebuttal.html">
Debunking Linus's Latest</weblink>".</entry>
<entry level="2" type="bullet">

 Tanenbaum, A. S. "<weblink xlink:type="simple" xlink:href="http://www.cs.vu.nl/~ast/reliable-os/">
Tanenbaum-Torvalds Debate: Part II</weblink>".</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../194/22194.xml">
Operating system</link></header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
General</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../395/55395.xml">
History</link>&nbsp;·  <record wordnetid="106647206" confidence="0.8">
<chronology wordnetid="106503224" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<timeline wordnetid="106504965" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../968/247968.xml">
Timeline</link></written_record>
</timeline>
</evidence>
</indication>
</chronology>
</record>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/229119.xml">
Developement</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../531/981531.xml">
List</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../394/50394.xml">
Kernel</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
General</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../023/20023.xml">
Microkernel</link>&nbsp;·  <link xlink:type="simple" xlink:href="../023/20023.xml#xpointer(//*[./st=%22Nanokernel%22])">
Nanokernel</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Types</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../825/20825.xml">
monolithic</link>&nbsp;·  <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/4345041.xml">
hybrid</link></kernel>
</natural_object>
</plant_part>
&nbsp;·  <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../757/95757.xml">
exokernel</link></kernel>
</natural_object>
</plant_part>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Components</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../467/93467.xml">
Kernel space</link>&nbsp;·  <link xlink:type="simple" xlink:href="../658/371658.xml">
Loadable kernel module</link>&nbsp;·  <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>&nbsp;·  <link xlink:type="simple" xlink:href="../467/93467.xml">
User space</link>&nbsp;·  <link xlink:type="simple" xlink:href="../109/555109.xml">
Userland</link></col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../806/15395806.xml">
Process management</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../178/45178.xml">
Process</link>&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Multiprogramming</link>&nbsp;·  <link xlink:type="simple" xlink:href="../289/15289.xml">
Interrupt</link>&nbsp;·  Modes: (<link xlink:type="simple" xlink:href="../596/167596.xml">
Protected mode</link>&nbsp;·  <link>
Supervisor mode</link>)&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Computer multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../920/231920.xml">
Scheduling</link>&nbsp;·  <link xlink:type="simple" xlink:href="../904/6904.xml">
Context switch</link>&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Cooperative multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../566/2204566.xml">
Preemptive multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../954/3991954.xml">
CPU modes</link>&nbsp;·  <link xlink:type="simple" xlink:href="../303/45303.xml">
Thread (computer science)</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Memory management</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../373/515373.xml">
Memory protection</link>&nbsp;·  <link xlink:type="simple" xlink:href="../131/1323131.xml">
Segmentation</link>&nbsp;·  <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link>&nbsp;·  <link xlink:type="simple" xlink:href="../112/177112.xml">
Memory management unit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../803/28803.xml">
Segmentation fault</link>&nbsp;·  <link xlink:type="simple" xlink:href="../943/573943.xml">
General protection fault</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Examples</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../304/18933304.xml">
AmigaOS</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../801/4801.xml">
BeOS</link>&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../409/22409.xml">
IBM OS/2</link></O>
&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../027/20027.xml">
MS-DOS</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../890/18890.xml">
Windows</link>&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link>&nbsp;·  <link xlink:type="simple" xlink:href="../658/1178658.xml">
OpenSolaris</link>&nbsp;·  <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>&nbsp;·   <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../889/360889.xml">
ReactOS</link></O>
&nbsp;·  <it><link xlink:type="simple" xlink:href="../916/71916.xml">
more…</link>''</it></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Miscellaneous concepts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../679/6885679.xml">
Boot loader</link>&nbsp;·  <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../253/432253.xml">
PXE</link></system_of_measurement>
</standard>
&nbsp;·  <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/351131.xml">
Virtual file system</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../071/2550071.xml">
Virtual tape library</link>&nbsp;·  <link xlink:type="simple" xlink:href="../592/4122592.xml">
Computer network</link>&nbsp;·  <link xlink:type="simple" xlink:href="../293/12293.xml">
GUI</link>&nbsp;·  <link xlink:type="simple" xlink:href="../511/425511.xml">
HAL</link></col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</entity>
</article>
