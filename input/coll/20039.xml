<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:30:54[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<kind  confidence="0.9511911446218017" wordnetid="105839024">
<algorithm  confidence="0.9508927676800064" wordnetid="105847438">
<header>
<title>Merge sort</title>
<id>20039</id>
<revision>
<id>244421487</id>
<timestamp>2008-10-10T18:49:31Z</timestamp>
<contributor>
<username>Cic</username>
<id>1968383</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Stable sorts</category>
<category>Comparison sorts</category>
<category>Sorting algorithms</category>
<category>Online sorts</category>
<category>Articles with unsourced quotes</category>
</categories>
</header>
<bdy>
<template>
<name>Infobox Algorithm</name>
<parameters>

<image location="none" width="300px" src="Merge_sort_animation2.gif">
<caption>

Example of merge sort sorting a list of random dots.
</caption>
</image>
Example of merge sort sorting a list of random dots.<time>
<it>О(n</it> log <it>n)''</it></time>
<data>
<link xlink:type="simple" xlink:href="../052/2052.xml">
Array</link></data>
<class>
<link xlink:type="simple" xlink:href="../442/28442.xml">
Sorting algorithm</link></class>
<optimal>
Sometimes</optimal>
<space>
<it>О(n)''</it></space>
</parameters>
</template>


In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>merge sort</b> or <b>mergesort</b> is an <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link></it>(<it>n</it> log <it>n</it>) <link xlink:type="simple" xlink:href="../304/3189304.xml">
comparison-based</link> <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>. In most implementations it is <link xlink:type="simple" xlink:href="../442/28442.xml#xpointer(//*[./st=%22Classification%22])">
stable</link>, meaning that it preserves the input order of equal elements in the sorted output. It is an example of the <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer</link> algorithmic paradigm. It was invented by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../942/15942.xml">
John von Neumann</link></scientist>
</person>
 in 1945.
<sec>
<st>
Algorithm</st>
<p>

Conceptually, a merge sort works as follows:
<list>
<entry level="1" type="number">

If the list is of length 0 or 1, then it is already sorted. Otherwise:</entry>
<entry level="1" type="number">

Divide the unsorted list into two sublists of about half the size.</entry>
<entry level="1" type="number">

Sort each sublist <link xlink:type="simple" xlink:href="../407/25407.xml">
recursively</link> by re-applying merge sort.</entry>
<entry level="1" type="number">

<link xlink:type="simple" xlink:href="../362/20362.xml">
Merge</link> the two sublists back into one sorted list.</entry>
</list>
</p>
<p>

Merge sort incorporates two main ideas to improve its runtime: 
<list>
<entry level="1" type="number">

A small list will take fewer steps to sort than a large list.</entry>
<entry level="1" type="number">

Fewer steps are required to construct a sorted list from two sorted lists than two unsorted lists.  For example, you only have to traverse each list once if they're already sorted (see the <link xlink:type="simple" xlink:href="../362/20362.xml">
merge</link> function below for an example implementation).</entry>
</list>
</p>
<p>

Example: Using merge sort to sort a list of integers contained in an <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>:</p>
<p>

Suppose we have an array <it>A</it> with <it>n</it> indices ranging from <math>A_0</math> to <math>A_n</math>.
We apply merge sort to <math>A(A_0..A_{c-1})</math> and <math>A(A_c..A_n)</math> where <it>c</it> is the integer part of <math>n/2</math>.
When the two halves are returned they will have been sorted.
They can now be merged together to form a sorted array.</p>
<p>

In a simple <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link> form, the algorithm could look something like this:</p>
<p>

<b>function</b> merge_sort(m)
<b>var</b> <it>list</it> left, right, result
<b>if</b> length(m) ≤ 1
<b>return</b> m</p>
<p>

<b>var</b> middle = length(m) / 2
<b>for each</b> x <b>in</b> m <b>up to</b> middle
add x to left
<b>for each</b> x <b>in</b> m <b>after</b> middle
add x to right
left = merge_sort(left)
right = merge_sort(right)
result = merge(left, right)
<b>return</b> result</p>
<p>

There are several variants for the merge() function, the simplest variant could look like this:</p>
<p>

<b>function</b> merge(left,right)
<b>var</b> <it>list</it> result
<b>while</b> length(left) &amp;gt; 0 <b>and</b> length(right) &amp;gt; 0
<b>if</b> first(left) ≤ first(right)
append first(left) to result
left = rest(left)
<b>else</b>
append first(right) to result
right = rest(right)
<b>end while</b>
<b>while</b> length(left) &amp;gt; 0 
append left to result
<b>while</b> length(right) &amp;gt; 0 
append right to result
<b>return</b> result</p>

</sec>
<sec>
<st>
Analysis</st>
<p>

<image location="right" width="300px" src="merge_sort_algorithm_diagram.svg" type="thumb">
<caption>

A recursive merge sort algorithm used to sort an array of 7 integer values.  These are the steps a human would take to emulate merge sort (top-down).
</caption>
</image>
</p>
<p>

In sorting <it>n</it> items, merge sort has an <link xlink:type="simple" xlink:href="../956/37956.xml">
average</link> and <link xlink:type="simple" xlink:href="../956/37956.xml">
worst-case performance</link> of <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>&nbsp;log&nbsp;<it>n</it>). If the running time of merge sort for a list of length <it>n</it> is <it>T</it>(<it>n</it>), then the recurrence <it>T</it>(<it>n</it>) = 2<it>T</it>(<it>n</it>/2) + <it>n</it> follows from the definition of the algorithm (apply the algorithm to two lists of half the size of the original list, and add the <it>n</it> steps taken to merge the resulting two lists). The closed form follows from the <link xlink:type="simple" xlink:href="../585/561585.xml">
master theorem</link>. </p>
<p>

In the worst case, merge sort does approximately (<it>n</it>&nbsp;⌈<link xlink:type="simple" xlink:href="../992/249992.xml">
lg</link>&nbsp;<it>n</it>⌉ - 2⌈lg&nbsp;<it>n</it>⌉ + 1) comparisons, which is between (<it>n</it>&nbsp;lg&nbsp;<it>n</it> - <it>n</it> + 1) and (<it>n</it>&nbsp;lg&nbsp;<it>n</it> + <it>n</it> + O(lg <it>n</it>)). <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

For large <it>n</it> and a randomly ordered input list,  merge sort's expected (average) number of comparisons approaches <it>α</it>·<it>n</it> fewer than the worst case where <math>\alpha = -1 + \sum_{k=0}^\infty \frac1{2^k+1} \approx 0.2645.</math></p>
<p>

In the <it>worst</it> case, merge sort does about 39% fewer comparisons than <link xlink:type="simple" xlink:href="../249/3268249.xml">
quicksort</link> does in the <it>average</it> case; merge sort always makes fewer comparisons than quicksort, except in extremely rare cases, when they tie, where merge sort's <it>worst</it> case is found  simultaneously with quicksort's <it>best</it> case.  In terms of moves, merge sort's worst case complexity is <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>&nbsp;log&nbsp;<it>n</it>)—the same complexity as quicksort's best case, and merge sort's best case takes about half as many iterations as the worst case.</p>
<p>

Recursive implementations of merge sort make 2<it>n</it>&nbsp;-&nbsp;1 method calls in the worst case, compared to quicksort's <it>n</it>, thus has roughly twice as much recursive overhead as quicksort. However, iterative, non-recursive, implementations of merge sort, avoiding method call overhead, are not difficult to code. Merge sort's most common implementation does not sort in place; therefore, the memory size of the input must be allocated for the sorted output to be stored in.</p>
<p>

Sorting in-place is possible but is very complicated, and will offer little performance gains in practice, even if the algorithm runs in O(<it>n</it>&nbsp;log&nbsp;<it>n</it>) time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> In these cases, algorithms like <link xlink:type="simple" xlink:href="../995/13995.xml">
heapsort</link> usually offer comparable speed, and are far less complex. Additionally, unlike the standard merge sort, in-place merge sort is not a stable sort.</p>
<p>

Merge sort is more efficient than quicksort for some types of lists if the data to be sorted can only be efficiently accessed sequentially, and is thus popular in languages such as <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link>, where sequentially accessed data structures are very common.  Unlike some (efficient) implementations of quicksort, merge sort is a <link>
stable sort</link> as long as the merge operation is implemented properly.</p>
<p>

As can be seen from the procedure merge sort, there are some complaints. One complaint we might raise is its use of 2n locations; the additional n locations were needed because one couldn't reasonably merge two sorted sets in place.  But despite the use of this space the algorithm must still work hard, copying the result placed into Result list back into m list on each call of merge . An alternative to this copying is to associate a new field of information with each key (the elements in m are called keys). This field will be used to link the keys and any associated information together in a sorted list (a key and its related information is called a record). Then the merging of the sorted lists proceeds by changing the link values; no records need to be moved at all. A field which contains only a link will generally be smaller than an entire record so less space will also be used.</p>

</sec>
<sec>
<st>
Merge sorting tape drives</st>
<p>

Merge sort is so inherently sequential that it's practical to run it using slow tape drives as input and output devices. It requires very little memory, and the memory required does not change with the number of data elements. </p>
<p>

For the same reason it is also useful for sorting data on <link xlink:type="simple" xlink:href="../472/Species_8472.xml">
disk</link> that is too large to fit entirely into <link>
primary memory</link>. On tape drives that can run both backwards and forwards, merge passes can be run in both directions, avoiding rewind time.</p>
<p>

If you have four tape drives, it works as follows:</p>
<p>

<list>
<entry level="1" type="number">

 Divide the data to be sorted in half and put half on each of two tapes</entry>
<entry level="1" type="number">

 Merge individual pairs of records from the two tapes; write two-record chunks alternately to each of the two output tapes</entry>
<entry level="1" type="number">

 Merge the two-record chunks from the two output tapes into four-record chunks; write these alternately to the original two input tapes</entry>
<entry level="1" type="number">

 Merge the four-record chunks into eight-record chunks; write these alternately to the original two output tapes</entry>
<entry level="1" type="number">

 Repeat until you have one chunk containing all the data, sorted --- that is, for log <it>n</it> passes, where <it>n</it> is the number of records.</entry>
</list>
</p>

<p>

For almost-sorted data on tape, a bottom-up "natural merge sort" variant of this algorithm is popular.</p>
<p>

The bottom-up "natural merge sort" merges whatever "chunks" of in-order records are already in the data.
In the worst case (reversed data), "natural merge sort" performs the same as the above -- it merges individual records into 2-record chunks, then 2-record chunks into 4-record chunks, etc.
In the best case (already mostly-sorted data), "natural merge sort" merges large already-sorted chunks into even larger chunks, hopefully finishing in fewer than log <it>n</it> passes.</p>
<p>

In a simple <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link> form, the "natural merge sort" algorithm could look something like this:</p>
<p>

<list>
<entry level="1" type="number">

 Original data is on the input tape; the other tapes are blank</entry>
</list>

<b>function</b> merge_sort(input_tape, output_tape, scratch_tape_C, scratch_tape_D)
<b>while</b> any records remain on the input_tape
<b>while</b> any records remain on the input_tape
merge( input_tape, output_tape, scratch_tape_C)
merge( input_tape, output_tape, scratch_tape_D)
<b>while</b> any records remain on C or D
merge( scratch_tape_C, scratch_tape_D, output_tape)
merge( scratch_tape_C, scratch_tape_D, input_tape)</p>
<p>

<list>
<entry level="1" type="number">

 take the next sorted chunk from the input tapes, and merge into the single given output_tape.</entry>
<entry level="1" type="number">

 tapes are scanned linearly.</entry>
<entry level="1" type="number">

 tape[next] gives the record currently under the read head of that tape.</entry>
<entry level="1" type="number">

 tape[current] gives the record previously under the read head of that tape.</entry>
<entry level="1" type="number">

 (Generally both tape[current] and tape[previous] are buffered in RAM ...)</entry>
</list>

<b>function</b> merge(left, right, output_tape)
<b>do</b>
<b>if</b> left[current] ≤ right[current]
append left[current] to output_tape
read next record from left tape
<b>else</b>
append right[current] to output_tape
read next record from right tape
<b>while</b> left[current]  left[next] <b>and</b> right[current]  right[next]
<b>if</b> left[current]  left[next]
append current_left_record to output_tape
<b>if</b> right[current]  right[next]
append current_right_record to output_tape
<b>return</b></p>
<p>

Either form of merge sort can be generalized to any number of tapes.</p>

</sec>
<sec>
<st>
Optimizing merge sort</st>
<p>

On modern computers, <link xlink:type="simple" xlink:href="../028/64028.xml">
locality of reference</link> can be of paramount importance in <link xlink:type="simple" xlink:href="../779/225779.xml">
software optimization</link>, because multi-level <link xlink:type="simple" xlink:href="../146/137146.xml">
memory hierarchies</link> are used. <link xlink:type="simple" xlink:href="../829/6829.xml">
Cache</link>-aware versions of the merge sort algorithm, whose operations have been specifically chosen to minimize the movement of pages in and out of a machine's memory cache, have been proposed. For example, the <b>tiled merge sort</b> algorithm stops partitioning subarrays when subarrays of size S are reached, where S is the number of data items fitting into a single page in memory. Each of these subarrays is sorted with an in-place sorting algorithm, to discourage memory swaps, and normal merge sort is then completed in the standard recursive fashion. This algorithm has demonstrated better performance on machines that benefit from cache optimization. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

M.A. Kronrod suggested in 1969 an alternative version of merge sort that used constant additional space.&#91;&#93;</p>

</sec>
<sec>
<st>
Comparison with other sort algorithms</st>
<p>

Although <link xlink:type="simple" xlink:href="../995/13995.xml">
heapsort</link> has the same time bounds as merge sort, it requires only  Θ(1) auxiliary space instead of merge sort's Θ(n), and is often faster in practical implementations. <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../249/3268249.xml">
Quicksort</link></algorithm>
, however, is considered by many to be the fastest general-purpose sort algorithm. On the plus side, merge sort is a stable sort, parallelizes better, and is more efficient at handling slow-to-access sequential media. Merge sort is often the best choice for sorting a <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link>: in this situation it is relatively easy to implement a merge sort in such a way that it requires only Θ(1) extra space, and the slow random-access performance of a linked list makes some other algorithms (such as quicksort) perform poorly, and others (such as heapsort) completely impossible.</p>
<p>

As of <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 5.8, merge sort is its default sorting algorithm (it was quicksort in previous versions of Perl). In <link>
Java</link>, the <weblink xlink:type="simple" xlink:href="http://java.sun.com/j2se/latest/docs/api/java/util/Arrays.html">
Arrays.sort()</weblink> methods use merge sort or a tuned quicksort depending on the datatypes<weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Arrays.html">
http://java.sun.com/javase/6/docs/api/java/util/Arrays.html</weblink> and for implementation efficiency switch when fewer than seven array elements are being sorted.[https://openjdk.dev.java.net/source/browse/openjdk/jdk/trunk/jdk/src/share/classes/java/util/Arrays.java?view=markup]</p>

</sec>
<sec>
<st>
Utility in online sorting</st>
<p>

Merge sort's merge operation is useful in online sorting, where the list to be sorted is received a piece at a time, instead of all at the beginning (see <link xlink:type="simple" xlink:href="../716/22716.xml">
online algorithm</link>). In this application, we sort each new piece that is received using any sorting algorithm, and then merge it into our sorted list so far using the merge operation. However, this approach can be expensive in time and space if the received pieces are small compared to the sorted list &mdash; a better approach in this case is to store the list in a <link xlink:type="simple" xlink:href="../310/378310.xml">
self-balancing binary search tree</link> and add elements to it as they are received.</p>

</sec>
<sec>
<st>
References</st>

<ss1>
<st>
Citations and notes</st>
<p>

<reflist>
<entry id="1">
The worst case number given here does not agree with that given in <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Knuth</link></scientist>
</person>
's <it><link xlink:type="simple" xlink:href="../358/31358.xml">
Art of Computer Programming</link>, Vol 3</it>. The discrepancy is due to Knuth analyzing a variant implementation of merge sort that is slightly sub-optimal</entry>
<entry id="2">
 Jyrki Katajainen. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/katajainen96practical.html">
Practical In-Place Mergesort</weblink>. Nordic Journal of Computing. 1996.</entry>
<entry id="3">
A. LaMarca and R. E. Ladner, ``The influence of caches on the performance of sorting," Proc. 8th Ann. ACM-SIAM Symp. on Discrete Algorithms (SODA97), 1997, 370-379.</entry>
</reflist>
</p>

</ss1>
<ss1>
<st>
General</st>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Knuth, Donald</link></scientist>
</person>
&#32;(1998).&#32;"Section 5.2.4: Sorting by Merging", <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
.&#32;Addison-Wesley,&#32;158-168. ISBN 0-201-89685-0.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Cormen-2001" style="font-style:normal" class="book"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Cormen, Thomas H.</link></scientist>
;&#32;<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Leiserson, Charles E.</link></scientist>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../057/68057.xml">
Rivest, Ronald L.</link></scientist>
</person>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Stein, Clifford</link></scientist>
&#32;[1990]&#32;(2001).&#32;"2.3: Designing algorithms", <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, 2nd edition,&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../601/719601.xml">
MIT Press</link></company>
 and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../269/651269.xml">
McGraw-Hill</link></company>
,&#32;pp. 27–37. ISBN 0-262-03293-7.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 Sun Microsystems, Inc..&#32;"<weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Arrays.html">
Arrays API</weblink>".&#32;Retrieved on <link>
2007-11-19</link>.</entry>
<entry level="1" type="bullet">

 Sun Microsystems, Inc..&#32;"[https://openjdk.dev.java.net/source/browse/openjdk/jdk/trunk/jdk/src/share/classes/java/util/Arrays.java?view=markup java.util.Arrays.java]".&#32;Retrieved on <link>
2007-11-19</link>.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
External links</st>


<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://tide4javascript.com/?s=Merge">
Analyze Merge Sort in an online Javascript IDE</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.atkinson.yorku.ca/~sychen/research/sorting/sortingHome.html">
Merge sort applet</weblink> with <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../584/597584.xml">
level order</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 recursive calls to help improve algorithm analysis</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/mergesort.html">
Dictionary of Algorithms and Data Structures: Merge sort</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://en.literateprograms.org/Category:Merge_sort">
Literate implementations of merge sort in various languages</weblink> on LiteratePrograms</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.algorithmist.com/index.php/Merge_sort">
Implementation for C++</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://coderaptors.com/?MergeSort">
A colored graphical Java applet</weblink> which allows experimentation with initial state and shows statistics</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="3" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../442/28442.xml">
Sorting algorithm</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
Theory</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../543/7543.xml">
Computational complexity theory</link> | <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link> | <link xlink:type="simple" xlink:href="../330/30330.xml">
Total order</link> | <link xlink:type="simple" xlink:href="../382/208382.xml">
Lists</link> | <link xlink:type="simple" xlink:href="../442/28442.xml#xpointer(//*[./st=%22Stability%22])">
Stability</link> | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../304/3189304.xml">
Comparison sort</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
</col>
<col style="width:0%;padding:0px 0px 0px 2px;" rowspan="15">
<image width="200px" src="SimpleSortingNetwork.svg">
</image>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Exchange sorts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../255/4255.xml">
Bubble sort</link></algorithm>
 | <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../482/159482.xml">
Cocktail sort</link></algorithm>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../945/10807945.xml">
Odd-even sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../439/159439.xml">
Comb sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../127/522127.xml">
Gnome sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../249/3268249.xml">
Quicksort</link></algorithm>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Selection sorts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../352/29352.xml">
Selection sort</link></algorithm>
 | <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../995/13995.xml">
Heapsort</link></algorithm>
 | <link xlink:type="simple" xlink:href="../450/100450.xml">
Smoothsort</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Insertion sorts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../205/15205.xml">
Insertion sort</link></algorithm>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../355/77355.xml">
Shell sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../027/6508027.xml">
Tree sort</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../633/2448633.xml">
Library sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/1184256.xml">
Patience sorting</link></kind>
</psychological_feature>
</game>
</contest>
</social_event>
</event>
</category>
</concept>
</idea>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Merge sorts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../039/20039.xml">
Merge sort</link></algorithm>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/14083351.xml">
Strand sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Non-comparison sorts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../980/25980.xml">
Radix sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../592/97592.xml">
Bucket sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../864/99864.xml">
Counting sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/24681.xml">
Pigeonhole sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../302/11517302.xml">
Burstsort</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Others</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<link xlink:type="simple" xlink:href="../064/897064.xml">
Topological sorting</link></procedure>
</activity>
</psychological_feature>
</wordnet>
</act>
</rule>
</event>
</message>
</algorithm>
</database>
</lexical_database>
</electronic_database>
</information>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../061/562061.xml">
Sorting network</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../090/2713090.xml">
Bitonic sorter</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Ineffective/jokeful sorts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../870/99870.xml">
Bogosort</link></algorithm>
 | <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../662/563662.xml">
Stooge sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
</col>
</row>
</table>
</col>
</row>
</table>
</p>


</sec>
</bdy>
</algorithm>
</kind>
</article>
