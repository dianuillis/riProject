<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:12:15[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<information  confidence="0.8" wordnetid="106634376">
<electronic_database  confidence="0.8" wordnetid="106588511">
<lexical_database  confidence="0.8" wordnetid="106638868">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<wordnet  confidence="0.8" wordnetid="106639428">
<database  confidence="0.8" wordnetid="106637824">
<header>
<title>RC 4000 Multiprogramming System</title>
<id>2005452</id>
<revision>
<id>224385363</id>
<timestamp>2008-07-08T16:54:22Z</timestamp>
<contributor>
<username>Ghettoblaster</username>
<id>6603820</id>
</contributor>
</revision>
<categories>
<category>Operating systems</category>
<category>Microkernels</category>
</categories>
</header>
<bdy>

The <b>RC 4000 Multiprogramming System</b> was an <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> developed for the <link>
RC 4000</link> <link xlink:type="simple" xlink:href="../272/20272.xml">
minicomputer</link> in 1969. It is historically notable for being the first attempt to break down an operating system into a group of interacting programs communicating via a message passing kernel. Although RC 4000 itself was not very successful it was nevertheless extremely influential, sparking the <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link> concept that dominated operating system research through the 1970s and 80s. The system is also known as <b>Monitor</b> and, somewhat confusingly, simply <b>RC 4000</b> depending on the reference. For clarity, this article will use the term Monitor.<p>

Monitor was created largely by one programmer, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Per Brinch Hansen</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
, who worked at <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../254/519254.xml">
Regnecentralen</link></institution>
</company>
 where the RC 4000 was being designed. Leif Svalgaard participated in the implementation and testing of Monitor. Brinch Hansen found that no existing operating system was suited to the new machine, and was tired of having to adapt existing systems. He felt that a better solution was to build an underlying kernel, which he referred to as the <it>nucleus</it>, that could be used to build up an operating system from interacting programs. <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
, for instance, uses small interacting programs for many tasks, transferring data through a system known as <it>pipes</it>. However a large amount of fundamental code is buried in the kernel itself, notably things like file systems and program control. Monitor would remove this code as well, making almost the entire system a set of interacting programs, reducing the kernel (nucleus) to a communications and support system only.</p>
<p>

Monitor used a pipe-like system of shared memory as the basis of its <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link>s. Data to be sent from one process to another was copied into an empty memory buffer, and when the receiving program was ready, back out again. The buffer was then returned to the pool. Programs had a very simple <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link> for passing data, using an <link xlink:type="simple" xlink:href="../011/163011.xml">
asynchronous</link> set of four methods. Client applications send data with send message and could optionally block using wait answer. Servers used a mirroring set of calls, wait message and send answer. Note that messages had an implicit "return path" for every message sent, making the semantics more like a <link xlink:type="simple" xlink:href="../346/26346.xml">
remote procedure call</link> than <link xlink:type="simple" xlink:href="../028/21028.xml">
Mach</link>'s completely I/O-based system.</p>
<p>

Monitor divided the application space in two; <it>internal processes</it> were traditional programs, started on request, while <it>external programs</it> were effectively device drivers. External processes were actually handled outside of user space by the nucleus, although they could be started and stopped just like any other program. Internal programs were started in the context of the "parent" that launched them, so each user could effectively build up their own operating system by starting and stopping programs in their own context.</p>
<p>

<link xlink:type="simple" xlink:href="../851/4941851.xml">
Scheduling</link> was left entirely to the programs, if required at all (in the 1960's, <link xlink:type="simple" xlink:href="../857/6857.xml">
multitasking</link> was a debatable feature). One user could start up a session in a <link xlink:type="simple" xlink:href="../566/2204566.xml">
pre-emptive multitasking</link> environment, while another might start in a single-user mode to run <link xlink:type="simple" xlink:href="../285/37285.xml">
batch processing</link> at higher speed. <link xlink:type="simple" xlink:href="../767/25767.xml">
Real-time</link> scheduling could be supported by sending messages to a timer process that would only return at the appropriate time.</p>
<p>

Monitor proved to have truly terrible performance. Much of this was due to the cost of IPC, a problem that has since plagued most microkernels. Under Monitor data was copied twice for every message, and memory handling on the RC 4000 was not particularly fast. Another area of serious concern was launching and killing programs to handle requests, which happened all the time.</p>
<p>

These two areas have seen the vast majority of development since Monitor's release, driving newer designs to use hardware to support messaging, and supporting threads within applications to reduce launch times. For instance, Mach required a <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link> to improve messaging by using the <link xlink:type="simple" xlink:href="../603/407603.xml">
copy-on-write</link> protocol and mapping (instead of copying) data from process to process. Mach also used threading extensively, allowing the external programs, or <it>servers</it> in more modern terms, to easily start up new handlers for incoming requests. Still, Mach IPC was too slow to make the microkernel approach practically useful. This only changed when Liedtke <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel</link> demonstrated an order-of-magnitude improvement in IPC overheads.</p>

<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<record wordnetid="106647206" confidence="0.8">
<chronology wordnetid="106503224" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<timeline wordnetid="106504965" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../968/247968.xml">
Timeline of operating systems</link></written_record>
</timeline>
</evidence>
</indication>
</chronology>
</record>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal">Brinch Hansen, Per&#32;(1970).&#32;"<weblink xlink:type="simple" xlink:href="http://www.brinch-hansen.net/papers/1970a.pdf">
The Nucleus of a Multiprogramming Operating System</weblink>". <it>Communications of the ACM</it>&#32;<b>13</b>: 238--250.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://brinch-hansen.net/papers/1969a.pdf">
RC 4000 SOFTWARE: MULTIPROGRAMMING SYSTEM</weblink></entry>
</list>
</p>

</sec>
</bdy>
</database>
</wordnet>
</entity>
</lexical_database>
</electronic_database>
</information>
</message>
</article>
