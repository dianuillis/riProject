<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:09:50[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Low (complexity)</title>
<id>2006468</id>
<revision>
<id>243245394</id>
<timestamp>2008-10-05T19:43:14Z</timestamp>
<contributor>
<username>Vorash</username>
<id>161317</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, it is said that a <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link> <it>B</it> is <b>low</b> for a complexity class <it>A</it> if <it>AB</it> = <it>A</it>; that is, <it>A</it> with an <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle</link> for <it>B</it> is equal to <it>A</it>. Such a statement implies that an <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link> which solves problems in <it>A</it> achieves no additional power if it is given the ability to solve problems in <it>B</it> instantly. Notice this means lowness implies containment. Informally, lowness means that problems in <it>B</it> are not only solvable by machines which can solve problem in <it>A</it>, but are "easy to solve". An <it>A</it> machine can simulate many oracle queries to <it>B</it> without exceeding its resource bounds. Containment does not always imply lowness -- an <it>A</it> machine with access to an oracle for an <it>A</it> machine can solve any problem in <it>coA</it> by passing the query to the oracle and then negating the result. Thus, any class which is low for itself must be closed under complement.<p>

Results and relationships that establish one class is low for another are often called <b>lowness</b> results.</p>

<sec>
<st>
 Results </st>

<p>

Some trivial lowness results are:
<list>
<entry level="1" type="bullet">

 <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
 is low for itself (because polynomial algorithms are closed under composition)</entry>
<entry level="1" type="bullet">

 <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../999/1149999.xml">
L</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
 is low for itself (because it can simulate log space oracle queries in log space, reusing the same space for each query)</entry>
<entry level="1" type="bullet">

 Every class which is low for itself is closed under <link xlink:type="simple" xlink:href="../955/1929955.xml">
complement</link>. This is because it can solve a complement problem by simply querying itself and then inverting the answer. This implies that <b>NP</b> isn't low for itself unless <b>NP</b> = co-<b>NP</b>, which is considered unlikely.</entry>
</list>
</p>
<p>

Some of the more complex and famous results regarding lowness of classes include:
<list>
<entry level="1" type="bullet">

 Both <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../422/2120422.xml">
Parity P</link></group>
</collection>
</class>
 (<math>{\oplus}\hbox{P}</math>) and <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
 are low for themselves. These were important in showing <link xlink:type="simple" xlink:href="../091/18125091.xml">
Toda's theorem</link>. <weblink xlink:type="simple" xlink:href="http://www.cs.rutgers.edu/~allender/538/murata3.ps.gz">
http://www.cs.rutgers.edu/~allender/538/murata3.ps.gz</weblink></entry>
<entry level="1" type="bullet">

 <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../080/4080.xml">
BQP</link></group>
</collection>
</class>
 is low for <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../322/659322.xml">
PP</link></group>
</collection>
</class>
. <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%221%22])">
1</link> In other words, a <link xlink:type="simple" xlink:href="../383/495383.xml">
randomized algorithm</link> that can be run an unbounded number of times can easily solve all the problems that a <link xlink:type="simple" xlink:href="../220/25220.xml">
quantum computer</link> can solve efficiently.</entry>
<entry level="1" type="bullet">

 The <link>
graph isomorphism problem</link> is low for <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../422/2120422.xml">
Parity P</link></group>
</collection>
</class>
 (<math>{\oplus}\hbox{P}</math>).<link xlink:type="simple" xlink:href="#xpointer(//*[./st=%222%22])">
2</link> This means that if we can determine whether an <b>NP</b> machine has an even or odd number of accepting paths, we can easily solve graph isomorphism. In fact, it was later shown that graph isomorphism is low for <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../772/54772.xml">
ZPP</link></group>
</collection>
</class>
NP</b>, showing that an efficient <link xlink:type="simple" xlink:href="../519/537519.xml">
Las Vegas algorithm</link> with access to an <b>NP</b> oracle can easily solve graph isomorphism as well. <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%224%22])">
4</link></entry>
<entry level="1" type="bullet">

 <link>
Amplified PP</link> is low for <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../322/659322.xml">
PP</link></group>
</collection>
</class>
.<link xlink:type="simple" xlink:href="#xpointer(//*[./st=%223%22])">
3</link></entry>
</list>
</p>
<p>

Lowness is particularly valuable in relativization arguments, where it can be used to establish that the power of a class does not change in the "relativized universe" where a particular oracle machine is available for free. This allows us to reason about it in the same manner we normally would. For example, in the relativized universe of <b>BQP</b>, <b>PP</b> is still closed under union and intersection. It's also useful when seeking to expand the power of a machine with oracles, because lowness results determine when the machine's power remains the same.</p>

</sec>
<sec>
<st>
 References </st>
<p>

1. L. Fortnow and J. D. Rogers. <weblink xlink:type="simple" xlink:href="http://xxx.lanl.gov/abs/cs.CC/9811023">
Complexity limitations on quantum computation</weblink>. In <it>Proceedings of IEEE Complexity '98</it>, p.202-209. 1998.</p>
<p>

2. V. Arvind and P. Kurur. Graph isomorphism is in SPP. <weblink xlink:type="simple" xlink:href="http://eccc.hpi-web.de/eccc/">
<it>Electronic Colloquium on Computational Complexity''</it></weblink>, <weblink xlink:type="simple" xlink:href="http://eccc.hpi-web.de/eccc-reports/2002/TR02-037/index.html">
TR02-037</weblink>. 2002.</p>
<p>

3. L. Li. On the Counting Functions. PhD thesis, University of Chicago. 1993.</p>
<p>

4. Vikraman Arvind and Johannes KÃ¶bler. Graph Isomorphism Is Low for ZPP(NP) and Other Lowness Results. <it>Proceedings of the 17th Annual Symposium on Theoretical Aspects of Computer Science</it>, ISBN 3-540-67141-2, p.431-442. 2000.</p>

</sec>
</bdy>
</article>
