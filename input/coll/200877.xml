<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:30:45[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<graph  confidence="0.9511911446218017" wordnetid="107000195">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Maze generation algorithm</title>
<id>200877</id>
<revision>
<id>233304923</id>
<timestamp>2008-08-21T11:43:57Z</timestamp>
<contributor>
<username>Mr2001</username>
<id>105757</id>
</contributor>
</revision>
<categories>
<category>Mazes</category>
<category>Algorithms</category>
<category>Random graphs</category>
</categories>
</header>
<bdy>
<p>

There are a number of different <b>maze generation <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s</b>, that is, automated methods for the creation of <link xlink:type="simple" xlink:href="../161/20161.xml">
maze</link>s.</p>
<p>

<image location="right" width="150px" src="maze.png" type="frame">
<caption>

This maze generated by modified version of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, below. Click the Maze for <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 <link xlink:type="simple" xlink:href="../661/27661.xml">
source code</link>.
</caption>
</image>
</p>

<sec>
<st>
 Theory </st>

<p>

A maze is basically a graph which presents a traversal challenge between two points.  If the graph is not <link xlink:type="simple" xlink:href="../492/1614492.xml">
connected</link>, then there are regions of the graph that are wasted because they do not contribute to the search space.  If the graph contains loops, then there may be multiple paths between the chosen paths.  Because of this, maze generation is often approached as generating a random <link xlink:type="simple" xlink:href="../770/455770.xml">
spanning tree</link> on a connected graph.  Loops which can confound naive maze solvers may be introduced by adding random edges to the result during the course of the algorithm.</p>
<p>

Common algorithms are based on search or <link xlink:type="simple" xlink:href="../795/41795.xml">
minimal spanning tree</link> algorithms for connected graphs, with edge weights chosen randomly.  Because mazes are often approached from a different paradigm to traditional graph theory, different nomenclature is commonly used: graph edges not included in the resultant spanning tree are called "walls"; edges in the spanning tree are called "passages"; and vertices are typically called "cells" or "rooms".  Although maze algorithms are often presented in the context of rectangular or hexagonal arrays, typically they perform equally well on any <link xlink:type="simple" xlink:href="../492/1614492.xml">
connected graph</link>.</p>

</sec>
<sec>
<st>
 Depth-first search </st>
<p>

This algorithm is a randomized version of the <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link> algorithm.</p>
<p>

<list>
<entry level="1" type="number">

 Start at a particular cell and call it the "exit."</entry>
<entry level="1" type="number">

 Mark the current cell as visited, and get a list of its neighbors.  For each neighbor, starting with a randomly selected neighbor:</entry>
<entry level="2" type="number">

 If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then <link xlink:type="simple" xlink:href="../407/25407.xml">
recurse</link> with that neighbor as the current cell.</entry>
</list>
</p>
<p>

If your computer architecture has a small stack and cannot effectively use recursion, you can store the backtracking information in the maze itself;
this also provides a quick way to display a solution, by starting at any given point and backtracking to the exit.</p>
<p>

Mazes generated with a depth-first search have a low branching factor and contain many long corridors, which makes depth-first a good algorithm for generating mazes in <link xlink:type="simple" xlink:href="../363/5363.xml">
video game</link>s.</p>
<p>

In mazes generated by that algorithm, it will typically be relatively easy to find the way to the square that was first picked at the beginning of the algorithm, since most paths lead to or from there, but hard to find the way out.</p>

<ss1>
<st>
 Recursive backtracker </st>

<p>

The depth-first search algorithm of maze generation is frequently implemented using <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link>:</p>
<p>

<list>
<entry level="1" type="number">

 Mark the current cell as 'Visited'</entry>
<entry level="1" type="number">

 If the current cell has any neighbours which have not been visited </entry>
<entry level="2" type="number">

  Choose randomly one of the unvisited neighbours</entry>
<entry level="2" type="number">

  add the current cell to the stack</entry>
<entry level="2" type="number">

  remove the wall between the current cell and the chosen cell</entry>
<entry level="2" type="number">

  Make the chosen cell the current cell</entry>
<entry level="2" type="number">

  Recursively call this function</entry>
<entry level="1" type="number">

 else</entry>
<entry level="2" type="number">

  remove the last current cell from the stack</entry>
<entry level="2" type="number">

  Backtrack to the previous execution of this function</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 Randomized Kruskal's algorithm </st>
<p>

This algorithm is simply a randomized version of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>
<p>

<list>
<entry level="1" type="number">

 Create a list of all walls, and create a set for each cell, each containing just that one cell.</entry>
<entry level="1" type="number">

 For each wall, in some random order:</entry>
<entry level="2" type="number">

 If the cells divided by this wall belong to distinct sets:</entry>
<entry level="3" type="number">

 Remove the current wall.</entry>
<entry level="3" type="number">

 Join the sets of the formerly divided cells.</entry>
</list>
</p>
<p>

There are several data structures that can be used to model the sets of cells.  An efficient implementation using a <link xlink:type="simple" xlink:href="../551/1037551.xml">
disjoint-set data structure</link> can perform each union and find operation on two sets in nearly-constant <link xlink:type="simple" xlink:href="../683/236683.xml">
amortized time</link> (specifically, <math>O(\alpha(V))</math> time; <math>\alpha(x) &amp;lt; 5</math> for any plausible value of <math>x</math>), so the running time of this algorithm is essentially proportional to the number of walls available to the maze.</p>
<p>

It matters little whether the list of walls is initially randomized or if a wall is randomly chosen from a nonrandom list, either way is just as easy to code.</p>
<p>

Because the effect of this algorithm is to produce a minimal spanning tree from a graph with equally-weighted edges, it tends to produce regular patterns which are fairly easy to solve.</p>

</sec>
<sec>
<st>
 Randomized Prim's algorithm </st>
<p>

This algorithm is a randomized version of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.  </p>
<p>

<list>
<entry level="1" type="number">

 Start with a grid full of walls.</entry>
<entry level="1" type="number">

 Pick a cell, mark it as part of the maze. Add the walls of the cell to the wall list.</entry>
<entry level="1" type="number">

 While there are walls in the list:</entry>
<entry level="2" type="number">

 Pick a random wall from the list. If the cell on the opposite side isn't in the maze yet:</entry>
<entry level="3" type="number">

 Make the wall a passage and mark the cell on the opposite side as part of the maze.</entry>
<entry level="3" type="number">

 Add the neighboring walls of the cell to the wall list.</entry>
</list>
</p>
<p>

Like the depth-first algorithm, it will usually be relatively easy to find the way to the starting cell, but hard to find the way anywhere else.</p>
<p>

Note that simply running classical Prim's on a graph with random weights would create mazes stylistically identical to Kruskal's, because they are both minimal spanning tree algorithms.  Instead, this algorithm introduces stylistic variation because the edges closer to the starting point have a lower effective weight.</p>

<ss1>
<st>
 Modified version </st>
<p>

Although the classical Prim's algorithm keeps a list of edges, for maze generation we could instead maintain a list of adjacent cells.  If the randomly chosen cell has multiple edges that connect it to the existing maze, select one of these edges at random.  This will tend to branch slightly more than the edge-based version above.</p>

</ss1>
</sec>
<sec>
<st>
 Small-memory algorithm </st>
<p>

Other algorithms exist that require only enough memory to store one line of a 2D maze or one plane of a 3D maze; they work by storing which cells in the current line are connected through cells in the previous lines. This algorithm never removes a wall between any two cells already connected.</p>

</sec>
<sec>
<st>
 Simple algorithms </st>
<p>

Most maze generation algorithms require maintaining relationships between cells within it, to ensure the end result will be solvable. Valid simply connected mazes can however be generated by focusing on each cell independently. A binary tree maze is a standard orthogonal maze where each cell always has a passage leading up or leading left, but never both. To create a binary tree maze, for each cell flip a coin to decide whether to add a passage leading up or left. Always pick the same direction for cells on the boundary, and the end result will be a valid simply connected maze that looks like a <link xlink:type="simple" xlink:href="../321/4321.xml">
binary tree</link>, with the upper left corner its root.</p>
<p>

A related form of flipping a coin for each cell is to create an image using a random mix of forward slash and backslash characters. This doesn't generate a valid simply connected maze, but rather a selection of closed loops and unicursal passages. The maze generator at <weblink xlink:type="simple" xlink:href="http://www.edepot.com/algorithm.html">
edepot's algorithms</weblink>, authored by Po-Han Lin in just 5 lines of code, implements this where the maze generated is tilted at an angle because of the slashes.</p>
<p>

<table align="right" class="wikitable">
<caption>
<b>Illustration of Recursive Division</b></caption>
<row>
<header width="110px">
<it>original chamber''</it></header>
<header width="110px">
<it>division by two walls''</it></header>
<header width="110px">
<it>holes in walls''</it></header>
<header width="110px">
<it>continue subdividing...''</it></header>
<header width="110px">
<it>completed''</it></header>
</row>
<row>
<col align="center">
 <image width="101px" src="Chamber.png">
</image>
</col>
<col align="center">
 <image width="101px" src="Chamber_division.png">
</image>
</col>
<col align="center">
 <image width="101px" src="Chamber_divided.png">
</image>
</col>
<col align="center">
 <image width="101px" src="Chamber_subdivision.png">
</image>
</col>
<col align="center">
 <image width="101px" src="Chamber_finished.png">
</image>
</col>
</row>
</table>
</p>
<p>

Another simple algorithm for rectangular mazes, <it>recursive division</it>, works as follows. Begin with a rectangular space with no walls. Call this a chamber. Build at random points two walls that are perpendicular to each other. These two walls divide the large chamber into four smaller chambers separated by four walls. Choose three of the four walls at random, and open a one cell-wide hole at a random point in each of the three. Continuing in this manner recursively, until every chamber has a width of one cell in either of the two directions, one can easily generate interesting mazes that avoid the ease of solution of binary tree mazes.</p>

</sec>
<sec>
<st>
 Non-cell-based algorithm </st>
<p>

A maze can also be generated without the use of cells. In year 2000, a shareware called AmorphousMaze, appeared on the Internet that creates mazes with walls placed at totally random angles. <weblink xlink:type="simple" xlink:href="http://www.puz.com/sw/amorphous/theory/amz1.jpg">
Sample picture</weblink>. The algorithm is based on extending the wall by a small segment at a time without crossing over a pre-existing one. <weblink xlink:type="simple" xlink:href="http://www.puz.com/sw/amorphous/theory/index.htm">
Algorithm detail</weblink>. The disadvantage of this algorithm is that the number of tests for intersection is <math>O(E^2)</math>, where <math>E</math> is the number of line segments being drawn.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../167/3259167.xml">
cut-the-knot</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.astrolog.org/labyrnth/algrithm.htm#perfect">
Think Labyrinth: Maze algorithms</weblink> (details on these and other maze generation algorithms)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://homepages.cwi.nl/~tromp/maze.html">
Explanation of an Obfuscated C maze algorithm</weblink> (a program to generate mazes line-by-line, obfuscated in a single physical line of code)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mazeworks.com/mazegen/">
Maze generation and solving Java applet</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://chiesaclan.spaces.live.com/blog/cns!842434EBE9688900!632.entry">
Maze generator and solver, in C#</weblink> - print out mazes in various shapes on paper.</entry>
</list>
</p>


</sec>
</bdy>
</entity>
</graph>
</article>
