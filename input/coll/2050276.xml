<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:12:00[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Fetch-and-add</title>
<id>2050276</id>
<revision>
<id>243698087</id>
<timestamp>2008-10-07T17:49:00Z</timestamp>
<contributor>
<username>Emheryok</username>
<id>1375705</id>
</contributor>
</revision>
<categories>
<category>Concurrency control</category>
<category>Computer arithmetic</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>fetch-and-add</b> <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> instruction is a special instruction that <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic</link>ally modifies the contents of a memory location. It is used to implement <link xlink:type="simple" xlink:href="../827/36827.xml">
Mutual exclusion</link> and concurrent algorithms in multiprocessor systems.<p>

In <link xlink:type="simple" xlink:href="../718/2782718.xml">
uniprocessor</link> systems, it is sufficient to disable <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>s before accessing a <link xlink:type="simple" xlink:href="../195/363195.xml">
critical region</link>.
However, in multiprocessor systems, it is impossible and undesirable to disable <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>s on all processors at the same time; and even with interrupts disabled two or more processors could be attempting to access the same memory at the same time. The fetch-and-add instruction allows any processor to atomically increment a value in memory location, preventing such multiple processor collisions.</p>
<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../089/9169089.xml">
Maurice Herlihy</link></associate>
</recipient>
</scientist>
</acquirer>
</causal_agent>
</colleague>
</laureate>
</honoree>
</person>
</peer>
</physical_entity>
 (1993) proved that fetch-and-add is inferior to <link xlink:type="simple" xlink:href="../224/632224.xml">
compare-and-swap</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.</p>

<sec>
<st>
Implementation</st>
<p>

The standard fetch and add -instruction behaves like the following function. Crucially the entire function is executed <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomically</link>: no process can interrupt the function mid-execution and hence see a state that only exists during the execution of the function. This code only serves to help explain the behaviour of fetch-and-add; atomicity requires explicit hardware support and hence can not be implemented as a simple high level function.</p>
<p>

atomic &amp;gt;&amp;gt;
<b>function</b> FetchAndAdd(<it>address</it> location) {
<it>int</it> value := *location
<list>
<entry level="1" type="bullet">

location := value + 1</entry>
</list>

<b>return</b> value
}</p>
<p>

With fetch-and-add primitive a mutual exclusion lock can be implemented as:</p>
<p>

<b>record</b> locktype {
<it>int</it> ticketnumber
<it>int</it> turn
}
<b>procedure</b> LockInit( <it>locktype</it>* lock ) {
lock.ticketnumber := 0
lock.turn  := 0
}
<b>procedure</b> Lock( <it>locktype</it>* lock ) {
<it>int</it> myturn := FetchAndAdd( &amp;lock.ticketnumber )
<b>while</b> lock.turn ≠ myturn 
<b>skip</b> // <it>spin until lock is acquired</it>
}
<b>procedure</b> UnLock( <it>locktype</it>* lock) {
FetchAndAdd( &amp;lock.turn )
}</p>
<p>

These routines provide a mutual-exclusion lock when following conditions are met:
<list>
<entry level="1" type="bullet">

Locktype data structure is initialized with function LockInit before use</entry>
<entry level="1" type="bullet">

Number of tasks waiting for the lock does not exceed INT_MAX at any time</entry>
<entry level="1" type="bullet">

Integer datatype used in lock values can 'wrap around' when continuously incremented</entry>
</list>
</p>

</sec>
<sec>
<st>
x86 implementation</st>
<p>

In the x86 architecture, the instruction ADD with the first operand specifying a memory location is a fetch-and-add instruction that has been there since the 8086 (it just wasn't called that then), and with the LOCK prefix, is atomic across multiple processors. However, it could not return the original value of the memory location (though it returned some flags) until the 486 introduced the XADD instruction.</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Herlihy, Maurice&#32;(January, 1991).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cs.brown.edu/~mph/Herlihy91/p124-herlihy.pdf">
Wait-free synchronization</weblink>". <it>ACM Trans. Program. Lang. Syst.</it>&#32;<b>13</b>&#32;(1): 124–149. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F114005.102808">
10.1145/114005.102808</weblink>. Retrieved on <link>
2007-05-20</link>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../099/394099.xml">
Test-and-set</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../574/2084574.xml">
Test and Test-and-set</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../224/632224.xml">
Compare-and-swap</link></entry>
<entry level="1" type="bullet">

<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/2882985.xml">
Load-Link/Store-Conditional</link></concept>
</idea>
</entry>
</list>
</p>




</sec>
</bdy>
</article>
