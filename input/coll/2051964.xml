<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:21:04[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<shell  confidence="0.8" wordnetid="104190464">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<ammunition  confidence="0.8" wordnetid="102703275">
<weaponry  confidence="0.8" wordnetid="104566257">
<header>
<title>Read-eval-print loop</title>
<id>2051964</id>
<revision>
<id>240597189</id>
<timestamp>2008-09-24T02:50:11Z</timestamp>
<contributor>
<username>CALR</username>
<id>80866</id>
</contributor>
</revision>
<categories>
<category>Lisp programming language</category>
<category>Command shells</category>
</categories>
</header>
<bdy>

A <b>read-eval-print loop (REPL)</b>, also known as an <b>interactive toplevel</b>, is a simple, interactive <link xlink:type="simple" xlink:href="../311/5311.xml">
computer programming</link> environment. The term is most usually used to refer to a <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link> interactive environment, but can be applied to <link xlink:type="simple" xlink:href="../707/6707.xml">
command line</link> <link xlink:type="simple" xlink:href="../397/2281397.xml">
shells</link> and similar environments for <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/28319.xml">
Smalltalk</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
, <link xlink:type="simple" xlink:href="../451/1451.xml">
APL</link>, <link xlink:type="simple" xlink:href="../015/4015.xml">
BASIC</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../227/73227.xml">
J</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
, <link xlink:type="simple" xlink:href="../912/612912.xml">
TCL</link>, and other languages as well.<p>

In a REPL, the user may enter expressions, which are then evaluated, and the results displayed. The name <it>read-eval-print loop</it> comes from the names of the Lisp primitive functions which implement this functionality:</p>
<p>

<indent level="1">

The <b>read</b> function accepts a single expression from the user, and <link xlink:type="simple" xlink:href="../015/310015.xml">
parses</link> it into a data structure in memory. For instance, the user may enter the <link xlink:type="simple" xlink:href="../458/54458.xml">
s-expression</link> (+ 1 2 3), which is parsed into a <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link> containing four data elements.
</indent>
:The <b><link xlink:type="simple" xlink:href="../831/623831.xml">
eval</link></b> function takes this internal data structure and evaluates it. In Lisp, evaluating an s-expression beginning with the name of a function means calling that function on the arguments that make up the rest of the expression. So the function + is called on the arguments 1 2 3, yielding the result 6.
<indent level="1">

The <b>print</b> function takes the result yielded by <it>eval</it>, and prints it out to the user. If it is a complex expression, it may be <link>
 pretty-printed</link> to make it easier to understand. In this example, though, the number 6 does not need much formatting to print.
</indent>

The REPL is commonly misnamed an <it><link xlink:type="simple" xlink:href="../868/59868.xml">
interpreter</link></it>. This is an erroneous usage, since many programming languages that use <link xlink:type="simple" xlink:href="../739/5739.xml">
compilation</link> (including <link xlink:type="simple" xlink:href="../997/89997.xml">
bytecode</link> compilation) have REPLs, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../068/6068.xml">
Common Lisp</link></programming_language>
 and Python.</p>
<p>

Because the <it>print</it> function outputs in the same textual format that the <it>read</it> function uses for input, most results are printed in a form that could (if it's useful) be copied and pasted back into the REPL. However, it's sometimes necessary to print representations of opaque data elements that can't sensibly be read back in -- such as a socket handle or a complex class instance. In these cases, there must exist a syntax for unreadable objects -- in Python, it's the __module__.class instance&amp;gt; notation; in Common Lisp, the # form. The REPL of <link xlink:type="simple" xlink:href="../245/5137245.xml">
CLIM</link> and the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<company wordnetid="108058098" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<digital_computer wordnetid="103196324" confidence="0.8">
<workstation wordnetid="104603399" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../195/28195.xml">
Symbolics</link></institution>
</workstation>
</digital_computer>
</machine>
</device>
</company>
</instrumentality>
</artifact>
</computer>
 <link xlink:type="simple" xlink:href="../123/18123.xml">
Lisp Machine</link> can also read back unreadable objects. They record for each output which object was printed. Later when the code is read back, the object will be retrieved from the printed output.</p>

<ss1>
<st>
Advantages</st>

<p>

A REPL can become an essential part of learning a new language as it gives quick feedback to the novice. Many tool-suites as well as programming languages use a REPL to allow algorithm exploration and <link xlink:type="simple" xlink:href="../395/323395.xml">
debug</link>, such as <link xlink:type="simple" xlink:href="../412/20412.xml">
Matlab</link>, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../472/263472.xml">
SciPy</link></software>
 and <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../015/11322015.xml">
IPython</link></software>
. The <link xlink:type="simple" xlink:href="../737/3415737.xml">
doctest</link> module of the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 programming language allows tests to be easily generated from the captured output of its REPL command line shell.</p>

</ss1>
<ss1>
<st>
Implementation</st>

<p>

To implement a Lisp REPL, it is necessary only to implement these three functions and an infinite-loop function. (Naturally, the implementation of eval will be complicated, since it must also implement all the primitive functions like <link xlink:type="simple" xlink:href="../195/206195.xml">
car</link> and + and special operators like if.) This done, a basic REPL itself is but a single line of code: (loop (print (eval (read)))).</p>
<p>

One possible implementation of eval is as a recursive interpreter that acts on the syntax tree created by read. Another possibility is to compile the syntax tree into machine code and execute it.</p>

</ss1>
<sec>
<st>
Major language environments and associated REPLs</st>
<p>

<list>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 has a built-in REPL and a more enhanced version in <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../015/11322015.xml">
IPython</link></software>
.</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 does not have a built-in REPL, but has a pure Java implementation in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../435/1565435.xml">
BeanShell</link></programming_language>
. It can also be driven via scripting languages ported to the Java platform like <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../263/390263.xml">
Jython</link></software>
.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
's <link xlink:type="simple" xlink:href="../669/374669.xml">
standard library</link> contains a module called IRB which stands for <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../435/3616435.xml">
Interactive Ruby Shell</link></software>
 which provides a REPL. The standard Ruby distribution packages a standalone utility called <b>irb</b> which simply spawns an IRB instance.</entry>
<entry level="1" type="bullet">

 At least two <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
 implementations provide REPL functionality. The <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/562879.xml">
Glasgow Haskell Compiler</link></software>
 provides <b>ghci</b> and the <link xlink:type="simple" xlink:href="../845/562845.xml">
Hugs</link> interpreter is often used by beginners as a Haskell REPL.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/24131.xml">
PHP</link></writer>
</language>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
 does not have a built-in REPL, but has the third-party <weblink xlink:type="simple" xlink:href="http://www.phpsh.org/">
phpsh</weblink>.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../225/20225.xml">
Mozilla</link>'s internal JavaScript engine can be interactively manipulated through <weblink xlink:type="simple" xlink:href="http://hyperstruct.net/projects/mozrepl">
MozRepl</weblink>.</entry>
<entry level="1" type="bullet">

<software wordnetid="106566077" confidence="0.9508927676800064">
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../871/14465871.xml">
Windows PowerShell</link></programming_language>
</software>
, part of Microsoft Windows, provides a REPL.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../955/509955.xml">
Scala</link> (a language on the JVM) provides a REPL; start it at the command line by typing "scala" (as opposed to scalac, the compiler).</entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 provides a REPL via the module <weblink xlink:type="simple" xlink:href="http://search.cpan.org/~mstrout/Devel-REPL-1.002001/lib/Devel/REPL.pm">
Devel::REPL</weblink>.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../394/11519394.xml">
F#</link> has a REPL in the form of a command called fsi (F# interactive).</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../412/20412.xml">
Matlab</link>, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../024/49024.xml">
Mathematica</link></software>
 and other <link xlink:type="simple" xlink:href="../427/54427.xml">
computer algebra systems</link> are mainly accessed through REPL which allow for the evaluation of mathematical expressions and invocation of system commands.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 Paul Graham has written a <weblink xlink:type="simple" xlink:href="http://www.paulgraham.com/rootsoflisp.html">
description of a REPL implementation</weblink> in Common Lisp.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://neugierig.org/software/c-repl/">
c-repl</weblink> an REPL for C</entry>
</list>
</p>

</sec>
</bdy>
</weaponry>
</ammunition>
</instrumentality>
</artifact>
</shell>
</article>
