<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:16:20[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Test and Test-and-set</title>
<id>2084574</id>
<revision>
<id>214668016</id>
<timestamp>2008-05-24T18:13:29Z</timestamp>
<contributor>
<username>Zoonfafer</username>
<id>630608</id>
</contributor>
</revision>
<categories>
<category>Concurrency control</category>
<category>Computer arithmetic</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <link xlink:type="simple" xlink:href="../099/394099.xml">
test-and-set</link> CPU <link xlink:type="simple" xlink:href="../801/3149801.xml">
instruction</link> is used to implement 
<link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> in <link xlink:type="simple" xlink:href="../020/64020.xml">
multiprocessor</link> environments. Although a correct <link xlink:type="simple" xlink:href="../593/244593.xml">
lock</link> can be implemented with test-and-set, it can lead to <link>
memory contention</link> in busy lock (caused by bus locking and cache invalidation when test-and-set operation needs to access memory <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomically</link>).<p>

To lower the overhead a more elaborate locking protocol <b>test and test-and-set</b>
is used. The main idea is <it>not</it> to <link xlink:type="simple" xlink:href="../489/671489.xml">
spin</link> in test-and-set but increase the likelihood of successful test-and-set by using following entry protocol to the lock:</p>
<p>

<it>boolean</it> locked := false <it>// shared lock variable</it>
<b>procedure</b> EnterCritical() {
<b>do</b> {
<b>while</b> (locked == true) skip <it>// spin until lock </it><b>seems</b><it> free
} </it>'while<b> TestAndSet(locked) <it>// actual atomic locking</it></b><b>
}</b></p>
<p>

Exit protocol is:
<b>procedure</b> ExitCritical() {
locked := false
}</p>
<p>

The entry protocol uses normal memory reads to spin, waiting for the lock to become free. Test-and-set is only used to try to get the lock when normal memory read says it's free. Thus the expensive atomic memory operations happens less often than in simple spin around test-and-set.</p>
<p>

If the <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> used supports <link xlink:type="simple" xlink:href="../018/704018.xml">
short-circuit evaluation</link>, the entry protocol could be implemented as:</p>
<p>

<b>procedure</b> EnterCritical() {
<b>while</b> ( locked == true or TestAndSet(locked) == true )
<b>skip</b> <it>// spin until locked</it>
}</p>

<sec>
<st>
Caveat</st>
<p>

Although this <link xlink:type="simple" xlink:href="../779/225779.xml">
optimization</link> is useful in <link xlink:type="simple" xlink:href="../264/365264.xml">
system programming</link> it should be avoided in high level <link xlink:type="simple" xlink:href="../605/2581605.xml">
concurrent programming</link>. One example of bad usage of this <link xlink:type="simple" xlink:href="../563/47563.xml">
idiom</link> is <link xlink:type="simple" xlink:href="../874/164874.xml">
double-checked locking</link>, which is listed as an <link xlink:type="simple" xlink:href="../956/233956.xml">
anti-pattern</link>.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../162/145162.xml">
Parallel processor</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../162/145162.xml">
Parallel programming</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../827/36827.xml">
Mutual exclusion</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../099/394099.xml">
Test-and-set</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Gregory R. Andrews, <it>Foundations of Multithreaded, Parallel, and Distributed Programming</it>, pp. 100-101. Addison-Wesley, 2000. ISBN 0-201-35752-6.</entry>
</list>
</p>


</sec>
</bdy>
</article>
