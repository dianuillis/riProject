<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:30:36[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Mach (kernel)</title>
<id>21028</id>
<revision>
<id>242850177</id>
<timestamp>2008-10-03T22:49:24Z</timestamp>
<contributor>
<username>Frogger3140</username>
<id>7272440</id>
</contributor>
</revision>
<categories>
<category>Articles lacking in-text citations</category>
<category>Microkernels</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Text_document_with_red_question_mark.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 This article or section includes a  or , but its sources remain unclear because it has <b>insufficient  .</b>
You can  this article by introducing more precise citations . <it>(October 2008)''</it></col>
</row>
</table>


<b>Mach</b> is an <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link> developed at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../093/48093.xml">
Carnegie Mellon University</link></university>
 to support operating system research, primarily distributed and parallel computation. It is one of the earliest examples of a microkernel, and still the standard by which similar projects are measured.<p>

The project at Carnegie Mellon ran from 1985 to 1994, ending with Mach 3.0. A number of other efforts have continued Mach research, including the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../097/32097.xml">
University of Utah</link></university>
's <weblink xlink:type="simple" xlink:href="http://www.cs.utah.edu/flux/mach4/html/Mach4-proj.html">
Mach 4</weblink>. Mach was developed as a replacement for the kernel in the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../622/18932622.xml">
BSD</link></O>
 version of <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link>, so no new operating system would have to be designed around it. Today further experimental research on Mach appears ended, although Mach and its derivatives are in use in a number of commercial operating systems, such as <link xlink:type="simple" xlink:href="../642/40642.xml">
NEXTSTEP</link> and <link xlink:type="simple" xlink:href="../114/53114.xml">
OPENSTEP</link>, and most notably <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link> (using the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../754/617754.xml">
XNU</link></software>
 kernel).  The Mach virtual memory management system was also adopted by the BSD developers at <link xlink:type="simple" xlink:href="../698/955698.xml">
CSRG</link>, and appears in  modern BSD-derived UNIX systems, such as <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/7580554.xml">
FreeBSD</link></horizontal_surface>
</surface>
</artifact>
</platform>
.  Neither Mac OS X nor FreeBSD maintain the microkernel structure pioneered in Mach, although Mac OS X continues to offer microkernel <link xlink:type="simple" xlink:href="../106/152106.xml">
Inter-Process Communication</link> and control primitives for use directly by applications.</p>
<p>

Mach is the logical successor to Carnegie Mellon's <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/1531415.xml">
Accent kernel</link></kernel>
</natural_object>
</plant_part>
. The lead developer on the Mach project, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../822/2164822.xml">
Richard Rashid</link></employee>
</causal_agent>
</worker>
</person>
</physical_entity>
, has been working at <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../001/19001.xml">
Microsoft</link></company>
 since <link xlink:type="simple" xlink:href="../703/34703.xml">
1991</link> in various top-level positions revolving around the <physical_entity wordnetid="100001930" confidence="0.8">
<military_unit wordnetid="108198398" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<division wordnetid="108213205" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<army_unit wordnetid="108190754" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../522/2163522.xml">
Microsoft Research</link></research_worker>
</army_unit>
</scientist>
</causal_agent>
</division>
</person>
</military_unit>
</physical_entity>
 division. Another of the original Mach developers, <link xlink:type="simple" xlink:href="../282/241282.xml">
Avie Tevanian</link>, was formerly head of software at <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
, then Chief Software Technology Officer at <link xlink:type="simple" xlink:href="../856/856.xml">
Apple Computer</link> until March 2006.<weblink xlink:type="simple" xlink:href="http://sfgate.com/cgi-bin/blogs/sfgate/sso_detail?blogid=19&amp;entry_id=3821">
http://sfgate.com/cgi-bin/blogs/sfgate/sso_detail?blogid=19&amp;entry_id=3821</weblink></p>

<sec>
<st>
Mach concepts</st>
<p>

Since Mach was designed as a "drop-in" replacement for the traditional UNIX kernel, this discussion focuses on what distinguishes Mach from UNIX. It became clear early that UNIX's concept of everything-as-a-file might not be practical on modern systems, although some systems such as <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../226/24226.xml">
Plan 9 from Bell Labs</link></O>
 have tried this way. Nevertheless, those same developers lamented the loss of flexibility that the original concept offered. Another level of <link xlink:type="simple" xlink:href="../356/18311356.xml">
virtualization</link> was sought that would make the system "work" again.</p>
<p>

The critical <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/60491.xml">
abstraction</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 in UNIX was the <link xlink:type="simple" xlink:href="../117/1236117.xml">
pipe</link>. What was needed was a pipe-like concept that worked at a much more general level, allowing a broad variety of information be passed between programs. Such a system did exist using <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> (IPC):  A pipe-like system that would move <it>any</it> information between two programs, as opposed to file-like information. While many systems, including most Unices, had added various IPC implementations over the years, these were special-purpose libraries only really useful for one-off tasks.</p>
<p>

<university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../093/48093.xml">
Carnegie Mellon University</link></university>
 started experimentation along these lines under the <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/1531415.xml">
Accent kernel</link></kernel>
</natural_object>
</plant_part>
 project, using an IPC system based on <link xlink:type="simple" xlink:href="../653/825653.xml">
shared memory</link>. Accent was a purely experimental system with many features, developed in an ad-hoc fashion over a period of time with changing research interests. Additionally, Accent's usefulness for research was limited because it was not UNIX-compatible, and UNIX was already the de-facto standard for almost all operating system research. Finally, Accent was tightly coupled with the hardware platform on which it was developed, and at the time in the early 1980s it appeared there would soon be an explosion of new platforms, many of them <link xlink:type="simple" xlink:href="../979/994979.xml">
massively parallel</link>.</p>
<p>

Mach started largely as an effort to produce a cleanly-defined, UNIX-based, highly portable Accent. The result was a short list of generic concepts:</p>
<p>

<list>
<entry level="1" type="bullet">

 a "task" is a set of resources that enable "threads" to run</entry>
<entry level="1" type="bullet">

 a "thread" is a single unit of code running on a processor</entry>
<entry level="1" type="bullet">

 a "port" defines a secure pipe for IPC between tasks</entry>
<entry level="1" type="bullet">

 "messages" are passed between programs on ports</entry>
</list>
</p>
<p>

Mach developed on Accent's IPC concepts, but made the system much more UNIX-like in nature, even able to run UNIX programs with little or no modification. To do this, Mach introduced the concept of a <it>port</it>, representing each endpoint of a two-way IPC. Ports had security and rights like files under UNIX, allowing a very UNIX-like model of protection to be applied to them. Additionally, Mach allowed any program to be handed privileges that would normally be given to the kernel only, in order to allow <link xlink:type="simple" xlink:href="../467/93467.xml">
user space</link> programs to handle things like interacting with hardware.</p>
<p>

Under Mach, and like UNIX, the operating system again becomes primarily a collection of utilities. As UNIX, Mach keeps the concept of a driver for handling the hardware. Therefore all the drivers for the present hardware have to be included in the microkernel. Other architectures based on <link xlink:type="simple" xlink:href="../511/425511.xml">
Hardware Abstraction Layer</link> or <link xlink:type="simple" xlink:href="../757/95757.xml">
exokernel</link>s could move the drivers out of the microkernel.</p>
<p>

The main difference with UNIX is that instead of utilities handling files, they can handle any "task". More code was moved out of the kernel and into user space, resulting in a much smaller kernel and the rise of the term <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link>. Unlike traditional systems, under Mach a process, or "task", can consist of a number of threads. While this is common in modern systems, Mach was the first system to define tasks and threads in this way. The kernel's job was reduced from essentially being the operating system to maintaining the "utilities" and scheduling their access to hardware.</p>
<p>

The existence of ports and the use of IPC is perhaps the most fundamental difference between Mach and traditional kernels. Under UNIX, calling the kernel consists of an operation known as a <it><link xlink:type="simple" xlink:href="../908/102908.xml">
syscall</link></it> or <it><link xlink:type="simple" xlink:href="../602/938602.xml">
trap</link></it>. The program uses a <link xlink:type="simple" xlink:href="../421/106421.xml">
library</link> to place data in a well known location in memory and then causes a <it><link xlink:type="simple" xlink:href="../289/15289.xml">
fault</link></it>, a type of error. When the system is first started the kernel is set up to be the "handler" of all faults, so when the program causes a fault the kernel takes over, examines the information passed to it, and then carries out the instructions.</p>
<p>

Under Mach, the IPC system was used for this role instead. In order to call system functionality, a program would ask the kernel for access to a port, then use the IPC system to send messages to that port. Although the messages were triggered by syscalls as they would be on other kernels, under Mach that was pretty much all the kernel did&mdash;handling the actual request would be up to some other program.</p>
<p>

The use of IPC for message passing benefited support for threads and concurrency. Since tasks consisted of multiple threads, and it was the code in the threads that used the IPC mechanism, Mach was able to freeze and unfreeze threads while the message was handled. This allowed the system to be distributed over multiple processors, either using shared memory directly as in most Mach messages, or by adding code to copy the message to another processor if needed. In a traditional kernel this is difficult to implement; the system has to be sure that different programs don't try to write to the same memory from different processors. Under Mach this was well defined and easy to implement; it was the very process of accessing that memory, the ports, that was made a first-class citizen of the system.</p>
<p>

The IPC system initially had performance problems, so a few strategies were developed to minimize the impact. Like its predecessor, <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/1531415.xml">
Accent</link></kernel>
</natural_object>
</plant_part>
, Mach used a single shared-memory mechanism for physically passing the message from one program to another.  Physically copying the message would be too slow, so Mach relies on the machine's <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link> (MMU) to quickly map the data from one program to another. Only if the data is written to would it have to be physically copied, a process known as <it><link xlink:type="simple" xlink:href="../603/407603.xml">
copy-on-write</link></it>.</p>
<p>

Messages were also checked for validity by the kernel, to avoid bad data crashing one of the many programs making up the system.  Ports were deliberately modeled on the UNIX file system concepts. This allowed the user to find ports using existing file system navigation concepts, as well as assigning rights and permissions as they would on the file system.</p>
<p>

Development under such a system would be easier. Not only would the code being worked on exist in a traditional program that could be built using existing tools, it could also be started, debugged and killed off using the same tools. With a <link xlink:type="simple" xlink:href="../825/20825.xml">
monokernel</link> a bug in new code would take down the entire machine and require a reboot, whereas under Mach this would require only that the program be restarted. Additionally the user could tailor the system to include, or exclude, whatever features they required. Since the operating system was simply a collection of programs, they could add or remove parts by simply running or killing them as they would any other program.</p>
<p>

Finally, under Mach, all of these features were deliberately designed to be extremely platform neutral. To quote one text on Mach:</p>
<p>

<indent level="1">

 Unlike UNIX, which was developed without regard for multiprocessing, Mach incorporates multiprocessing support throughout. Its multiprocessing support is also exceedingly flexible, ranging from shared memory systems to systems with no memory shared between processors. Mach is designed to run on computer systems ranging from one to thousands of processors. In addition, Mach is easily ported to many varied computer architectures. A key goal of Mach is to be a distributed system capable of functioning on heterogeneous hardware. (<weblink xlink:type="simple" xlink:href="http://www3.interscience.wiley.com:8100/legacy/college/silberschatz/0471694665/appendices/appb.pdf">
Appendix B</weblink>, <weblink xlink:type="simple" xlink:href="http://he-cda.wiley.com/WileyCDA/HigherEdTitle/productCd-0471694665,courseCd-CX9000,pageType-copy,page-detailedTOC.html">
Operating System Concepts</weblink>)
</indent>
There are a number of disadvantages, however. A relatively mundane one is that it is not clear how to find ports. Under UNIX this problem was solved over time as programmers agreed on a number of "well known" locations in the file system to serve various duties. While this same approach worked for Mach's ports as well, under Mach the operating system was assumed to be much more fluid, with ports appearing and disappearing all the time. Without some mechanism to find ports and the services they represented, much of this flexibility would be lost.</p>

</sec>
<sec>
<st>
Development</st>

<p>

Mach was initially hosted as additional code written directly into the existing 4.2BSD kernel, allowing the team to work on the system long before it was complete. Work started with the already functional Accent IPC/port system, and moved on to the other key portions of the OS, tasks and threads and virtual memory. As portions were completed various parts of the BSD system were re-written to call into Mach, and a change to 4.3BSD was also made during this process.</p>
<p>

By 1986 the system was complete to the point of being able to run on its own on the <link xlink:type="simple" xlink:href="../517/32517.xml">
DEC VAX</link>. Although doing little of practical value, the goal of making a microkernel was realized. This was soon followed by versions on the <link xlink:type="simple" xlink:href="../430/1367430.xml">
IBM PC/RT</link> and for <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../980/26980.xml">
Sun Microsystems</link></institution>
</company>
 <link xlink:type="simple" xlink:href="../322/20322.xml">
68030</link>-based workstations, proving the system's portability. By 1987 the list included the <link>
Encore Multimax</link> and <company wordnetid="108058098" confidence="0.8">
<subsidiary_company wordnetid="108003935" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../458/222458.xml">
Sequent Balance</link></institution>
</subsidiary_company>
</company>
 machines, testing Mach's ability to run on multiprocessor systems. A public Release 1 was made that year, and Release 2 followed the next year.</p>
<p>

Throughout this time the promise of a "true" microkernel was not yet being delivered. These early Mach versions included the majority of 4.3BSD in the kernel, a system known as <b>POE</b> Server, resulting in a kernel that was actually larger than the UNIX it was based on. The idea, however, was to move the UNIX layer out of the kernel into user-space, where it could be more easily worked on and even replaced outright. Unfortunately performance proved to be a major problem, and a number of architectural changes were made in order to solve this problem. Unwieldy UNIX licensing issues were also plaguing researchers, so this early effort to provide a non-licensed UNIX-like system environment continued to find use, well into the further development of Mach. </p>
<p>

The resulting Mach 3 was released in 1990, and generated intense interest. A small team had built Mach and ported it to a number of platforms, including complex multiprocessor systems which were causing serious problems for older-style kernels. This generated considerable interest in the commercial market, where a number of companies were in the midst of considering changing hardware platforms. If the existing system could be ported to run on Mach, it would seem it would then be easy to change the platform underneath.</p>
<p>

Mach received a major boost in visibility when the <foundation wordnetid="113790712" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/190219.xml">
Open Software Foundation</link></foundation>
 (OSF) announced they would be hosting future versions of <link>
OSF/1</link> on Mach 2.5, and were investigating Mach 3 as well. Mach 2.5 was also selected for the <link xlink:type="simple" xlink:href="../642/40642.xml">
NeXTSTEP</link> system and a number of commercial multiprocessor vendors. Mach 3 led to a number of efforts to port other operating systems to the kernel, including <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
's <link xlink:type="simple" xlink:href="../497/1044497.xml">
Workplace OS</link> and several efforts by <link xlink:type="simple" xlink:href="../856/856.xml">
Apple Computer</link> to build a cross-platform version of the <link xlink:type="simple" xlink:href="../043/20043.xml">
Mac OS</link>.</p>
<p>

For some time it appeared that every future operating system would be based on Mach by the late 1990s.</p>

</sec>
<sec>
<st>
Performance problems</st>

<p>

Mach was originally intended to be a replacement for classical UNIX, and for this reason contained many UNIX-like ideas. For instance, Mach used a permissioning and security system patterned on UNIX's file system. Since the kernel was privileged (running in <it>kernel-space</it>) it was possible for malfunctioning or malicious programs to send it commands that would cause damage to the system, and for this reason the kernel checked every message for validity. Additionally most of the functionality was to be located in user-space programs, so this meant there needed to be some way for the kernel to grant these programs additional privileges, to operate on hardware for instance.</p>
<p>

Some of Mach's more esoteric features were also based on this same IPC mechanism. For instance, Mach was able to support multi-processor machines with ease. In a traditional kernel extensive work needs to be carried out to make it <link xlink:type="simple" xlink:href="../851/154851.xml">
reentrant (subroutine)</link> or <it>interruptible</it>, as programs running on different processors could call into the kernel at the same time. Under Mach, the bits of the operating system are isolated in servers, which are able to run, like any other program, on any processor. Although in theory the Mach kernel would also have to be reentrant, in practice this isn't an issue because its response times are so fast it can simply wait and serve requests in turn. Mach also included a server that could forward messages not just between programs, but even over the network, which was an area of intense development in the late 1980s and early 1990s.</p>
<p>

Unfortunately, the use of IPC for almost all tasks turned out to have serious performance impact. Benchmarks on 1997 hardware showed that Mach 3.0-based <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> single-server implementations were about 50% slower than native UNIX.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

Studies showed the vast majority of this performance hit, 73% by one measure, was due to the overhead of the IPC . And this was measured on a system with a single large server providing the operating system; breaking the system down further into smaller servers would only make the problem worse. It appeared the goal of a collection-of-servers was simply not possible.</p>
<p>

Many attempts were made to improve the performance of Mach and Mach-like microkernels, but by the mid-1990s much of the early intense interest had died. The concept of an operating system based on IPC appeared to be dead, the idea itself flawed .</p>
<p>

In fact, further study of the exact nature of the performance problems turned up a number of interesting facts. One was that the IPC itself was not the problem: there was some overhead associated with the memory mapping needed to support it, but this added only a small amount of time to making a call. The rest, 80% of the time being spent, was due to additional tasks the kernel was running on the messages. Primary among these was the port rights checking and message validity. In tests on a <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/15161.xml">
486</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
DX-50 a standard UNIX system call took 21 <order wordnetid="107168623" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<command wordnetid="107168131" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<speech_act wordnetid="107160883" confidence="0.8">
<link xlink:type="simple" xlink:href="../451/203451.xml">
microseconds</link></speech_act>
</psychological_feature>
</act>
</command>
</event>
</order>
 to complete, while a corresponding operation on Mach took 114 microseconds. Only 18 microseconds of this was hardware related; the rest was the Mach kernel running various routines on the message <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

When Mach was first being seriously used in the 2.x versions, performance was slower than traditional kernels, perhaps as much as 25% . This cost was not considered particularly worrying, however, because the system was also offering multi-processor support and easy portability.  Many felt this was an expected and acceptable cost to pay.  In fact the system was hiding a serious performance problem, one that only became obvious when Mach 3 started to be widely used, and developers attempted to make systems running in user-space.</p>
<p>

When Mach 3 attempted to move the operating system into user-space, the overhead suddenly became overwhelming. In this case consider the simple task of asking the system for the time. Under a true user-space system, there would be a server handling this request. The caller would trigger the IPC system to run the kernel, causing a context switch and memory mapping. The kernel would then examine the contents of the message to see if the caller had rights to call the server, and if so, do another mapping into the server's memory and another context switch to allow it to run. The process then repeats to return the results, adding up to a total of four context switches and memory mappings, as well as two runs of the code to check the rights and validity of the messages.</p>
<p>

To put numbers to this, a call into the BSD kernel on a <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/15161.xml">
486DX-50</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 requires about 20 microseconds (μs). The same call on the same system running Mach 3 required 114 μs. Given a syscall that does nothing, a full round-trip under BSD would require about 40 μs, whereas on a user-space Mach system it would take just under 500 μs. In detailed testing published in 1991, Chen and Bershad found overall system performance was degraded by up to 66% compared to a traditional kernel .</p>
<p>

This was not the only source of performance problems. Another centered on the problems of trying to handle memory properly when physical memory ran low and paging had to occur. In the traditional monokernels the authors had direct experience with which parts of the kernel called which others, allowing them to fine tune their pager to avoid paging out code that was about to be used. Under Mach this wasn't possible because the kernel had no real idea what the operating system consisted of. Instead they had to use a single one-size-fits-all solution that added to the performance problems.  Mach 3 attempted to address this problem by providing a simple pager, relying on user-space pagers for better specialization.  But this turned out to have little effect.  In practice, any benefits it had were wiped out by the expensive IPC needed to call it in.</p>
<p>

Other performance problems were related to Mach's support for <link xlink:type="simple" xlink:href="../020/64020.xml">
multiprocessor</link> systems. From the mid-1980s to the early 1990s, commodity CPUs grew in performance at a rate of about 60% a year, but the speed of memory access grew at only 7% a year. This meant that the cost of accessing memory grew tremendously over this period, and since Mach was based on mapping memory around between programs, any "cache miss" made IPC calls excruciatingly slow.</p>
<p>

Regardless of the advantages of the Mach approach, these sorts of real-world performance hits were simply not acceptable. As other teams found the same sorts of results, the early Mach enthusiasm quickly disappeared. After a short time many in the development community seemed to conclude that the entire concept of using IPC as the basis of an operating system was inherently flawed .</p>

</sec>
<sec>
<st>
Potential solutions</st>

<p>

IPC overhead is a major issue for Mach 3 systems. However, the concept of a  <it>multi-server system</it> is still promising, though it still requires some research. The developers have to be careful to isolate code into modules that do not call from server to server. For instance, the majority of the networking code would be placed in a single server, thereby minimizing IPC for normal networking tasks. Under UNIX this isn't very easy, however, because the system is based on using the file system as the basis for everything from security to networking.</p>
<p>

Most developers instead stuck with the original POE concept of a single large server providing the operating system functionality. In order to ease development, they allowed the operating system server to run either in user-space or kernel-space. This allowed them to develop in user-space and have all the advantages of the original Mach idea, and then move the debugged server into kernel-space in order to get better performance. Several operating systems have since been constructed using this method, known as <it>co-location</it>, among them <link xlink:type="simple" xlink:href="../077/626077.xml">
Lites</link>, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../761/547761.xml">
MkLinux</link></O>
, <link>
OSF/1</link> and <link xlink:type="simple" xlink:href="../642/40642.xml">
NeXTSTEP</link>/<link xlink:type="simple" xlink:href="../114/53114.xml">
OPENSTEP</link>/<link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>. The <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../461/1206461.xml">
Chorus microkernel</link></O>
 made this a feature of the basic system, allowing servers to be raised into the kernel space using built-in mechanisms.</p>
<p>

Mach 4 attempted to address these problems, this time with a more radical set of upgrades. In particular, it was found that program code was typically not writable, so potential hits due to copy-on-write were rare. Thus it made sense to not map the memory between programs for IPC, but instead migrate the program code being used into the local space of the program. This led to the concept of "shuttles" and it seemed performance had improved, but the developers moved on with the system in a semi-usable state. Mach 4 also introduced built-in co-location primitives, making it a part of the kernel itself.</p>
<p>

By the mid-1990s, work on microkernel systems was largely dead, despite the market generally believing that all modern operating systems would be microkernel based by the 1990s.  The only remaining widespread use of the Mach kernel is Apple's Mac OS X, which runs a heavily modified Mach 2.5 kernel.</p>

</sec>
<sec>
<st>
The Next Generation</st>
<p>

Further analysis demonstrated that the IPC performance problem was not as obvious as it seemed. Recall that a single-side of a syscall took 20 μs under BSD and 114 μs on Mach running on the same system. Of the 114, 11 were due to the context switch, identical to BSD. An additional 18 were used by the MMU to map the message between user-space and kernel space. This adds up to only 31 μs, longer than a traditional syscall, but not by much.</p>
<p>

The rest, the majority of the actual problem, was due to the kernel performing tasks such as checking the message for port access rights. While it would seem this is an important security concern, in fact, it only makes sense in a UNIX-like system. For instance, a single-user operating system running on a <link xlink:type="simple" xlink:href="../137/19644137.xml">
cell phone</link> might not need any of these features, and this is exactly the sort of system where Mach's pick-and-choose operating system would be most valuable. Likewise Mach caused problems when memory had been moved by the operating system, another task that only really makes sense if the system has more than one address space. <link xlink:type="simple" xlink:href="../146/8146.xml">
DOS</link> and the early <link xlink:type="simple" xlink:href="../043/20043.xml">
Mac OS</link> had a <link xlink:type="simple" xlink:href="../531/2968531.xml">
single large address space</link> shared by all programs, so under these systems the mapping is a waste of time.</p>
<p>

These realizations led to a series of <link>
second generation microkernel</link>s, which further reduced the complexity of the system and placed almost all functionality in the user space. For instance, the <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 kernel</link> includes only seven functions and uses 12k of memory, whereas Mach 3 includes about 140 functions and uses about 330k of memory. IPC calls under L4 on a 486DX-50 take only 5 μs, faster than a UNIX syscall on the same system, and over 20 times as fast as Mach. Of course this ignores the fact that L4 is not handling permissioning or security, but by leaving this to the user-space programs, they can select as much or as little overhead as they require.</p>
<p>

The <it>potential</it> performance gains of L4 are tempered by the fact that the user-space applications will often have to provide many of the functions formerly supported by the kernel. In order to test the end-to-end performance, MkLinux in co-located mode was compared with an L4 port running in user-space. L4 added about 5%-10% overhead, compared to Mach's 15%, all the more interesting considering the double context switches needed.</p>
<p>

These newer microkernels have revitalized the industry as a whole, and many formerly dead projects such as the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../236/13236.xml">
GNU Hurd</link></software>
 have received new attention as a result.</p>

</sec>
<sec>
<st>
Operating systems and kernels based on Mach</st>
<p>

<list>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../236/13236.xml">
GNU Hurd</link></software>
 (based on <link xlink:type="simple" xlink:href="../008/64008.xml">
GNU Mach</link>)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../443/16161443.xml">
iPhone OS</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../077/626077.xml">
Lites</link></entry>
<entry level="1" type="bullet">

 <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../761/547761.xml">
MkLinux</link></O>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../187/737187.xml">
mtXinu</link></entry>
<entry level="1" type="bullet">

 <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../746/2889746.xml">
MachTen</link></O>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../124/2886124.xml">
MacMach</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../642/40642.xml">
NEXTSTEP</link></entry>
<entry level="1" type="bullet">

 <link>
OSF/1</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../497/1044497.xml">
Workplace OS</link></entry>
<entry level="1" type="bullet">

 <link>
xMach</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../266/47266.xml">
UNICOS MAX</link></entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../023/20023.xml">
Microkernel</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel family</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

J. Bradley Chen, Brian N. Bershad. <it><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=168629&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
The impact of operating system structure on memory system performance</weblink></it>, ACM Press, 1994, ISBN 0-89791-632-8</entry>
</list>
</p>

<ss1>
<st>
 Notes </st>
<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">M. Condict, D. Bolinger, E. McManus, D. Mitchell, S. Lewontin&#32;(April 1994).&#32;"Microkernel modularity with integrated kernel performance". <it>Technical report, OSF Research Institute, Cambridge, MA</it>.</cite>&nbsp;</entry>
<entry id="2">
  <cite style="font-style:normal">Hermann Härtig, Michael Hohmuth, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
, Sebastian Schönberg, Jean Wolter&#32;(October 1997).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=266660&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
The performance of μ-kernel-based systems</weblink>". <it>Proceedings of the 16th ACM symposium on Operating systems principles (SOSP), Saint-Malo, France</it>: 67. ISBN 0-89791-916-5.</cite>&nbsp; <weblink xlink:type="simple" xlink:href="http://os.inf.tu-dresden.de/pubs/sosp97/">
url2</weblink> </entry>
<entry id="3">
  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
&#32;(1993).&#32;"Improving IPC by Kernel Design". <it>Proceedings of the 14th ACM Symposium on Operating System Principles (SOSP)</it>. ISBN0-89791-632-8.</cite>&nbsp;</entry>
</reflist>
</p>

</ss1>
</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-2.cs.cmu.edu/afs/cs/project/mach/public/www/mach.html">
The Mach project at Carnegie Mellon</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://codex.cs.yale.edu/avi/os-book/os7/online-dir/Mach.pdf">
The Mach System</weblink> – Appendix to <it>Operating System Concepts</it> (7th ed) by Avi Silberschatz, Peter Baer Galvin and Greg Gagne</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cdk3.net/oss/Ed2/Comparison.pdf">
A comparison of Mach, Amoeba and Chorus</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://rtsl.cs.ccu.edu.tw/upload/paper/(2002-12-05)%20Toward%20Real%20Microkernels.ppt">
Towards Real Microkernels</weblink> – Contains numerous performance measurements, including those quoted in the article</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://os.inf.tu-dresden.de/pubs/sosp97/">
The Performance of µ-Kernel-Based Systems</weblink> – Contains an excellent performance comparison of Linux running as a monokernel, on Mach 3 and on L4</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://fxr.watson.org/fxr/source/?v=MK84">
Mach kernel source code</weblink> - Browsable version of the Mach Kernel source code on the FreeBSD/Linux kernel cross reference site</entry>
</list>
</p>


</sec>
</bdy>
</entity>
</article>
