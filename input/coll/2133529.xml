<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:19:49[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Goertzel algorithm</title>
<id>2133529</id>
<revision>
<id>243049695</id>
<timestamp>2008-10-04T22:36:28Z</timestamp>
<contributor>
<username>Glrx</username>
<id>2289521</id>
</contributor>
</revision>
<categories>
<category>FFT algorithms</category>
<category>Digital signal processing</category>
</categories>
</header>
<bdy>

The <b>Goertzel algorithm</b> is a <link xlink:type="simple" xlink:href="../TN$$/HT$C$_T$yT$N$.xml">
digital signal processing</link> (DSP) technique for identifying <link xlink:type="simple" xlink:href="../779/10779.xml">
frequency</link> components of a signal, published by <link>
Dr. Gerald Goertzel</link> in 1958.  While the general <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/11512.xml">
Fast Fourier transform</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (FFT) algorithm computes evenly across the <link xlink:type="simple" xlink:href="../967/3967.xml">
bandwidth</link> of the incoming signal, the Goertzel algorithm looks at specific, predetermined frequency.<p>

A practical application of this algorithm is recognition of the tones produced by the buttons pushed on a telephone keypad.  This application is illustrated by the below 'C' programming language implementation of the algorithm, demonstrating the production of a <link xlink:type="simple" xlink:href="../854/146854.xml">
DTMF</link> tone detector.</p>

<sec>
<st>
 Explanation of algorithm </st>

<p>

The Goertzel algorithm computes a sequence, <math>s(n)</math>, given an input sequence, <math>x(n)</math>:
<indent level="1">

<math>s(n) = x(n) + 2 \cos(2 \pi \omega) s(n-1) - s(n-2)</math>
</indent>
where <math>s(-2) = s(-1) = 0</math> and <math>\omega</math> is some frequency of interest, in cycles per sample, which should be less than 1/2.  This effectively implements a second-order <link xlink:type="simple" xlink:href="../140/570140.xml">
IIR</link> filter with poles at <math>e^{+2 \pi i \omega}</math> and <math>e^{-2 \pi i \omega}</math>, and requires only one multiplication (assuming <math>2 cos(2 \pi \omega)</math> is pre-computed), one addition and one subtraction per input sample.  For real inputs, these operations are real.</p>
<p>

The <link xlink:type="simple" xlink:href="../589/171589.xml">
Z transform</link> of this process is
<indent level="1">

<math>\frac{S(z)}{X(z)} = \frac{1}{1 - 2 \cos(2 \pi \omega) z^{-1} + z^{-2}} = \frac{1}{(1 - e^{+2 \pi i \omega} z^{-1})(1 - e^{-2 \pi i \omega} z^{-1})}</math>
</indent>
Applying an additional, <link xlink:type="simple" xlink:href="../101/443101.xml">
FIR</link>, transform of the form
<indent level="1">

<math>\frac{Y(z)}{S(z)} = 1 - e^{-2 \pi i \omega}z^{-1}</math>
</indent>
will give an overall transform of
<indent level="1">

<math>\frac{S(z)}{X(z)} \frac{Y(z)}{S(z)} = \frac{Y(z)}{X(z)} = \frac{(1 - e^{-2 \pi i \omega}z^{-1})}{(1 - e^{+2 \pi i \omega} z^{-1})(1 - e^{-2 \pi i \omega} z^{-1})} = \frac{1}{1 - e^{+2 \pi i \omega} z^{-1}}</math>
</indent>
The time-domain equivalent of this overall transform is
<indent level="1">

<math>y(n) = x(n) + e^{+2 \pi i \omega} y(n-1) = \sum_{k=-\infty}^{n}x(k) e^{+2 \pi i \omega (n-k)} = e^{+2 \pi i \omega n} \sum_{k=-\infty}^{n}x(k) e^{-2 \pi i \omega k}</math>
</indent>
which becomes, assuming <math>x(k) = 0</math> for all <math>k &amp;lt; 0</math>
<indent level="1">

<math>y(n) = e^{+2 \pi i \omega n} \sum_{k=0}^{n}x(k) e^{-2 \pi i \omega k}</math>
</indent>

or, the equation for the <math>(n+1)</math>-sample <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml">
DFT</link></function>
</operator>
</mathematical_relation>
 of <math>x</math>, evaluated for <math>\omega</math> and multiplied by the scale factor <math>e^{+2 \pi i \omega n}</math>.</p>
<p>

Note that applying the additional transform Y(z)/S(z) only requires the last two samples of the <math>s</math> sequence.  Consequently, upon processing <math>N</math> samples <math>x(0)...x(N-1)</math>, the last two samples from the <math>s</math> sequence can be used to compute the value of a <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml">
DFT</link></function>
</operator>
</mathematical_relation>
 bin which corresponds to the chosen frequency <math>\omega</math> as
<indent level="1">

<math>X(\omega) = y(N-1) e^{-2 \pi i \omega (N - 1)} = ( s(N-1) - e^{-2 \pi i \omega} s(N-2) ) e^{-2 \pi i \omega (N - 1)}</math>
</indent>
For the special case often found when computing <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml">
DFT</link></function>
</operator>
</mathematical_relation>
 bins, where <math>\omega N = k</math> for some integer, <math>k</math>, this simplifies to
<indent level="1">

<math>X(\omega) = ( s(N-1) - e^{-2 \pi i \omega} s(N-2) ) e^{+2 \pi i \omega} = e^{+2 \pi i \omega} s(N-1) - s(N-2)</math>
</indent>
In either case, the corresponding power can be computed using the same cosine term required to compute <math>s</math> as
<indent level="1">

<math>X(\omega) X'(\omega) = s(N-2)^2 + s(N-1)^2 - 2 cos(2 \pi \omega) s(N-2) s(N-1)</math>
</indent>

When implemented in a general-purpose processor, values for <math>s(n-1)</math> and <math>s(n-2)</math> can be retained in variables and new values of <math>s</math> can be shifted through as they are computed, assuming that only the final two values of the <math>s</math> sequence are required.  The code may then be as follows:</p>
<p>


s_prev = 0
s_prev2 = 0
coeff = 2*cos(2*PI*normalized_frequency);
for each sample, x[n],
  s = x[n] + coeff*s_prev - s_prev2;
  s_prev2 = s_prev;
  s_prev = s;
end
power = s_prev2*s_prev2 + s_prev*s_prev - coeff*s_prev2*s_prev;
</p>

</sec>
<sec>
<st>
 Computational complexity </st>

<p>

In order to compute a single <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml">
DFT</link></function>
</operator>
</mathematical_relation>
 bin for a complex sequence of length <it>N</it>, this algorithm requires 2<it>N</it> multiplies and 4<it>N</it> add/subtract operations within the loop, as well as 4 multiplies and 4 add/subtract operations to compute <math>X(\omega)</math>, for a total of 2<it>N</it>+4 multiplies and 4<it>N</it>+4 add/subtract operations (for real sequences, the required operations are half that amount).  In contrast, the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/11512.xml">
Fast Fourier transform</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (FFT) requires 2log2<it>N</it> multiplies and 3log2<it>N</it> add/subtract operations per <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml">
DFT</link></function>
</operator>
</mathematical_relation>
 bin, but must compute all <it>N</it> bins simultaneously (similar optimizations are available to halve the number of operations in an FFT when the input sequence is real).</p>
<p>

When the number of desired <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/8811.xml">
DFT</link></function>
</operator>
</mathematical_relation>
 bins, <it>M</it>, is small (e.g., when detecting <link xlink:type="simple" xlink:href="../854/146854.xml">
DTMF</link> tones), it is computationally advantageous to implement the Goertzel algorithm, rather than the FFT.  Approximately, this occurs when
<indent level="1">

<math>M &amp;lt; \frac{5}{6} \log_2 N</math>
</indent>
or if, for some reason, <it>N</it> is not an integral power of 2 while you stick to a simple FFT algorithm like the 2-radix <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/352702.xml">
Cooley-Tukey FFT algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, and zero-padding the samples out to an integral power of 2 would violate
<indent level="1">

<math>M &amp;lt; \frac{5 N_{\mbox{padded}}}{6 N} \log_2(N_{\mbox{padded}})</math>
</indent>
Moreover, the Goertzel algorithm can be computed as samples come in, and the FFT algorithm may require a large table of <it>N</it> pre-computed sines and cosines in order to be efficient.</p>
<p>

If multiplications are not considered as difficult as additions, or vice versa, the 5/6 ratio can shift between anything from 3/4 (additions dominate) to 1/1 (multiplications dominate).</p>

</sec>
<sec>
<st>
 Practical considerations </st>

<p>

The term <link xlink:type="simple" xlink:href="../854/146854.xml">
DTMF</link> or Dual-Tone Multi Frequency is the official name of the tones generated from a telephone keypad.  (AT&amp;T used the trademark "Touch-Tone" for its DTMF dialing service.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>)  The original keypads were mechanical switches triggering RC controlled oscillators.  The digit detectors were also tuned circuits.  The interest in decoding DTMF is high because of the large numbers of phones generating these types of tones.</p>
<p>

At present, DTMF detectors are most often implemented as numerical algorithms on either general purpose computers or on fast digital signal processors.  The algorithm shown below is an example of such a detector.</p>
<p>

However, this algorithm needs an additional post-processing step to completely implement a functional DTMF tone detector.  DTMF tone bursts can be as short as 50 milli-seconds or as long as several seconds.  The tone burst can have noise or dropouts within it which must be ignored.  The Goertzel algorithm produces multiple outputs; a post-processing step needs to smooth these outputs into one output per tone burst.</p>
<p>

One additional problem is that the algorithm will sometimes produce spurious outputs because of a window period that is not completely filled with samples.  Imagine a DTMF tone burst and then imagine the window superimposed over this tone burst.  Obviously, the detector is running at a fixed rate and the tone burst is not guaranteed to arrive aligned with the timing of the detector.  So some window intervals on the leading and trailing edges of the tone burst will not be entirely filled with valid tone samples.  Worse, RC-based tone generators will often have voltage sag/surge related anomalies at the leading and trailing edges of the tone burst.  These also can contribute to spurious outputs.</p>
<p>

It is highly likely that this detector will report false or incorrect results at the leading and trailing edges of the tone burst due to a lack of sufficient valid samples within the window.  In addition, the tone detector must be able to tolerate tone dropouts within the tone burst and these can produce additional false reports due to the same windowing effects.</p>
<p>

The post-processing system can be implemented as a statistical aggregator which will examine a series of outputs of the algorithm below.  There should be a counter for each possible output.  These all start out at zero.  The detector starts producing outputs and depending on the output, the appropriate counter is incremented.  Finally, the detector stops generating outputs for long enough that the tone burst can be considered to be over.  The counter with the highest value wins and should be considered to be the DTMF digit signaled by the tone burst.</p>
<p>

While it is true that there are eight possible frequencies in a DTMF tone, the algorithm as originally entered on this page was computing a few more frequencies so as to help reject false tones (talkoff).  Notice the peak tone counter loop.  This checks to see that only two tones are active.  If more than this are found then the tone is rejected.</p>

</sec>
<sec>
<st>
 Sample code for a DTMF detector </st>



<p>

<list>
<entry level="1" type="number">

define SAMPLING_RATE       8000</entry>
<entry level="1" type="number">

define MAX_BINS            8</entry>
<entry level="1" type="number">

define GOERTZEL_N          92</entry>
</list>
</p>
<p>

int         sample_count;
double      q1[ MAX_BINS ];
double      q2[ MAX_BINS ];
double      r[ MAX_BINS ];</p>
<p>

/*
<list>
<entry level="1" type="bullet">

 coef = 2.0 * cos( (2.0 * PI * k) / (float)GOERTZEL_N)) ;</entry>
<entry level="1" type="bullet">

 Where k = (int) (0.5 + ((float)GOERTZEL_N * target_freq) / SAMPLING_RATE));</entry>
<entry level="1" type="bullet">
</entry>
<entry level="1" type="bullet">

 More simply: coef = 2.0 * cos( (2.0 * PI * target_freq) / SAMPLING_RATE );</entry>
<entry level="1" type="bullet">

/</entry>
</list>

double      freqs[ MAX_BINS] = 
{
697,
770,
852,
941,
1209,
1336,
1477,
1633
};</p>
<p>

double      coefs[ MAX_BINS ] ;</p>

<p>

/*----------------------------------------------------------------------------
<list>
<entry level="1" type="bullet">

  calc_coeffs</entry>
<entry level="1" type="bullet">

----------------------------------------------------------------------------</entry>
<entry level="1" type="bullet">

 This is where we calculate the correct co-efficients.</entry>
<entry level="1" type="bullet">

/</entry>
</list>

void calc_coeffs()
{
int n;</p>
<p>

for(n = 0; n  MAX_BINS; n++)
{
coefs[n] = 2.0 * cos(2.0 * 3.141592654 * freqs[n] / SAMPLING_RATE);
}
}</p>

<p>

/*----------------------------------------------------------------------------
<list>
<entry level="1" type="bullet">

  post_testing</entry>
<entry level="1" type="bullet">

----------------------------------------------------------------------------</entry>
<entry level="1" type="bullet">

 This is where we look at the bins and decide if we have a valid signal.</entry>
<entry level="1" type="bullet">

/</entry>
</list>

void post_testing()
{
int         row, col, see_digit;
int         peak_count, max_index;
double      maxval, t;
int         i;
char *  row_col_ascii_codes[4][4] = {
{"1", "2", "3", "A"},
{"4", "5", "6", "B"},
{"7", "8", "9", "C"},
{"*", "0", "#", "D"}};</p>

<p>

/* Find the largest in the row group. */
row = 0;
maxval = 0.0;
for ( i=0; i4; i++ )
{
if ( r[i] &amp;gt; maxval )
{
maxval = r[i];
row = i;
}
}</p>
<p>

/* Find the largest in the column group. */
col = 4;
maxval = 0.0;
for ( i=4; i8; i++ )
{
if ( r[i] &amp;gt; maxval )
{
maxval = r[i];
col = i;
}
}</p>

<p>

/* Check for minimum energy */</p>
<p>

if ( r[row]  4.0e5 )   /* 2.0e5 ... 1.0e8 no change */
{
/* energy not high enough */
}
else if ( r[col]  4.0e5 )
{
/* energy not high enough */
}
else
{
see_digit = TRUE;</p>
<p>

/* Twist check
<list>
<entry level="1" type="bullet">

 CEPT =&amp;gt; twist  6dB</entry>
<entry level="1" type="bullet">

 AT&amp;T =&amp;gt; forward twist  4dB and reverse twist  8dB</entry>
<entry level="1" type="bullet">

  -ndB  10 log10( v1 / v2 ), where v1  v2</entry>
<entry level="1" type="bullet">

  -4dB  10 log10( v1 / v2 )</entry>
<entry level="1" type="bullet">

  -0.4   log10( v1 / v2 )</entry>
<entry level="1" type="bullet">

  0.398  v1 / v2</entry>
<entry level="1" type="bullet">

  0.398 * v2  v1</entry>
<entry level="1" type="bullet">

/</entry>
</list>

if ( r[col] &amp;gt; r[row] )
{
/* Normal twist */
max_index = col;
if ( r[row]  (r[col] * 0.398) )    /* twist &amp;gt; 4dB, error */
see_digit = FALSE;
}
else /* if ( r[row] &amp;gt; r[col] ) */
{
/* Reverse twist */
max_index = row;
if ( r[col]  (r[row] * 0.158) )    /* twist &amp;gt; 8db, error */
see_digit = FALSE;
}</p>
<p>

/* Signal to noise test
<list>
<entry level="1" type="bullet">

 AT&amp;T states that the noise must be 16dB down from the signal.</entry>
<entry level="1" type="bullet">

 Here we count the number of signals above the threshold and</entry>
<entry level="1" type="bullet">

 there ought to be only two.</entry>
<entry level="1" type="bullet">

/</entry>
</list>

if ( r[max_index] &amp;gt; 1.0e9 )
t = r[max_index] * 0.158;
else
t = r[max_index] * 0.010;</p>
<p>

peak_count = 0;
for ( i=0; i8; i++ )
{
if ( r[i] &amp;gt; t )
peak_count++;
}
if ( peak_count &amp;gt; 2 )
see_digit = FALSE;</p>
<p>

if ( see_digit )
{
printf( "%s", row_col_ascii_codes[row][col-4] );
fflush(stdout);
}
}
}</p>

<p>

/*----------------------------------------------------------------------------
<list>
<entry level="1" type="bullet">

  goertzel</entry>
<entry level="1" type="bullet">

----------------------------------------------------------------------------</entry>
<entry level="1" type="bullet">

/</entry>
</list>

void goertzel( int sample )
{
double      q0;
ui32        i;</p>
<p>

sample_count++;
/*q1[0] = q2[0] = 0;*/
for ( i=0; i</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://tarr.uspto.gov/servlet/tarr?regser=serial&amp;entry=72109459">
USPTO trademark entry for Touch-Tone</weblink>, retrieved on <link xlink:type="simple" xlink:href="../586/20586.xml">
March 29</link>, <link xlink:type="simple" xlink:href="../165/36165.xml">
2007</link>.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 http://ptolemy.eecs.berkeley.edu/papers/96/dtmf_ict/www/node3.html</entry>
<entry level="1" type="bullet">

 http://www.embedded.com/story/OEG20020819S0057</entry>
<entry level="1" type="bullet">

 http://www.embedded.com/showArticle.jhtml?articleID=17301593</entry>
<entry level="1" type="bullet">

 http://www.numerix-dsp.com/goertzel.html</entry>
<entry level="1" type="bullet">

 http://www.mathworks.com/access/helpdesk/help/toolbox/signal/goertzel.html</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.dattalo.com/technical/theory/dtmf.html">
DTMF decoding with a 1-bit A/D converter</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ti.com/sc/docs/psheets/abstract/apps/spra066.htm">
Modified Goertzel Algorithm in DTMF Detection Using the TMS320C80 DSP</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://focus.ti.com/lit/an/spra096a/spra096a.pdf">
DTMF Tone Generation and Detection: An Implementation Using the TMS320C54x</weblink></entry>
<entry level="1" type="bullet">

  <weblink xlink:type="simple" xlink:href="http://focus.ti.com/lit/an/spra168/spra168.pdf">
Mock, P., Add DTMF Generation and Decoding to DSP-μP Designs, EDN, March 21, 1985, also DSP Applications with the TMS320 Family, Vol. 1, Texas Instruments, 1989.</weblink></entry>
</list>


</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
