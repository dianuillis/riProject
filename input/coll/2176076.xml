<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:21:35[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Lamport&apos;s bakery algorithm</title>
<id>2176076</id>
<revision>
<id>241744854</id>
<timestamp>2008-09-29T11:04:44Z</timestamp>
<contributor>
<username>RainerBlome</username>
<id>67213</id>
</contributor>
</revision>
<categories>
<category>Distributed systems</category>
<category>Concurrency control</category>
<category>Articles with example pseudocode</category>
<category>Concurrent algorithms</category>
</categories>
</header>
<bdy>

<b><it>Lamport's bakery algorithm</it></b> is a computer <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> devised by computer scientist <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../671/195671.xml">
Dr. Leslie Lamport</link></scientist>
, which is intended to improve the safety in the usage of shared resources among multiple <link xlink:type="simple" xlink:href="../303/45303.xml">
threads</link> by means of <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link>.
<ss1>
<st>
 Nature of the problem </st>
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, it is common for multiple threads to simultaneously access the same resources. <information wordnetid="105816287" confidence="0.8">
<datum wordnetid="105816622" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/1040512.xml">
Data corruption</link></datum>
</information>
 can occur if two or more threads try to write into the same <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> location, or if one thread reads a memory location before another has finished writing into it. <it>Lamport's bakery algorithm</it> is one of many <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> algorithms designed to prevent <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrent</link> threads entering <link>
critical sections</link> of code concurrently to eliminate the risk of data corruption.</p>

</ss1>
<sec>
<st>
 Algorithm </st>

<ss1>
<st>
 Analogy </st>
<p>

Lamport envisioned a <link xlink:type="simple" xlink:href="../677/390677.xml">
bakery</link> with a numbering machine at its entrance so each customer is given a unique number. Numbers increase by one as customers enter the store. A global counter displays the number of the customer that is currently being served. All other customers must wait in a queue until the baker finishes serving the current customer and the next number is displayed. When done shopping, the customer loses their number and can then do whatever they want, except for shopping without getting a new number. </p>
<p>

In the computer world, the 'customers' will be threads, identified by the letter <it>i</it>, obtained from a global variable.</p>
<p>

Due to the limitations of computer architecture, some parts of the Lamport's <link xlink:type="simple" xlink:href="../533/103533.xml">
analogy</link> need slight modification. It is possible that more than one thread will get the same number when they request it; this cannot be avoided. Therefore, it is assumed that the thread identifier <it>i</it> is also a priority identifier. A lower value of <it>i</it> means a higher priority and threads with higher priority will enter the <b><link xlink:type="simple" xlink:href="../312/638312.xml">
critical section</link></b> first.</p>

</ss1>
<ss1>
<st>
 Critical section </st>
<p>

The critical section is that part of code that requires exclusive access to resources and may only be executed by one thread at a time. In the bakery analogy, it is when the customer trades with the baker and others must wait. </p>
<p>

When a thread wants to enter the critical section, it has to check whether it is its turn to do so. It should check the numbers of every other thread to make sure that it has the smallest one. In case another thread has the same number, the thread with the smallest <it>i</it> will enter the critical section first.</p>
<p>

In <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link> this comparison will be written in the form:
(a, b)  (c, d)
which is equivalent to:
(a  c) or ((a == c) and (b  d))</p>
<p>

Once the thread ends its critical job, it gets rid of its number and enters the <b>non-critical section</b>.</p>

</ss1>
<ss1>
<st>
 Non-critical section </st>
<p>

The non-critical section is the part of code that doesn't need exclusive access. It represents some thread-specific computation that doesn't interfere with other threads' resources and execution. </p>
<p>

This part is analogous to actions that occur after shopping, such as putting change back into the wallet.</p>

</ss1>
</sec>
<sec>
<st>
 Implementation of the algorithm </st>

<ss1>
<st>
 Pseudocode </st>
<p>

// <it>declaration and initial values of global variables</it>
Entering: <b>array</b> [1..N] <b>of</b> <b>bool</b> = {false};
Number: <b>array</b> [1..N] <b>of</b> <b>integer</b> = {0};</p>
<p>

1  lock(integer i) {
2      Entering[i] = true;
3      Number[i] = 1 + max(Number[1], ..., Number[N]);
4      Entering[i] = false;
5      <b>for</b> (j = 1; j = N; j++) {
6          // <it>Wait until thread j receives its number</it>:
7          <b>while</b> (Entering[j]) { /* nothing */ }
8          // <it>Wait until all threads with smaller numbers or with the same</it>
9          // <it>number, but with higher priority, finish their work</it>:
10          <b>while</b> ((Number[j] != 0) &amp;&amp; ((Number[j], j)  (Number[i], i))) {
11              /* nothing */
12          }
13      }
14  }
15
16  unlock(integer i) {
17      Number[i] = 0;
18  }
19
20  Thread(integer i) {
21      <b>while</b> (true) {
22          lock(i);
23          // <it>The critical section goes here...</it>
24          unlock(i);
25          // <b><it>non-critical section...</it></b>
26      }
27  }</p>
<p>

In this example, all threads execute the same "main" function, <it>Thread</it>.  In real applications, different threads often have different "main" functions.</p>
<p>

<b>Note:</b> The thread also checks itself before entering the critical section, but that doesn't cause any delays since the loop conditions will evaluate as <it>false</it>.</p>

</ss1>
<ss1>
<st>
 Discussion </st>
<p>

Each thread only writes its own storage, only reads are shared. It is remarkable that this algorithm is not built on top of some lower level 'atomic' operation, e.g. <link xlink:type="simple" xlink:href="../224/632224.xml">
compare-and-swap</link>. The original proof shows that for overlapping reads and writes to the same storage cell only the write must be correct. The read operation can return an arbitrary number.
Therefore this algorithm can be used to implement mutual exclusion on 'memory' that lacks synchronisation primitives, e.g., a simple SCSI disk shared between two computers.</p>
<p>

The necessity of variable <it>Entering</it> might not be obvious as there is no 'lock' around lines 7 to 13. See <weblink xlink:type="simple" xlink:href="http://nob.cs.ucdavis.edu/classes/ecs150-1999-02/sync-bakery.html">
UCDAVIS: Bakery Algorithm</weblink> for an in depth discussion.</p>
<p>

When implementing the pseudo code for a single processor/core system, it is better to replace the "do nothing" sections with code that notifies the operating system to immediately switch to the next thread. This is often referred to as yielding the current thread.</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../826/36826.xml">
Dekker's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../891/331891.xml">
Peterson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.onjava.com/pub/a/onjava/2006/04/05/ajax-mutual-exclusion.html">
Wallace Variation of Bakery Algorithm</weblink> which overcomes limitations of Javascript language</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/lamport/pubs/pubs.html#bakery">
Lamport's Bakery Algorithm</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/lamport/pubs/bakery.pdf">
Original Paper</weblink></entry>
<entry level="1" type="bullet">

 On his <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/lamport/pubs/pubs.html#bakery">
publications page</weblink>, Lamport has added some remarks regarding the algorithm. </entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</article>
