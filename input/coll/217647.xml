<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:31:44[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<paradigm  confidence="0.8" wordnetid="113804375">
<linguistic_relation  confidence="0.8" wordnetid="113797142">
<inflection  confidence="0.8" wordnetid="113803782">
<grammatical_relation  confidence="0.8" wordnetid="113796779">
<header>
<title>Self-modifying code</title>
<id>217647</id>
<revision>
<id>235306380</id>
<timestamp>2008-08-31T02:55:11Z</timestamp>
<contributor>
<username>Sarrazip</username>
<id>16125</id>
</contributor>
</revision>
<categories>
<category>Programming paradigms</category>
<category>Articles with weasel words</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>self-modifying code</b> is <link xlink:type="simple" xlink:href="../661/27661.xml">
code</link> that alters its own <link xlink:type="simple" xlink:href="../801/3149801.xml">
instructions</link>, intentionally or otherwise, while it is <link xlink:type="simple" xlink:href="../206/418206.xml">
executing</link>.<p>

Self-modifying code is quite straightforward to write when using <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly language</link> (taking into account the CPU <link xlink:type="simple" xlink:href="../181/849181.xml">
cache</link>). It is also supported by some high level language <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreters</link> such as <link xlink:type="simple" xlink:href="../515/29515.xml">
SNOBOL4</link>, the <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp programming language</link>, or the ALTER verb in <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link>.  It is more difficult to implement on <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>s but compilers such as <link xlink:type="simple" xlink:href="../367/246367.xml">
Clipper</link> and <link>
Spitbol</link> make a fair attempt at it, and COBOL almost encourages it. One <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../030/15264030.xml">
batch</link></format>
 programming technique is to use self-modifying code<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. Most <link xlink:type="simple" xlink:href="../524/29524.xml">
scripting languages</link> such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 are interpreted, which means that the program can generate new code and execute it; usually, this is done in a <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>, but it can also be performed by writing out a new file and running it in the scripting language interpreter.</p>

<sec>
<st>
Usage </st>

<p>

Self-modifying code can be used for various purposes:</p>
<p>

<list>
<entry level="1" type="number">

Semi-automatic <link xlink:type="simple" xlink:href="../779/225779.xml">
optimization</link> of a state dependent loop.</entry>
<entry level="1" type="number">

<platform wordnetid="103961939" confidence="0.8">
<structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../263/192263.xml">
Runtime</link></room>
</library>
</horizontal_surface>
</area>
</surface>
</artifact>
</structure>
</platform>
 code generation, or specialization of an algorithm in runtime or loadtime (which is popular, for example, in the domain of real-time graphics) such as a general sort utility preparing code to perform the key comparison described in a specific invocation.</entry>
<entry level="1" type="number">

Altering of <link xlink:type="simple" xlink:href="../330/428330.xml">
inlined</link> state of an <link xlink:type="simple" xlink:href="../665/169665.xml">
object</link>, or simulating the high-level construction of <link xlink:type="simple" xlink:href="../319/62319.xml">
closures</link>.</entry>
<entry level="1" type="number">

Patching of <link xlink:type="simple" xlink:href="../988/40988.xml">
subroutine</link> address calling, as done usually at load time of <link>
dynamic libraries</link>, or, on each invocation patching the subroutine's internal references to its parameters so as to use their actual addresses.  Whether this is regarded as 'self-modifying code' or not is a case of <link xlink:type="simple" xlink:href="../476/430476.xml">
terminology</link>.</entry>
<entry level="1" type="number">

Evolutionary computing systems such as <link xlink:type="simple" xlink:href="../424/12424.xml">
genetic programming</link>.</entry>
<entry level="1" type="number">

Hiding of code to prevent <link xlink:type="simple" xlink:href="../488/18935488.xml">
reverse engineering</link>, as through use of a <link xlink:type="simple" xlink:href="../390/54390.xml">
disassembler</link> or <link xlink:type="simple" xlink:href="../485/50485.xml">
debugger</link>.</entry>
<entry level="1" type="number">

Hiding of code to evade detection by virus/spyware scanning software and the like.</entry>
<entry level="1" type="number">

Filling 100% of memory (in some architectures) with a rolling pattern of repeating <link xlink:type="simple" xlink:href="../470/230470.xml">
opcodes</link>, to erase all programs and data, or to <link xlink:type="simple" xlink:href="../745/1306745.xml">
burn-in</link> hardware.</entry>
<entry level="1" type="number">

<link xlink:type="simple" xlink:href="../013/8013.xml">
Compression</link> of code to be decompressed and executed at runtime, e.g., when memory or disk space is limited.</entry>
<entry level="1" type="number">

Some very limited <link xlink:type="simple" xlink:href="../772/47772.xml">
instruction sets</link> leave no option but to use self-modifying code to achieve certain functionality. For example, a <link xlink:type="simple" xlink:href="../713/151713.xml">
"One Instruction Set Computer"</link> machine that uses only the subtract-and-branch-if-negative "instruction" cannot do an indirect copy (something like the equivalent of "*a = **b" in the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
) without using self-modifying code.</entry>
<entry level="1" type="number">

Altering instructions for fault-tolerance</entry>
</list>
</p>
<p>

The second and third types are probably the kinds mostly used also in high-level languages, such as <link xlink:type="simple" xlink:href="../016/18016.xml">
LISP</link>.</p>

<ss1>
<st>
Optimizing a state-dependent loop</st>
<p>

<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
 example:</p>
<p>

repeat N times {
if STATE is 1
increase A by one
else
decrease A by one</p>
<p>

do something with A
}</p>
<p>

Self-modifying code in this case would simply be a matter of rewriting the loop like this:</p>
<p>

repeat N times {</p>
<p>

<it>increase</it> A by one
do something with A
}</p>
<p>

when STATE has to switch {
replace the opcode "increase" above with the opcode to decrease
}</p>
<p>

Note that 2-state replacement of the <link xlink:type="simple" xlink:href="../470/230470.xml">
opcode</link> can be easily written as
'xor var at address with the value "opcodeOf(Inc) xor opcodeOf(dec)"'.</p>
<p>

Choosing this solution will have to depend of course on the value of 'N' and the frequency of state changing.</p>

</ss1>
<ss1>
<st>
Attitudes </st>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_content.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This article or section contains </b>, vague phrasing that often accompanies  or  information. Such statements should be .</col>
</row>
</table>

</p>
<p>

Self-modifying code can either be seen as a feature like any other (or even as just <it>delayed code-editing</it>), or as a bad practice which makes code harder to read and maintain.</p>
<p>

In the early days of computers, self-modifying code was used often in order to reduce the usage of memory, which was extremely limited, and didn't pose any problem. It was also used to implement subroutine calls and returns when the instruction set only provided simple branching or skipping instructions to vary the <link xlink:type="simple" xlink:href="../459/45459.xml">
control flow</link>. This application is still relevant in certain ultra-<link xlink:type="simple" xlink:href="../672/3963672.xml">
RISC</link> architectures, at least theoretically; see for example <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../713/151713.xml">
One instruction set computer</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
. <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
's <link xlink:type="simple" xlink:href="../236/173236.xml">
MIX</link> architecture also used self-modifying code to implement subroutine calls.</p>
<p>

Already, critical systems which are too complex for people to fully manage in real time, such as the <link xlink:type="simple" xlink:href="../539/14539.xml">
Internet</link> and <link xlink:type="simple" xlink:href="../824/38824.xml">
electrical distribution networks</link> routinely rely upon self-modifying behaviors (though not necessarily self-modifying code) in order to function acceptably.</p>

</ss1>
<ss1>
<st>
Use as camouflage</st>
<p>

Self-modifying code was used to hide copy protection instructions in 1980s disk based programs for platforms such as <link xlink:type="simple" xlink:href="../032/15032.xml">
IBM PC</link> and <link xlink:type="simple" xlink:href="../ury/22nd_century.xml">
Apple II</link>. For example, on an IBM PC (or <link xlink:type="simple" xlink:href="../803/49803.xml">
compatible</link>), the <link xlink:type="simple" xlink:href="../891/10891.xml">
floppy disk</link> drive access instruction '<link xlink:type="simple" xlink:href="../289/15289.xml">
int</link> 0x13' would not appear in the executable program's image but it would be written into the executable's memory image after the program started executing.</p>
<p>

Self-modifying code is also sometimes used by programs that do not want to reveal their presence &mdash; such as <link xlink:type="simple" xlink:href="../196/18994196.xml">
computer virus</link>es and some <link xlink:type="simple" xlink:href="../067/218067.xml">
shellcode</link>s. Viruses and shellcodes that use self-modifying code mostly do this in combination with <link xlink:type="simple" xlink:href="../447/218447.xml">
polymorphic code</link>. Polymorphic viruses are sometimes called primitive self-mutators. Modifying a piece of running code is also used in certain attacks, such as <link xlink:type="simple" xlink:href="../373/4373.xml">
buffer overflow</link>s.</p>

</ss1>
<ss1>
<st>
Self-referential machine learning systems</st>

<p>

Traditional <link xlink:type="simple" xlink:href="../488/233488.xml">
machine learning</link> systems have a fixed, pre-programmed learning <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> to adjust their <link xlink:type="simple" xlink:href="../065/25065.xml">
parameters</link>. However, since the 1980s <link>
Jürgen Schmidhuber</link> has published several self-modifying systems with the ability to change their own learning algorithm. They avoid the danger of catastrophic self-rewrites by making sure that self-modifications will survive only if they are useful according to a user-given <link xlink:type="simple" xlink:href="../285/412285.xml">
fitness function</link> or <link xlink:type="simple" xlink:href="../111/177111.xml">
error function</link> or <link xlink:type="simple" xlink:href="../573/2352573.xml">
reward</link> function.</p>

</ss1>
<ss1>
<st>
Operating systems </st>
<p>

Because of the security implications of self-modifying code, all of the major <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s are careful to remove such vulnerabilities as they become known. The concern is typically not that programs will intentionally modify themselves, but that they could be maliciously changed by an <accomplishment wordnetid="100035189" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<feat wordnetid="100036762" confidence="0.8">
<link xlink:type="simple" xlink:href="../875/9875.xml">
exploit</link></feat>
</psychological_feature>
</act>
</action>
</event>
</accomplishment>
.</p>
<p>

As consequence of the troubles that can be caused by these exploits, an OS feature called <link xlink:type="simple" xlink:href="../113/1157113.xml">
W^X</link> (for "write <link xlink:type="simple" xlink:href="../979/105979.xml">
xor</link> execute") has been developed which prohibits a program from making any page of memory both writable and executable. Some systems prevent a writable page from ever being changed to be executable, even if write permission is removed. Other systems provide a back door of sorts, allowing multiple mappings of a page of memory to have different permissions. A relatively portable way to bypass W^X is to create a file with all permissions, then map the file into memory twice. On Linux, one may use an undocumented SysV shared memory flag to get executable shared memory without needing to create a file. On Windows Vista and Windows XP the W^X protection is named <link xlink:type="simple" xlink:href="../836/2225836.xml">
Data Execution Prevention</link> and can be disabled via the Control Panel.</p>
<p>

Regardless, at a <link xlink:type="simple" xlink:href="../814/1018814.xml">
meta-level</link>, programs can still modify their own behavior by changing data stored elsewhere (see <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../460/393460.xml">
Metaprogramming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
) or via use of <link xlink:type="simple" xlink:href="../869/23869.xml">
polymorphism</link>.</p>

</ss1>
<ss1>
<st>
Just-in-time compilers</st>
<p>

<link xlink:type="simple" xlink:href="../632/220632.xml">
Just-in-time</link> compilers for <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, <link>
.NET</link>, <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../691/519691.xml">
ActionScript 3.0</link></format>
 and other <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s compile blocks of <link xlink:type="simple" xlink:href="../997/89997.xml">
byte-code</link> or <link xlink:type="simple" xlink:href="../722/24722.xml">
p-code</link> into machine code suitable for the host processor and then immediately execute them. Fabrice Bellard's <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/3538024.xml">
Tiny C Compiler</link></writer>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
 can and has been used as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
-Just-in-Time-Compiler-Library, e.g. by TCCBOOT (a bootloader that can compile, load and run its operation system on-the-fly).</p>
<p>

Graphics drivers for modern GPUs perform JIT-Compilation of DirectX or OpenGL/<structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/2152476.xml">
GLSL</link></room>
</library>
</area>
</artifact>
</structure>
 geometry and fragment shaders, and can thus be seen as self-modifying code, sometimes distributed over multiple processors and DSPs (or even self-modifying hardware).</p>
<p>

Some CPU Architecture Emulators use similar techniques as JIT-Compilers (simulated instruction set as "programming language" that becomes compiled for the target processor).</p>

</ss1>
<ss1>
<st>
Interaction of cache and self-modifying code</st>
<p>

On architectures without coupled data and instruction cache (some ARM and MIPS cores) the cache synchronization must be explicitly performed by the modifying code (flush data cache and invalidate instruction cache for the modified memory area).</p>
<p>

In some cases short sections of self-modifying code executes more slowly on modern processors. This is because a modern processor will usually try to keep blocks of code in its cache memory. Each time the program rewrites a part of itself, the rewritten part must be loaded into the cache again, which results in a slight delay, if the modified codelet shares the same cache line with the modifying code, as is the case when the modified memory address is located within a few bytes to the one of the modifying code.</p>
<p>

The cache invalidation issue on modern processors usually means that self-modifying code would still be faster only when the modification will occur rarely, such as in the case of a state switching inside an inner loop.</p>
<p>

Most modern processors load the machine code before they execute it, which means that if an instruction that is too near the <link xlink:type="simple" xlink:href="../944/59944.xml">
instruction pointer</link> is modified, the processor will not notice, but instead execute the code as it was <it>before</it> it was modified. See <link xlink:type="simple" xlink:href="../822/439822.xml">
Prefetch Input Queue</link> (PIQ). PC processors have to handle self-modifying code correctly for backwards compatibility reasons but they are far from efficient at doing so.</p>

</ss1>
<ss1>
<st>
Henry Massalin's Synthesis kernel</st>
<p>

The Synthesis <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link> written by Dr. <link xlink:type="simple" xlink:href="../942/13637942.xml">
Henry Massalin</link> as his <degree wordnetid="105093890" confidence="0.8">
<property wordnetid="104916342" confidence="0.8">
<link xlink:type="simple" xlink:href="../775/8775.xml">
Ph.D.</link></property>
</degree>
 thesis is commonly viewed to be the "mother of all self-modifying code."  Massalin's tiny <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 kernel takes a <link xlink:type="simple" xlink:href="../695/27695.xml">
structured</link>, or even <link xlink:type="simple" xlink:href="../757/22757.xml">
object oriented</link>, approach to self-modifying code, where code is created for individual <link xlink:type="simple" xlink:href="../060/3821060.xml">
quaject</link>s, like filehandles; generating code for specific tasks allows the Synthesis kernel to (as a JIT interpreter might) apply a number of <link xlink:type="simple" xlink:href="../355/40355.xml">
optimizations</link> such as <link xlink:type="simple" xlink:href="../347/113347.xml">
constant folding</link> or <link xlink:type="simple" xlink:href="../794/547794.xml">
common subexpression elimination</link>. </p>
<p>

The Synthesis kernel was extremely fast, but was written entirely in assembly. The resulting lack of portability has prevented Massalin's optimization ideas from being adopted by any production kernel. However, the structure of the techniques suggests that they could be captured by a higher level <link xlink:type="simple" xlink:href="../015/23015.xml">
language</link>, albeit one more complex than existing mid-level languages. Such a language and compiler could allow development of extremely fast operating systems and applications.</p>
<p>

Paul Haeberli and Bruce Karsh have objected to the "marginalization" of self-modifying code, and optimization in general, in favor of reduced development costs, drawing a parallel to the "heavy religious atmosphere" which the <link xlink:type="simple" xlink:href="../846/230846.xml">
Italian Futurist</link> movement rebelled against.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../905/314905.xml">
Reflection (computer science)</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../549/29549.xml">
Self-replication</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../270/25270.xml">
Quine (computing)</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www.csd.net/~cgadd/knowbase/DOS0019.HTM">
Self-modifying Batch File</weblink> by Lars Fosdal</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://asm.sourceforge.net/articles/smc.html">
Using self-modifying code under Linux</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://public.carnet.hr/~jbrecak/sm.html">
Self-modifying C code</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.columbia.edu/~library/TR-repository/reports/reports-1992/cucs-039-92.ps.gz">
"Synthesis: An Efficient Implementation of Fundamental Operating System Services"</weblink>: Henry Massalin's Ph.D. thesis on the Synthesis kernel</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.graficaobscura.com/future/index.html">
Futurist Programming</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://flint.cs.yale.edu/flint/publications/smc.html">
Certified Self-Modifying Code</weblink></entry>
<entry level="1" type="bullet">

<link>
Jürgen Schmidhuber</link>'s  publications on <weblink xlink:type="simple" xlink:href="http://www.idsia.ch/~juergen/metalearner.html">
self-modifying code for self-referential machine learning systems</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.pcosmos.ca/pcastl/">
PCASTL: by Parent and Childset Accessible Syntax Tree Language</weblink></entry>
</list>
</p>


</sec>
</bdy>
</grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</article>
