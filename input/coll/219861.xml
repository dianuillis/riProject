<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:33:43[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>In-place algorithm</title>
<id>219861</id>
<revision>
<id>234621172</id>
<timestamp>2008-08-27T18:39:17Z</timestamp>
<contributor>
<username>SpBot</username>
<id>7016748</id>
</contributor>
</revision>
<categories>
<category>Algorithms</category>
</categories>
</header>
<bdy>

"In-place" redirects here. For execute in place <link xlink:type="simple" xlink:href="../280/1010280.xml">
file system</link>s, see <link xlink:type="simple" xlink:href="../152/2234152.xml">
execute in place</link>.<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, an <b>in-place algorithm</b> (or in <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../730/17730.xml">
Latin</link></language>
 <b>in situ</b>) is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> which transforms a <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link> using a small, constant amount of extra storage space. The input is usually overwritten by the output as the algorithm executes. An algorithm which is not in-place is sometimes called <b>not-in-place</b> or <b>out-of-place</b>.</p>
<p>

An algorithm is sometimes informally called in-place as long as it overwrites its input with its output. In reality this is not sufficient (as the case of quicksort demonstrates) nor is it necessary; the output space may be constant, or may not even be counted, for example if the output is to a stream. On the other hand, sometimes it may be more practical to count the output space in determining whether an algorithm is in-place, such as in the first reverse example below; this makes it difficult to strictly define in-place algorithms. In theory applications such as <link xlink:type="simple" xlink:href="../850/1174850.xml">
log-space reduction</link>s, it's more typical to always ignore output space (in these cases it's more essential that the output is <it>write-only</it>). </p>

<sec>
<st>
 Examples </st>

<p>

Suppose we want to reverse an <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link> of <it>n</it> items. One simple way to do this is:</p>
<p>

<b>function</b> reverse(a[0..n])
allocate b[0..n]
<b>for</b> i <b>from</b> 0 <b>to</b> n
b[n - i] = a[i]
<b>return</b> b</p>
<p>

Unfortunately, this requires O(<it>n</it>) space to create the array <it>b</it>, and allocation is often a slow operation. If we no longer need <it>a</it>, we can instead overwrite it with its own reversal using this in-place algorithm:</p>
<p>

<b>function</b> reverse-in-place(a[0..n])
<b>for</b> i <b>from</b> 0 <b>to</b> floor(n/2)
swap(a[i], a[n-i])</p>
<p>

As another example, there are a number of <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>s that can rearrange <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>s into sorted order in-place, including: <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../255/4255.xml">
Bubble sort</link></algorithm>
, <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../439/159439.xml">
Comb sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
, <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../352/29352.xml">
Selection sort</link></algorithm>
, <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../205/15205.xml">
Insertion sort</link></algorithm>
, <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../995/13995.xml">
Heapsort</link></algorithm>
, <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../355/77355.xml">
Shell sort</link></database>
</kind>
</wordnet>
</lexical_database>
</category>
</concept>
</electronic_database>
</idea>
</information>
</message>
.</p>
<p>

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../249/3268249.xml">
Quicksort</link></algorithm>
 is commonly described as an in-place algorithm, but is not in fact one. Most implementations require O(log <it>n</it>) space to support its <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer</link> recursion.</p>
<p>

Most <link xlink:type="simple" xlink:href="../786/552786.xml">
selection algorithm</link>s are also in-place, although some considerably rearrange the input
array in the process of finding the final, constant-sized result.</p>
<p>

Some text manipulation algorithms such as <work wordnetid="100575741" confidence="0.8">
<examination wordnetid="100635850" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<investigation wordnetid="100633864" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<comparison wordnetid="100142665" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../246/4496246.xml">
trim</link></algorithm>
</activity>
</comparison>
</procedure>
</psychological_feature>
</act>
</investigation>
</rule>
</event>
</examination>
</work>
 and reverse may be done in-place.</p>

</sec>
<sec>
<st>
 In computational complexity </st>

<p>

In <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, in-place algorithms include all algorithms with O(1) space complexity, the class <link>
<b>DSPACE</b></link>(1). This class is very limited; it equals the <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> In fact, it does not even include any of the examples listed above.</p>
<p>

For this reason, we also consider algorithms in <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../999/1149999.xml">
L</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
, the class of problems requiring O(log <it>n</it>) additional space, to be in-place. Although this seems to contradict our earlier definition, we have to consider that in the abstract world our input can be arbitrarily large. On a real computer, a <link xlink:type="simple" xlink:href="../018/459018.xml">
pointer</link> requires only a small fixed amount of space, because the amount of physical memory is limited, but in general O(log <it>n</it>) bits are required to specify an index into a list of size <it>n</it>.</p>
<p>

Does this mean quicksort is in-place after all? Not at all—technically, it requires O(log2 <it>n</it>) space, since each of its O(log <it>n</it>) stack frames contains a constant number of pointers (each of size O(log <it>n</it>)).</p>
<p>

Identifying the in-place algorithms with L has some interesting implications; for example, it means that there is a (rather complex) in-place algorithm to determine whether a path exists between two nodes in an <link xlink:type="simple" xlink:href="../806/325806.xml">
undirected graph</link>,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> a problem that requires O(<it>n</it>) extra space using typical algorithms such as <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link> (a visited bit for each node). This in turn yields in-place algorithms for problems such as determining if a graph is <link xlink:type="simple" xlink:href="../431/244431.xml">
bipartite</link> or testing whether two graphs have the same number of <link xlink:type="simple" xlink:href="../223/246223.xml">
connected component</link>s. See <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../919/1174919.xml">
SL</link></group>
</collection>
</class>
 for more information.</p>

</sec>
<sec>
<st>
 Role of randomness </st>

<p>

In many cases, the space requirements for an algorithm can be drastically cut by using a <link xlink:type="simple" xlink:href="../383/495383.xml">
randomized algorithm</link>. For example, say we wish to know if two vertices in a graph of <it>n</it> vertices are in the same <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../223/246223.xml">
connected component</link></part>
</component>
</concept>
</idea>
 of the graph. There is no known simple, deterministic, in-place algorithm to determine this, but if we simply start at one vertex and perform a <link xlink:type="simple" xlink:href="../451/235451.xml">
random walk</link> of about 20<it>n</it>3 steps, the chance that we will stumble across the other vertex provided that it's in the same component is very high. Similarly, there are simple randomized in-place algorithms for primality testing such as the <region wordnetid="108630985" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../999/188999.xml">
Miller-Rabin primality test</link></higher_cognitive_process>
</trial>
</geographical_area>
</experiment>
</problem_solving>
</tract>
</location>
</thinking>
</inquiry>
</field>
</process>
</region>
, and there are also simple in-place randomized factoring algorithms such as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. See <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../581/1176581.xml">
RL</link></group>
</collection>
</class>
 and <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../708/18449708.xml">
BPL</link></group>
</collection>
</class>
 for more discussion of this phenomenon.</p>

</sec>
<sec>
<st>
 In functional programming </st>

<p>

<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
Functional programming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 languages often discourage or don't support explicit in-place algorithms that overwrite data, since this is a type of <link xlink:type="simple" xlink:href="../519/29519.xml">
side effect</link>; instead, they only allow new data to be constructed. However, good functional language compilers will often recognize when an object very similar to an existing one is created and then the old one thrown away, and will optimize this into a simple mutation "under-the-hood".</p>
<p>

Note that it is possible in principle to carefully construct in-place algorithms that don't modify data (unless the data is no longer being used), but this is rarely done in practice.  See <link xlink:type="simple" xlink:href="../375/468375.xml">
purely functional data structure</link>s.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../442/28442.xml#xpointer(//*[./st=%22List+of+sorting+algorithms%22])">
Table of in-place and not-in-place algorithms</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
Maciej Liśkiewicz and Rüdiger Reischuk. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/34203.html">
The Complexity World below Logarithmic Space</weblink>. <it>Structure in Complexity Theory Conference</it>, pp. 64-78. 1994. Online: p. 3, Theorem 2.</entry>
<entry id="2">
Omer Reingold. <weblink xlink:type="simple" xlink:href="http://www.wisdom.weizmann.ac.il/~reingold/publications/sl.ps">
Undirected ST-connectivity in Log-Space</weblink>.  Electronic Colloquium on Computational Complexity. No. 94.</entry>
</reflist>
</p>


</sec>
</bdy>
</article>
