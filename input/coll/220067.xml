<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:32:44[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Standard streams</title>
<id>220067</id>
<revision>
<id>244163995</id>
<timestamp>2008-10-09T16:37:44Z</timestamp>
<contributor>
<username>EncMstr</username>
<id>551385</id>
</contributor>
</revision>
<categories>
<category>Unix</category>
<category>C programming language</category>
</categories>
</header>
<bdy>

<image location="right" width="150px" src="Stdstreams-notitle.svg" type="thumb">
<caption>

The standard streams for input, output, and error
</caption>
</image>

In <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 and <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../815/31815.xml">
Unix-like</link></family>
 operating systems, as well as certain <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> interfaces, the <b>standard streams</b> are preconnected input and output channels between a computer program and its environment (typically a <link xlink:type="simple" xlink:href="../402/249402.xml">
text terminal</link>) when it begins execution. The three <link xlink:type="simple" xlink:href="../558/14558.xml">
I/O</link> connections are called <b>standard input</b>, <b>standard output</b> and <b>standard error</b>.
<sec>
<st>
Background</st>
<p>

In most operating systems predating Unix, programs had to explicitly connect to the appropriate input and output data.  On many of those systems, this could be an intimidating programming challenge created by OS-specific intricacies such as obtaining control environment settings, accessing a local file table, determining the intended data set, and handling the correct case of a card reader, magnetic tape drive, disk drive, line printer, card punch, or interactive terminal.</p>
<p>

Unix provided several groundbreaking advances, one of which was to provide <it>abstract devices</it>:  it removed the need for a program to know or care what kind of devices it was communicating with.  Older operating systems forced upon the programmer a record structure and, frequently <link xlink:type="simple" xlink:href="../221/102221.xml#xpointer(//*[./st=%22Computer+science%22])">
non-orthogonal</link> data semantics and device control.  Unix eliminated this complexity with the concept of a data stream:  an ordered sequence of data bytes which can be read until the <link xlink:type="simple" xlink:href="../322/342322.xml">
end of file</link>.  A program may also write bytes as desired and need not (and can't easily) declare how many there will be, or how they will be grouped.</p>
<p>

Another Unix breakthrough was to automatically associate input and output by default—the program (and programmer) did absolutely nothing to establish input and output for a typical input-process-output program (unless it chose a different paradigm).  In contrast, previous operating systems usually required some—often complex—<link xlink:type="simple" xlink:href="../487/391487.xml">
job control language</link> to establish connections, or the equivalent burden had to be orchestrated by the program.</p>
<p>

Since Unix provided standard streams, the Unix C runtime environment was obligated to support it as well.  As a result, most C runtime environments (and C's descendants), regardless of the operating system, provide equivalent functionality.</p>

</sec>
<sec>
<st>
Standard input (stdin)</st>
<p>

Standard input is data (often text) going into a program.  The program requests data transfers by use of the <it>read</it> operation.  Not all programs require input.  For example, the <it>dir</it> or <it>ls</it> program (which displays file names contained in a directory) performs its operation without any stream data input.</p>
<p>

Unless <link xlink:type="simple" xlink:href="../829/607829.xml">
redirected</link>, input is expected from the <link>
text keyboard</link> which started the program.</p>
<p>

The <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link> for standard input is 0 (zero); the corresponding <b>' variable is FILE* stdin; similarly, the </b>' variable is std::cin.</p>

</sec>
<sec>
<st>
Standard output (stdout)</st>
<p>

Standard output is the stream where a program writes its output data.  The program requests data transfer with the <it>write</it> operation.  Not all programs generate output.  For example the <it>file rename</it> command (variously called <it>mv</it>, <it>move</it>, <it>ren</it>) is silent on success.</p>
<p>

Unless <link xlink:type="simple" xlink:href="../829/607829.xml">
redirected</link>, standard output is the <link xlink:type="simple" xlink:href="../402/249402.xml">
text terminal</link> which initiated the program.</p>
<p>

The <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link> for standard output is 1 (one); the corresponding <b>' variable is FILE* stdout; similarly, the </b>' variable is std::cout.</p>

</sec>
<sec>
<st>
Standard error (stderr)</st>
<p>

Standard error is another output stream typically used by programs to output <link xlink:type="simple" xlink:href="../502/3388502.xml">
error message</link>s or <link xlink:type="simple" xlink:href="../525/18507525.xml">
diagnostic</link>s.  It is a stream independent of standard output and can be redirected separately.  The usual destination is the <link xlink:type="simple" xlink:href="../402/249402.xml">
text terminal</link> which started the program to provide the best chance of being seen even if <it>standard output</it> is redirected (so not readily observed). For example, output of a program in a <link xlink:type="simple" xlink:href="../117/1236117.xml">
pipeline</link> is redirected to input of the next program, but errors from each program still go directly to the text terminal.</p>
<p>

It is acceptable—and normal—for <it>standard output</it> and <it>standard error</it> to be directed to the same destination, such as the text terminal.  Messages appear in the same order as the program writes them, unless buffering is involved. (For example, a common situation is when the standard error stream is unbuffered but the standard output stream is line-buffered; in this case, text written to standard error later may appear on the terminal earlier, if the standard output stream's buffer is not yet full.)</p>
<p>

The <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link> for standard error is 2; the corresponding <b>' variable is FILE* stderr. The C++ </b>' standard header provides two variables associated with this stream: std::cerr and std::clog, the former being unbuffered and the latter using the same buffering mechanism as all other C++ streams.</p>
<p>

Most shells allow both <it>standard output</it> and <it>standard error</it> to be redirected to the same file using
&amp;gt;&amp; filename</p>
<p>

Bourne-style shells allow <it>standard error</it> to be redirected to the same destination that standard output is directed to using
2&amp;gt;&amp;1</p>

</sec>
<sec>
<st>
 Timeline </st>

<ss1>
<st>
 1950s: Fortran </st>
<p>

Fortran had the equivalent of Unix file descriptors, UNIT=5 for stdin, and UNIT=6 for stdout.</p>
<p>

! FORTRAN 77 example
PROGRAM MAIN
READ(UNIT=5,*)NUMBER
WRITE(UNIT=6,'(F5.3)')' NUMBER IS: ',NUMBER
END</p>



</ss1>
<ss1>
<st>
 1960: ALGOL 60</st>
<p>

<link xlink:type="simple" xlink:href="../878/692878.xml">
ALGOL 60</link> was criticized for having no standard file access. 
</p>
</ss1>
<ss1>
<st>
 1968: ALGOL 68</st>
<p>

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../880/692880.xml">
ALGOL 68</link></programming_language>
's input and output facilities were collectively referred to as the transput.  <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<link xlink:type="simple" xlink:href="../519/3265519.xml">
Koster</link></creator>
</originator>
</scientist>
</causal_agent>
</pioneer>
</person>
</physical_entity>
  coordinated the definition of the <it>transput</it> standard.  This standard included: stand in, stand out, stand error and stand back. </p>
<p>

Example: 
# ALGOL 68 example #
main:(
  REAL number;
  getf(stand in,($g$,number));
  printf(($"Number is: "g(6,4)"OR "$,number)); # OR #
  putf(stand out,($" Number is: "g(6,4)"!"$,number));
  newline(stand out)
)
<table>
<header align="left">
Input:</header>
<header align="left">
Output:</header>
<row>
<col>
3.14159</col>
<col>
Number is: +3.142 OR Number is: +3.142!</col>
</row>
</table>
</p>

</ss1>
<ss1>
<st>
 1970s: C and Unix </st>
<p>

In the <b><programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
</b> stdin, stdout and stderr streams were attached to the existing Unix file descriptors 0, 1 and 2 respectively.</p>

</ss1>
<ss1>
<st>
1995: Java </st>
<p>

In <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, the standard streams are referred to by <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#in">
System.in</weblink> (for stdin), <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#out">
System.out</weblink> (for stdout), and  <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#err">
System.err</weblink> (for stderr).</p>
<p>

public static void main(String args) {
try {
BufferedReader br = 
new BufferedReader(new InputStreamReader(System.in));
String s = br.readLine();
double number = double.Parse(s);
System.out.println("Number is:", number);
} catch (Exception e) {
System.err.println("Error:" + e.getMessage());
}
}</p>


</ss1>
<ss1>
<st>
2000s: .NET </st>
<p>

In <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 and other <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/60402.xml">
.NET</link></implement>
</horizontal_surface>
</tool>
</instrumentality>
</surface>
</artifact>
</platform>
 languages, the standard streams are referred to by System.Console (for stdin and stdout) and System.Console.Error (for stderr).</p>
<p>

// C# example
public static int Main()
{
double number;
string s;</p>
<p>

try
{
s = System.Console.ReadLine();
number = double.Parse(s);
System.Console.WriteLine("Number is: {0:F3}", number);
return 0;
}
catch (System.FormatException e)
{
// if Parse() threw an exception
System.Console.Error.WriteLine("No number was entered!");
return 1;
}
}</p>


<p>

' Visual Basic .NET example</p>
<p>

Public Function Main() As Integer
Dim number As Double
Dim s As String</p>
<p>

Try
s = System.Console.ReadLine()
number = CDbl(s)
System.Console.WriteLine("Number is: {0:F3}", number)
Return 0
Catch e As System.InvalidCastException
' if CDbl() threw an exception
System.Console.Error.WriteLine("No number was entered!")
Return 1
End Try
End Function</p>


</ss1>
<ss1>
<st>
GUIs</st>
<p>

<link xlink:type="simple" xlink:href="../293/12293.xml">
Graphical user interface</link>s (GUIs) rarely make use of the standard streams.  Consequently, redirecting GUI programs or constructing a GUI pipeline is neither practical nor useful.  The nearest analog is probably <it>cutting</it> (or <it>copying</it>) from one application and <it>pasting</it> into another.  Since manual user operations are required, moving large numbers of <it>pastes</it> is not especially efficient. One notable exception is the <link xlink:type="simple" xlink:href="../714/7108714.xml">
dwm</link> <link xlink:type="simple" xlink:href="../103/2652103.xml">
tiling window manager</link>, which displays data directed through stdin on a status bar.</p>
<p>

Some GUI programs, primarily on Unix, still write debug information to standard error.</p>
<p>

<link xlink:type="simple" xlink:href="../420/19176420.xml">
GTK-server</link> can use stdin as communication interface with an interpreted program to realize a GUI.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../829/607829.xml">
Redirection (Unix)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../117/1236117.xml">
Pipeline (Unix)</link></entry>
<entry level="1" type="bullet">

 <information wordnetid="105816287" confidence="0.8">
<datum wordnetid="105816622" confidence="0.8">
<link xlink:type="simple" xlink:href="../533/2761533.xml">
Stream (computing)</link></datum>
</information>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../558/14558.xml">
Input/output</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../766/238766.xml">
C file input/output</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <it>KRONOS 2.1 Reference Manual</it>, Control Data Corporation, Part Number 60407000, 1974</entry>
<entry level="1" type="bullet">

 <it>NOS Version 1 Applications Programmer's Instant</it>, Control Data Corporation, Part Number 60436000, 1978</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.bitsavers.org/pdf/honeywell/multics/AG90-03_PgmgIntro_Dec81.pdf">
Level 68 Introduction to Programming on MULTICS</weblink>, Honeywell Corporation, 1981</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.research.ibm.com/journal/rd/255/auslander.pdf">
Evolution of the MVS Operating System</weblink>, IBM Corporation, 1981</entry>
<entry level="1" type="bullet">

 <it>Lions' Commentary on UNIX Sixth Edition</it>, John Lions, ISBN 1-57398-013-7, 1977</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/system.console.aspx">
Console Class, .NET Framework Class Library</weblink>, Microsoft Corporation, 2008</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.linfo.org/standard_output.html">
Standard Output Definition</weblink> - by The Linux Information Project (LINFO)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://compsecblog.bruceblacklaws.com/2008/07/redirect-stdout-and-stderr.html">
Video tutorial demonstrating stdout and stderr</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
