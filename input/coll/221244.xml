<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:32:12[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<condition  confidence="0.8" wordnetid="113920835">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<state  confidence="0.8" wordnetid="100024720">
<problem  confidence="0.8" wordnetid="114410605">
<difficulty  confidence="0.8" wordnetid="114408086">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Bellman-Ford algorithm</title>
<id>221244</id>
<revision>
<id>243853939</id>
<timestamp>2008-10-08T09:55:01Z</timestamp>
<contributor>
<username>Danny</username>
<id>584</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Wikipedia articles needing clarification</category>
<category>Articles with example C code</category>
<category>Graph algorithms</category>
<category>Polynomial-time problems</category>
</categories>
</header>
<bdy>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>
<p>

The <b>Bellmanâ€“Ford algorithm</b>, a label correcting algorithm<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, computes single-source <link xlink:type="simple" xlink:href="../985/41985.xml">
shortest path</link>s in a <link xlink:type="simple" xlink:href="../986/19721986.xml">
weighted digraph</link> (where some of the <link>
edge</link> weights may be negative).  <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 solves the same problem with a lower running time, but requires edge weights to be non-negative.  Thus, Bellmanâ€“Ford is usually used only when there are negative edge weights.</p>
<p>

According to <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../503/235503.xml">
Robert Sedgewick</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, "Negative weights are not merely a mathematical curiosity; [...] [they] arise in a natural way when we reduce other problems to shortest-paths problems"<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>, and he gives the specific example of a <link xlink:type="simple" xlink:href="../067/848067.xml">
reduction</link> from the <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 <link xlink:type="simple" xlink:href="../646/149646.xml">
Hamilton path problem</link> to the shortest paths problem with general weights. If a graph contains a cycle of total negative weight then arbitrarily low weights are achievable and so there's no solution; Bellman-Ford detects this case.</p>
<p>

If the graph does contain a cycle of negative weights, Bellman-Ford can only detect this; Bellman-Ford cannot find the shortest path that does not repeat any vertex in such a graph. This problem is at least as hard as the NP-complete <link xlink:type="simple" xlink:href="../567/18757567.xml">
longest path problem</link>.</p>

<sec>
<st>
 Algorithm </st>

<p>

Bellman-Ford is in its basic structure very similar to <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, but instead of greedily selecting the minimum-weight node not yet processed to relax, it simply relaxes <it>all</it> the edges, and does this |V|&nbsp;&amp;minus;&nbsp;1 times, where |V| is the number of vertices in the graph. The repetitions allow minimum distances to accurately propagate throughout the graph, since, in the absence of negative cycles, the shortest path can only visit each node at most once. Unlike the greedy approach, which depends on certain structural assumptions derived from positive weights, this straightforward approach extends to the general case.</p>
<p>

Bellmanâ€“Ford runs in <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link></it>(<it>|V|</it>Â·<it>|E|</it>) time, where <it>|V|</it> and <it>|E|</it> are the number of vertices and edges respectively.</p>
<p>

<b>procedure</b> BellmanFord(<it>list</it> vertices, <it>list</it> edges, <it>vertex</it> source)
<it>// This implementation takes in a graph, represented as lists of vertices</it>
<it>// and edges, and modifies the vertices so that their </it>distance<it> and</it>
<it>//</it> predecessor <it>attributes store the shortest paths.</it></p>
<p>

<it>// Step 1: Initialize graph</it>
<b>for each</b> vertex v in vertices:
<b>if</b> v <b>is</b> source <b>then</b> v.distance := 0
<b>else</b> v.distance := <b>infinity</b>
v.predecessor := <b>null</b></p>
<p>

<it>// Step 2: relax edges repeatedly</it>
<b>for</b> i <b>from</b> 1 <b>to</b> size(vertices)-1:       
<b>for each</b> edge uv in edges:
u := uv.source
v := uv.destination             <it>// uv is the edge from u to v</it>
<b>if</b> v.distance &amp;gt; u.distance + uv.weight:
v.distance := u.distance + uv.weight
v.predecessor := u</p>
<p>

<it>// Step 3: check for negative-weight cycles</it>
<b>for each</b> edge uv in edges:
u := uv.source
v := uv.destination
<b>if</b> v.distance &amp;gt; u.distance + uv.weight:
<b>error</b> "Graph contains a negative-weight cycle"</p>

</sec>
<sec>
<st>
 Proof of correctness </st>

<p>

The correctness of the algorithm can be shown by <link xlink:type="simple" xlink:href="../881/18881.xml">
induction</link>. The precise statement shown by induction is:</p>
<p>

<b>Lemma</b>. After <it>i</it> repetitions of <it>for</it> cycle:
<list>
<entry level="1" type="bullet">

 If Distance(u) is not infinity, it is equal to the length of some path from <it>s</it> to <it>u</it>;</entry>
<entry level="1" type="bullet">

 If there is a path from <it>s</it> to <it>u</it> with at most <it>i</it> edges, then Distance(u) is at most the length of the shortest path from <it>s</it> to <it>u</it> with at most <it>i</it> edges.</entry>
</list>
</p>
<p>

<b>Proof</b>. For the base case of induction, consider i=0 and the moment before <it>for</it> cycle is executed for the first time. Then, for the source vertex,  source.distance = 0, which is correct. For other vertices <it>u</it>, u.distance = <b>infinity</b>, which is also correct because there is no path from <it>source</it> to <it>u</it> with 0 edges.</p>
<p>

For the inductive case, we first prove the first part. Consider a moment when a vertex's distance is updated by 
v.distance := u.distance + uv.weight. By inductive assumption, u.distance is the length of some path from <it>source</it> to <it>u</it>. Then u.distance + uv.weight is the length of the path from <it>source</it> to <it>v</it> that follows the path from  <it>source</it> to <it>u</it> and then goes to <it>v</it>.</p>
<p>

For the second part, consider the shortest path from <it>source</it> to <it>u</it> with at most <it>i</it> edges. Let <it>v</it> be the last vertex before <it>u</it> on this path. Then, the part of the path from <it>source</it> to <it>v</it> is the shortest path from <it>source</it> to <it>v</it> with at most <it>i-1</it> edges. By inductive assumption, v.distance after <it>i-1</it> cycles is at most the length of this path. Therefore, uv.weight + v.distance is at most the length of the path from <it>s</it> to <it>u</it>. In the <it>ith</it> cycle, u.distance gets compared with uv.weight + v.distance, and is set equal to it if uv.weight + v.distance was smaller. Therefore, after <it>i</it> cycles, u.distance is at most the length of the shortest path from <it>source</it> to <it>u</it> that uses at most <it>i</it> edges.</p>
<p>

If there are no negative-weight cycles, then every shortest path visits each vertex at most once, so at step 3 no further improvements can be made. Conversely, suppose no improvement can be made. Then for any cycle with vertices v[0],..,v[k-1], </p>
<p>

v[i].distance = v[i-1 (mod k)].distance + v[i-1 (mod k)]v[i].weight</p>
<p>

Summing around the cycle, the v[i].distance terms and the v[i-1 (mod k)] distance terms cancel, leaving</p>
<p>

0 = sum from 1 to k of v[i-1 (mod k)]v[i].weight</p>
<p>

I.e., every cycle has nonnegative weight.</p>

</sec>
<sec>
<st>
 Applications in routing </st>

<p>

A distributed variant of Bellmanâ€“Ford algorithm is used in <link xlink:type="simple" xlink:href="../228/159228.xml">
distance-vector routing protocol</link>s, for example the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../389/43389.xml">
Routing Information Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 (RIP). The algorithm is distributed because it involves a number of nodes (routers) within an <link xlink:type="simple" xlink:href="../399/312399.xml">
Autonomous system</link>, a collection of IP networks typically owned by an ISP.
It consists of the following steps:</p>
<p>

<list>
<entry level="1" type="number">

Each node calculates the distances between itself and all other nodes within the AS and stores this information as a table.</entry>
<entry level="1" type="number">

Each node sends its table to all neighboring nodes.</entry>
<entry level="1" type="number">

When a node receives distance tables from its neighbors, it calculates the shortest routes to all other nodes and updates its own table to reflect any changes.</entry>
</list>
</p>
<p>

The main disadvantages of Bellmanâ€“Ford algorithm in this setting are
<list>
<entry level="1" type="bullet">

Does not scale well</entry>
<entry level="1" type="bullet">

Changes in <link xlink:type="simple" xlink:href="../413/41413.xml">
network topology</link> are not reflected quickly since updates are spread node-by-node.</entry>
<entry level="1" type="bullet">

Counting to <link xlink:type="simple" xlink:href="../455/15455.xml">
infinity</link> (if link or node failures render a node unreachable from some set of other nodes, those nodes may spend forever gradually increasing their estimates of the distance to it, and in the meantime there may be routing loops)</entry>
</list>
</p>

</sec>
<sec>
<st>
Implementation</st>
<p>

The following program implements the Bellmanâ€“Ford algorithm in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
.</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

/* Let INFINITY be an integer value not likely to be
confused with a real weight, even a negative one. */
<list>
<entry level="1" type="number">

define INFINITY ((1  14)-1)</entry>
</list>
</p>
<p>

typedef struct {
int source;
int dest;
int weight;
} Edge;</p>
<p>

void BellmanFord(Edge edges, int edgecount, int nodecount, int source)
{
int *distance = malloc(nodecount * sizeof *distance);
int i, j;</p>
<p>

for (i=0; i  nodecount; ++i)
distance[i] = INFINITY;
distance[source] = 0;</p>
<p>

for (i=0; i  nodecount; ++i) {
int nbChanges = 0; 
for (j=0; j  edgecount; ++j) {
if (distance[edges[j].source] != INFINITY) {
int new_distance = distance[edges[j].source] + edges[j].weight;
if (new_distance  distance[edges[j].dest]) {
distance[edges[j].dest] = new_distance;
nbChanges++; 
} 
}
}
if (nbChanges == 0) break; // if one iteration had no impact, further iterations will have no impact either
}</p>
<p>

for (i=0; i  edgecount; ++i) {
if (distance[edges[i].dest] &amp;gt; distance[edges[i].source] + edges[i].weight) {
puts("Negative edge weight cycles detected!");
free(distance);
return;
}
}</p>
<p>

for (i=0; i  nodecount; ++i) {
printf("The shortest distance between nodes %d and %d is %d\n",
source, i, distance[i]);
}</p>
<p>

free(distance);
return;
}</p>
<p>

int main(void)
{
/* This test case should produce the distances 2, 4, 7, -2, and 0. */
Edge edges[10] = ;
BellmanFord(edges, 10, 5, 4);
return 0;
}</p>


</sec>
<sec>
<st>
Yen's improvement</st>
<p>

In a 1970 publication, Yen<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> described an improvement to the Bellman-Ford algorithm for a graph without negative-weight cycles. Yen's improvement first assigns some arbitrary linear order on all vertices and then partitions the set of all edges into one of two subsets. The first subset, Ef, contains all edges (vi, vj) such that i  j; the second, Eb, contains edges (vi, vj) such that i &amp;gt; j. The edges of each vertex are then relaxed in the same arbitrary order,&#91;&#93; i.e. ascending for the set Ef and descending for the set Eb. Yen's improvement effectively halves the number of "passes" required for the single-source-shortest-path solution.</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Dimitri P. Bertsekas&#32;(March 1992).&#32;"<weblink xlink:type="simple" xlink:href="http://www.mit.edu/people/dimitrib/SLF.pdf">
A Simple and Fast Label Correcting Algorithm for Shortest Paths</weblink>".&#32;<it>Networks, Vol. 23, pp. 703-709, 1993</it>.&#32;Retrieved on <link>
2008-10-01</link>.</entry>
<entry id="2">
Robert Sedgewick. Algorithms in Java. Third Edition. ISBN 0-201-36121-3. Section 21.7: Negative Edge Weights. http://safari.oreilly.com/0201361213/ch21lev1sec7</entry>
<entry id="3">
Jin Y. Yen. "An algorithm for Finding Shortest Routes from all Source Nodes to a Given Destination in General Network", Quart. Appl. Math., 27, 1970, 526&ndash;530.</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../173/730173.xml">
Richard Bellman</link>: <it>On a Routing Problem</it>, in Quarterly of Applied Mathematics, 16(1), pp.87-90, 1958.</entry>
<entry level="1" type="bullet">

 Lestor R. Ford jr., D. R. Fulkerson: <it>Flows in Networks</it>, Princeton University Press, 1962.</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 24.1: The Bellman-Ford algorithm, pp.588&ndash;592. Problem 24-1, pp.614&ndash;615.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://links.math.rpi.edu/applets/appindex/graphtheory.html">
Interactive Java-Applet demonstration</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://snippets.dzone.com/posts/show/4828">
C code example</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</article>
