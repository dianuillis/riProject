<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:24:10[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Mental poker</title>
<id>2218782</id>
<revision>
<id>223161464</id>
<timestamp>2008-07-02T20:56:30Z</timestamp>
<contributor>
<username>Ilmari Karonen</username>
<id>398996</id>
</contributor>
</revision>
<categories>
<category>Articles with Alice and Bob explanations</category>
<category>Cryptographic algorithms</category>
<category>Cryptography</category>
</categories>
</header>
<bdy>

<b>Mental poker</b> is the common name for a set of <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptographic</link> problems that concerns playing a fair game over distance without the need for a <link xlink:type="simple" xlink:href="../651/584651.xml">
trusted third party</link>. The term is also applied to the <link xlink:type="simple" xlink:href="../746/30746.xml">
theories</link> surrounding these problems and their possible solutions.  The name stems from the <link xlink:type="simple" xlink:href="../360/5360.xml">
card game</link> <link xlink:type="simple" xlink:href="../014/23014.xml">
poker</link> which is one of the games to which this kind of problems apply. A similar problem is <link>
flipping a coin over a distance</link>.<p>

The problem can be described thus: "How can one allow only authorized actors to have access to certain information while not using a trusted arbiter?".  (Eliminating the trusted third-party avoids the problem of trying to determine whether the third party can be trusted or not, and may also reduce the resources required.)</p>
<p>

In poker, this could translate to: "How can we make sure no player is stacking the deck or peeking at other players' cards when we are shuffling the deck ourselves?". In a physical card game, this would be relatively simple if the players were sitting face to face and observing each other, at least if the possibility of conventional cheating can be ruled out. However, if the players are not sitting at the same location but instead are at widely separate locations and pass the entire deck between them (using the postal <link xlink:type="simple" xlink:href="../138/51138.xml">
mail</link>, for instance), this suddenly becomes very difficult. And for electronic card games, such as <link xlink:type="simple" xlink:href="../421/530421.xml">
online poker</link>, where the mechanics of the game are hidden from the user, this is impossible unless the method used is such that it cannot allow any party to cheat by manipulating or inappropriately observing the electronic "deck".</p>
<p>

Several protocols for doing this have been suggested, the first by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../314/57314.xml">
Adi Shamir</link></scientist>
</person>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../057/68057.xml">
Ron Rivest</link></scientist>
</person>
 and <link xlink:type="simple" xlink:href="../886/249886.xml">
Len Adleman</link> (the creators of the <link xlink:type="simple" xlink:href="../385/25385.xml">
RSA</link>-encryption protocol).<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Mental_poker#endnote_SRAtechreport">
http://localhost:18088/wiki/index.php/Mental_poker#endnote_SRAtechreport</weblink></p>

<sec>
<st>
Shuffling cards using <link xlink:type="simple" xlink:href="../390/294390.xml">
commutative</link> <link xlink:type="simple" xlink:href="../294/10294.xml">
encryption</link></st>

<p>

One possible <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for <link xlink:type="simple" xlink:href="../189/23189.xml">
shuffling</link> cards without the use of a trusted third party is to use a <link xlink:type="simple" xlink:href="../390/294390.xml">
commutative</link> encryption scheme. A commutative scheme means that if some data is encrypted more than once, the order in which you decrypt this data will not matter. </p>
<p>

Example: <link xlink:type="simple" xlink:href="../079/679079.xml">
Alice</link> has a <link xlink:type="simple" xlink:href="../935/157935.xml">
plaintext</link> message. She encrypts this, producing a garbled <link xlink:type="simple" xlink:href="../294/10294.xml">
ciphertext</link> which she gives this to <link xlink:type="simple" xlink:href="../079/679079.xml">
Bob</link>. Bob encrypts the ciphertext again, using the same scheme as Alice but with another <link xlink:type="simple" xlink:href="../039/53039.xml">
key</link>. When decrypting this double encrypted message, if the encryption scheme is commutative, it will not matter who decrypts first. </p>

<ss1>
<st>
The algorithm</st>

<p>

An algorithm for shuffling cards using commutative encryption would be as follows:</p>
<p>

<list>
<entry level="1" type="number">

 Alice and Bob agree on a certain "deck" of cards. In practice, this means they agree on a set of numbers or other data that each represents a card.</entry>
<entry level="1" type="number">

 Alice picks an encryption key A and uses this to encrypt each card of the deck.</entry>
<entry level="1" type="number">

 Alice shuffles the cards.</entry>
<entry level="1" type="number">

 Alice passes the encrypted and shuffled deck to Bob. With the encryption in place, Bob cannot know which card is which.</entry>
<entry level="1" type="number">

 Bob picks an encryption key B and uses this to encrypt each card of the encrypted and shuffled deck.</entry>
<entry level="1" type="number">

 Bob shuffles the deck. </entry>
<entry level="1" type="number">

 Bob passes the double encrypted and shuffled deck back to Alice.</entry>
<entry level="1" type="number">

 Alice decrypts each card using her key A. This still leaves Bob's encryption in place though so she cannot know which card is which.</entry>
<entry level="1" type="number">

 Alice picks one encryption key for each card (A1, A2, etc) and encrypts them individually.</entry>
<entry level="1" type="number">

 Alice passes the deck to Bob. </entry>
<entry level="1" type="number">

 Bob decrypts each card using his key B. This still leaves Alice's individual encryption in place though so he cannot know which card is which.</entry>
<entry level="1" type="number">

 Bob picks one encryption key for each card (B1, B2, etc) and encrypts them individually.</entry>
<entry level="1" type="number">

 Bob passes the deck back to Alice.</entry>
<entry level="1" type="number">

 Alice publishes the deck for everyone playing (in this case only Alice and Bob, see below on expansion though).</entry>
</list>
</p>
<p>

The deck is now shuffled.</p>
<p>

This algorithm may be expanded for an arbitrary number of players. Players <link xlink:type="simple" xlink:href="../079/679079.xml">
Carol</link>, <link xlink:type="simple" xlink:href="../079/679079.xml">
Dave</link> and so forth need only repeat steps 2-4 and 8-10. </p>
<p>

During the game, Alice and Bob will pick cards from the deck, identified in which order they are placed in the shuffled deck. When either player wants to see their cards, they will request the corresponding keys from the other player. That player, upon checking that the requesting player is indeed entitled to look at the cards, passes the individual keys for those cards to the other player. The check is to ensure that the player does not try to request keys for cards that do not belong to that player. </p>
<p>

Example: Alice has picked cards 1 to 5 in the shuffled deck. Bob has picked cards 6 to 10. Bob requests to look at his allotted cards. Alice agrees that Bob is entitled to look at cards 6 to 10 and gives him her individual card keys A6 to A10. Bob decrypts his cards by using both Alice's keys and his own for these cards, B6 to B10. Bob can now see the cards. Alice cannot know which cards Bob has because she does not have access to Bob keys B6 to B10 which are required to decrypt the cards.</p>

</ss1>
<ss1>
<st>
Weakness</st>

<p>

The encryption scheme used must be secure against <link xlink:type="simple" xlink:href="../019/517019.xml">
known-plaintext attack</link>s: Bob must not be able to determine Alice's original key A (or enough of it to allow him to decrypt any cards he does not hold) based on his knowledge of the unencrypted values of the cards he has drawn.  This rules out some obvious commutative encryption schemes, such as simply <link xlink:type="simple" xlink:href="../979/105979.xml">
XOR</link>ing each card with the key.  (Using a separate key for each card even in the initial exchange, which would otherwise <link xlink:type="simple" xlink:href="../210/22210.xml">
make this scheme secure</link>, doesn't work since the cards are shuffled before they're returned.)</p>
<p>

Depending on the deck agreed upon, this algorithm may be weak. When encrypting data, certain properties of this data may be preserved from the plaintext to the ciphertext. This may be used to "tag" certain cards. Therefore, the parties must agree on a deck where no cards have properties that are preserved during encryption.</p>

</ss1>
</sec>
<sec>
<st>
A Toolbox for Mental Card Games and its Implementation</st>
<p>

Christian Schindelhauer describes sophisticated protocols to both perform and verify a large number of useful operations on cards and stacks of cards in his 1998 paper [SCH98]. The work is concerned with general-purpose operations (masking and unmasking cards, shuffling and re-shuffling, inserting a card in to a stack, etc.) that make the protocols applicable to any card game. The <link>
 cryptographic protocols</link> used by Schindelhauer are based on <link>
 quadratic residuosity</link>, and the general scheme is similar in spirit to the above protocol. The correctness of operations can be checked by using <link xlink:type="simple" xlink:href="../541/450541.xml">
zero-knowledge proof</link>s, so that players don't need to reveal their strategy to verify the game's correctness.</p>
<p>

The C++ library libtcmg [STA05] (available at http://www.nongnu.org/libtmcg/) provides an implementation of the Schindelhauer toolbox. It has been used to implement a secure version of the German card game <link>
 Skat</link>, achieving modest real-world performance. The game Skat is played by three players with a 32-card deck, and so is substantially less computationally intensive than a poker game in which anywhere from five to eight players use a full 52-card deck.</p>

</sec>
<sec>
<st>
A Non-Shuffling Poker Protocol</st>
<p>

To date, mental poker approaches based on the standard Alice-Bob protocol (above) don't offer high enough performance for real-time online play. The requirement that each player encrypts each card imposes a substantial overhead. A recent paper by Golle [GOL05] describes a mental poker protocol that achieves significantly higher performance by exploiting the properties of the poker game to move away from the encrypt-shuffle model. Rather than shuffle the cards and then deal as needed, with the new approach, the players generate (encrypted) random numbers on the fly, which are used to select the next card. Every new card needs to be checked against all the cards that have already been dealt to detect duplicates. As a result, this method is uniquely useful in poker-style games, in which the number of cards dealt is very small compared to the size of the whole deck. However, the method needs all cards that have already been dealt to be known to all, which in most poker-style games would beat its very purpose.</p>
<p>

The card-generation algorithm requires a cryptosystem with two key properties. The encryption E must be additively <link xlink:type="simple" xlink:href="../564/13564.xml">
homomorphic</link>, so that <it>E(c1)E(c2) = E(c1 + c2)</it>. Second, collisions must be detectable, without revealing the plaintext. In other words, given <it>E(c1)</it> and <it>E(c2)</it>, it must be possible to answer whether <it>c1=c2</it>, without the players learning any other information (specifically, the identities of <it>c1</it> and <it>c2</it>). The <link xlink:type="simple" xlink:href="../458/59458.xml">
Elgamal encryption</link> scheme is just one example of a well-known system with these properties.
The algorithm operates as follows:
<list>
<entry level="1" type="number">

 Players initialize an empty list <it>L</it> that records cards that are in use. </entry>
<entry level="1" type="number">

 To deal a card, each player computes a random number <it>ri</it> in {0,...,51}, computes <it>E(ri)</it>, and publishes a non-malleable <link>
 commitment</link> to <it>E(ri)''</it></entry>
<entry level="1" type="number">

 Players then publish their actual <it>E(ri)</it>, and can verify that every player honors its commitment</entry>
<entry level="1" type="number">

 Players compute <math>\Pi E(r_i) = E(\Sigma r_i) </math>, which produces a new encrypted card <it>E(r*)</it>, with <math>r* =  \Sigma r_i</math></entry>
<entry level="1" type="number">

 Players check if <it>E(r*)</it> is already in <it>L</it>. If not, <it>E(r*)</it> is dealt to the appropriate player, and added to <it>L</it>. When cards need to be revealed, they can be jointly decrypted.</entry>
</list>
</p>
<p>

In this way, the players need only to compute encryption for the cards that are actually used in the game, plus some overhead for the collisions that is small as long as the number of cards needed is much less than the size of the deck. As a result, this scheme turns out to be 2-4 times faster (as measured by the total number of modular exponentiations) than the best-known protocol [JAK99] that does full shuffling using <link>
 mix-networks</link>. </p>
<p>

Note that the <link>
 random number generation</link> is secure as long as any one player is generating valid random numbers. Even if <it>k-1</it> players collude to generate the number <it>r*</it>, as long as the <it>k</it>th player truthfully generates a random <math>r'</math>, the sum <math>r = r* + r'</math> is still uniformly random in {0, 51}.</p>
<p>

Measured in terms of the number of single-agent encryptions, the algorithm in [GOL05] is optimal when no collisions occur, in the sense that any protocol that is fair to every player must perform at least as many encryption operations. At minimum, every agent must encrypt every card that is actually used. Otherwise, if any agent doesn't participate in the encryption, then that agent is susceptible to being cheated by a coalition of the remaining players. Unknown to the non-encrypting agent, the other agents may share the keys to enable them all to know the values of all the cards. Thus, any approach relying on the agents to perform the encryption must focus on schemes that minimize the effect of collisions if they are to achieve better performance.</p>

</sec>
<sec>
<st>
Better Performance through Increased Trust</st>

<p>

Any mental poker protocol that relies on the players to perform the encryption is bound by the requirement that every player encrypt every card that is dealt. However, by making limited assumptions about the trustworthiness of third parties, significantly more efficient protocols may be realized. The protocol for choosing cards without shuffling may be adapted so that the encryption is handled by two or more servers. Under the assumption that the servers are non-colluding—that is, that at least one is honest—such a protocol is secure.</p>
<p>

The basic protocol using two servers is as follows:
<list>
<entry level="1" type="number">

 Servers <it>S1</it> and <it>S2</it> encrypt and shuffle a deck of cards, and publish a non-malleable commitment to some <link xlink:type="simple" xlink:href="../027/44027.xml">
permutation</link> of encrypted cards to the players. This can be done with any of several well-understood cryptographic protocols. </entry>
<entry level="1" type="number">

 Players compute independent random numbers in {0,...,51}, which are combined to generate a random number in {0,..., 51}, as in [GOL05]</entry>
<entry level="1" type="number">

 The random number is used as an index into the random permutation, the appropriate player gains "ownership" of the specified card, and the servers send that player the keys to read the card's value.</entry>
</list>
</p>
<p>

In this protocol, servers <it>S1</it> and <it>S2</it> must collude if either is to learn the values of any cards. Furthermore, because players ultimately decide which cards are dealt, non-trustworthy servers are unable to influence the game to the extent that is possible in traditional <link xlink:type="simple" xlink:href="../421/530421.xml">
online poker</link>. The scheme may be extended to allow more servers, (and thus, increased security), simply by including the additional servers in the initial encryption. Finally, step one in the protocol may be done offline, allowing for large numbers of shuffled, encrypted "decks" to be pre-computed and cached, resulting in excellent in-game performance.</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="endnote_SRAtechreport" style="font-style: normal;">
<b>^</b></cite>&nbsp; A. Shamir, R. Rivest, and L. Adleman, "Mental Poker", Technical Report LCS/TR-125, Massachusetts Institute of Technology, April 1979.</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../178/842178.xml">
Goldwasser, S.</link></scientist>
 and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/1385119.xml">
Micali, S.</link></scientist>
 1982. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=802212">
Probabilistic encryption &amp; how to play mental poker keeping secret all partial information</weblink>. In Proceedings of the Fourteenth Annual ACM Symposium on theory of Computing.</entry>
<entry level="1" type="bullet">

 [STA05] Stamer, H. Efficient Electronic Gambling: An Extended Implementation of the Toolbox for Mental Card Games. WEWoRC 2005, LN P-74, 1-12, 2005</entry>
<entry level="1" type="bullet">

 [SCH98] Schindelhauer, C. A Toolbox for Mental Card Games. Tech. Rep. of Medizinische Universitat Lubeck.</entry>
<entry level="1" type="bullet">

 [GOL05] Golle, P. Dealing Cards in Poker Games. In Proceedings of the International Conference on Information Technology: Coding and Computing, (2005)</entry>
</list>
</p>
<p>

There exists a comprehensive bibliography on Mental Poker <weblink xlink:type="simple" xlink:href="http://liinwww.ira.uka.de/bibliography/Misc/MentalPoker.html">
http://liinwww.ira.uka.de/bibliography/Misc/MentalPoker.html</weblink>


</p>
</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
