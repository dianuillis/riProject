<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:34:06[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>McCarthy 91 function</title>
<id>222665</id>
<revision>
<id>222519468</id>
<timestamp>2008-06-29T19:52:32Z</timestamp>
<contributor>
<username>Anog</username>
<id>303131</id>
</contributor>
</revision>
<categories>
<category>discrete mathematics</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../492/8492.xml">
discrete mathematics</link> and <link xlink:type="simple" xlink:href="../054/270054.xml">
formal verification</link> (within <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>), the <b>McCarthy 91 function</b> is a <link>
 recursive</link> function conceived by <link xlink:type="simple" xlink:href="../784/328784.xml">
computer scientist</link> <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../362/308362.xml">
John McCarthy</link></scientist>
</person>
.<p>

The McCarthy 91 function is defined as</p>
<p>

<indent level="1">

<math>M(n)=\left\{\begin{matrix} n - 10, &amp; \mbox{if }n &amp;gt; 100\mbox{ } \\ M(M(n+11)), &amp; \mbox{if }n \le 100\mbox{ } \end{matrix}\right.</math>
</indent>

The function returns 91 for all integer arguments <it>n</it> &amp;le; 101. It returns <math>n - 10</math> for <it>n</it> &amp;gt; 101.</p>
<p>

Example A:</p>
<p>

M(99) = M(M(110)) since 99 &amp;le; 100
= M(100)    since 110 &amp;gt; 100
= M(M(111)) since 100 &amp;le; 100
= M(101)    since 111 &amp;gt; 100
= 91        since 101 &amp;gt; 100</p>
<p>

Example B:</p>
<p>

M(87) = M(M(98))
= M(M(M(109)))
= M(M(99))
= M(M(M(110)))
= M(M(100))
= M(M(M(111)))
= M(M(101))
= M(91)
= M(M(102))
= M(92)
= M(M(103))
= M(93)
.... Pattern continues
= M(99)
(same as example A)
= 91</p>
<p>

Here is how John McCarthy may have written this function in <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link>, the language he invented:</p>
<p>

(defun mc91 (n)
(cond ((= n 100) (mc91 (mc91 (+ n 11))))
(t (- n 10))))</p>

<p>

Here is a proof that the function behaves as expected.</p>
<p>

For 90 &amp;le; <it>n</it>  101,</p>
<p>

M(n) = M(M(n + 11))
= M(n + 11 - 10), since n &amp;gt;= 90 so n + 11 &amp;gt;= 101
= M(n + 1)</p>
<p>

So <it>M</it>(<it>n</it>) = 91 for 90 &amp;le; <it>n</it>  101.</p>
<p>

We can use this as a base case for <link xlink:type="simple" xlink:href="../881/18881.xml">
induction</link> on blocks of 11 numbers, like so:</p>
<p>

Assume that <it>M</it>(<it>n</it>) = 91 for <it>a</it> &amp;le; <it>n</it>  <it>a</it> + 11.</p>
<p>

Then, for any <it>n</it> such that <it>a</it> - 11 &amp;le; <it>n</it>  <it>a</it>,</p>
<p>

M(n) = M(M(n + 11))
= M(91), by hypothesis, since a &amp;le; n + 11  a + 11
= 91, by the base case.</p>
<p>

Now by induction <it>M</it>(<it>n</it>) = 91 for any <it>n</it> in such a block. There are no holes between the blocks, so <it>M</it>(<it>n</it>) = 91 for <it>n</it>  101. We can also add <it>n</it> = 101 as a special case.</p>
<p>

The 91 function was introduced in papers published by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../529/699529.xml">
Zohar Manna</link></associate>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../365/308365.xml">
Amir Pnueli</link></scientist>
</person>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../362/308362.xml">
John McCarthy</link></scientist>
</person>
 in 1970.  These papers represented early developments towards the application of <link xlink:type="simple" xlink:href="../883/161883.xml">
formal methods</link> to <link xlink:type="simple" xlink:href="../054/270054.xml">
program verification</link>.  The 91 function was chosen for having a complex recursion pattern (contrasted with simple patterns, such as defining <math>f(n)</math> by means of <math>f(n-1)</math>).  The example was popularized by Manna's book, <it>Mathematical Theory of Computation</it> (1974). As the field of Formal Methods advanced, this example appeared repetitively in the research literature.
In particular, it is viewed as a "challenge problem" for automated program verification.</p>
<p>

Often, it is easier to reason about non-recursive computation. As one of the examples used to demonstrate such reasoning, Manna's book includes a non-recursive algorithm that simulates the original (recursive) 91 function. Many of the papers that report an "automated verification" (or <link xlink:type="simple" xlink:href="../658/6782658.xml">
termination proof</link>) of the 91 function only handle the non-recursive version.</p>
<p>

Here is an implementation of the non-recursive algorithm in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
: </p>
<p>

int mccarthy(int n)
{
for (int c = 1; c != 0; ) {
if (n &amp;gt; 100) {
n = n - 10;
c--;
} else {
n = n + 11;
c++;
}
}
return n;
}</p>
<p>

A formal derivation of the non-recursive version from the recursive one was given in a 1980 article by <link xlink:type="simple" xlink:href="../664/19336664.xml">
Mitchell Wand</link>, based on the use of <link xlink:type="simple" xlink:href="../189/505189.xml">
continuations</link>.</p>

<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Zohar Manna and Amir Pnueli&#32;(July 1970).&#32;"Formalization of Properties of Functional Programs". <it>Journal of the ACM</it>&#32;<b>17</b>&#32;(3): 555–569. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F321592.321606">
10.1145/321592.321606</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Zohar Manna and John McCarthy&#32;(1970).&#32;"Properties of programs and partial function logic". <it>Machine Intelligence</it>&#32;<b>5</b>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 Zohar Manna. <it>Mathematical Theory of Computation.</it> McGraw-Hill Book Company, New-York, 1974. Reprinted in 2003 by Dover Publications.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Mitchell Wand&#32;(January 1980).&#32;"Continuation-Based Program Transformation Strategies". <it>Journal of the ACM</it>&#32;<b>27</b>&#32;(1): 164–180. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F322169.322183">
10.1145/322169.322183</weblink>.</cite>&nbsp;</entry>
</list>
</p>


</sec>
</bdy>
</article>
