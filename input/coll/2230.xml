<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:21:09[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Analysis of algorithms</title>
<id>2230</id>
<revision>
<id>241517741</id>
<timestamp>2008-09-28T12:01:20Z</timestamp>
<contributor>
<username>Closedmouth</username>
<id>372693</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
<category>Analysis of algorithms</category>
</categories>
</header>
<bdy>

To <b>analyze an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link></b> is to determine the amount of resources (such as time and storage) necessary to execute it. Most algorithms are designed to work with inputs of arbitrary length. Usually the <b>efficiency</b> or <b><link xlink:type="simple" xlink:href="../543/7543.xml">
complexity</link></b> of an algorithm is stated as a function relating the <link xlink:type="simple" xlink:href="../299/89299.xml">
input length</link> to the number of steps (<b>time complexity</b>) or storage locations (<b>space complexity</b>).<p>

Algorithm analysis is an important part of a broader <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, which provides theoretical estimates for the resources needed by any algorithm which solves a given computational problem. These estimates provide an insight into reasonable directions of search of efficient algorithms.</p>
<p>

In theoretical analysis of algorithms it is common to estimate their complexity in <b>asymptotic sense</b>, i.e., to estimate the complexity function for reasonably large length of input. <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link>, <link xlink:type="simple" xlink:href="../578/44578.xml">
omega</link> notation and <link xlink:type="simple" xlink:href="../578/44578.xml">
theta</link> notation are used to this end. For instance, <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> is said to run an amount of steps proportional to a logarithm, or in O(log(n)), colloquially "in logarithmic time". Usually asymptotic estimates are used because different <link xlink:type="simple" xlink:href="../704/407704.xml">
implementation</link>s of the same algorithm may differ in efficiency. However the efficiencies of any two "reasonable" implementations of a given algorithm are related by a constant multiplicative factor  called <b>hidden constant</b>.</p>
<p>

Exact (not asymptotic) measures of efficiency can sometimes be computed but they usually require certain assumptions concerning the particular implementation of the algorithm, called <link xlink:type="simple" xlink:href="../278/1773278.xml">
model of computation</link>. A model of computation may be defined in terms of an <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract computer</link>, e.g., <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
, and/or by postulating that certain operations are executed in unit time.
For example, if the sorted set to which we apply <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> has N elements, and we can guarantee that a single binary lookup can be done in unit time, then at most log2 N + 1 time units are needed to return an answer.</p>
<p>

Exact measures of efficiency are useful to the people who actually implement and use algorithms, because they are more precise and thus enable them to know how much time they can expect to spend in execution. To some people (e.g. game programmers), a hidden constant can make all the difference between success and failure.</p>
<p>

Time efficiency estimates depend on what we define to be a step. For the analysis to make sense, the time required to perform a step must be guaranteed to be bounded above by a constant. One must be careful here; for instance, some analyses count an addition of two numbers as a step. This assumption may not be warranted in certain contexts. For example, if the numbers involved in a computation may be arbitrarily large, addition no longer can be assumed to require constant time (compare the time you need to add two 2-digit integers and two 1000-digit integers using a pen and paper).</p>

<sec>
<st>
Run-time analysis</st>
<p>

Run-time analysis is a theoretical classification that estimates and anticipates the increase in <it><assets wordnetid="113329641" confidence="0.8">
<possession wordnetid="100032613" confidence="0.8">
<resource wordnetid="113331778" confidence="0.8">
<link xlink:type="simple" xlink:href="../538/658538.xml">
running time</link></resource>
</possession>
</assets>
</it> (or run-time) of an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> as its <it><link xlink:type="simple" xlink:href="../264/41264.xml">
input size</link></it> (usually denoted as "n") increases.  Run-time efficiency is a topic of great interest in <link xlink:type="simple" xlink:href="../323/5323.xml">
Computer Science</link>:  a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link> can take seconds, hours or even years to finish executing, depending on which algorithm it implements.
(This should not be confused with the analysis of an algorithm's actual run-time which is covered in the article <link xlink:type="simple" xlink:href="../080/2310080.xml">
performance analysis</link>).  </p>

<ss1>
<st>
Shortcomings of empirical metrics</st>

<p>

Since algorithms are <link xlink:type="simple" xlink:href="../193/81193.xml">
platform-independent</link> (i.e. a given algorithm can be implemented in any <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> on any <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> running any <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>), there are significant drawbacks to using an <link xlink:type="simple" xlink:href="../139/307139.xml">
empirical</link> approach to gauge the comparative performance of a given set of algorithms.</p>
<p>

Take as an example a program that looks up a specific entry in a <link xlink:type="simple" xlink:href="../489/7489.xml">
sorted</link> <link xlink:type="simple" xlink:href="../382/208382.xml">
list</link> of size n.  Suppose this program were implemented on Computer A, a state-of-the-art machine, using a <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link> algorithm, and on Computer B, a much slower machine, using a <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> algorithm.  <link xlink:type="simple" xlink:href="../870/1980870.xml">
Benchmark testing</link> on the two computers running their respective programs might look something like the following:</p>
<p>

<table class="wikitable">
<row>
<header>
n (list size)</header>
<header>
Computer A run-time(in nanoseconds)</header>
<header>
Computer B run-time(in nanoseconds)</header>
</row>
<row>
<col>
15</col>
<col>
7 ns</col>
<col>
100,000 ns</col>
</row>
<row>
<col>
65</col>
<col>
32 ns</col>
<col>
150,000 ns</col>
</row>
<row>
<col>
250</col>
<col>
128 ns</col>
<col>
200,000 ns</col>
</row>
<row>
<col>
1,000</col>
<col>
500 ns</col>
<col>
250,000 ns</col>
</row>
</table>
</p>
<p>

Based on these <link xlink:type="simple" xlink:href="../658/731658.xml">
metrics</link>, it would be easy to jump to the conclusion that Computer A is running an algorithm that is far superior in efficiency to what Computer B is running.  However, if the size of the input-list is increased to a sufficient number, that conclusion is dramatically demonstrated to be in error:</p>
<p>

<table class="wikitable">
<row>
<header>
n (list size)</header>
<header>
Computer A run-time(in nanoseconds)</header>
<header>
Computer B run-time(in nanoseconds)</header>
</row>
<row>
<col>
15</col>
<col>
7 ns</col>
<col>
100,000 ns</col>
</row>
<row>
<col>
65</col>
<col>
32 ns</col>
<col>
150,000 ns</col>
</row>
<row>
<col>
250</col>
<col>
125 ns</col>
<col>
200,000 ns</col>
</row>
<row>
<col>
1,000</col>
<col>
500 ns</col>
<col>
250,000 ns</col>
</row>
<row>
<col>
...</col>
<col>
...</col>
<col>
...</col>
</row>
<row>
<col>
1,000,000</col>
<col>
500,000 ns</col>
<col>
500,000 ns</col>
</row>
<row>
<col>
4,000,000</col>
<col>
2,000,000 ns</col>
<col>
550,000 ns</col>
</row>
<row>
<col>
16,000,000</col>
<col>
8,000,000 ns</col>
<col>
600,000 ns</col>
</row>
<row>
<col>
...</col>
<col>
...</col>
<col>
...</col>
</row>
<row>
<col>
63,072 * 1012</col>
<col>
31,536 * 1012 ns,or 1 year</col>
<col>
1,375,000 ns,or 1.375 milliseconds</col>
</row>
</table>
</p>
<p>

Computer A, running the linear search program, exhibits a <link xlink:type="simple" xlink:href="../591/91591.xml">
linear</link> <link xlink:type="simple" xlink:href="../751/498751.xml">
growth rate</link>.  The program's run-time is directly proportional to its input size.  Doubling the input size doubles the run time, quadrupling the input size quadruples the run-time, and so forth.  Whereas Computer B, running the binary search program, exhibits a <link xlink:type="simple" xlink:href="../860/17860.xml">
logarithm</link>ic growth rate.  Doubling the input size only increases the run time by a <link xlink:type="simple" xlink:href="../453/12860453.xml">
constant</link> amount (in this example, 25,000 ns).  Even though Computer A is ostensibly a faster machine, Computer B will inevitably surpass Computer A in run-time because it's running an algorithm with a much slower growth rate.</p>

</ss1>
<ss1>
<st>
Orders of growth</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link></it>
</indent>
Informally, an algorithm can be said to exhibit a growth rate on the order of a <mathematical_relation wordnetid="113783581" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../427/185427.xml">
mathematical function</link></function>
</concept>
</idea>
</mathematical_relation>
 if beyond a certain input size n, the function f(n) times a positive constant provides an <link xlink:type="simple" xlink:href="../995/641995.xml">
upper bound or limit</link> for the run-time of that algorithm.  In other words, for a given input size n greater than some n0 and a constant c, an algorithm can run no slower than c * f(n).  This concept is frequently expressed using Big O notation (<it>see <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link> for a more formal discussion</it>).  For example, since the run-time of <link xlink:type="simple" xlink:href="../205/15205.xml">
insertion sort</link> <link xlink:type="simple" xlink:href="../246/9228246.xml">
grows quadratically</link> as its input size increases, insertion sort can be said to be of order O(n²).</p>
<p>

Big O notation is a convenient way to express the <link xlink:type="simple" xlink:href="../956/37956.xml">
worst-case scenario</link> for a given algorithm, although it can also be used to express the average-case &mdash; for example, the worst-case scenario for <link xlink:type="simple" xlink:href="../249/3268249.xml">
quicksort</link> is O(n²) but the average-case run-time is O(n lg n).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</ss1>
<ss1>
<st>
 Evaluating run-time complexity </st>
<p>

The run-time complexity for the worst-case scenario of a given algorithm can sometimes be evaluated by examining the structure of the algorithm and making some simplifying assumptions.  Consider the following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>:</p>
<p>

1    get a positive integer from input
2    if n &amp;gt; 10
3        print "This might take a while..."
4    for i = 1 to n
5        for j = 1 to i
6            print i * j
7    print "Done!"</p>
<p>

A given computer will take a <assets wordnetid="113329641" confidence="0.8">
<possession wordnetid="100032613" confidence="0.8">
<resource wordnetid="113331778" confidence="0.8">
<link xlink:type="simple" xlink:href="../538/658538.xml">
discrete amount of time</link></resource>
</possession>
</assets>
 to execute each of the <link xlink:type="simple" xlink:href="../801/3149801.xml">
instructions</link> involved with carrying out this algorithm.  The specific amount of time to carry out a given instruction will vary depending on which instruction is being executed and which computer is executing it, but on a conventional computer, this amount will be <link xlink:type="simple" xlink:href="../958/522958.xml">
deterministic</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>.  Say that the actions carried out in step 1 are considered to consume time T1, step 2 uses time T2, and so forth.</p>
<p>

In the algorithm above, steps 1, 2 and 7 will only be run once.  For a worst-case evaluation, it should be assumed that step 3 will be run as well.  Thus the total amount of time to run steps 1-3 and step 7 is:</p>
<p>

<indent level="1">

<math>T_1 + T_2 + T_3 + T_7 \,</math>
</indent>

The <link xlink:type="simple" xlink:href="../023/4378023.xml">
loops</link> in steps 4, 5 and 6 are trickier to evaluate.  The outer loop test in step 4 will execute ( n + 1 ) times, which will consume T4( n + 1 ) time.  The inner loop, on the other hand, is governed by the value of i, which <link xlink:type="simple" xlink:href="../833/68833.xml">
iterates</link> from 1 to n.  On the first pass through the outer loop, j iterates from 1 to 1:  the inner loop makes one pass, so running the inner loop body (step 6) consumes T6 time, and the inner loop test (step 5) consumes 2T5 time.  During the next pass through the outer loop, j iterates from 1 to 2:  the inner loop makes two passes, so running the inner loop body (step 6) consumes 2T6 time, and the inner loop test (step 5) consumes 3T5 time.</p>
<p>

Altogether, the total time required to run the inner loop body can be expressed as an <link xlink:type="simple" xlink:href="../389/168389.xml">
arithmetic progression</link>:</p>
<p>

<indent level="1">

<math>T_6 + 2T_6 + 3T_6 + \cdots + (n-1) T_6 + n T_6</math>
</indent>

which can be <link xlink:type="simple" xlink:href="../341/82341.xml">
factored</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> as</p>
<p>

<indent level="1">

<math>T_6 \left[ 1 + 2 + 3 + \cdots + (n-1) + n \right] = T_6 \left[ \frac{1}{2} (n^2 + n) \right] </math>
</indent>

The total time required to run the inner loop test can be evaluated similarly:</p>
<p>

<indent level="1">

<math>2T_5 + 3T_5 + 4T_5 + \cdots + (n-1) T_5 + n T_5 + (n + 1) T_5</math>
</indent>
:<math> = T_5 + 2T_5 + 3T_5 + 4T_5 + \cdots + (n-1)T_5 + nT_5 + (n+1)T_5 - T_5</math></p>
<p>

which can be factored as</p>
<p>

<indent level="1">

<math>T_5 \left[ 1+2+3+\cdots + (n-1) + n + (n + 1) \right] - T_5 = T_5 \left[ \frac{1}{2} (n^2 + 3n + 2) \right] - T_5</math>
</indent>

Therefore the total running time for this algorithm is:</p>
<p>

<indent level="1">

<math>f(n) = T_1 + T_2 + T_3 + T_7 + (n + 1)T_4 + \left[ \frac{1}{2} (n^2 + n) \right] T_6 + \left[ \frac{1}{2} (n^2+3n+2) \right] T_5 - T_5</math>
</indent>

which <link xlink:type="simple" xlink:href="../865/1033865.xml">
reduces</link> to</p>
<p>

<indent level="1">

<math>f(n) = \left[ \frac{1}{2} (n^2 + n) \right] T_6 + \left[ \frac{1}{2} (n^2 + 3n) \right] T_5 + (n + 1)T_4 + T_1 + T_2 + T_3 + T_7
</math>
</indent>

As a <link xlink:type="simple" xlink:href="../538/56538.xml">
rule-of-thumb</link>, one can assume that the highest-order term in any given function dominates its rate of growth and thus defines its run-time order.  In this example, n² is the highest-order term, so one can conclude that f(n) = O(n²).  Formally this can be proven as follows:Prove that <math>\left[ \frac{1}{2} (n^2 + n) \right] T_6 + \left[ \frac{1}{2} (n^2 + 3n) \right] T_5 + (n + 1)T_4 + T_1 + T_2 + T_3 + T_7 \le cn^2,\ n \ge n_0</math></p>
<p>

<math>\left[ \frac{1}{2} (n^2 + n) \right] T_6 + \left[ \frac{1}{2} (n^2 + 3n) \right] T_5 + (n + 1)T_4 + T_1 + T_2 + T_3 + T_7</math></p>
<p>

<math>\le ( n^2 + n )T_6 + ( n^2 + 3n )T_5 + (n + 1)T_4 + T_1 + T_2 + T_3 + T_7</math> (<it>for n ≥ 0</it>)</p>
<p>

Let k be a constant greater than or equal to [T1..T7]
<math>T_6( n^2 + n ) + T_5( n^2 + 3n ) + (n + 1)T_4 + T_1 + T_2 + T_3 + T_7 \le k( n^2 + n ) + k( n^2 + 3n ) + kn + 5k</math>
<math>= 2kn^2 + 5kn + 5k \le 2kn^2 + 5kn^2 + 5kn^2</math> (<it>for n ≥ 1</it>) <math>= 12kn^2</math></p>
<p>

Therefore <math>\left[ \frac{1}{2} (n^2 + n) \right] T_6 + \left[ \frac{1}{2} (n^2 + 3n) \right] T_5 + (n + 1)T_4 + T_1 + T_2 + T_3 + T_7 \le cn^2, n \ge n_0</math> for <math>c = 12k,\ n_0 = 1</math></p>
<p>

A more <link xlink:type="simple" xlink:href="../721/235721.xml">
elegant</link> approach to analyzing this algorithm would be to declare that [T1..T7] are all equal to one <unit_of_measurement wordnetid="113583724" confidence="0.8">
<definite_quantity wordnetid="113576101" confidence="0.8">
<link xlink:type="simple" xlink:href="../364/586364.xml">
unit</link></definite_quantity>
</unit_of_measurement>
 of time greater than or equal to [T1..T7].  This would mean that the algorithm's running time breaks down as follows:<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><math>4+\sum_{i=1}^n i\leq 4+\sum_{i=1}^n n=4+n^2\leq5n^2</math>(<it>for n ≥ 1</it>)<math>=O(n^2)</math></p>

</ss1>
<ss1>
<st>
Growth rate analysis of other resources</st>
<p>

The methodology of run-time analysis can also be utilized for predicting other growth rates, such as consumption of <assets wordnetid="113329641" confidence="0.8">
<possession wordnetid="100032613" confidence="0.8">
<resource wordnetid="113331778" confidence="0.8">
<link xlink:type="simple" xlink:href="../520/658520.xml">
memory space</link></resource>
</possession>
</assets>
.  As an example, consider the following pseudocode which manages and reallocates memory usage by a program based on the size of a <link xlink:type="simple" xlink:href="../077/7077.xml">
file</link> which that program manages:</p>
<p>

1    While file is still open
2        Let n = file size
3        For every 100,000 <link xlink:type="simple" xlink:href="../794/16794.xml">
kilobyte</link>s of increase in file size
4            Double the amount of memory reserved</p>
<p>

In this instance, as the file size n increases, memory will be consumed at an <link xlink:type="simple" xlink:href="../933/191933.xml">
exponential growth</link> rate, which is order O(2n).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../775/775.xml">
Algorithm</link>s</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../128/145128.xml">
Algorithmic efficiency</link>, optimizing an algorithm for speed, memory or both</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../995/641995.xml">
Asymptotic analysis</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../956/37956.xml">
Best, worst and average case</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../543/7543.xml">
Computational complexity theory</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../080/2310080.xml">
Performance analysis</link>, measuring an algorithm's actual run-time performance</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../576/44576.xml">
Polynomial time</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../466/39466.xml">
NP-Complete</link></entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
The term <it>lg</it> is often used as shorthand for log2</entry>
<entry id="2">
However, this is not the case with a <link xlink:type="simple" xlink:href="../220/25220.xml">
quantum computer</link></entry>
<entry id="3">
It can be proven by <link xlink:type="simple" xlink:href="../881/18881.xml">
induction</link> that <math>1 + 2 + 3 + \cdots + (n-1) + n = \frac{n(n+1)}{2}</math></entry>
<entry id="4">
This approach, unlike the above approach, neglects the constant time consumed by the loop tests which terminate their respective loops, but it is <link xlink:type="simple" xlink:href="../053/193053.xml">
trivial</link> to prove that such omission does not affect the final result</entry>
<entry id="5">
Note that this is an extremely rapid and most likely unmanageable growth rate for consumption of memory <link xlink:type="simple" xlink:href="../365/1728365.xml">
resources</link></entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 1: Foundations, pp.3&ndash;122.</entry>
<entry level="1" type="bullet">

 Daniel H. Greene &amp; Donald E. Knuth, <it>Mathematics for the analysis of algorithms''</it></entry>
<entry level="1" type="bullet">

 <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
 (Second Edition)</it>, Cormen, Leiserson, Rivest and Stein, 2001, MIT Press, Cambridge, MA, USA, ISBN 0262032937</entry>
<entry level="1" type="bullet">

 <it>Algorithms in C, Parts 1-4: Fundamentals, Data Structures, Sorting, Searching (3rd Edition)</it>, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../503/235503.xml">
Robert Sedgewick</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, Addison-Wesley Professional, ISBN 978-0201314526</entry>
<entry level="1" type="bullet">

 <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
, Addison-Wesley</entry>
</list>
</p>



</sec>
</bdy>
</article>
