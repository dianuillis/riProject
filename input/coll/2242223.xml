<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:22:26[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Bitap algorithm</title>
<id>2242223</id>
<revision>
<id>239213341</id>
<timestamp>2008-09-18T07:10:20Z</timestamp>
<contributor>
<username>Quuxplusone</username>
<id>245306</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Articles with example C code</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

The <b>bitap algorithm</b> (also known as the <b>shift-or</b>, <b>shift-and</b> or <b>Baeza-Yates-Gonnet</b> algorithm) is a <link xlink:type="simple" xlink:href="../881/308881.xml">
fuzzy string searching</link> algorithm developed by <physical_entity wordnetid="100001930" confidence="0.8">
<executive wordnetid="110069645" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<leader wordnetid="109623038" confidence="0.8">
<administrator wordnetid="109770949" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<head wordnetid="110162991" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../574/474574.xml">
Udi Manber</link></employee>
</head>
</writer>
</scientist>
</causal_agent>
</worker>
</administrator>
</leader>
</person>
</communicator>
</executive>
</physical_entity>
 and <link>
Sun Wu</link> in 1991<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Bitap_algorithm#endnote_Manber91">
http://localhost:18088/wiki/index.php/Bitap_algorithm#endnote_Manber91</weblink><weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Bitap_algorithm#endnote_Manber92">
http://localhost:18088/wiki/index.php/Bitap_algorithm#endnote_Manber92</weblink> based on work done by <link xlink:type="simple" xlink:href="../233/2764233.xml">
Ricardo Baeza-Yates</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<exile wordnetid="110071332" confidence="0.8">
<absentee wordnetid="109757653" confidence="0.8">
<link xlink:type="simple" xlink:href="../300/819300.xml">
Gaston Gonnet</link></absentee>
</exile>
</scientist>
</causal_agent>
</traveler>
</person>
</physical_entity>
.<weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php/Bitap_algorithm#endnote_BYG89">
http://localhost:18088/wiki/index.php/Bitap_algorithm#endnote_BYG89</weblink> The algorithm tells whether a given text contains a substring which is "approximately equal" to a given pattern, where approximate equality is defined in terms of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../418/406418.xml">
Levenshtein distance</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 &mdash; if the substring and pattern are within a given distance <it>k</it> of each other, then the algorithm considers them equal. The algorithm  begins by precomputing a set of <link xlink:type="simple" xlink:href="../313/468313.xml">
bitmask</link>s containing one bit for each element of the pattern. Then it is able to do most of the work with <link xlink:type="simple" xlink:href="../399/264399.xml">
bitwise operation</link>s, which are extremely fast.<p>

The bitap algorithm is perhaps best known as one of the underlying algorithms of the <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 <link xlink:type="simple" xlink:href="../882/370882.xml">
utility</link> <link xlink:type="simple" xlink:href="../939/308939.xml">
agrep</link>, written by Manber, Wu, and <link>
Burra Gopal</link>. Manber and Wu's original paper gives extensions of the algorithm to deal with fuzzy matching of general <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link>s.</p>
<p>

Due to the data structures required by the algorithm, it performs best on patterns less than a constant length (typically the <link xlink:type="simple" xlink:href="../344/1613344.xml">
word length</link> of the machine in question), and also prefers inputs over a small alphabet. Once it has been implemented for a given alphabet and word length <it>m</it>, however, its <link xlink:type="simple" xlink:href="../ury/23rd_century.xml">
running time</link> is completely predictable &mdash; it runs in <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>mn</it>) operations, no matter the structure of the text or the pattern.</p>
<p>

This algorithm was improved by Baeza-Yates and <link>
Navarro</link> in 1996 and later by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<biologist wordnetid="109855630" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../498/1773498.xml">
Gene Myers</link></scientist>
</causal_agent>
</biologist>
</person>
</physical_entity>
 for long patterns in 1998.</p>

<sec>
<st>
Exact searching</st>
<p>

The bitap algorithm for exact <link xlink:type="simple" xlink:href="../648/28648.xml">
string searching</link>, in full generality, looks like this when implemented in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

typedef char BIT;</p>
<p>

const char *bitap_search(const char *text, const char *pattern)
{
const char *result = NULL;
int m = strlen(pattern);
BIT *R;
int i, k;</p>
<p>

if (pattern[0] == '\0') return text;</p>
<p>

/* Initialize the bit array R */
R = malloc((m+1) * sizeof *R);
for (k=1; k = m; ++k)
R[k] = 0;
R[0] = 1;</p>
<p>

for (i=0; text[i] != '\0'; ++i) {
/* Update the bit array */
for (k=m; k &amp;gt;= 1; --k)
R[k] = R[k-1] &amp;&amp; (text[i] == pattern[k-1]);</p>
<p>

if (R[m]) {
result = (text+i - m) + 1;
break;
}
}</p>
<p>

free(R);
return result;
}</p>

<p>

Bitap distinguishes itself from other well-known string searching algorithms in its natural mapping onto simple bitwise operations, as in the following modification of the above program. Notice that in this implementation, counterintuitively, each bit with value&nbsp;zero indicates a match, and each bit with value&nbsp;1 indicates a non-match. The same algorithm can be written with the intuitive semantics for 0 and 1, but in that case we must introduce another instruction into the <link xlink:type="simple" xlink:href="../659/1819659.xml">
inner loop</link> to set R |= 1. In this implementation, we take advantage of the fact that left-shifting a value shifts in zeros on the right, which is precisely the behavior we need.</p>
<p>

Notice also that we require CHAR_MAX additional bitmasks in order to convert the (text[i] == pattern[k-1]) condition in the general implementation into bitwise operations. Therefore, the bitap algorithm performs better when applied to inputs over smaller alphabets.</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

const char *bitap_bitwise_search(const char *text, const char *pattern)
{
int m = strlen(pattern);
unsigned long R;
unsigned long pattern_mask[CHAR_MAX+1];
int i;</p>
<p>

if (pattern[0] == '\0') return text;
if (m &amp;gt; 31) return "The pattern is too long!";</p>
<p>

/* Initialize the bit array R */
R = ~1;</p>
<p>

/* Initialize the pattern bitmasks */
for (i=0; i = CHAR_MAX; ++i)
pattern_mask[i] = ~0;
for (i=0; i  m; ++i)
pattern_mask[pattern[i]] &amp;= ~(1UL  i);</p>
<p>

for (i=0; text[i] != '\0'; ++i) {
/* Update the bit array */
R |= pattern_mask[text[i]];
R = 1;</p>
<p>

if (0 == (R &amp; (1UL  m)))
return (text+i - m) + 1;
}</p>
<p>

return NULL;
}</p>


</sec>
<sec>
<st>
Fuzzy searching</st>
<p>

To perform fuzzy string searching using the bitap algorithm, it is necessary to extend the bit array <it>R</it> into a second dimension. Instead of having a single array <it>R</it> that changes over the length of the text, we now have <it>k</it> distinct arrays <it>R</it>1..<it>k</it>. Array <it>Ri</it> holds a representation of the prefixes of <it>pattern</it> that match any suffix of the current string with <it>i</it> or fewer errors. In this context, an "error" may be an insertion, deletion, or substitution; see <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../418/406418.xml">
Levenshtein distance</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for more information on these operations.</p>
<p>

The implementation below performs fuzzy matching (returning the first match with up to <it>k</it> errors) using the fuzzy bitap algorithm. However, it only pays attention to substitutions, not to insertions or deletions. As before, the semantics of 0 and 1 are reversed from their intuitive meanings.</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

const char *bitap_fuzzy_bitwise_search(const char *text, const char *pattern, int k)
{
const char *result = NULL;
int m = strlen(pattern);
unsigned long *R;
unsigned long pattern_mask[CHAR_MAX+1];
int i, d;</p>
<p>

if (pattern[0] == '\0') return text;
if (m &amp;gt; 31) return "The pattern is too long!";</p>
<p>

/* Initialize the bit array R */
R = malloc((k+1) * sizeof *R);
for (i=0; i = k; ++i)
R[i] = ~1;</p>
<p>

/* Initialize the pattern bitmasks */
for (i=0; i = CHAR_MAX; ++i)
pattern_mask[i] = ~0;
for (i=0; i  m; ++i)
pattern_mask[pattern[i]] &amp;= ~(1UL  i);</p>
<p>

for (i=0; text[i] != '\0'; ++i) {
/* Update the bit arrays */
unsigned long old_Rd1 = R[0];</p>
<p>

R[0] |= pattern_mask[text[i]];
R[0] = 1;</p>
<p>

for (d=1; d = k; ++d) {
unsigned long tmp = R[d];
/* Substitution is all we care about */
R[d] = (old_Rd1 &amp; (R[d] | pattern_mask[text[i]]))  1;
old_Rd1 = tmp;
}</p>
<p>

if (0 == (R[k] &amp; (1UL  m))) {
result = (text+i - m) + 1;
break;
}
}</p>
<p>

return result;
}</p>


</sec>
<sec>
<st>
External links and references</st>
<p>

<list>
<entry level="1" type="number">

 <cite id="endnote_Manber91" style="font-style: normal;">
<b>^</b></cite>&nbsp; Udi Manber, Sun Wu. "Fast text searching with errors." Technical Report TR-91-11. Department of Computer Science, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../015/32015.xml">
University of Arizona</link></university>
, Tucson, June 1991. (<weblink xlink:type="simple" xlink:href="ftp://ftp.cs.arizona.edu/agrep/agrep.ps.1.Z">
gzipped PostScript</weblink>)</entry>
<entry level="1" type="number">

 <cite id="endnote_Manber92" style="font-style: normal;">
<b>^</b></cite>&nbsp; Udi Manber, Sun Wu. "Fast text search allowing errors." <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>, 35(10), October 1992.</entry>
<entry level="1" type="number">

 <cite id="endnote_BYG89" style="font-style: normal;">
<b>^</b></cite>&nbsp; Ricardo A. Baeza-Yates, Gast√≥n H. Gonnet. "A New Approach to Text Searching." <it>Communications of the ACM</it>, 35(10): pp. 74&ndash;82, October 1992.</entry>
<entry level="1" type="number">

  <cite id="endnote_BN96" style="font-style: normal;">
<b>^</b></cite>&nbsp; R. Baeza-Yates and G. Navarro. A faster algorithm for approximate string matching. In Dan Hirchsberg and Gene Myers, editors, Combinatorial Pattern Matching (CPM'96), LNCS 1075, pages 1--23, Irvine, CA, Jun 1996.</entry>
<entry level="1" type="number">

  <cite id="endnote_M99" style="font-style: normal;">
<b>^</b></cite>&nbsp; G. Myers. A fast bit-vector algorithm for approximate string matching based on dynamic programming,	Journal of the ACM (JACM) 46 (3), May 1999, 395 - 415.  </entry>
<entry level="1" type="number">

 <weblink xlink:type="simple" xlink:href="http://www.rational.co.za/libbitap/">
Libbitap</weblink>, a free implementation that shows how the algorithm can easily be extended for most regular expressions. Unlike the code above, it places no limit on the pattern length.</entry>
<entry level="1" type="number">

 Baeza-Yates. <it>Modern Information Retrieval</it>. ISBN 0-201-39829-X.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://johannburkard.de/software/stringsearch/">
StringSearch &#8211; high-performance pattern matching algorithms in Java</weblink> &ndash; Implementations of many String-Matching-Algorithms in Java (BNDM, Boyer-Moore-Horspool, Boyer-Moore-Horspool-Raita, Shift-Or)</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
