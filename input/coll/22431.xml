<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:32:00[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Oracle machine</title>
<id>22431</id>
<revision>
<id>232018576</id>
<timestamp>2008-08-15T01:49:28Z</timestamp>
<contributor>
<username>Gianfranco</username>
<id>918</id>
</contributor>
</revision>
<categories>
<category>Computational models</category>
<category>Recursion theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity theory</link> and <link xlink:type="simple" xlink:href="../136/442136.xml">
computability theory</link>, an <b>oracle machine</b> is an <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link> used to study <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>s. It can be visualized as a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 with a black box, called an <link xlink:type="simple" xlink:href="../589/22589.xml">
oracle</link>, which is able to decide certain decision problems in a single operation. The problem can be of any <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link>. Even <link xlink:type="simple" xlink:href="../795/54795.xml">
undecidable</link> problems, like the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link>, can be used.
<sec>
<st>
Definition</st>
<p>

An <b>oracle machine</b> is a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 connected to an <b>oracle</b>. The oracle, in this context, is thought of as an entity capable of answering some collection of questions, and usually represented as some subset <it>A</it> of the natural numbers. Intuitively then, the Turing machine can perform all of the usual operations of a Turing machine, and can also query the oracle for an answer to a specific question of the form "is <it>x</it> in <it>A</it>?" There are several different definitions of an oracle machine, all of which are equivalent in the sense that they agree on when a specific function <it>f</it> can be computed by an oracle machine with oracle <it>A</it>. The following is a description of one particular definition.</p>
<p>

An oracle machine, like a Turing machine, includes a work tape: a sequence of cells without beginning or end, each of which may contain a B (for blank) or a 1; a read/write head, which rests on a single cell of the work tape and can read the data there, write new data, and move left or right along the tape; and a control mechanism, which can be in one of a finite number of states, and which will perform different actions (reading data, writing data, moving the control mechanism, and changing states) depending on the current state and the data being read. In addition to these components, an oracle machine also includes an oracle tape, on which is printed an infinite sequence of B's and 1's corresponding to the characteristic function of the oracle set <it>A</it>, and an oracle head, which (like the read/write head) can move left or right along the oracle tape reading data, but which cannot write.</p>

<ss1>
<st>
Formal definition</st>
<p>

An oracle Turing machine is a 4-<link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link> <math>M= \langle Q, \delta, q_0, F \rangle</math> where
<list>
<entry level="1" type="bullet">

 <math>Q</math> is a finite set of <it>states''</it></entry>
<entry level="1" type="bullet">

 <math>\delta: Q \times \{B,1\}^2 \rightarrow Q \times \{B,1\} \times \{L,R\}^2</math> is a <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link> called the <it><link xlink:type="simple" xlink:href="../475/1817475.xml">
transition function</link></it>, where L is left shift, R is right shift.</entry>
<entry level="1" type="bullet">

 <math>q_0 \in Q</math> is the <it>initial state''</it></entry>
<entry level="1" type="bullet">

 <math>F \subseteq Q</math> is the set of <it>halting states</it>.</entry>
</list>
</p>
<p>

The oracle machine is initialized with the work tape containing some input with finitely many 1's and the rest of the tape blank, the oracle tape containing the characteristic function of the oracle, <it>A</it>, and the Turing machine in state <it>q</it>0 with read/write head reading the first nonblank cell of the work tape, and oracle head reading the cell of the oracle tape which corresponds to <math>\chi_A(0)</math>. Thereafter it operates according to <math>\delta</math>: if the Turing machine is currently in state <it>q</it>, the read/write head is reading a symbol <it>S</it>1, and the oracle head is reading <it>S</it>2, then if <math>\delta(q,S_1,S_2)=(q',S_1',D_1,D_2)</math>, the machine enters state <math>q'</math>, the read/write head writes the symbol <it>S</it>1' in place of <it>S</it>1, and then the read/write head moves 1 cell in direction <it>D</it>1 and the oracle head moves one cell in direction <it>D</it>2. At this point if <math>q'</math> is a halting state, the machine halts, otherwise it repeats this same procedure.</p>
<p>

Turing machines can compute functions as follows: if <it>f</it> is a function that takes natural numbers to natural numbers, <it>MA</it> is a Turing machine with oracle <it>A</it>, and whenever <it>MA</it> is initialized with the work tape consisting of <it>n</it>+1 consecutive 1's (and blank elsewhere) <it>MA</it> eventually halts with <it>f(n)</it> 1's on the tape, <it>MA</it> is said to compute the function <it>f</it>. A similar definition can be made for functions of more than one variable, or partial functions.</p>
<p>

If there is an oracle machine <it>M</it> that computes a function <it>f</it> with oracle <it>A</it>, <it>f</it> is said to be <it>A</it>-computable. If <it>f</it> is the characteristic function of a set <it>B</it>, <it>B</it> is also said to be <it>A</it>-computable, and <it>M</it> is said to be a <link xlink:type="simple" xlink:href="../375/1188375.xml">
Turing reduction</link> from <it>A</it> to <it>B</it>.</p>

</ss1>
</sec>
<sec>
<st>
Complexity classes of oracle machines</st>
<p>

The <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link> of <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>s solvable by an algorithm in class A with an oracle for a problem in class B is written AB. For example, the class of problems solvable in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link> by a <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link> with an oracle for a problem in <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
 is PNP. (This is also the class of problems reducible by <link xlink:type="simple" xlink:href="../695/159695.xml">
polynomial-time Turing reduction</link> to a problem in NP.)</p>
<p>

It is obvious that NP &amp;sube; PNP, but the question of whether NPNP, PNP, NP, and P are equal remains open. See <link xlink:type="simple" xlink:href="../651/658651.xml">
polynomial hierarchy</link> for further extensions.</p>
<p>

The notation AB also means the class of problems solvable by an algorithm in class A with an oracle for the <it>language</it> B. For example, PSAT is the class of problems solvable in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link> by a <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link> with an oracle for the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
. When language B is <link xlink:type="simple" xlink:href="../530/1176530.xml">
complete</link> for some class C, then AB=AC. In particular, since SAT is <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
, PSAT=PNP. Note that this assumes that the machine used in the definition of the class A is powerful enough to execute the reductions used in the completeness definition of the class C; for example, if A = <assets wordnetid="113329641" confidence="0.8">
<possession wordnetid="100032613" confidence="0.8">
<resource wordnetid="113331778" confidence="0.8">
<link xlink:type="simple" xlink:href="../520/658520.xml">
DSPACE</link></resource>
</possession>
</assets>
(1), ASAT does not necessarily equal ANP.</p>
<p>

Oracle machines are useful for investigating the relationship between <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../115/6115.xml">
complexity classes P and NP</link></group>
</collection>
</difficulty>
</problem>
</class>
</state>
</condition>
, by considering the relationship between PA and NPA for an oracle A. In particular, it has been shown that there exist languages A and B such that PA=NPA and PB&amp;ne;NPB (Baker, Gill, <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<theorist wordnetid="110706812" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../110/3160110.xml">
Solovay</link></logician>
</mathematician>
</scientist>
</causal_agent>
</intellectual>
</theorist>
</person>
</expert>
</physical_entity>
, 1975). The fact that the P=NP question relativizes both ways is taken as evidence that answering this question will be difficult, because any proof technique that <it>relativizes</it> (i.e., is unaffected by the addition of an oracle) will not answer the P=NP question.</p>
<p>

It is interesting to consider the case where an oracle is chosen randomly from among all possible oracles. It has been shown that if oracle A is chosen randomly, then with probability 1, PA&amp;ne;NPA (Bennett, Gill, 1981). When a question is true for almost all oracles, it is said to be true <it>for a random oracle</it>. This is sometimes taken as evidence that P&amp;ne;NP. Unfortunately, a statement may be true for a <link xlink:type="simple" xlink:href="../286/451286.xml">
random oracle</link> and false for ordinary Turing machines at the same time; for example for almost all oracles A, IPA&amp;ne;PSPACEA, while <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP</link></group>
</collection>
</class>
 = <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
Oracles and halting problems</st>
<p>

It is possible to posit the existence of an oracle which computes a <link xlink:type="simple" xlink:href="../338/1139338.xml">
non-computable function</link>, such as the answer to the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link> or some equivalent. A machine with an oracle of this sort is a <link xlink:type="simple" xlink:href="../613/175613.xml">
hypercomputer</link>.</p>
<p>

Interestingly, the halting paradox still applies to such machines; that is, although they can determine whether particular Turing machines will halt on particular inputs, they cannot determine whether machines with equivalent halting oracles will themselves halt. This fact creates a hierarchy of machines, called the <it><link xlink:type="simple" xlink:href="../475/186475.xml">
arithmetical hierarchy</link></it>, each with a more powerful halting oracle and an even harder halting problem.</p>

</sec>
<sec>
<st>
Applications to cryptography</st>
<p>

In <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>, oracles are sometimes used to make arguments for the security of cryptographic protocols where (typically) a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<primitive wordnetid="109627462" confidence="0.8">
<link xlink:type="simple" xlink:href="../526/439526.xml">
hash function</link></primitive>
</causal_agent>
</person>
</physical_entity>
 is used.  A <link xlink:type="simple" xlink:href="../348/1182348.xml">
security reduction</link> for the protocol is given in the case where, instead of a hash function, a <link xlink:type="simple" xlink:href="../286/451286.xml">
random oracle</link> is used which answers each query randomly but consistently; the oracle is assumed to be available to all parties including the attacker, just as a hash function is.  Such a proof shows that unless the attacker can solve the hard problem at the heart of the security reduction, they must make use of some interesting property of the hash function to break the protocol; they cannot treat the hash function as a black box (i.e., as a random oracle).  This method has been very effective in giving good reductions for the security of efficient protocols, but its validity is sometimes challenged in the cryptographic community since computable functions are inherently very different from random oracles.  See <link xlink:type="simple" xlink:href="../286/451286.xml">
random oracle</link> for more details.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../375/1188375.xml">
Turing reduction</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Bibliography</st>
<p>

<list>
<entry level="1" type="number">

 Alan Turing, <it>Systems of logic based on ordinals</it>, Proc. London math. soc., <b>45</b>, 1939</entry>
<entry level="1" type="number">

 C. Papadimitriou. <it>Computational Complexity</it>. Addison-Wesley, 1994. Section 14.3: Oracles, pp. 339 &ndash; 343.</entry>
<entry level="1" type="number">

 T. P. Baker, J. Gill, R. Solovay. <it>Relativizations of the P =? NP Question</it>. <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../724/1230724.xml">
SIAM Journal on Computing</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
, 4(4): 431-442 (1975)</entry>
<entry level="1" type="number">

 C. H. Bennett, J. Gill. <it>Relative to a Random Oracle A, PA != NPA != co-NPA with Probability 1</it>. SIAM Journal on Computing, 10(1): 96-113 (1981)</entry>
<entry level="1" type="number">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Michael Sipser</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(1997). Introduction to the Theory of Computation.&#32;PWS Publishing. ISBN 0-534-94728-X.</cite>&nbsp; Section 9.2: Relativization, pp.318 &ndash; 321.</entry>
<entry level="1" type="number">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, editor: <it>The Undecidable, Basic Papers on Undecidable Propositions, Unsolvable Problems And Computable Functions</it>, Raven Press, New York, 1965. Turing's paper is in this volume. Papers include those by Godel, Church, Rosser, Kleene, and Post.</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Richard Chang, Benny Chor, Oded Goldreich, Juris Hartmanis, Johan Hastad, Desh Ranjan, Pankaj Rohatgi. The Random Oracle Hypothesis is False. <it>Journal of Computer and System Sciences</it>, volume 49, issue 1, pp.24&ndash;39. August 1994. ISSN 0022-0000. http://citeseer.ist.psu.edu/282397.html</entry>
</reflist>
</p>


</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
