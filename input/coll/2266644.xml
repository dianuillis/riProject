<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:27:51[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Multilayer perceptron</title>
<id>2266644</id>
<revision>
<id>240832168</id>
<timestamp>2008-09-25T04:52:55Z</timestamp>
<contributor>
<username>SpBot</username>
<id>7016748</id>
</contributor>
</revision>
<categories>
<category>Neural networks</category>
<category>Classification algorithms</category>
</categories>
</header>
<bdy>

A <b>multilayer perceptron</b> is a <link xlink:type="simple" xlink:href="../759/574759.xml">
feedforward</link> <link xlink:type="simple" xlink:href="../523/21523.xml">
artificial neural network</link> model that maps sets of input data onto a set of appropriate output. It is a modification of the standard linear <link xlink:type="simple" xlink:href="../777/172777.xml">
perceptron</link> in that it uses three or more layers of neurons (nodes) with nonlinear <link xlink:type="simple" xlink:href="../835/14179835.xml">
activation functions</link>, and is more powerful than the perceptron in that it can distinguish data that is not linearly separable, or separable by a <link xlink:type="simple" xlink:href="../862/99862.xml">
hyperplane</link>.
<sec>
<st>
 Theory </st>


<ss1>
<st>
 Activation function </st>
<p>

If a multilayer perceptron consists of a linear activation function in all neurons, that is, a simple on-off mechanism to determine whether or not a neuron fires, then it is easily proved with <link xlink:type="simple" xlink:href="../422/18422.xml">
linear algebra</link> that any number of layers can be reduced to the standard two-layer input-output model (see <link xlink:type="simple" xlink:href="../777/172777.xml">
perceptron</link>). What makes a multilayer perceptron different is that each neuron uses a <it>nonlinear</it> activation function which was developed to model the frequency of <link xlink:type="simple" xlink:href="../998/156998.xml">
action potentials</link>, or firing, of biological neurons in the brain. This function is modeled in several ways, but must always be <link xlink:type="simple" xlink:href="../386/499386.xml">
normalizable</link> and <link xlink:type="simple" xlink:href="../335/61335.xml">
differentiable</link>.</p>
<p>

The two main activation functions used in current applications are both <link xlink:type="simple" xlink:href="../210/87210.xml">
sigmoids</link>, and are described by</p>
<p>

<indent level="1">

<math>\phi(v_i) = \tanh(v_i) ~~ \textrm{and} ~~ \phi(v_i) = (1+e^{-v_i})^{-1}</math>,
</indent>

in which the former function is a <link xlink:type="simple" xlink:href="../567/56567.xml">
hyperbolic tangent</link> which ranges from -1 to 1, and the latter is equivalent in shape but ranges from 0 to 1. Here <math>y_i</math> is the output of the <math>i</math>th node (neuron) and <math>v_i</math> is the weighted sum of the input synapses. More specialized activation functions include <link xlink:type="simple" xlink:href="../753/2310753.xml">
radial basis functions</link> which are used in another class of supervised neural network models.</p>

</ss1>
<ss1>
<st>
 Layers </st>

<p>

The multilayer perceptron consists of an input and an output layer with one or more <it>hidden layers</it> of nonlinearly-activating nodes. Each node in one layer connects with a certain weight <math>w_ij</math> to every other node in the following layer.</p>

</ss1>
<ss1>
<st>
 Learning through backpropagation </st>
<p>

Learning occurs in the perceptron by changing connection weights (or <link>
synaptic weights</link>) after each piece of data is processed, based on the amount of error in the output compared to the expected result. This is an example of <link xlink:type="simple" xlink:href="../926/20926.xml">
supervised learning</link>, and is carried out through <link xlink:type="simple" xlink:href="../091/1360091.xml">
backpropagation</link>, a generalization of the least mean squares algorithm in the linear perceptron.</p>
<p>

We represent the error in output node <math>j</math> in the <math>n</math>th data point by <math>e_j(n)=d_j(n)-y_j(n)</math>, where <math>d</math> is the target value and <math>y</math> is the value produced by the perceptron. We then make corrections to the weights of the nodes based on those corrections which minimize the <link xlink:type="simple" xlink:href="../649/9649.xml">
energy</link> of error in the entire output, given by </p>
<p>

<indent level="1">

<math>\mathcal{E}(n)=\frac{1}{2}\sum_j e_j^2(n)</math>.
</indent>

By the theory of <link xlink:type="simple" xlink:href="../159/677159.xml">
differentials</link>, we find our change in each weight to be</p>
<p>

<indent level="1">

<math>\Delta w_{ji} (n) = -\eta\frac{\partial\mathcal{E}(n)}{\partial v_j(n)} y_i(n)</math>
</indent>

where <math>y_i</math> is the output of the previous neuron and <math>\eta</math> is the <it>learning rate</it>, which is carefully selected to ensure that the weights converge to a response that is neither too specific nor too general. In programming applications, typically ranges from 0.2 to 0.8.</p>
<p>

The derivative to be calculated depends on the input synapse sum <math>v_j</math>, which itself varies. It is easy to prove that for an output node this derivative can be simplified to</p>
<p>

<indent level="1">

<math>-\frac{\partial\mathcal{E}(n)}{\partial v_j(n)} = e_j(n)\phi^\prime (v_j(n))</math>
</indent>

where <math>\phi^\prime</math> is the derivative of the activation function describe above, which itself does not vary. The analysis is more difficult for the change in weights to a hidden node, but it can be shown that the relevant derivative is</p>
<p>

<indent level="1">

<math>-\frac{\partial\mathcal{E}(n)}{\partial v_j(n)} = \phi^\prime (v_j(n))\sum_k -\frac{\partial\mathcal{E}(n)}{\partial v_k(n)} w_{kj}(n)</math>.
</indent>

Note that this depends on the change in weights of the <math>k</math>th nodes, which represent the output layer. So to change the hidden layer weights, we must first change the output layer weights according to the derivative of the activation function, and so this algorithm represents a <it>backpropagation of the activation function</it>. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</ss1>
</sec>
<sec>
<st>
 Applications </st>
<p>

Multilayer perceptrons using a backpropagation algorithm are the standard algorithm for any supervised-learning pattern recognition process and the subject of ongoing research in <link xlink:type="simple" xlink:href="../430/271430.xml">
computational neuroscience</link> and <link xlink:type="simple" xlink:href="../636/263636.xml">
parallel distributed processing</link>. They are useful in research in terms of their ability to solve problems stochastically, which often allows one to get approximate solutions for extremely <link xlink:type="simple" xlink:href="../543/7543.xml">
complex</link> problems.</p>
<p>

Currently, they are most commonly seen in <link xlink:type="simple" xlink:href="../468/29468.xml">
speech recognition</link>, <link>
image recognition</link>, and <link xlink:type="simple" xlink:href="../980/19980.xml">
machine translation</link> software, but they have also seen applications in other fields such as <link xlink:type="simple" xlink:href="../398/7398.xml">
cyber security</link>. In general, their most important use has been in the growing field of <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link>, where the multilayer perceptron's power comes from its similarity to certain <link xlink:type="simple" xlink:href="../672/1726672.xml">
biological neural networks</link> in the human brain.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite id="Reference-Haykin-1998" style="font-style:normal" class="book"><link>
Haykin, Simon</link>&#32;(1998). Neural Networks: A Comprehensive Foundation, 2,&#32;Prentice Hall. ISBN 0132733501.</cite>&nbsp;</entry>
</reflist>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
