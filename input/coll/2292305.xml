<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:28:02[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Negascout</title>
<id>2292305</id>
<revision>
<id>208034999</id>
<timestamp>2008-04-25T03:43:00Z</timestamp>
<contributor>
<username>Slizyboy</username>
<id>4429353</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Game artificial intelligence</category>
</categories>
</header>
<bdy>

<b>NegaScout</b> or <b>Principal Variation Search</b> is a <link xlink:type="simple" xlink:href="../703/1732703.xml">
negamax</link> algorithm that can be faster than <link xlink:type="simple" xlink:href="../501/159501.xml">
alpha-beta pruning</link>. Like alpha-beta pruning, NegaScout is a directional search algorithm for computing the <link xlink:type="simple" xlink:href="../589/19589.xml">
minimax</link> value of a node in a <link xlink:type="simple" xlink:href="../875/18955875.xml">
tree</link>. It dominates alpha-beta pruning in the sense that it will never examine a node that can be pruned by alpha-beta; however it relies on accurate move ordering to capitalize on this advantage.<p>

NegaScout works best when there is a good move ordering.  In practice, the move ordering is often determined by previous shallower searches.  It produces more cutoffs than alpha-beta by assuming that the first explored node is the best.  In other words, it supposes the first node is in the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../817/14819817.xml">
principal variation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.  Then, it can check whether that is true by searching the remaining nodes with a null window (also known as a scout window; when alpha and beta are equal), which is faster than searching with the regular alpha-beta window.  If the proof fails, then the first node was not in the principal variation, and the search continues as normal alpha-beta.  Hence, NegaScout works best when the move ordering is good.  With a random move ordering, NegaScout will take more time than regular alpha-beta; although it will not explore any nodes alpha-beta did not, it will have to re-search many nodes.</p>
<p>

In <link xlink:type="simple" xlink:href="../134/5134.xml">
chess</link> engines, NegaScout has typically given a 10 percent performance increase.</p>
<p>

<link xlink:type="simple" xlink:href="../985/9459985.xml">
Alexander Reinefeld</link> invented NegaScout several decades after the invention of alpha-beta pruning.  He gives a proof of correctness of NegaScout in his book. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

Another search algorithm called <link xlink:type="simple" xlink:href="../022/2381022.xml">
MTD(f)</link> can theoretically result in even fewer nodes searched.  However it has practical issues (in particular, it relies heavily on the <link xlink:type="simple" xlink:href="../748/242748.xml">
transposition table</link>) and nowadays most chess engines still use a form of NegaScout in their search. Yet another search algorithm which tends to do better than NegaScout in practice is the first-best algorithm called <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/14021543.xml">
SSS*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, although neither algorithm dominates the other. There are trees in which NegaScout searches fewer nodes than SSS* and vice-versa.  However, note that SSS* is not a depth-first search and thus has larger memory requirements.</p>

<sec>
<st>
<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
</st>

<p>

<b>function</b> negascout(node, depth, α, β)
<b>if</b> node is a terminal node <b>or</b> depth = 0
<b>return</b> the heuristic value of node
b := β                                          <it>(* initial window is (-β, -α) *)</it>
<b>foreach</b> child of node
a := -negascout (child, depth-1, -b, -α)
<b>if</b> a&amp;gt;α
α := a
<b>if</b> α&amp;ge;β
<b>return</b> α                                <it>(* Beta cut-off *)</it>
<b>if</b> α&amp;ge;b                                      <it>(* check if null-window failed high*)</it>
α := -negascout(child, depth-1, -β, -α)  <it>(* full re-search *)</it>
<b>if</b> α&amp;ge;β
<b>return</b> α                             <it>(* Beta cut-off *)</it>    
b := α+1                                    <it>(* set new null window *)</it>             
<b>return</b> α</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.seanet.com/~brucemo/topics/pvs.htm">
Principal Variation Search in chess</weblink></entry>
</list>
</p>
<p>

<reflist>
<entry id="1">
A. Reinefeld. Spielbaum-Suchverfahren. Informatik-Fachbericht 200, Springer-Verlag, Berlin (1989), ISBN 3-540-50742-6</entry>
</reflist>
</p>


</sec>
</bdy>
</article>
