<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:31:59[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<subject  confidence="0.9511911446218017" wordnetid="106599788">
<header>
<title>Programming language</title>
<id>23015</id>
<revision>
<id>244367345</id>
<timestamp>2008-10-10T13:32:50Z</timestamp>
<contributor>
<username>Derek farn</username>
<id>752956</id>
</contributor>
</revision>
<categories>
<category>Computer languages</category>
<category>Programming language topics</category>
</categories>
</header>
<bdy>

A <b>programming language</b> is an <link xlink:type="simple" xlink:href="../652/652.xml">
artificial language</link> that can be used to write <link xlink:type="simple" xlink:href="../622/18713622.xml">
programs</link> which control the behavior of a machine, particularly a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>  Programming languages are defined by <link xlink:type="simple" xlink:href="../860/26860.xml">
syntactic</link> and <link xlink:type="simple" xlink:href="../107/29107.xml">
semantic</link> rules which describe their structure and meaning respectively. Many programming languages have some form of written specification of their syntax and semantics; some are defined by an official implementation (for example, an <link xlink:type="simple" xlink:href="../934/14934.xml">
ISO</link> Standard), while others have a dominant implementation (such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
).<p>

Programming languages are also used to facilitate communication about the task of organizing and manipulating information, and to express <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s  precisely. Some authors restrict the term "programming language" to those languages that can express <it>all</it> possible algorithms;<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> sometimes the term "<link xlink:type="simple" xlink:href="../015/23015.xml">
computer language</link>" is used for more limited artificial languages.</p>

<p>

<table style="margin: 0 0 1em 1em; border: 1px solid #aaaaaa; background: #f9f9f9;" align="right" cellpadding="0" cellspacing="0">
<header style="padding: 0 5px 0 5px; background:#ccccff" align="center">
 <link xlink:type="simple" xlink:href="../015/23015.xml">
Programming language</link>lists</header>
<row>
<col style="font-size: 90%; padding: 0 5px 0 5px; border-top: #aaa 1px solid;">
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../146/144146.xml">
Alphabetical</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../144/144144.xml">
Categorical</link></entry>
<entry level="1" type="bullet">

 <record wordnetid="106647206" confidence="0.8">
<chronology wordnetid="106503224" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<timeline wordnetid="106504965" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../696/23696.xml">
Chronological</link></written_record>
</timeline>
</evidence>
</indication>
</chronology>
</record>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../148/144148.xml">
Generational</link></entry>
</list>
</col>
</row>
</table>

Thousands of different programming languages have been created so far,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> and new languages are created every year.</p>

<sec>
<st>
Definitions</st>
<p>

Traits often considered important for constituting a programming language:</p>
<p>

<list>
<entry level="1" type="bullet">

<it>Function:</it>  A programming language is a language used to write <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s, which involve a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> performing some kind of <link xlink:type="simple" xlink:href="../926/5926.xml">
computation</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> or <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> and possibly control external devices such as <link xlink:type="simple" xlink:href="../272/5272.xml">
printers</link>, robots,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> and so on.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<it>Target:</it>  Programming languages differ from <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link>s in that natural languages are only used for interaction between people, while programming languages also allow humans to communicate instructions to machines. Some programming languages are used by one device to control another. For example <link xlink:type="simple" xlink:href="../080/24080.xml">
PostScript</link> programs are frequently created by another program to control a <link xlink:type="simple" xlink:href="../272/5272.xml">
computer printer</link> or display.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<it>Constructs:</it> Programming languages may contain constructs for defining and manipulating <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link>s or controlling the <link xlink:type="simple" xlink:href="../459/45459.xml">
flow of execution</link>. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<it>Expressive power:</it>  The <link xlink:type="simple" xlink:href="../402/30402.xml">
theory of computation</link> classifies languages by the computations they are capable of expressing. All <link xlink:type="simple" xlink:href="../621/30621.xml">
Turing complete</link> languages can implement the same set of <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s. <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
ANSI/ISO SQL</link></programming_language>
 and <link xlink:type="simple" xlink:href="../508/1364508.xml">
Charity</link> are examples of languages that are not Turing complete yet often called programming languages.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></entry>
</list>
</p>
<p>

Non-computational languages, such as <link xlink:type="simple" xlink:href="../910/18910.xml">
markup language</link>s like <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../191/13191.xml">
HTML</link></format>
 or <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>s like <link>
BNF</link>, are usually not considered programming languages. A programming language (which may or may not be Turing complete) may be embedded in these non-computational (host) languages.</p>

</sec>
<sec>
<st>
Usage</st>
<p>

Programming languages (sometimes also known as computer languages) differ from most other forms of human expression in that they require a greater degree of precision and completeness. When using a natural language to communicate with other people, human authors and speakers can be ambiguous and make small errors, and still expect their intent to be understood. However, figuratively speaking, computers "do exactly what they are told to do", and cannot "understand" what code the programmer intended to write. The combination of the language definition, a program, and the program's inputs must fully specify the external behavior that occurs when the program is executed, within the domain of control of that program.</p>
<p>

Programs for a computer might be <link xlink:type="simple" xlink:href="../206/418206.xml">
executed</link> in a <link xlink:type="simple" xlink:href="../285/37285.xml">
batch process</link> without human interaction, or a user might type <link xlink:type="simple" xlink:href="../461/215461.xml">
commands</link> in an <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../452/865452.xml">
interactive session</link></rule>
</direction>
</protocol>
</message>
 of an <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreter</link>. In this case the "commands" are simply programs, whose execution is chained together.  When a language is used to give commands to a software application (such as a <environment wordnetid="113934596" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<situation wordnetid="113927383" confidence="0.8">
<link xlink:type="simple" xlink:href="../397/2281397.xml">
shell</link></situation>
</state>
</environment>
) it is called a <link xlink:type="simple" xlink:href="../524/29524.xml">
scripting language</link>.</p>
<p>

Many languages have been designed from scratch, altered to meet new needs, combined with other languages, and eventually fallen into disuse. Although there have been attempts to design one "universal" computer language that serves all purposes, all of them have failed to be generally accepted as filling this role.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref>  The need for diverse computer languages arises from the diversity of contexts in which languages are used:</p>
<p>

<list>
<entry level="1" type="bullet">

 Programs range from tiny scripts written by individual hobbyists to huge systems written by hundreds of programmers.</entry>
<entry level="1" type="bullet">

 Programmers range in expertise from novices who need simplicity above all else, to experts who may be comfortable with considerable complexity.</entry>
<entry level="1" type="bullet">

 Programs must balance speed, size, and simplicity on systems ranging from <link xlink:type="simple" xlink:href="../017/21017.xml">
microcontroller</link>s to <link xlink:type="simple" xlink:href="../153/37153.xml">
supercomputer</link>s.  </entry>
<entry level="1" type="bullet">

 Programs may be written once and not change for generations, or they may undergo nearly constant modification.</entry>
<entry level="1" type="bullet">

 Finally, programmers may simply differ in their tastes: they may be accustomed to discussing problems and expressing them in a particular language.  </entry>
</list>
</p>
<p>

One common trend in the development of programming languages has been to add more ability to solve problems using a higher level of <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/60491.xml">
abstraction</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
. The earliest programming languages were tied very closely to the underlying hardware of the computer. As new programming languages have developed, features have been added that let programmers express ideas that are more remote from simple translation into underlying hardware instructions. Because programmers are less tied to the complexity of the computer, their programs can do more computing with less effort from the programmer. This lets them write more functionality per time unit.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></p>
<p>

<link xlink:type="simple" xlink:href="../652/21652.xml">
Natural language processor</link>s have been proposed as a way to eliminate the need for a specialized language for programming. However, this goal remains distant and its benefits are open to debate. <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> took the position that the use of a formal language is essential to prevent the introduction of meaningless constructs, and dismissed natural language programming as "foolish."<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../462/300462.xml">
Alan Perlis</link></scientist>
</person>
 was similarly dismissive of the idea.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>
<p>

According to the heterogeneous methodology used by langpop.com,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref> as of 2008 the 12 most actively used programming languages are (in alphabetical order): <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
, <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/9845.xml">
JavaScript</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
, <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/24131.xml">
PHP</link></writer>
</language>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
, <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
, <environment wordnetid="113934596" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<situation wordnetid="113927383" confidence="0.8">
<link xlink:type="simple" xlink:href="../397/2281397.xml">
Shell</link></situation>
</state>
</environment>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
, and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../382/6097382.xml">
Visual Basic</link></programming_language>
.</p>

</sec>
<sec>
<st>
Elements</st>

<ss1>
<st>
Syntax</st>
<p>

<image location="right" width="396px" src="Python_add5_parse.svg" type="thumb">
</image>

<image location="right" width="292px" src="Python_add5_syntax.svg" type="thumb">
</image>
</p>
<p>

A programming language's surface form is known as its <link xlink:type="simple" xlink:href="../060/3206060.xml">
syntax</link>. Most programming languages are purely textual; they use sequences of text including words, numbers, and punctuation, much like written natural languages. On the other hand, there are some programming languages which are more <link xlink:type="simple" xlink:href="../268/499268.xml">
graphical</link> in nature, using spatial relationships between symbols to specify a program.</p>
<p>

The syntax of a language describes the possible combinations of symbols that form a syntactically correct program. The meaning given to a combination of symbols is handled by semantics (either <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../608/397608.xml">
formal</link></method>
</know-how>
 or hard-coded in a <link xlink:type="simple" xlink:href="../864/2484864.xml">
reference implementation</link>). Since most languages are textual, this article discusses textual syntax.</p>
<p>

Programming language syntax is usually defined using a combination of <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link>s (for <link xlink:type="simple" xlink:href="../251/81251.xml">
lexical</link> structure) and <link xlink:type="simple" xlink:href="../247/62247.xml">
Backus-Naur Form</link> (for <link xlink:type="simple" xlink:href="../759/6759.xml">
grammatical</link> structure). Below is a simple grammar, based on <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link>:</p>

<p>

expression ::= atom   | list
atom       ::= number | symbol    
number     ::= [+-]?['0'-'9']+
symbol     ::= ['A'-'Z''a'-'z'].*
list       ::= '(' expression* ')'</p>

<p>

This grammar specifies the following:
<list>
<entry level="1" type="bullet">

 an <it>expression</it> is either an <it>atom</it> or a <it>list</it>;</entry>
<entry level="1" type="bullet">

 an <it>atom</it> is either a <it>number</it> or a <it>symbol</it>;</entry>
<entry level="1" type="bullet">

 a <it>number</it> is an unbroken sequence of one or more decimal digits, optionally preceded by a plus or minus sign;</entry>
<entry level="1" type="bullet">

 a <it>symbol</it> is a letter followed by zero or more of any characters (excluding whitespace); and</entry>
<entry level="1" type="bullet">

 a <it>list</it> is a matched pair of parentheses, with zero or more <it>expressions</it> inside it.</entry>
</list>
</p>
<p>

The following are examples of well-formed token sequences in this grammar: '12345', '()', '(a b c232 (1))'</p>
<p>

Not all syntactically correct programs are semantically correct. Many syntactically correct programs are nonetheless ill-formed, per the language's rules; and may (depending on the language specification and the soundness of the implementation) result in an error on translation or execution. In some cases, such programs may exhibit <link xlink:type="simple" xlink:href="../992/515992.xml">
undefined behavior</link>. Even when a program is well-defined within a language, it may still have a meaning that is not intended by the person who wrote it.  </p>
<p>

Using <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link> as an example, it may not be possible to assign a meaning to a grammatically correct sentence or the sentence may be false:
<list>
<entry level="1" type="bullet">

 "<link xlink:type="simple" xlink:href="../438/46438.xml">
Colorless green ideas sleep furiously</link>." is grammatically well-formed but has no generally accepted meaning.</entry>
<entry level="1" type="bullet">

 "John is a married bachelor." is grammatically well-formed but expresses a meaning that cannot be true.</entry>
</list>
</p>
<p>

The following C language fragment is syntactically correct, but performs an operation that is not semantically defined (because p is a <link>
null pointer</link>, the operations p-&amp;gt;real and p-&amp;gt;im have no meaning):</p>
<p>

complex *p = NULL;
complex abs_p = sqrt (p-&amp;gt;real * p-&amp;gt;real + p-&amp;gt;im * p-&amp;gt;im);</p>
<p>

The grammar needed to specify a programming language can be classified by its position in the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky hierarchy</link></language>
. The syntax of most programming languages can be specified using a Type-2 grammar, i.e., they are <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link>s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></p>

</ss1>
<ss1>
<st>
Static semantics</st>

<p>

The static semantics defines restrictions on the structure of valid texts that are hard or impossible to express in standard syntactic formalisms.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref> The most important of these restrictions are covered by type systems.</p>

</ss1>
<ss1>
<st>
Type system</st>

<p>

<indent level="1">

<it>For more details on this topic, see <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/199701.xml">
Type system</link></kind>
</type>
</category>
</concept>
</idea>
.</it>
</indent>

<indent level="1">

<it>For more details on this topic, see <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../650/602650.xml">
Type safety</link></subject>
</message>
.</it>
</indent>

A type system defines how a programming language classifies values and expressions into <it>types</it>, how it can manipulate those types and how they interact. This generally includes a description of the <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link>s that can be constructed in the language. The design and study of type systems using formal mathematics is known as <it><link xlink:type="simple" xlink:href="../282/40282.xml">
type theory</link></it>.  </p>

<ss2>
<st>
Typed versus untyped languages</st>
<p>

A language is <it>typed</it> if the specification of every operation defines types of data to which the operation is applicable, with the implication that it is not applicable to other types.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref> For example, "this text between the quotes" is a string. In most programming languages, dividing a number by a string has no meaning. Most modern programming languages will therefore reject any program attempting to perform such an operation. In some languages, the meaningless operation will be detected when the program is compiled ("static" type checking), and rejected by the compiler, while in others, it will be detected when the program is run ("dynamic" type checking), resulting in a runtime <abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../231/59231.xml">
exception</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
.</p>
<p>

A special case of typed languages are the <it>single-type</it> languages. These are often scripting or markup languages, such as <link xlink:type="simple" xlink:href="../858/25858.xml">
Rexx</link> or <link>
SGML</link>, and have only one data type — most commonly character strings which are used for both symbolic and numeric data.</p>
<p>

In contrast, an <it>untyped language</it>, such as most <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly language</link>s, allows any operation to be performed on any data, which are generally considered to be sequences of bits of various lengths.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>  High-level languages which are untyped include <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../052/4052.xml">
BCPL</link></programming_language>
 and some varieties of <link xlink:type="simple" xlink:href="../012/11012.xml">
Forth</link>.</p>
<p>

In practice, while few languages are considered typed from the point of view of <link xlink:type="simple" xlink:href="../282/40282.xml">
type theory</link> (verifying or rejecting <it>all</it> operations), most modern languages offer a degree of typing.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>  Many production languages provide means to bypass or subvert the type system.</p>

</ss2>
<ss2>
<st>
Static versus dynamic typing</st>
<p>

In <it><link>
static typing</link></it> all expressions have their types determined prior to the program being run (typically at compile-time). For example, 1 and (2+2) are integer expressions; they cannot be passed to a function that expects a string, or stored in a variable that is defined to hold dates.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref></p>
<p>

Statically-typed languages can be <it>manifestly typed</it> or <it><link xlink:type="simple" xlink:href="../690/279690.xml">
type-inferred</link></it>. In the first case, the programmer must explicitly write types at certain textual positions (for example, at variable <link xlink:type="simple" xlink:href="../406/4329406.xml">
declaration</link>s). In the second case, the compiler <it>infers</it> the types of expressions and declarations based on context. Most mainstream statically-typed languages, such as <link>
C++</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 and <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, are manifestly typed. Complete type inference has traditionally been associated with less mainstream languages, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
 and <link xlink:type="simple" xlink:href="../607/20607.xml">
ML</link>. However, many manifestly typed languages support partial type inference; for example, <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 both infer types in certain limited cases.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref>
<it>Dynamic typing</it>, also called <it>latent typing</it>, determines the type-safety of operations at runtime; in other words, types are associated with <it>runtime values</it> rather than <it>textual expressions</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>  As with type-inferred languages, dynamically typed languages do not require the programmer to write explicit type annotations on expressions. Among other things, this may permit a single variable to refer to values of different types at different points in the program execution. However, type errors cannot be automatically detected until a piece of code is actually executed, making debugging more difficult. <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
, <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/9845.xml">
JavaScript</link></programming_language>
, and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 are dynamically typed.</p>

</ss2>
<ss2>
<st>
Weak and strong typing</st>
<p>

<it>Weak typing</it> allows a value of one type to be treated as another, for example treating a string as a number.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>  This can occasionally be useful, but it can also allow some kinds of program faults to go undetected at <link xlink:type="simple" xlink:href="../766/191766.xml">
compile time</link> and even at <link xlink:type="simple" xlink:href="../434/460434.xml">
run time</link>.</p>
<p>

<it>Strong typing</it> prevents the above.  An attempt to perform an operation on the wrong type of value raises an error.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>  Strongly-typed languages are often termed <it>type-safe</it> or <it><link xlink:type="simple" xlink:href="../650/602650.xml">
safe</link></it>.</p>
<p>

An alternative definition for "weakly typed" refers to languages, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/9845.xml">
JavaScript</link></programming_language>
, and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, which permit a large number of implicit type conversions.  In JavaScript, for example, the expression 2 * x implicitly converts x to a number, and this conversion succeeds even if x is null, undefined, an Array, or a string of letters.  Such implicit conversions are often useful, but they can mask programming errors.</p>
<p>

<it>Strong</it> and <it>static</it> are now generally considered orthogonal concepts, but usage in the literature differs. Some use the term <it>strongly typed</it> to mean <it>strongly, statically typed</it>, or, even more confusingly, to mean simply <it>statically typed</it>. Thus <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 has been called both strongly typed and weakly, statically typed.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref></p>

</ss2>
</ss1>
<ss1>
<st>
Execution semantics</st>
<p>

Once data has been specified, the machine must be instructed to perform operations on the data. The <it>execution semantics</it> of a language defines how and when the various constructs of a language should produce a program behavior.</p>
<p>

For example, the semantics may define the <link xlink:type="simple" xlink:href="../119/2977119.xml">
strategy</link> by which expressions are evaluated to values, or the manner in which <link xlink:type="simple" xlink:href="../459/45459.xml">
control structure</link>s conditionally execute statements.</p>

</ss1>
<ss1>
<st>
Core library</st>

<p>

<indent level="1">

<it>For more details on this topic, see <link xlink:type="simple" xlink:href="../669/374669.xml">
Standard library</link>.</it>
</indent>

Most programming languages have an associated <link xlink:type="simple" xlink:href="../421/106421.xml">
core library</link> (sometimes known as the 'Standard library', especially if it is included as part of the published language standard), which is conventionally made available by all implementations of the language. Core libraries typically include definitions for commonly used algorithms, data structures, and mechanisms for input and output.</p>
<p>

A language's core library is often treated as part of the language by its users, although the designers may have treated it as a separate entity. Many language specifications define a core that must be made available in all implementations, and in the case of standardized languages this core library may be required. The line between a language and its core library therefore differs from language to language. Indeed, some languages are designed so that the meanings of certain syntactic constructs cannot even be described without referring to the core library. For example, in <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, a string literal is defined as an instance of the java.lang.String class; similarly, in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/28319.xml">
Smalltalk</link></programming_language>
, an <link xlink:type="simple" xlink:href="../181/7018181.xml">
anonymous function</link> expression (a "block") constructs an instance of the library's BlockContext class. Conversely, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
 contains multiple coherent subsets that suffice to construct the rest of the language as library macros, and so the language designers do not even bother to say which portions of the language must be implemented as language constructs, and which must be implemented as parts of a library.</p>

</ss1>
</sec>
<sec>
<st>
Practice</st>
<p>

A language's designers and users must construct a number of artifacts that govern and enable the practice of programming. The most important of these artifacts are the language <it>specification</it> and <it>implementation</it>.</p>

<ss1>
<st>
Specification</st>

<p>

<indent level="1">

<it>For more details on this topic, see <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../926/5438926.xml">
Programming language specification</link></subject>
</message>
.</it>
</indent>
The <b>specification</b> of a programming language is intended to provide a definition that the language <link xlink:type="simple" xlink:href="../716/23716.xml">
user</link>s and the <link xlink:type="simple" xlink:href="../284/5439284.xml">
implementors</link> can use to determine whether the behavior of a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link> is correct, given its <link xlink:type="simple" xlink:href="../661/27661.xml">
source code</link>.</p>
<p>

A programming language specification can take several forms, including the following:</p>
<p>

<list>
<entry level="1" type="bullet">

 An explicit definition of the syntax, static semantics, and execution semantics of the language. While syntax is commonly specified using a formal grammar, semantic definitions may be written in <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link> (e.g., the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C language</link></programming_language>
), or a <link xlink:type="simple" xlink:href="../608/397608.xml">
formal semantics</link> (e.g., the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../337/100337.xml">
Standard ML</link></programming_language>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref> and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2220%22])">20</ref> specifications). </entry>
<entry level="1" type="bullet">

 A description of the behavior of a <link xlink:type="simple" xlink:href="../739/5739.xml">
translator</link> for the language (e.g., the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
 specifications). The syntax and semantics of the language have to be inferred from this description, which may be written in natural or a formal language.</entry>
<entry level="1" type="bullet">

 A <it>reference</it> or <it>model</it> implementation, sometimes written in the language being specified (e.g., <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link> or <link xlink:type="simple" xlink:href="../858/25858.xml">
ANSI REXX</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref>). The syntax and semantics of the language are explicit in the behavior of the reference implementation.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Implementation</st>

<p>

<indent level="1">

<it>For more details on this topic, see <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../284/5439284.xml">
Programming language implementation</link></subject>
</message>
.</it>
</indent>
An <b>implementation</b> of a programming language provides a way to execute that program on one or more configurations of hardware and software. There are, broadly, two approaches to programming language implementation: <it><link xlink:type="simple" xlink:href="../739/5739.xml">
compilation</link></it> and <it><link xlink:type="simple" xlink:href="../868/59868.xml">
interpretation</link></it>. It is generally possible to implement a language using either technique.</p>
<p>

The output of a <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> may be executed by hardware or a program called an interpreter. In some implementations that make use of the interpreter approach there is no distinct boundary between compiling and interpreting. For instance, some implementations of the <link xlink:type="simple" xlink:href="../015/4015.xml">
BASIC programming language</link> compile and then execute the source a line at a time.</p>
<p>

Programs that are executed directly on the hardware usually run several orders of magnitude faster than those that are interpreted in software.</p>
<p>

One technique for improving the performance of interpreted programs is <link xlink:type="simple" xlink:href="../632/220632.xml">
just-in-time compilation</link>. Here the <link xlink:type="simple" xlink:href="../353/32353.xml">
virtual machine</link>, just before execution, translates the blocks of <link xlink:type="simple" xlink:href="../997/89997.xml">
bytecode</link> which are going to be used to machine code, for direct execution on the hardware.</p>

</ss1>
</sec>
<sec>
<st>
History</st>
<p>

<image location="right" width="230px" src="Programming_language_textbooks.jpg" type="thumb">
<caption>

A selection of textbooks that teach programming, in languages both popular and obscure. These are only a few of the thousands of programming languages and dialects that have been designed in history.
</caption>
</image>
</p>

<p>

<indent level="1">

<it>For more details on this topic, see <link xlink:type="simple" xlink:href="../120/896120.xml">
History of programming languages</link>.</it>
</indent>

</p>
<ss1>
<st>
Early developments</st>
<p>

The first programming languages predate the modern computer. The 19th century had "programmable" <link xlink:type="simple" xlink:href="../595/46595.xml">
loom</link>s and <link xlink:type="simple" xlink:href="../012/146012.xml">
player piano</link> scrolls which implemented what are today recognized as examples of <link xlink:type="simple" xlink:href="../239/519239.xml">
domain-specific programming language</link>s. By the beginning of the twentieth century, punch cards encoded data and directed mechanical processing. In the 1930s and 1940s, the formalisms of <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Alonzo Church</link></scientist>
's <link xlink:type="simple" xlink:href="../203/18203.xml">
lambda calculus</link> and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
's <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s provided mathematical abstractions for expressing <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s; the lambda calculus remains influential in language design.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref></p>
<p>

In the 1940s, the first electrically powered digital computers were created. The first <link xlink:type="simple" xlink:href="../842/189842.xml">
high-level programming language</link> to be designed for a computer was <link>
Plankalkül</link>, developed for the German <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../671/152671.xml">
Z3</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../810/16810.xml">
Konrad Zuse</link></scientist>
</person>
 between 1943 and 1945.</p>
<p>

The computers of the early 1950s, notably the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../981/142981.xml">
UNIVAC I</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 and the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/192701.xml">
IBM 701</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 used <link xlink:type="simple" xlink:href="../683/20683.xml">
machine language programs</link>. <link xlink:type="simple" xlink:href="../826/81826.xml">
First generation</link> machine language programming was quickly superseded by a <link xlink:type="simple" xlink:href="../475/649475.xml">
second generation</link> of programming languages known as <link xlink:type="simple" xlink:href="../368/1368.xml">
Assembly language</link>s. Later in the 1950s, assembly language programming, which had evolved to include the use of <link xlink:type="simple" xlink:href="../906/6427906.xml">
macro instruction</link>s, was followed by the development of three higher-level programming languages: <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link>, <link xlink:type="simple" xlink:href="../016/18016.xml">
LISP</link>, and <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link>. Updated versions of all of these are still in general use, and each has strongly influenced the development of later languages.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref>  At the end of the 1950s, the language formalized as <link xlink:type="simple" xlink:href="../453/1453.xml">
Algol 60</link> was introduced, and most later programming languages are, in many respects, descendants of Algol.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref> The format and use of the early programming languages was heavily influenced by the <link xlink:type="simple" xlink:href="../371/7380371.xml">
constraints of the interface</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref></p>

</ss1>
<ss1>
<st>
Refinement</st>

<p>

The period from the 1960s to the late 1970s brought the development of the major language paradigms now in use, though many aspects were refinements of ideas in the very first <link xlink:type="simple" xlink:href="../250/393250.xml">
Third-generation programming language</link>s:
<list>
<entry level="1" type="bullet">

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../451/1451.xml">
APL</link></programming_language>
 introduced <it><link xlink:type="simple" xlink:href="../887/890887.xml">
array programming</link></it> and influenced <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2225%22])">25</ref></entry>
<entry level="1" type="bullet">

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../708/23708.xml">
PL/I</link></programming_language>
 (NPL) was designed in the early 1960s to incorporate the best ideas from FORTRAN and COBOL.</entry>
<entry level="1" type="bullet">

In the 1960s, <link xlink:type="simple" xlink:href="../513/29513.xml">
Simula</link> was the first language designed to support <it><link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented programming</link></it>; in the mid-1970s, <link xlink:type="simple" xlink:href="../319/28319.xml">
Smalltalk</link> followed with the first "purely" object-oriented language.</entry>
<entry level="1" type="bullet">

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 was developed between 1969 and 1973 as a <it><link>
systems programming</link></it> language, and remains popular.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2226%22])">26</ref></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link>, designed in 1972, was the first <it><link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic programming</link></it> language.</entry>
<entry level="1" type="bullet">

In 1978, <link xlink:type="simple" xlink:href="../607/20607.xml">
ML</link> built a polymorphic type system on top of Lisp, pioneering <it><link>
statically typed</link> <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming</link></it> languages.</entry>
</list>

Each of these languages spawned an entire family of descendants, and most modern languages count at least one of them in their ancestry.</p>
<p>

The 1960s and 1970s also saw considerable debate over the merits of <it><link xlink:type="simple" xlink:href="../695/27695.xml">
structured programming</link></it>, and whether programming languages should be designed to support it.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2227%22])">27</ref> <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link></scientist>
</person>
, in a famous 1968 letter published in the <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
, argued that <link xlink:type="simple" xlink:href="../853/197853.xml">
GOTO</link> statements should be eliminated from all "higher level" programming languages.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2228%22])">28</ref></p>
<p>

The 1960s and 1970s also saw expansion of techniques that reduced the footprint of a program as well as improved productivity of the programmer and user. The <link xlink:type="simple" xlink:href="../371/7380371.xml">
card deck</link> for an early <link xlink:type="simple" xlink:href="../367/11367.xml">
4GL</link> was a lot smaller for the same functionality expressed in a <link xlink:type="simple" xlink:href="../250/393250.xml">
3GL deck</link>.</p>

</ss1>
<ss1>
<st>
Consolidation and growth</st>

<p>

The 1980s were years of relative consolidation. <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
 combined object-oriented and systems programming. The United States government standardized <link xlink:type="simple" xlink:href="../242/1242.xml">
Ada</link>, a systems programming language intended for use by defense contractors. In Japan and elsewhere, vast sums were spent investigating so-called <link xlink:type="simple" xlink:href="../832/347832.xml">
"fifth generation" languages</link> that incorporated logic programming constructs.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2229%22])">29</ref> The functional languages community moved to standardize ML and Lisp. Rather than inventing new paradigms, all of these movements elaborated upon the ideas invented in the previous decade.</p>
<p>

One important trend in language design during the 1980s was an increased focus on programming for large-scale systems through the use of <it>modules</it>, or large-scale organizational units of code.  <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/81259.xml">
Modula-2</link></programming_language>
, Ada, and ML all developed notable module systems in the 1980s, although other languages, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../708/23708.xml">
PL/I</link></programming_language>
, already had extensive support for modular programming. Module systems were often wedded to <link xlink:type="simple" xlink:href="../837/105837.xml">
generic programming</link> constructs.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2230%22])">30</ref></p>
<p>

The rapid growth of the <link xlink:type="simple" xlink:href="../539/14539.xml">
Internet</link> in the mid-1990s created opportunities for new languages.  <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
, originally a Unix scripting tool first released in 1987, became common in dynamic <link xlink:type="simple" xlink:href="../898/33898.xml">
Web site</link>s.  <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 came to be used for server-side programming. These developments were not fundamentally novel, rather they were refinements to existing languages and paradigms, and largely based on the C family of programming languages.</p>
<p>

Programming language evolution continues, in both industry and research. Current directions include security and reliability verification, new kinds of modularity (<link xlink:type="simple" xlink:href="../968/271968.xml">
mixin</link>s, <link xlink:type="simple" xlink:href="../333/604333.xml">
delegates</link>, <link xlink:type="simple" xlink:href="../329/145329.xml">
aspects</link>), and database integration. </p>
<p>

The <link xlink:type="simple" xlink:href="../367/11367.xml">
4GL</link>s are examples of languages which are domain-specific, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
, which manipulates and returns <link xlink:type="simple" xlink:href="../886/454886.xml">
set</link>s of data rather than the scalar values which are canonical to most programming languages. <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
, for example, with its '<link xlink:type="simple" xlink:href="../425/1426425.xml">
here document</link>' can hold multiple 4GL programs, as well as multiple JavaScript programs, in part of its own perl code and use variable interpolation in the 'here document' to support multi-language programming.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2231%22])">31</ref></p>

</ss1>
<ss1>
<st>
 Measuring language usage </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../719/18968719.xml">
Measuring programming language popularity</link></it>
</indent>

It is difficult to determine which programming languages are most widely used, and what usage means varies by context. One language may occupy the greater number of programmer hours, a different one have more lines of code, and a third utilize the most CPU time. Some languages are very popular for particular kinds of applications. For example, <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link> is still strong in the corporate data center, often on large <link xlink:type="simple" xlink:href="../266/20266.xml">
mainframes</link>; <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link> in engineering applications; <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 in embedded applications and operating systems; and other languages are regularly used to write many different kinds of applications.</p>
<p>

Various methods of measuring language popularity, each subject to a different bias over what is measured, have been proposed:</p>
<p>

<list>
<entry level="1" type="bullet">

counting the number of job advertisements that mention the language<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2232%22])">32</ref></entry>
<entry level="1" type="bullet">

the number of books sold that teach or describe the language<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2233%22])">33</ref></entry>
<entry level="1" type="bullet">

estimates of the number of existing lines of code written in the language—which may underestimate languages not often found in public searches<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2234%22])">34</ref></entry>
<entry level="1" type="bullet">

counts of language references (i.e., to the name of the language) found using a web search engine.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Taxonomies</st>

<p>

<indent level="1">

<it>For more details on this topic, see <link xlink:type="simple" xlink:href="../144/144144.xml">
Categorical list of programming languages</link>.</it>
</indent>
There is no overarching classification scheme for programming languages. A given programming language does not usually have a single ancestor language. Languages commonly arise by combining the elements of several predecessor languages with new ideas in circulation at the time. Ideas that originate in one language will diffuse throughout a family of related languages, and then leap suddenly across familial gaps to appear in an entirely different family.</p>
<p>

The task is further complicated by the fact that languages can be classified along multiple axes. For example, Java is both an object-oriented language (because it encourages object-oriented organization) and a concurrent language (because it contains built-in constructs for running multiple <link xlink:type="simple" xlink:href="../303/45303.xml">
threads</link> in parallel).  <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 is an object-oriented <link xlink:type="simple" xlink:href="../524/29524.xml">
scripting language</link>.</p>
<p>

In broad strokes, programming languages divide into <it><link xlink:type="simple" xlink:href="../897/189897.xml">
programming paradigm</link>s</it> and a classification by <it>intended domain of use</it>. Paradigms include <link xlink:type="simple" xlink:href="../801/23801.xml">
procedural programming</link>, <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented programming</link>, <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming</link>, and <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic programming</link>; some languages are hybrids of paradigms or multi-paradigmatic. An <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly language</link> is not so much a paradigm as a direct model of an underlying machine architecture. By purpose, programming languages might be considered general purpose, system programming languages, scripting languages, domain-specific languages, or concurrent/distributed languages (or a combination of these).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2235%22])">35</ref>  Some general purpose languages were designed largely with educational goals.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2236%22])">36</ref></p>
<p>

A programming language may also be classified by factors unrelated to programming paradigm. For instance, most programming languages use <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../916/8569916.xml">
English language</link></language>
 keywords, while a <link xlink:type="simple" xlink:href="../144/144144.xml#xpointer(//*[./st=%22Non-English-based+languages%22])">
minority do not</link>. Other languages may be classified as being <link xlink:type="simple" xlink:href="../398/53398.xml">
esoteric</link> or not.</p>

</sec>
<sec>
<st>
See also</st>

<p>

<table style="background:#f9f9f9; font-size:85%; line-height:110%; ">
<row>
<col>
 <image width="32x28px" src="Portal.svg">
</image>
</col>
<col style="padding:0 0.2em;">
 <b><it>
Computer science&#32;portal</it></b></col>
</row>
</table>
</p>


<p>

<image location="none" width="50px" src="Wiktionary-logo-en.svg">
<caption>

Wiktionary
</caption>
</image>

Look up  in <web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../658/156658.xml">
Wiktionary</link></web_site>
, the free dictionary.</p>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../311/5311.xml">
Computer programming</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../458/113458.xml">
Lists of programming languages</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../469/3406469.xml">
Comparison of programming languages</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../019/14513019.xml">
Comparison of basic instructions of programming languages</link></entry>
<entry level="1" type="bullet">

<work wordnetid="100575741" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<examination wordnetid="100635850" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<investigation wordnetid="100633864" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<comparison wordnetid="100142665" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/426660.xml">
Educational programming language</link></activity>
</comparison>
</psychological_feature>
</act>
</investigation>
</event>
</subject>
</examination>
</message>
</work>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../992/4160992.xml">
Invariant based programming</link></entry>
<entry level="1" type="bullet">

<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../136/18136.xml">
Literate programming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../744/948744.xml">
Programming language dialect</link></entry>
<entry level="1" type="bullet">

<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../218/3882218.xml">
Programming language theory</link></subject>
</message>
</entry>
<entry level="1" type="bullet">

<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../323/5323.xml">
Computer science</link> and <link xlink:type="simple" xlink:href="../633/169633.xml">
List of basic computer science topics</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../010/27010.xml">
Software engineering</link> and <link xlink:type="simple" xlink:href="../762/264762.xml">
List of software engineering topics</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=33636">
ISO 5127</weblink>—Information and documentation—Vocabulary, clause 01.05.10, defines a programming language as: an artificial language for expressing programs</entry>
<entry id="2">
In mathematical terms, this means the programming language is <link xlink:type="simple" xlink:href="../621/30621.xml">
Turing-complete</link>  <cite id="Reference-MacLennan-1987" style="font-style:normal" class="book">MacLennan, Bruce J.&#32;(1987). Principles of Programming Languages.&#32;Oxford University Press,&#32;1. ISBN 0-19-511306-3.</cite>&nbsp;</entry>
<entry id="3">
<link xlink:type="simple" xlink:href="../164/36164.xml">
As of May 2006</link> <weblink xlink:type="simple" xlink:href="http://hopl.murdoch.edu.au/">
The Encyclopedia of Computer Languages</weblink> by <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../107/285107.xml">
Murdoch University</link></university>
, Australia lists 8512 computer languages.</entry>
<entry id="4">
<organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
ACM</link></organization>
 SIGPLAN&#32;(2003).&#32;"<weblink xlink:type="simple" xlink:href="http://www.acm.org/sigs/sigplan/sigplan_bylaws.htm">
Bylaws of the Special Interest Group on Programming Languages of the Association for Computing Machinery</weblink>".&#32;Retrieved on <link>
2006-06-19</link>., <it>The scope of SIGPLAN is the theory, design, implementation, description, and application of computer programming languages - languages that permit the specification of a variety of different computations, thereby providing the user with significant control (immediate or delayed) over the computer's operation.''</it></entry>
<entry id="5">
Dean, Tom&#32;(2002).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cs.brown.edu/people/tld/courses/cs148/02/programming.html">
Programming Robots</weblink>".&#32;<it>Building Intelligent Robots</it>.&#32;  Brown University Department of Computer Science.&#32;Retrieved on <link>
2006-09-23</link>.</entry>
<entry id="6">
Digital Equipment Corporation.&#32;"<weblink xlink:type="simple" xlink:href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">
Information Technology - Database Language SQL (Proposed revised text of DIS 9075)</weblink>".&#32;<it>ISO/IEC 9075:1992, Database Language SQL</it>.&#32;Retrieved on June 29, 2006.</entry>
<entry id="7">
The Charity Development Group&#32;(December 1996).&#32;"<weblink xlink:type="simple" xlink:href="http://pll.cpsc.ucalgary.ca/charity1/www/home.html">
The CHARITY Home Page</weblink>".&#32;Retrieved on <link>
2006-06-29</link>., <it>Charity is a categorical programming language...</it>, <it>All Charity computations terminate.''</it></entry>
<entry id="8">
IBM in first publishing PL/I, for example, rather ambitiously titled its manual <it>The universal programming language PL/I</it> (IBM Library; 1966). The title reflected IBM's goals for unlimited subsetting capability: <it>PL/I is designed in such a way that one can isolate subsets from it satisfying the requirements of particular applications.</it> ("<weblink xlink:type="simple" xlink:href="http://eom.springer.de/P/p072885.htm">
Encyclopaedia of Mathematics » P  » PL/I</weblink>".&#32;<it>SpringerLink</it>.&#32;Retrieved on June 29, 2006.).  <link xlink:type="simple" xlink:href="../242/1242.xml">
Ada</link> and <link xlink:type="simple" xlink:href="../869/771869.xml">
UNCOL</link> had similar early goals.</entry>
<entry id="9">
 Frederick P. Brooks, Jr.: <it>The Mythical Man-Month,</it> Addison-Wesley, 1982, pp. 93-94 </entry>
<entry id="10">
Dijkstra, Edsger W. <weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html">
On the foolishness of "natural language programming."</weblink> EWD667.</entry>
<entry id="11">
Perlis, Alan, <weblink xlink:type="simple" xlink:href="http://www-pu.informatik.uni-tuebingen.de/users/klaeren/epigrams.html">
Epigrams on Programming</weblink>. SIGPLAN Notices Vol. 17, No. 9, September 1982, pp. 7-13</entry>
<entry id="12">
http://www.langpop.com/</entry>
<entry id="13">
 <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Michael Sipser</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(1997). Introduction to the Theory of Computation.&#32;PWS Publishing. ISBN 0-534-94728-X.</cite>&nbsp; Section 2.2: Pushdown Automata, pp.101&ndash;114.</entry>
<entry id="14">
 <cite id="Reference-Aaby-2004" style="font-style:normal" class="book">Aaby, Anthony&#32;(2004). <weblink xlink:type="simple" xlink:href="http://cs.wwc.edu/~aabyan/LN/PL/book/index.html">
Introduction to Programming Languages</weblink>.</cite>&nbsp;</entry>
<entry id="15">
Andrew Cooke.&#32;"<weblink xlink:type="simple" xlink:href="http://www.acooke.org/andrew/writing/lang.html#sec-types">
An Introduction to Programming Languages</weblink>".&#32;Retrieved on June 30, 2006.</entry>
<entry id="17">
"<weblink xlink:type="simple" xlink:href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-4.html">
Revised Report on the Algorithmic Language Scheme (February 20, 1998)</weblink>".&#32;Retrieved on June 9, 2006.</entry>
<entry id="16">
Specifically, instantiations of <link xlink:type="simple" xlink:href="../837/105837.xml">
generic</link> types are inferred for certain expression forms. Type inference in Generic Java—the research language that provided the basis for Java 1.5's bounded <link xlink:type="simple" xlink:href="../811/261811.xml">
parametric polymorphism</link> extensions—is discussed in two informal manuscripts from the <link>
Types mailing list</link>: <weblink xlink:type="simple" xlink:href="http://www.seas.upenn.edu/~sweirich/types/archive/1999-2003/msg00849.html">
Generic Java type inference is unsound</weblink> (<physical_entity wordnetid="100001930" confidence="0.8">
<cricketer wordnetid="109977326" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<contestant wordnetid="109613191" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<athlete wordnetid="109820263" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/11323318.xml">
Alan Jeffrey</link></athlete>
</causal_agent>
</contestant>
</person>
</cricketer>
</physical_entity>
, 17 December 2001) and <weblink xlink:type="simple" xlink:href="http://www.seas.upenn.edu/~sweirich/types/archive/1999-2003/msg00921.html">
Sound Generic Java type inference</weblink> (<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../093/13677093.xml">
Martin Odersky</link></scientist>
, 15 January 2002). C#'s type system is similar to Java's, and uses a similar partial type inference scheme.</entry>
<entry id="19">
 <cite id="Reference-Milner-1997" style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../547/93547.xml">
Milner, R.</link></scientist>
</person>
;&#32;<link>
M. Tofte</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../444/2871444.xml">
R. Harper</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 and D. MacQueen.&#32;(1997). The Definition of Standard ML (Revised).&#32;MIT Press. ISBN 0-262-63181-4.</cite>&nbsp;</entry>
<entry id="18">
<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../165/4614165.xml">
Luca Cardelli</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 and <link>
Peter Wegner</link>.&#32;"<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/cardelli85understanding.html">
On Understanding Types, Data Abstraction, and Polymorphism</weblink>".&#32;<it>Manuscript (1985)</it>.&#32;Retrieved on June 9, 2006.</entry>
<entry id="21">
<link xlink:type="simple" xlink:href="../659/659.xml">
ANSI</link> — Programming Language Rexx, X3-274.1996</entry>
<entry id="20">
Kelsey, Richard;&#32;William Clinger and Jonathan Rees&#32;(February 1998).&#32;"<weblink xlink:type="simple" xlink:href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-10.html#%_sec_7.2">
Section 7.2 Formal semantics</weblink>".&#32;<it>Revised5 Report on the Algorithmic Language Scheme</it>.&#32;Retrieved on <link>
2006-06-09</link>.</entry>
<entry id="23">
 <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../827/216827.xml">
O'Reilly Media</link></company>
.&#32;"<weblink xlink:type="simple" xlink:href="http://www.oreilly.com/news/graphics/prog_lang_poster.pdf">
History of programming languages</weblink>".&#32;Retrieved on October 5, 2006.</entry>
<entry id="22">
Benjamin C. Pierce writes:
<indent level="1">

"... the lambda calculus has seen widespread use in the specification of programming language features, in language design and implementation, and in the study of type systems."
</indent>
 <cite id="Reference-Pierce-2002" style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../961/1381961.xml">
Pierce, Benjamin C.</link></scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(2002). Types and Programming Languages.&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../601/719601.xml">
MIT Press</link></company>
,&#32;52. ISBN 0-262-16209-1.</cite>&nbsp;</entry>
<entry id="25">
Richard L. Wexelblat: <it>History of Programming Languages</it>, Academic Press, 1981, chapter XIV.</entry>
<entry id="24">
Frank da Cruz. <weblink xlink:type="simple" xlink:href="http://www.columbia.edu/acis/history/cards.html">
IBM Punch Cards</weblink> <weblink xlink:type="simple" xlink:href="http://www.columbia.edu/acis/history/index.html">
Columbia University Computing History</weblink>.</entry>
<entry id="27">
  <cite id="CITEREFHayes2006" style="font-style:normal">Hayes, Brian&#32;(2006),&#32;"The Semicolon Wars",&#32;<it>American Scientist</it>&#32;<b>94</b>(4):  pp. 299–303</cite>&nbsp; </entry>
<entry id="26">
François Labelle.&#32;"<weblink xlink:type="simple" xlink:href="http://www.cs.berkeley.edu/~flab/languages.html">
Programming Language Usage Graph</weblink>".&#32;<it><link xlink:type="simple" xlink:href="../227/52227.xml">
Sourceforge</link></it>.&#32;Retrieved on June 21, 2006.. This comparison analyzes trends in number of projects hosted by a popular community programming repository. During most years of the comparison, C leads by a considerable margin; in 2006, Java overtakes C, but the combination of C/C++ still leads considerably.</entry>
<entry id="29">
 
Tetsuro Fujise, Takashi Chikayama
Kazuaki Rokusawa, Akihiko Nakase (December 1994). "KLIC: A Portable Implementation of KL1" <it>Proc. of FGCS '94, ICOT</it> Tokyo, December 1994. <weblink xlink:type="simple" xlink:href="http://www.icot.or.jp/ARCHIVE/HomePage-E.html">
KLIC is a portable implementation of a concurrent logic programming language <link xlink:type="simple" xlink:href="../179/17179.xml">
KL1</link>.</weblink></entry>
<entry id="28">
 <cite style="font-style:normal"><link xlink:type="simple" xlink:href="../018/10018.xml">
Dijkstra, Edsger W.</link>&#32;(March 1968).&#32;"<weblink xlink:type="simple" xlink:href="http://www.acm.org/classics/oct95/">
Go To Statement Considered Harmful</weblink>". <it>Communications of the ACM</it>&#32;<b>11</b>&#32;(3): 147–148. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F362929.362947">
10.1145/362929.362947</weblink>. Retrieved on <link>
2006-06-29</link>.</cite>&nbsp;</entry>
<entry id="31">
Wall, <it>Programming Perl</it> ISBN 0-596-00027-8 p.66</entry>
<entry id="30">
Jim Bender&#32;(March 15th, 2004).&#32;"<weblink xlink:type="simple" xlink:href="http://readscheme.org/modules/">
Mini-Bibliography on Modules for Functional Programming Languages</weblink>".&#32;<it>ReadScheme.org</it>.&#32;Retrieved on <link>
2006-09-27</link>.</entry>
<entry id="34">
Bieman, J.M.; Murdock, V., Finding code on the World Wide Web: a preliminary investigation, Proceedings First IEEE International Workshop on Source Code Analysis and Manipulation, 2001</entry>
<entry id="35">
"<weblink xlink:type="simple" xlink:href="http://tunes.org/wiki/programming_20languages.html">
TUNES: Programming Languages</weblink>".</entry>
<entry id="32">
<weblink xlink:type="simple" xlink:href="http://www.computerweekly.com/Articles/2007/09/11/226631/sslcomputer-weekly-it-salary-survey-finance-boom-drives-it-job.htm">
Survey of Job advertisements mentioning a given language</weblink></entry>
<entry id="33">
<weblink xlink:type="simple" xlink:href="http://radar.oreilly.com/archives/2006/08/programming_language_trends_1.html">
Counting programming languages by book sales</weblink></entry>
<entry id="36">
 <cite style="font-style:normal"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../642/21642.xml">
Wirth, Niklaus</link></scientist>
</person>
&#32;(1993).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=155378">
Recollections about the development of Pascal</weblink>". <it>Proc. 2nd <link xlink:type="simple" xlink:href="../658/1226658.xml">
ACM SIGPLAN</link> conference on history of programming languages</it>: 333–342. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F154766.155378">
10.1145/154766.155378</weblink>. Retrieved on <link>
2006-06-30</link>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

Daniel P. Friedman, Mitchell Wand, Christopher Thomas Haynes: <it>Essentials of Programming Languages</it>, The MIT Press 2001.</entry>
<entry level="1" type="bullet">

David Gelernter, Suresh Jagannathan: <it>Programming Linguistics</it>, The MIT Press 1990.</entry>
<entry level="1" type="bullet">

Shriram Krishnamurthi: <it>Programming Languages: Application and Interpretation</it>, <weblink xlink:type="simple" xlink:href="http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/">
online publication</weblink>.</entry>
<entry level="1" type="bullet">

Bruce J. MacLennan: <it>Principles of Programming Languages: Design, Evaluation, and Implementation</it>, Oxford University Press 1999.</entry>
<entry level="1" type="bullet">

John C. Mitchell: <it>Concepts in Programming Languages</it>, Cambridge University Press 2002.</entry>
<entry level="1" type="bullet">

Benjamin C. Pierce: <it>Types and Programming Languages</it>, The MIT Press 2002.</entry>
<entry level="1" type="bullet">

Ravi Sethi: <it>Programming Languages: Concepts and Constructs</it>, 2nd ed., Addison-Wesley 1996.</entry>
<entry level="1" type="bullet">

Michael L. Scott: <it>Programming Language Pragmatics</it>, Morgan Kaufmann Publishers 2005.</entry>
<entry level="1" type="bullet">

Richard L. Wexelblat (ed.): <it>History of Programming Languages</it>, Academic Press 1981.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.99-bottles-of-beer.net/">
99 Bottles of Beer</weblink> A collection of implementations in many languages.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://dmoz.org/Computers/Programming/Languages/">
Open Directory - Computer Programming Languages</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://merd.sourceforge.net/pixel/language-study/syntax-across-languages/">
Syntax Patterns for Various Languages</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.langpop.com">
Popularity statistics</weblink>.</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
Types of <link xlink:type="simple" xlink:href="../015/23015.xml">
Programming language</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../887/890887.xml">
Array</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../368/1368.xml">
Assembly</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../101/174101.xml">
Compiled</link></subject>
</message>
 &nbsp;·  <link xlink:type="simple" xlink:href="../605/2581605.xml">
Concurrent</link> &nbsp;·  <link xlink:type="simple" xlink:href="../103/560103.xml">
Curly bracket</link> &nbsp;·  <link>
Data-oriented</link> &nbsp;·  <link xlink:type="simple" xlink:href="../378/2468378.xml">
Data-structured</link> &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../396/1079396.xml">
Dataflow</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../648/210648.xml">
Declarative</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../239/519239.xml">
Domain-specific</link> &nbsp;·  <link xlink:type="simple" xlink:href="../398/53398.xml">
Esoteric</link> &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../177/1445177.xml">
Extensible</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
Functional</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../847/197847.xml">
Imperative</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../089/15089.xml">
Interpreted</link> &nbsp;·  <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
Logic</link> &nbsp;·  <link xlink:type="simple" xlink:href="../683/20683.xml">
Machine</link> &nbsp;·  <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../560/20560.xml">
Macro</link></concept>
</idea>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../460/393460.xml">
Metaprogramming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../843/226843.xml">
Multi-paradigm</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link xlink:type="simple" xlink:href="../497/365497.xml">
Non-English-based</link> &nbsp;·  <link xlink:type="simple" xlink:href="../758/22758.xml">
Object-oriented</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../595/605595.xml">
Off-side rule</link></subject>
</message>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../467/1780467.xml">
Pipeline</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../801/23801.xml">
Procedural</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../003/61003.xml">
Prototype-based</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../905/314905.xml">
Reflective</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 &nbsp;·  <link>
Rule-based</link> &nbsp;·  <link xlink:type="simple" xlink:href="../524/29524.xml">
Scripting</link> &nbsp;·  <link xlink:type="simple" xlink:href="../347/2211347.xml">
Synchronous</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../268/499268.xml">
Visual</link></subject>
</message>
</col>
</row>
</table>
</col>
</row>
</table>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
Types of <link xlink:type="simple" xlink:href="../015/23015.xml">
Computer language</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../015/23015.xml">
Programming</link> · <link xlink:type="simple" xlink:href="../586/140586.xml">
Specification</link> · <link xlink:type="simple" xlink:href="../528/494528.xml">
Query</link> · <link xlink:type="simple" xlink:href="../910/18910.xml">
Markup</link> · <link xlink:type="simple" xlink:href="../200/957200.xml">
Transformation</link> · <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../831/7392831.xml">
Template processing</link></machine>
</language>
</device>
</motor>
</engine>
</instrumentality>
</artifact>
 · <link xlink:type="simple" xlink:href="../554/74554.xml">
Hardware description</link> · <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../169/1575169.xml">
Stylesheet</link></language>
 · <link>
Data modeling</link></col>
</row>
</table>
</col>
</row>
</table>
</p>





</sec>
</bdy>
</subject>
</article>
