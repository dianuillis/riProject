<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:32:00[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Indus programming language</title>
<id>2332852</id>
<revision>
<id>164238748</id>
<timestamp>2007-10-13T08:34:25Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Concurrent programming languages</category>
</categories>
</header>
<bdy>

<b>Indus</b> is an object oriented <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> for <link xlink:type="simple" xlink:href="../871/31871.xml">
Ubiquitous computing</link>.<p>

The primary components of the Indus platform are a <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> to implement <link xlink:type="simple" xlink:href="../106/430106.xml">
software agents</link>, <link xlink:type="simple" xlink:href="../421/106421.xml">
libraries</link> to provide services to agents on a distributed <link xlink:type="simple" xlink:href="../592/4122592.xml">
network</link>, and <link xlink:type="simple" xlink:href="../263/192263.xml">
run time environment</link>s to enable deployment of agents on a variety of hardware <link xlink:type="simple" xlink:href="../196/81196.xml">
platform</link>s starting from <link xlink:type="simple" xlink:href="../148/45148.xml">
8-bit</link> devices onwards.</p>
<p>

The Indus programming language enables implementation of <link xlink:type="simple" xlink:href="../106/430106.xml">
software agents</link> that have the ability to coordinate with other agents and compose components using <link xlink:type="simple" xlink:href="../209/4340209.xml">
connector</link>s. </p>
<p>

The libraries for the Indus programming language are segmented according to <link xlink:type="simple" xlink:href="../282/6282.xml">
classes</link> of target host platforms – enterprise platforms, mobile hosts and <link xlink:type="simple" xlink:href="../367/669367.xml">
motes</link>. Standard Indus libraries provide services to deployed agents and components such as activation strategies, lifecycle management, service discovery, routing, communications, interoperability, transaction management, persistence and security. Indus Enterprise libraries are used to enable provision of grid services to agents deployed on enterprise platforms. Indus Micro libraries are used to enable provision of services to agents deployed on mobile hosts. Indus Mote libraries are used to enable provision of services such as timer, power and interrupt management, etc to agents hosted on mote platforms.</p>
<p>

Indus applications compile to byte code that can be interpreted by a <link xlink:type="simple" xlink:href="../353/32353.xml">
Virtual Machine</link> (VM) and is suitable for execution on enterprise platforms. In the case of mobile hosts, Indus compiles to <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 code and binary executables that are managed by the Indus Micro run time. In the case of motes, the Indus compiler generates code targeted at the device platform.</p>

<sec>
<st>
Introduction</st>

<p>

Existing middleware for client server computing such as <link>
.NET</link>, <link xlink:type="simple" xlink:href="../869/42869.xml">
Java EE</link> and <link xlink:type="simple" xlink:href="../799/4096799.xml">
CORBA</link> were not designed for Ubiquitous computing. Indus aims to meet the requirements of adaptive middleware for ad hoc, device centric computing networks. The foundation of the Indus platform is an object-oriented language – Indus - for implementing software agents. </p>
<p>

The ubiquitous application developer is therefore expected to model any system as a set of concurrently executing agents, with each agent representing a role, and then use features of Indus – new types such as agent and component, component ports, syntax and semantics for composition and coordination, new libraries for distribution - to implement and deploy agents across a variety of ‘peers’ (enterprise servers, mobile terminals and motes).</p>

<ss1>
<st>
The Indus programming language</st>

<p>

Why is a new programming language required for Ubiquitous, adaptive computing?  For client-server applications that execute on networks with mostly static topology, code for aspects such as synchronization, concurrency, parallelism and distribution are all written together with business logic, which leads to tangled code. Indus, by design, models application systems as concurrently executing processes (agents) that compose components (reusable static code) and coordinate with each other to execute application functionality over a network. </p>
<p>

The Indus programming language features syntax and semantics that is similar to <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 but provides additional features such as
<list>
<entry level="1" type="bullet">

 <it>New reference types</it> – Indus does away with the Java type called Interface and instead substitutes two interface types called Agent and Component. Every Indus class must therefore implement an Agent or Component. </entry>
<entry level="1" type="bullet">

 <it>Coordination styles</it> – All object oriented languages support only the ‘call and return’ style of interaction between clients and servers where clients call servers that process logic and return calls to clients. Indus defines syntax and semantics for several coordination styles, e.g., parallel pipes, voter-coordination, blackboards, etc, to facilitate a variety of interactions between concurrent processes (agents).</entry>
<entry level="1" type="bullet">

 <it>Composition styles</it> – Indus defines syntax and semantics for several composition styles, e.g., <link xlink:type="simple" xlink:href="../238/1241238.xml">
pipes and filters</link>, <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../599/62599.xml">
events</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
, rules, etc, to enable plugging in of components by agents. Component composition facilitates code reuse in Indus.</entry>
<entry level="1" type="bullet">

 <it>Ports</it> – Indus defines a type called Ports that defines the ability of components to be plugged in in a number of ways. Ports validate component compositions.</entry>
<entry level="1" type="bullet">

 <it>Behavior inheritance</it> – Indus places more importance on interface composition as a way of inheriting behavior than class-based inheritance.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
The Indus libraries</st>
<p>

In Indus, the code for synchronization and management of concurrent agents has thus been subsumed within the language itself whereas the code for managing distributed agents is provided by the library support to the Indus programming language. These are in addition to the usual Java-like language libraries available for math, graphics, utilities, etc.</p>
<p>

The Indus Standard libraries provide general libraries available freely to every agent application developer. The Indus Standard libraries provide services for
<list>
<entry level="1" type="bullet">

 <it>Self configuration</it>: this enables an agent or component to publish services provided and set parameters such as peer ids, concurrency and transactional policies, and its implementation type. By implementation type, software agents can be classified as User agents (identified by a role that can be played by a number of agents executing on different threads of execution) or Process agents (identified by a role that can be played by agents sharing a single thread of execution); both types of agents are transactional, history aware and persistent. By implementation type, software components can be classified as Service components (non-transactional, not history aware) and Session components (non-transactional and not persistent but history aware within a session boundary).</entry>
<entry level="1" type="bullet">

 <it>Lifecycle management</it>: this comprises abilities to deploy agents and components and evaluate implementation types and associated invocation rules of agents and components prior to their invocation. </entry>
<entry level="1" type="bullet">

 <it>Activation strategies</it> (proactive and reactive): this comprises facilities to queue client requests and schedule them according to different activation strategies. Proactive activation would result in a first in/first out (FIFO) schedule whereas Reactive activation would schedule agent invocations as events occur.</entry>
<entry level="1" type="bullet">

 <it>Service discovery</it>: libraries for service discovery enable every channel and connector (these are communication abstractions in Indus hidden from the Indus programmer) to discover invoked services on local and remote hosts.</entry>
<entry level="1" type="bullet">

 <it>Communications</it>: libraries enable run time binding to adapters of various types. This enables a high level of interoperability between agents implemented in Indus and components implemented in other languages such as Java and C++. </entry>
<entry level="1" type="bullet">

 <it>Intelligent <link xlink:type="simple" xlink:href="../750/25750.xml">
routing</link></it> (route discovery, maintenance, shortening, salvaging): this comprises facilities to register and exchange route information between <link xlink:type="simple" xlink:href="../748/25748.xml">
routers</link> running on every agent host, route groups that allow maintenance of routes, discovery of least hop routes and route salvaging.</entry>
<entry level="1" type="bullet">

 <it>Transaction management</it> (includes nested transaction management): facilities comprise formation of transaction boundaries across concurrent processes (agents), exchange of transaction data across transaction managers running on agent hosts and commit/rollback operations on transactions.</entry>
<entry level="1" type="bullet">

 <it>Persistence</it>: library support for persistence enables mapping of agent parameters to data stores and their retrieval when required.</entry>
<entry level="1" type="bullet">

 <it>Policy management</it>: this includes support for attaching policies at run time to agents and components, and mechanisms for their evaluation at run time.</entry>
<entry level="1" type="bullet">

 <it>Security</it>: library support for security comprises different <link xlink:type="simple" xlink:href="../294/10294.xml">
encryption</link> schemes for location data, messages and mobile agent code.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
The Indus runtime</st>

<p>

The Indus compiler family enables step wise but seamless compilation of Indus code to byte code, byte code to C code, and finally from C code to machine dependent executable code.</p>
<p>

Indus implementations can therefore execute across a variety of enterprise, mobile and mote platforms from a large number of vendors. On enterprise platforms, Indus agents and components compiled into byte code are managed by the Indus Enterprise container that executes on the Virtual Machine (VM) and is therefore portable to a variety of underlying Operating System (OS) platforms. On mobile platforms, Indus agents and components compiled into C executables are managed by the Indus Micro container that is portable across a number of mobile Operating Systems. On mote platforms, usually 8-<link xlink:type="simple" xlink:href="../535/64535.xml">
16 bit</link> devices, Indus agents and components are managed by the Indus Mote container that is portable across a number of underlying core platform architectures, e.g., the 8051. </p>
<p>

Indus containers provide services such as process management, memory management, task scheduling and event management. In addition to container support, Indus Mote utilizes native device APIs for communications (RF, UART, etc), timer and clock, and interrupt management.</p>

</ss1>
</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://developer.aumeganetworks.com">
Indus website</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
