<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:37:09[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<artifact  confidence="0.8" wordnetid="100021939">
<merchandise  confidence="0.8" wordnetid="103748886">
<commodity  confidence="0.8" wordnetid="103076708">
<header>
<title>X86-64</title>
<id>244374</id>
<revision>
<id>244446201</id>
<timestamp>2008-10-10T21:07:13Z</timestamp>
<contributor>
<username>Isaac Rabinovitch</username>
<id>206087</id>
</contributor>
</revision>
<categories>
<category>X86 architecture</category>
<category>Microprocessors</category>
</categories>
</header>
<bdy>

<b>x86-64</b> is a <link xlink:type="simple" xlink:href="../273/29273.xml">
superset</link> of the <link xlink:type="simple" xlink:href="../198/34198.xml">
x86 instruction set architecture</link>. x86-64 <link xlink:type="simple" xlink:href="../831/2172831.xml">
processor</link>s can run existing 32-bit or 16-bit x86 programs at full speed, but also support new programs written with a <link xlink:type="simple" xlink:href="../285/148285.xml">
64-bit</link> address space and other additional capabilities.<p>

The x86-64 specification was designed by <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/24th_century.xml">
Advanced Micro Devices</link></company>
 (AMD), who have since renamed it <b>AMD64</b>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link> has implemented it under the name <b>Intel 64</b> (formerly <b>EM64T</b> or <b>IA-32e</b>) in its own x86 processors.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../567/207567.xml">
VIA Technologies</link></company>
 has also included x86-64 instructions in their <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../905/17667905.xml">
VIA Isaiah</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 architecture. The names <b>x86-64</b> or <b>x64</b> are often used as vendor-neutral terms to collectively refer to x86-64 processors from any company.</p>
<p>

x86-64 should not be confused with the Intel <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../454/15454.xml">
Itanium</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 (formerly <it>IA-64</it>) architecture, which is not compatible on the native instruction set level with the x86 or x86-64 architecture.</p>

<sec>
<st>
AMD64</st>
<p>

<image location="right" width="150px" src="AMD64_Logo.svg" type="thumb">
<caption>

AMD64 Logo
</caption>
</image>

The AMD64 instruction set is implemented in AMD's <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../944/188944.xml">
Athlon 64</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../944/188944.xml">
Athlon 64 FX</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../251/1863251.xml">
Athlon 64 X2</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../392/11025392.xml">
Phenom</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <link>
Athlon X2</link>, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../264/1371264.xml">
Turion 64</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../851/5199851.xml">
Turion 64 X2</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../237/165237.xml">
Opteron</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 and later <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/846929.xml">
Sempron</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 processors.</p>

<ss1>
<st>
History of AMD64</st>
<p>

AMD64 was created as an alternative to Intel and <link xlink:type="simple" xlink:href="../973/13973.xml">
Hewlett Packard</link>'s radically different <link xlink:type="simple" xlink:href="../454/15454.xml">
IA-64</link> architecture.  Originally announced as "x86-64" in August 2000,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> the architecture was positioned by AMD from the beginning as an evolutionary way to add 64-bit computing capabilities to the existing x86 architecture, as opposed to Intel's approach of creating an entirely new 64-bit architecture with IA-64.  </p>
<p>

The first AMD64-based processor, the Opteron, was released in April 2003.</p>

</ss1>
<ss1>
<st>
Architectural features</st>
<p>

The primary defining characteristic of AMD64 is availability of 64-bit general purpose registers, 64-bit integer arithmetic and logical operations, and 64-bit virtual addresses. The designers took the opportunity to make other improvements as well. The most significant changes include: </p>
<p>

<list>
<entry level="1" type="bullet">

<b>64-bit integer capability:</b> All general-purpose registers (GPRs) are expanded from 32&nbsp;bits to 64&nbsp;bits, and all arithmetic and logical operations, memory-to-register and register-to-memory operations, etc., can now operate directly on 64-bit integers. Pushes and pops on the stack are always in 8 byte strides, and pointers are 8 bytes wide. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Additional <register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link></written_record>
</evidence>
</indication>
</record>
</register>
:</b> In addition to increasing the size of the general-purpose registers, the number of named general-purpose registers is increased from eight (i.e. eax,ebx,ecx,edx,ebp,esp,esi,edi) in <link xlink:type="simple" xlink:href="../046/15046.xml">
x86-32</link> to 16. It is therefore possible to keep more local variables in registers rather than on the stack, and to let registers hold frequently accessed constants; arguments for small and fast subroutines may also be passed in registers to a greater extent. However, AMD64 still has fewer registers than many common <link xlink:type="simple" xlink:href="../672/3963672.xml">
RISC</link> processors (which typically have 32&ndash;64&nbsp;registers) or <link xlink:type="simple" xlink:href="../706/51706.xml">
VLIW</link>-like machines such as the <link xlink:type="simple" xlink:href="../454/15454.xml">
IA-64</link> (which has 128&nbsp;registers).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Additional XMM (SSE) registers:</b> Similarly, the number of 128-bit XMM registers (used for <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../365/55365.xml">
Streaming SIMD</link></direction>
</message>
 instructions) is also increased from 8 to 16.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Larger virtual address space:</b> Current processor models implementing the AMD64 architecture can address up to 256 <link xlink:type="simple" xlink:href="../657/30657.xml">
TB</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> of virtual address space. This limit can be raised in future implementations to 16&nbsp;<link xlink:type="simple" xlink:href="../756/9756.xml">
EB</link>. This is compared to just 4&nbsp;<link xlink:type="simple" xlink:href="../570/12570.xml">
GB</link> for 32-bit x86. This means that very large files can be operated on by mapping the entire file into the process' address space (which is generally faster than working with file read/write calls), rather than having to map regions of the file into and out of the address space.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Larger physical address space:</b> Current implementations of the AMD64 architecture can address up to 1&nbsp;TB of RAM; the architecture permits extending this to 4&nbsp;<link xlink:type="simple" xlink:href="../980/23980.xml">
PB</link> in the future (limited by the page table entry format). In <link xlink:type="simple" xlink:href="../556/3689556.xml">
legacy mode</link>, <link xlink:type="simple" xlink:href="../793/416793.xml">
Physical Address Extension</link> (PAE) is included, as it is on most current 32-bit x86 processors, allowing access to a maximum of 64&nbsp;GB. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Instruction pointer relative data access:</b> Instructions can now reference data relative to the instruction pointer (RIP register). This makes <link xlink:type="simple" xlink:href="../303/571303.xml">
position independent code</link>, as is often used in shared libraries and code loaded at run time, more efficient.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>SSE instructions:</b> The original AMD64 architecture adopted Intel's <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../365/55365.xml">
SSE</link></direction>
</message>
 and <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../203/311203.xml">
SSE2</link></direction>
</message>
 as core instructions. <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../502/494502.xml">
SSE3</link></direction>
</message>
 instructions were added in April 2005. SSE2 replaces the <link xlink:type="simple" xlink:href="../970/2532970.xml">
x87</link> instruction set's <link xlink:type="simple" xlink:href="../039/405039.xml">
IEEE 80-bit precision</link>, with the choice of either IEEE 32-bit or 64-bit floating-point mathematics. This provides floating-point operations compatible with many other modern CPUs. The SSE and SSE2 instructions have also been extended to operate on the eight new XMM registers. SSE and SSE2 are available in 32-bit mode in modern x86 processors; however, if they're used in 32-bit programs, those programs will only work on systems with processors that have the feature. This is not an issue in 64-bit programs, as all AMD64 processors have SSE and SSE2, so using SSE and SSE2 instructions instead of x87 instructions does not reduce the set of machines on which x64 programs can be run. Since SSE and SSE2 are generally faster than, and duplicate most of the features of, the traditional x87 instructions, <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../364/55364.xml">
MMX</link></direction>
</message>
, and <link xlink:type="simple" xlink:href="../551/211551.xml">
3DNow!</link>, the latter are redundant under AMD64. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b><link xlink:type="simple" xlink:href="../694/655694.xml">
No-Execute bit</link>:</b> The "NX" bit (bit 63 of the page table entry) allows the operating system to specify which pages of virtual address space can contain executable code and which cannot. An attempt to execute code from a page tagged "no execute" will result in a memory access violation, similar to an attempt to write to a read-only page. This should make it more difficult for malicious code to take control of the system via "<accomplishment wordnetid="100035189" confidence="0.8">
<invertebrate wordnetid="101905661" confidence="0.8">
<arthropod wordnetid="101767661" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<bug wordnetid="102236355" confidence="0.8">
<insect wordnetid="102159955" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<feat wordnetid="100036762" confidence="0.8">
<animal wordnetid="100015388" confidence="0.8">
<link xlink:type="simple" xlink:href="../373/4373.xml">
buffer overrun</link></animal>
</feat>
</psychological_feature>
</act>
</insect>
</bug>
</action>
</event>
</arthropod>
</invertebrate>
</accomplishment>
" or "unchecked buffer" attacks. A similar feature has been available on x86 processors since the <link xlink:type="simple" xlink:href="../054/15054.xml">
80286</link> as an attribute of segment descriptors; however, this works only on an entire segment at a time. Segmented addressing has long been considered an obsolete mode of operation, and all current PC operating systems in effect bypass it, setting all segments to a base address of 0 and a size of 4&nbsp;GB. AMD was the first x86-family vendor to implement no-execute in linear addressing mode. The feature is also available in legacy mode on AMD64 processors, and recent Intel x86 processors, when PAE is used. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Removal of older features:</b> A number of "system programming" features of the x86 architecture are not used in modern operating systems and are not available on AMD64 in long (64-bit and compatibility) mode. These include segmented addressing (although the FS and GS segments were retained in vestigial form for compatibility with Windows code)<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>, the task state switch mechanism, and Virtual-8086 mode. These features do of course remain fully implemented in "legacy mode," thus permitting these processors to run 32-bit and 16-bit operating systems without modification.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Virtual address space details</st>
<p>

Although virtual addresses are 64&nbsp;bits wide in 64-bit mode, current implementations (and any chips known to be in the planning stages) do not allow the entire virtual address space of 16&nbsp;EB to be used. Most operating systems and applications will not need such a large address space for the foreseeable future (for example, Windows implementations for AMD64 are only populating 16&nbsp;TB, or 44&nbsp;<link xlink:type="simple" xlink:href="../690/1036690.xml">
bits</link>' worth), so implementing such wide virtual addresses would simply increase the complexity and cost of address translation with no real benefit. AMD therefore decided that, in the first implementations of the architecture, only the least significant 48&nbsp;bits of a virtual address would actually be used in address translation (page table lookup). However, bits 48 through 63 of any virtual address must be copies of bit 47 (in a manner akin to <link xlink:type="simple" xlink:href="../272/3349272.xml">
sign extension</link>), or the processor will raise an exception. Addresses complying with this rule are referred to as "canonical form." Canonical form addresses run from 0 through 00007FFF`FFFFFFFF, and from FFFF8000`00000000 through FFFFFFFF`FFFFFFFF, for a total of 256&nbsp;TB of usable virtual address space.</p>
<p>

This "quirk" allows an important feature for later scalability to true 64-bit addressing: 
many operating systems (including, but not limited to, the <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/33438.xml">
Windows NT</link></family>
 family) take the higher-addressed half of the address space (named kernel space) for themselves  and leave the lower-addressed half (user space) for application code, user mode stacks, heaps, and other data regions. The "canonical address" design ensures that every AMD64 compliant implementation has, in effect, two memory halves: the lower half starts at 00000000`00000000 and "grows upwards" as more virtual address bits become available, while the higher half is "docked" to the top of the address space and grows downwards. Also, fixing the contents of the unused address bits prevents their use by operating system as flags, privilege markers, etc., which could become problematic when the architecture is indeed extended to 52, 56, 60 and 64 bits.</p>
<p>

<table style="text-align:center" align="center" border="0">
<row>
<col>
 Current 48-bit implementation
<image width="150px" src="AMD64-canonical--48-bit.svg">
<caption>

AMD64-canonical--48-bit.svg
</caption>
</image>
</col>
<col>
 56-bit implementation
<image width="150px" src="AMD64-canonical--56-bit.svg">
<caption>

AMD64-canonical--56-bit.svg
</caption>
</image>
</col>
<col>
 Full 64-bit implementation
<image width="150px" src="AMD64-canonical--64-bit.svg">
<caption>

AMD64-canonical--64-bit.svg
</caption>
</image>
</col>
</row>
<row>
<col colspan="3">
(not drawn to scale)</col>
</row>
</table>
</p>
<p>

The 64-bit addressing mode ("<link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link>") is a superset of <link xlink:type="simple" xlink:href="../793/416793.xml">
Physical Address Extension</link>s (PAE); because of this, <link xlink:type="simple" xlink:href="../193/311193.xml">
page</link> sizes may be either 4&nbsp;<link xlink:type="simple" xlink:href="../794/16794.xml">
KB</link>, 2&nbsp;<link xlink:type="simple" xlink:href="../918/19918.xml">
MB</link>, or 1&nbsp;GB. However, rather than the three-level <link xlink:type="simple" xlink:href="../962/674962.xml">
page table</link> system used by systems in PAE mode, systems running in <link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link> use four levels of page table: PAE's <it>Page-Directory Pointer Table</it> is extended from 4 entries to 512, and an additional <it>Page-Map Level 4 Table</it> is added, containing 512 entries in 48-bit implementations. In implementations providing larger virtual addresses, this latter table would either grow to accommodate sufficient entries to describe the entire address range, up to a theoretical maximum of 33,554,432 entries for a 64-bit implementation, or be over ranked by a new mapping level, such as a PML5. A full mapping hierarchy of 4&nbsp;KB pages for the whole 48-bit space would take a bit more than 512&nbsp;GB of RAM (about 0.196% of the 256&nbsp;TB virtual space).</p>

</ss1>
<ss1>
<st>
Operating modes</st>
<p>

<table class="wikitable">
<row bgcolor="#cccccc">
<header colspan="2">
Operating mode</header>
<header>
 <link xlink:type="simple" xlink:href="../194/22194.xml">
Operating system</link>required</header>
<header>
Compiled-application rebuild required</header>
<header>
Default address size</header>
<header>
Default operand size</header>
<header>
Register extensions</header>
<header>
 Typical <link xlink:type="simple" xlink:href="../432/486432.xml">
GPR</link>width</header>
</row>
<row align="center">
<col rowspan="3">
 <link xlink:type="simple" xlink:href="../691/2556691.xml">
Long mode</link></col>
<col>
64-bit mode</col>
<col rowspan="3">
OS with 64-bit support</col>
<col style="background: #ffdddd">
{}</col>
<col>
64</col>
<col>
32</col>
<col style="background: #ddffdd">
{}</col>
<col>
64</col>
</row>
<row align="center">
<col rowspan="2">
Compatibility mode</col>
<col style="background: #ddffdd" rowspan="2">
{}</col>
<col>
32</col>
<col>
32</col>
<col style="background: #ffdddd" rowspan="2">
{}</col>
<col>
32</col>
</row>
<row align="center">
<col>
16</col>
<col>
16</col>
<col>
16</col>
</row>
<row align="center">
<col rowspan="4">
Legacy mode</col>
<col rowspan="2">
 <link xlink:type="simple" xlink:href="../596/167596.xml">
Protected mode</link></col>
<col rowspan="3">
Legacy 16-bit or 32-bit OS</col>
<col style="background: #ddffdd" rowspan="4">
{}</col>
<col>
32</col>
<col>
32</col>
<col style="background: #ffdddd" rowspan="4">
{}</col>
<col>
32</col>
</row>
<row align="center">
<col>
16</col>
<col>
16</col>
<col>
16</col>
</row>
<row align="center">
<col>
 <artifact wordnetid="100021939" confidence="0.8">
<merchandise wordnetid="103748886" confidence="0.8">
<commodity wordnetid="103076708" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/641324.xml">
Virtual 8086 mode</link></commodity>
</merchandise>
</artifact>
</col>
<col rowspan="2">
16</col>
<col rowspan="2">
16</col>
<col rowspan="2">
16</col>
</row>
<row align="center">
<col>
 <link xlink:type="simple" xlink:href="../823/79823.xml">
Real mode</link></col>
<col>
Legacy 16-bit OS</col>
</row>
</table>
</p>

<ss2>
<st>
Operating mode explanation</st>
<p>

The architecture has two primary modes of operation:</p>
<p>

<list>
<entry level="1" type="definition">

<b><link xlink:type="simple" xlink:href="../691/2556691.xml">
Long mode</link></b>: The architecture's intended primary mode of operation; it is a combination of the processor's native 64-bit mode and a combined 32-bit and 16-bit compatibility mode. It is used by 64-bit operating systems. Under a 64-bit operating system, 64-bit, 32-bit and 16-bit (or <link xlink:type="simple" xlink:href="../054/15054.xml">
80286</link>) <link xlink:type="simple" xlink:href="../596/167596.xml">
protected mode</link> applications may be run. </entry>
</list>
</p>
<p>

<indent level="1">

 Since the basic instruction set is the same, there is no major performance penalty for executing x86 code. This is unlike Intel's <link xlink:type="simple" xlink:href="../454/15454.xml">
IA-64</link>, where differences in the underlying <link xlink:type="simple" xlink:href="../772/47772.xml">
ISA</link> means that running 32-bit code must be done either in emulation of x86, or with a dedicated x86 core, making the process extremely slow and essentially useless for backwards compatibility. However, on AMD64, 32-bit x86 applications may still benefit from a 64-bit <link xlink:type="simple" xlink:href="../739/5739.xml">
recompile</link>, due to the additional registers in 64-bit code, which a high-level <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> can use for optimization.
</indent>

<list>
<entry level="1" type="definition">

<b>Legacy mode</b>: The mode used by 16-bit (protected mode or real mode) and 32-bit operating systems. In this mode, the processor acts just like an x86 processor, and only 16-bit or 32-bit code can be executed. 64-bit programs will not run.</entry>
</list>
</p>

</ss2>
</ss1>
<ss1>
<st>
AMD64 Implementations</st>
<p>

The following processors implement the AMD64 architecture:
<list>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../944/188944.xml">
Athlon 64</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 </entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../251/1863251.xml">
Athlon 64 X2</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../944/188944.xml">
Athlon 64 FX</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../237/165237.xml">
Opteron</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../264/1371264.xml">
Turion 64</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../851/5199851.xml">
Turion 64 X2</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/846929.xml">
Sempron</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 ("Palermo" E6 stepping and all "Manila" models)</entry>
<entry level="1" type="bullet">

AMD <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../392/11025392.xml">
Phenom</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Intel 64</st>
<p>

<b>Intel 64</b> is Intel's implementation of x86-64. It is used in newer versions of <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../228/165228.xml">
Pentium 4</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../876/1560876.xml">
Pentium D</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <link>
Pentium Extreme Edition</link>, <link>
Celeron D</link>, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/269920.xml">
Xeon</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 and <link xlink:type="simple" xlink:href="../648/9501648.xml">
Pentium Dual-Core</link> processors, and in all versions of the <link xlink:type="simple" xlink:href="../988/5048988.xml">
Core 2</link> processors. </p>

<ss1>
<st>
History of Intel 64</st>
<p>

Historically, AMD has developed and produced processors patterned after Intel's original designs, but with x86-64, roles were reversed: Intel found itself in the position of adopting the architecture which AMD had created as an extension to Intel's own x86 processor line.</p>
<p>

Intel's project was originally <link xlink:type="simple" xlink:href="../198/308198.xml">
codename</link>d <b>Yamhill</b> (after the <stream wordnetid="109448361" confidence="0.8">
<body_of_water wordnetid="109225146" confidence="0.8">
<river wordnetid="109411430" confidence="0.8">
<link xlink:type="simple" xlink:href="../163/697163.xml">
Yamhill River</link></river>
</body_of_water>
</stream>
 in <region wordnetid="108630985" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../198/22198.xml">
Oregon</link></country>
</district>
</location>
</administrative_district>
</region>
's <region wordnetid="108630039" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<geological_formation wordnetid="109287968" confidence="0.8">
<valley wordnetid="109468604" confidence="0.8">
<natural_depression wordnetid="109366017" confidence="0.8">
<link xlink:type="simple" xlink:href="../549/33549.xml">
Willamette Valley</link></natural_depression>
</valley>
</geological_formation>
</location>
</region>
). After several years of denying its existence, Intel announced at the February 2004 <social_group wordnetid="107950920" confidence="0.8">
<meeting wordnetid="108307589" confidence="0.8">
<gathering wordnetid="107975026" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<conference wordnetid="108308497" confidence="0.8">
<link xlink:type="simple" xlink:href="../096/627096.xml">
IDF</link></conference>
</group>
</gathering>
</meeting>
</social_group>
 that the project was indeed underway. Intel's chairman at the time, <link xlink:type="simple" xlink:href="../778/60778.xml">
Craig Barrett</link>, admitted that this was one of their worst kept secrets.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>
<p>

Intel's name for this technology has changed several times.  The name used at the IDF was <b>CT</b> (presumably for <b>Clackamas Technology</b>, another codename from an <stream wordnetid="109448361" confidence="0.8">
<body_of_water wordnetid="109225146" confidence="0.8">
<river wordnetid="109411430" confidence="0.8">
<link xlink:type="simple" xlink:href="../959/611959.xml">
Oregon river</link></river>
</body_of_water>
</stream>
); within weeks they began referring to it as IA-32e (for <link xlink:type="simple" xlink:href="../046/15046.xml">
IA-32</link> extensions) and in March 2004 unveiled the "official" name <b>EM64T</b> (Extended Memory 64 Technology). In late 2006 Intel began instead using the name Intel 64 for its implementation, paralleling AMD's use of the name AMD64.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>

</ss1>
<ss1>
<st>
Intel 64 Implementations</st>
<p>

Intel 64 was originally implemented on the E revision (<chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link>
Prescott</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
) of <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../228/165228.xml">
Pentium 4</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 line of microprocessors, which were supported by i915P (Grantsdale) and i925X (Alderwood) chipsets in June 2004; the technology was largely built compatible to AMD64, and the then-announced <link>
Windows XP Professional x64 Edition</link>. The feature was not initially enabled on the initial Prescott chips (February 2004), likely because enabling Intel 64 did not coincide with Intel's stance on 64-bit x86 extensions at that particular time. </p>
<p>

Intel's first processor to activate the Intel 64 technology was the multi-socket processor <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/269920.xml">
Xeon</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 code-named <it><chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/269920.xml#xpointer(//*[./st=%22Xeon_.28DP.29_.26_Xeon_MP_.2864-bit.29%22])">
Nocona</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</it> later in 2004. Intel subsequently began selling Intel 64-enabled Pentium 4s using the E0 revision of the Prescott core, being sold on the OEM market as the Pentium 4, model F. The E0 revision also adds eXecute Disable (XD) (Intel's name for the <link xlink:type="simple" xlink:href="../694/655694.xml">
NX bit</link>) to Intel 64, and has been included in then current Xeon code-named <it>Irwindale</it>. Intel's official launch of Intel 64 (under the name EM64T at that time) in mainstream desktop processors was the N0 Stepping Prescott-2M. All 9xx, 8xx, 6xx, 5x6, 5x1, 3x6, and 3x1 series CPUs have Intel 64 enabled, as do the <link xlink:type="simple" xlink:href="../988/5048988.xml">
Core 2</link> CPUs, as will future Intel CPUs for workstations or servers. Intel 64 is also present in the last members of the <link>
Celeron D</link> line.</p>
<p>

The first Intel <link xlink:type="simple" xlink:href="../288/374288.xml">
mobile processor</link> implementing Intel 64 is the <link xlink:type="simple" xlink:href="../988/5048988.xml#xpointer(//*[./st=%22Merom%22])">
Merom</link> version of the <link xlink:type="simple" xlink:href="../988/5048988.xml">
Core 2</link> processor, which was released on <link xlink:type="simple" xlink:href="../922/15922.xml">
27 July</link> <link xlink:type="simple" xlink:href="../164/36164.xml">
2006</link>. None of Intel's earlier notebook CPUs (<link xlink:type="simple" xlink:href="../080/3429080.xml">
Core Duo</link>, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../672/199672.xml">
Pentium M</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <link>
Celeron M</link>, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../228/165228.xml">
Mobile Pentium 4</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
) implements Intel 64.</p>
<p>

The following processors implement the Intel 64 architecture:
<list>
<entry level="1" type="bullet">

Intel <link xlink:type="simple" xlink:href="../866/643866.xml">
NetBurst</link> microarchitecture</entry>
<entry level="2" type="bullet">

<link xlink:type="simple" xlink:href="../920/269920.xml">
Intel Xeon</link> (some models since "Nocona")</entry>
<entry level="2" type="bullet">

Intel <link>
Celeron D</link> (some models since "Prescott")</entry>
<entry level="2" type="bullet">

Intel <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../228/165228.xml">
Pentium 4</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 (some models since "Prescott")</entry>
<entry level="2" type="bullet">

Intel <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../876/1560876.xml">
Pentium D</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
<entry level="2" type="bullet">

Intel <link>
Pentium Extreme Edition</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../150/2467150.xml">
Intel Core microarchitecture</link></entry>
<entry level="2" type="bullet">

<link xlink:type="simple" xlink:href="../920/269920.xml">
Intel Xeon</link> (all models since "Woodcrest")</entry>
<entry level="2" type="bullet">

<chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../988/5048988.xml">
Intel Core 2</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 (Including Mobile processors since "Merom")</entry>
<entry level="2" type="bullet">

<link xlink:type="simple" xlink:href="../648/9501648.xml">
Intel Pentium Dual Core</link> (E2140, E2160, E2180, E2200, E2220, T2310, T2330, T2370, and T2390)</entry>
<entry level="2" type="bullet">

<link xlink:type="simple" xlink:href="../254/77254.xml">
Intel Celeron</link> (Celeron 4x0; Celeron M 5xx)</entry>
<entry level="1" type="bullet">

 Intel Atom microarchitecture</entry>
<entry level="2" type="bullet">

<chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../938/13949938.xml">
Intel Atom</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 <link>
200 series</link></entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Other x86-64 implementations</st>
<p>

<list>
<entry level="1" type="bullet">

<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../567/207567.xml">
VIA Technologies</link></company>
 <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../905/17667905.xml">
Isaiah</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 microarchitecture</entry>
<entry level="2" type="bullet">

<chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../360/12440360.xml">
VIA Nano</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
</entry>
</list>
</p>

</sec>
<sec>
<st>
Differences between AMD64 and Intel 64</st>

<p>

There are a few differences between the two instruction sets. Compilers generally produce binaries that are compatible with both (that is, compatible with the subset of X86-64 that is common to both AMD64 and Intel 64), making these differences mainly of interest to developers of compilers and operating systems.</p>

<ss1>
<st>
Recent implementations</st>
<p>

<list>
<entry level="1" type="bullet">

Intel 64's BSF and BSR instructions act differently when the source is 0 and the operand size is 32&nbsp;bits. The processor sets the zero flag and leaves the upper 32&nbsp;bits of the destination undefined.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Intel 64 lacks the ability to save and restore a reduced (and thus faster) version of the <link xlink:type="simple" xlink:href="../376/11376.xml">
floating-point</link> state (involving the FXSAVE and FXRSTOR instructions).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Intel 64 lacks some model-specific registers that are considered architectural to AMD64. These include SYSCFG, TOP_MEM, and TOP_MEM2.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

AMD64 requires a different microcode update format and control MSRs while Intel 64 implements  <link xlink:type="simple" xlink:href="../999/19999.xml">
microcode</link> update unchanged from their 32-bit only processors.  </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

AMD64 originally lacked the MONITOR and MWAIT instructions, used by operating systems to better deal with Intel's <link xlink:type="simple" xlink:href="../443/151443.xml">
Hyper-threading</link> feature and also to enter specific low power states.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

AMD64 systems allow the use of the AGP aperture as an <link xlink:type="simple" xlink:href="../181/5313181.xml">
IOMMU</link>. Operating systems can take advantage of this to let normal PCI devices DMA to memory above 4&nbsp;GB. Intel 64 systems require the use of <link>
bounce buffer</link>s, which are slower.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Intel 64 allows SYSCALL and SYSRET only in IA-32e mode (not in compatibility mode). It allows SYSENTER and SYSEXIT in both modes. </entry>
<entry level="1" type="bullet">

AMD64 lacks SYSENTER and SYSEXIT in both sub-modes of <link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link>. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Near branches with the <b>66H</b> (operand size) prefix behave differently. Intel 64 clears only the top 32&nbsp;bits, while AMD64 clears the top 48&nbsp;bits.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

More recent AMD64 processors supports 1GB pages.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Intel CPUs based on the Conroe microarchitecture have two major performance bottlenecks: they don't use Intel's "Macrofusion" technology which allows for faster reading from the instruction (L1) cache; and they address the additional registers less efficiently than AMD processors. This leads to a performance degradation compared to AMD64 when some Core 2 Duo models are in long mode.<weblink xlink:type="simple" xlink:href="http://www.xbitlabs.com/articles/cpu/display/core2duo-64bit_2.html">
http://www.xbitlabs.com/articles/cpu/display/core2duo-64bit_2.html</weblink></entry>
</list>
</p>

</ss1>
<ss1>
<st>
Older implementations</st>
<p>

<list>
<entry level="1" type="bullet">

Early AMD64 processors lacked the CMPXCHG16B instruction, which is an extension of the CMPXCHG8B instruction present on most post-<chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/15161.xml">
486</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 processors. Similar to CMPXCHG8B, CMPXCHG16B allows for <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic operation</link>s on 128-bit double quadword (or oword) data types. This is useful for parallel algorithms that use <link xlink:type="simple" xlink:href="../224/632224.xml">
compare and swap</link> on data larger than the size of a pointer, common in <link xlink:type="simple" xlink:href="../864/554864.xml">
lock-free and wait-free algorithms</link>. Without CMPXCHG16B one must use workarounds, such as a <link xlink:type="simple" xlink:href="../312/638312.xml">
critical section</link> or alternative lock-free approaches.<weblink xlink:type="simple" xlink:href="http://www.research.ibm.com/people/m/michael/disc-2004.pdf">
http://www.research.ibm.com/people/m/michael/disc-2004.pdf</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Early Intel CPUs with Intel 64 lacked LAHF and SAHF instructions available in AMD64 until introduction of Pentium 4 G1 step in December 2005. LAHF and SAHF are load and store instructions, respectively, for certain status flags. These instructions are used for virtualization and floating-point condition handling.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Early Intel CPUs with Intel 64 also lack the <link xlink:type="simple" xlink:href="../694/655694.xml">
NX bit</link> (No Execute bit) of the AMD64 architecture. The NX bit marks memory pages as non-executable, allowing protection against many types of malicious code.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Original AMD64 implementations allowed access only to 1&nbsp;TB of physical memory, however, recent AMD64 implementations now provide 256&nbsp;TB of physical address space (with planned expansion to 4&nbsp;PB).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Original Intel 64 implementations allowed access only to 64&nbsp;GB of physical memory, however, recent Intel 64 implementations now provide 1&nbsp;TB of physical address space.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Operating system compatibility</st>
<p>

The following operating systems and releases support the x86-64 architecture by running in <link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link>:</p>

<ss1>
<st>
Windows</st>
<p>

x64 editions of Microsoft Windows client and server, <link>
Windows XP Professional x64 Edition</link> and Windows Server 2003 SP1 x64 Edition, were released in March 2005. Internally they are actually the same build (5.2.3790.3959 SP2), as they share the same source base and operating system binaries, so even system updates are released in unified packages, much in the manner as Windows 2000 Professional and Server editions for x86. <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../648/2289648.xml">
Windows Vista</link></version>
, which also has many different versions, was released in January 2007. Windows for x64 has the following characteristics:
<list>
<entry level="1" type="bullet">

8&nbsp;TB of "user mode" virtual memory address space per process. A 64-bit program can use all of this, subject of course to backing store limits on the system. This is a 4096-fold increase over the default 2&nbsp;GB user-mode virtual address space offered by 32-bit Windows.</entry>
<entry level="1" type="bullet">

8&nbsp;TB of kernel mode virtual address space for the operating system. Again, this is a 4096-fold increase over 32-bit Windows versions. The increased space is primarily of benefit to the file system cache and kernel mode "heaps" (non-paged pool and paged pool).</entry>
<entry level="2" type="bullet">

Interestingly the total address space is limited to 16&nbsp;TB due to early AMD64 lacking a CMPXCHG16B instruction.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></entry>
<entry level="1" type="bullet">

Ability to use up to 128&nbsp;<link xlink:type="simple" xlink:href="../487/176487.xml">
GB</link> (Windows XP) or 1&nbsp;<link xlink:type="simple" xlink:href="../138/236138.xml">
TB</link> (Windows Server 2003) of random access memory (RAM). </entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../285/148285.xml">
LLP64</link> data model: "int" and "long" types are still 32&nbsp;bits wide, while pointers and types derived from pointers are 64&nbsp;bits wide. </entry>
<entry level="1" type="bullet">

Device drivers must be 64-bit versions; there is no way to run 32-bit kernel-mode executables within the 64-bit operating system. </entry>
<entry level="1" type="bullet">

Ability to run existing 32-bit applications (.exe's) and dynamic link libraries (.dll's). A 32-bit program, if linked with the "large address aware" option, can use up to 4&nbsp;GB of virtual address space, as compared to the default 2&nbsp;GB (optional 3&nbsp;GB with /3GB boot.ini option and "large address aware" link option) offered by 32-bit Windows. </entry>
<entry level="1" type="bullet">

16-bit DOS and Windows (Win16) applications will not run on x64 versions of Windows due to removal of <link xlink:type="simple" xlink:href="../173/1501173.xml">
NTVDM</link>.</entry>
<entry level="1" type="bullet">

Full implementation of the NX (No Execute) page protection feature. This is also implemented on recent 32-bit versions of Windows when they are started in PAE mode.</entry>
<entry level="1" type="bullet">

Instead of FS segment descriptor on x86 versions of the <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/33438.xml">
Windows NT</link></family>
 family, GS segment descriptor is used to point to two operating system defined structures: Thread Information Block (NT_TIB) in user mode and Processor Control Region (KPCR) in kernel mode. Thus, for example, in user mode GS:0 is the address of the first member of the Thread Information Block. Maintaining this convention made the x64 port easier, but required AMD to retain the function of the FS and GS segments in long mode — even though segmented addressing <it>per se</it> is not really used by any modern operating system.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></entry>
<entry level="1" type="bullet">

Early reports claimed that the operating system scheduler would not save and restore the x87 FPU machine state across thread context switches. Observed behavior shows that this is not the case: the x87 state is saved and restored, except for kernel-mode-only threads. The most recent documentation available from Microsoft states that the x87/MMX/3DNow! instructions may be used in long mode.</entry>
<entry level="1" type="bullet">

Some components like <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../417/1948417.xml">
Microsoft Jet Database Engine</link></machine>
</device>
</motor>
</engine>
</instrumentality>
</artifact>
 and <link xlink:type="simple" xlink:href="../568/1913568.xml">
Data Access Objects</link> will not be ported to 64-bit architectures such as x86-64 and IA-64.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></entry>
<entry level="1" type="bullet">

Microsoft Visual Studio allows you to build an application that is targeted to the X86-64 native environment.  Such an unmanaged application is only able to run on top of 64-bit versions of the Windows operating system.  A 64-bit version of Windows is only able to run on top of 64-bit hardware.  The same application can be built to run on top of 32-bit versions of Windows on top of either 32- or 64-bit hardware.  On 64-bit hardware, the 32-bit application requires the WoW64 (Windows-on-Windows) adaptation layer, which automatically loads when the application is launched.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Linux</st>

<p>

<indent level="1">

<it>See also: <link>
List of 64-bit Linux distributions</link></it>
</indent>

<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 was the first operating system kernel to run the x86-64 architecture in <link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link>, starting with the 2.4 version prior to the physical hardware's availability. Linux also provides backward compatibility for running 32-bit executables. This permits programs to be recompiled into long mode while retaining the use of 32-bit programs. Several Linux distributions currently ship with x86-64-native kernels and <link xlink:type="simple" xlink:href="../109/555109.xml">
userlands</link>. Some, such as <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../544/27544.xml">
SUSE</link></O>
, <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../368/19368.xml">
Mandriva</link></distribution>
</arrangement>
</structure>
 and <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../242/8242.xml">
Debian GNU/Linux</link></distribution>
</arrangement>
</structure>
 package both 32-bit and 64-bit systems on a single DVD-ROM image to allow automatic selection of the best software during installation. Other distributions, such as <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/9951070.xml">
Fedora</link></distribution>
</arrangement>
</structure>
 and <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../298/990298.xml">
Ubuntu</link></O>
, are available in a version compiled for 32-bit and one compiled for x86-64 architecture.</p>
<p>

64-bit Linux allows up to 128&nbsp;TB of address space for individual processes, and can address approximately 246 (64 TB) of physical memory, subject to processor and system limitations.</p>

</ss1>
<ss1>
<st>
Mac OS X</st>
<p>

<version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../664/2001664.xml">
Mac OS X v10.5</link></version>
 supports  64-bit GUI applications using <link xlink:type="simple" xlink:href="../890/55890.xml">
Cocoa</link>, <link xlink:type="simple" xlink:href="../289/1056289.xml">
Quartz</link>, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../497/22497.xml">
OpenGL</link></software>
 and <link xlink:type="simple" xlink:href="../147/34147.xml">
X11</link> on 64-bit Intel-based machines, as well as on 64-bit <link xlink:type="simple" xlink:href="../281/24281.xml">
PowerPC</link> machines.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> All non-GUI libraries and frameworks also support 64-bit applications on those platforms. The kernel is <link xlink:type="simple" xlink:href="../733/80733.xml">
32-bit</link>.</p>
<p>

Mac OS X v10.4.7 and higher versions of <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../975/641975.xml">
Mac OS X v10.4</link></version>
 run 64-bit command-line tools using the POSIX and math libraries on 64-bit Intel-based machines, just as all versions of Mac OS X v10.4 and higher run them on 64-bit PowerPC machines.  No other libraries or frameworks work with 64-bit applications in Mac OS X v10.4.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></p>

</ss1>
<ss1>
<st>
BSD</st>

<ss2>
<st>
FreeBSD</st>
<p>

<platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/7580554.xml">
FreeBSD</link></horizontal_surface>
</surface>
</artifact>
</platform>
 first added x86-64 support under the name "amd64" as an experimental architecture in 5.1-RELEASE in June 2003. It was included as a standard distribution architecture as of 5.2-RELEASE in January 2004. Since then, FreeBSD has designated it as a Tier 1 platform. The 6.0-RELEASE version cleaned up some quirks with running 32-bit x86 executables under amd64, and most drivers work just as they do on 32-bit x86 architectures. Work is currently being done to integrate more fully the 32-bit x86 <link xlink:type="simple" xlink:href="../471/60471.xml">
application binary interface</link> (ABI), in the same manner as the Linux 32-bit ABI compatibility currently works.</p>

</ss2>
<ss2>
<st>
NetBSD</st>
<p>

x86-64 architecture support was first committed to the <link xlink:type="simple" xlink:href="../495/21495.xml">
NetBSD</link> source tree on <link xlink:type="simple" xlink:href="../817/15817.xml">
19 June</link> <link xlink:type="simple" xlink:href="../551/34551.xml">
2001</link>. As of NetBSD 2.0, released on <link xlink:type="simple" xlink:href="../589/8589.xml">
9 December</link> <link xlink:type="simple" xlink:href="../524/35524.xml">
2004</link>, <it>NetBSD/amd64</it> is a fully integrated and supported port.</p>

</ss2>
<ss2>
<st>
OpenBSD</st>
<p>

<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../571/18949571.xml">
OpenBSD</link></O>
 has supported AMD64 since OpenBSD 3.5, released on <link xlink:type="simple" xlink:href="../348/19348.xml">
1 May</link> <link xlink:type="simple" xlink:href="../524/35524.xml">
2004</link>. Complete in-tree implementation of AMD64 support was achieved prior to the hardware's initial release due to AMD's loaning of several machines for the project's <link xlink:type="simple" xlink:href="../315/1954315.xml">
hackathon</link> that year. <link xlink:type="simple" xlink:href="../787/3444787.xml">
OpenBSD developers</link> have taken to the platform because of its use of the <link xlink:type="simple" xlink:href="../694/655694.xml">
NX bit</link>, which allowed for an easy implementation of the <link xlink:type="simple" xlink:href="../113/1157113.xml">
W^X</link> feature.</p>
<p>

The code for the AMD64 port of OpenBSD also runs on Intel 64 processors which contains cloned use of the AMD64 extensions, but since Intel left out the page table NX bit in early Intel 64 processors, there is no W^X capability on those Intel CPUs; later Intel 64 processors added the NX bit under the name "XD bit". <link xlink:type="simple" xlink:href="../318/50318.xml">
Symmetric multiprocessing</link> (SMP) works on OpenBSD's AMD64 port, starting with release 3.6 on <link xlink:type="simple" xlink:href="../460/21460.xml">
1 November</link> <link xlink:type="simple" xlink:href="../524/35524.xml">
2004</link>.</p>

</ss2>
</ss1>
<ss1>
<st>
MenuetOS</st>
<p>

The 64-bit version of <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../256/160256.xml">
MenuetOS</link></O>
 (M64) was released in June 2005. Although MenuetOS was originally written for 32-bit x86 architectures and released under the GPL, the 64-bit version is proprietary. It is distributed as <link xlink:type="simple" xlink:href="../592/11592.xml">
freeware</link> with the source code for some components.</p>

</ss1>
<ss1>
<st>
Solaris</st>
<p>

<link xlink:type="simple" xlink:href="../145/46145.xml">
Solaris</link> 10 and later releases support the x86-64 architecture. Just as with the <link xlink:type="simple" xlink:href="../954/36954.xml">
SPARC</link> architecture, there is only one operating system image for all 32-bit and 64-bit x86 systems; this is labeled as the "x86/x64" DVD-ROM image.</p>
<p>

Default behavior is to boot a 64-bit kernel, allowing both 64-bit and existing or new 32-bit executables to be run. A 32-bit kernel can also be manually selected, in which case only 32-bit executables will run. The isainfo command can be used to determine if a system is running a 64-bit kernel.</p>

</ss1>
<ss1>
<st>
DOS</st>
<p>

It is possible to enter <link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link> under <link xlink:type="simple" xlink:href="../146/8146.xml">
DOS</link> without a DOS extender<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>, but the user must return to real mode in order to call BIOS or DOS interrupts.</p>
<p>

It may also be possible to enter <link xlink:type="simple" xlink:href="../691/2556691.xml">
long mode</link> with a <link xlink:type="simple" xlink:href="../676/1595676.xml">
DOS extender</link> similar to <link xlink:type="simple" xlink:href="../315/4181315.xml">
DOS/4GW</link>, but more complex since x86-64 lacks <link xlink:type="simple" xlink:href="../324/641324.xml">
virtual 8086 mode</link>. DOS itself is not aware of that, and no benefits should be expected unless running DOS in an emulation with an adequate virtualization driver backend, for example: the mass storage interface.</p>

</ss1>
</sec>
<sec>
<st>
Industry naming conventions</st>
<p>

Since AMD64 and Intel 64 are substantially similar, many software and hardware products use one vendor-neutral term to indicate their compatibility with both implementations. AMD's original designation for this processor architecture, "x86-64", is still sometimes used for this purpose, as is the variant "x86_64".<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref> Other companies, such as <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../001/19001.xml">
Microsoft</link></company>
 and <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../980/26980.xml">
Sun Microsystems</link></institution>
</company>
, use "x64" (as a contraction of "x86-64") in marketing material.</p>
<p>

Many operating systems and products, especially those that introduced x86-64 support prior to Intel's entry into the market, use the term "AMD64" or "amd64" to refer to both AMD64 and Intel 64.</p>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../807/1223807.xml">
BSD</link> systems such as <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/7580554.xml">
FreeBSD</link></horizontal_surface>
</surface>
</artifact>
</platform>
, <link xlink:type="simple" xlink:href="../495/21495.xml">
NetBSD</link> and <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../571/18949571.xml">
OpenBSD</link></O>
 refer to both AMD64 and Intel 64 under the architecture name "amd64".</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../242/8242.xml">
Debian</link></distribution>
</arrangement>
</structure>
, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../298/990298.xml">
Ubuntu</link></O>
, and <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../419/94419.xml">
Gentoo</link></O>
  refer to both AMD64 and Intel 64 under the architecture name "amd64".</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../915/42915.xml">
Java Development Kit</link> (JDK): The name "amd64" is used in directory names containing x86-64 files.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link>: x64 versions of Windows use the AMD64 moniker to designate various components which use 64-bit technology for IA-32 processors. For example, the system folder on a Windows x64 Edition installation CD-ROM is named "AMD64", in contrast to "i386" in 32-bit versions.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/46145.xml">
Solaris</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
: The isalist command in Sun's Solaris operating system identifies both AMD64- and Intel 64&ndash;based systems as "amd64".</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../694/655694.xml">
NX bit</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Notes and references</st>

<p>

<reflist>
<entry id="1">
"<weblink xlink:type="simple" xlink:href="http://www.amd.com/us-en/Processors/ProductInformation/0,,30_118_9331_13278,00.html">
AMD64 FAQs</weblink>".&#32;  AMD.&#32;Retrieved on <link>
2008-08-08</link>.&nbsp;"AMD64 replaces terms such as [...] 'x86-64' (now 'AMD64 ISA')."</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="ftp://download.intel.com/technology/architecture/new-instructions-paper.pdf">
Extending the World's Most Popular Processor Architecture</weblink></entry>
<entry id="3">
AMD&#32;(August 10, 2000).&#32;"<weblink xlink:type="simple" xlink:href="http://www.amd.com/us-en/Corporate/VirtualPressRoom/0,,51_104_543_552~715,00.html">
AMD Releases x86-64™ Architectural Specification; Enables Market Driven Migration to 64-Bit Computing</weblink>". <link xlink:type="simple" xlink:href="../097/304097.xml">
Press release</link>. &#32;Retrieved on <link>
2007-08-03</link>.</entry>
<entry id="4">
Transistorized memory, such as RAM and cache sizes (other than solid state disk devices such as USB drives, CompactFlash cards, and so on) as well as CD-based storage size are specified using <link xlink:type="simple" xlink:href="../077/4077.xml">
binary meanings</link> for K (10241), M (10242), G (10243), ...</entry>
<entry id="5">
"<weblink xlink:type="simple" xlink:href="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/24593.pdf">
AMD64 Architecture Programmer’s Manual Volume 2: System Programming</weblink>"&#32;(pdf)&#32;p. 70.&#32;Retrieved on <link>
2007-08-30</link>.</entry>
<entry id="6">
<weblink xlink:type="simple" xlink:href="http://www.theinquirer.net/default.aspx?article=14189">
"Craig Barrett confirms 64&nbsp;bit address extensions for Xeon. And Prescott", from The Inquirer</weblink></entry>
<entry id="7">
<weblink xlink:type="simple" xlink:href="http://www.internetnews.com/ent-news/article.php/3518781">
"A Roundup of 64-Bit Computing", from internetnews.com</weblink></entry>
<entry id="8">
"<weblink xlink:type="simple" xlink:href="http://www.intel.com/technology/intel64/index.htm">
Intel® 64 Architecture</weblink>".&#32;  <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>.&#32;Retrieved on <link>
2007-06-29</link>.</entry>
<entry id="9">
"<weblink xlink:type="simple" xlink:href="http://www.alex-ionescu.com/?p=50">
Behind Windows x64’s 44-bit Virtual Memory Addressing Limit</weblink>".</entry>
<entry id="10">
"<weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/en-us/magazine/cc300794.aspx">
Everything You Need To Know To Start Programming 64-Bit Windows Systems</weblink>".&nbsp;"On x64 versions of Windows, the FS register has been replaced by the GS register."</entry>
<entry id="11">
<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/aa384190.aspx">
Microsoft Developer Network - General Porting Guidelines (64-bit Windows Programming)</weblink></entry>
<entry id="12">
<weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnmdac/html/data_mdacroadmap.asp">
Microsoft Developer Network - Data Access Road Map</weblink></entry>
<entry id="13">
<weblink xlink:type="simple" xlink:href="http://www.apple.com/macosx/technology/64bit.html">
Apple - Mac OS X Leopard - Technology - 64 bit</weblink></entry>
<entry id="14">
<weblink xlink:type="simple" xlink:href="http://developer.apple.com/releasenotes/DeveloperTools/RN-CompilerTools/index.html">
Apple - Mac OS X Xcode 2.4 Release Notes: Compiler Tools</weblink></entry>
<entry id="15">
<weblink xlink:type="simple" xlink:href="http://www.turboirc.com/asm">
 Tutorial for entering protected and long mode from DOS</weblink></entry>
<entry id="16">
Kevin Van Vechten&#32;(<link xlink:type="simple" xlink:href="../027/1027.xml">
August 9</link>, <link xlink:type="simple" xlink:href="../164/36164.xml">
2006</link>).&#32;"<weblink xlink:type="simple" xlink:href="http://lists.apple.com/archives/Darwin-dev/2006/Aug/msg00095.html">
re: Intel XNU bug report</weblink>".&#32;<it>Darwin-dev mailing list</it>.&#32;  <link xlink:type="simple" xlink:href="../856/856.xml">
Apple Computer</link>.&#32;Retrieved on <link>
2006-10-05</link>.&nbsp;"The kernel and developer tools have standardized on "x86_64" for the name of the Mach-O architecture"</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.amd.com/us-en/Processors/DevelopWithAMD/0,,30_2252_875_7044,00.html">
AMD's free technical documentation for the AMD64 architecture</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.amd.com/us-en/Processors/ProductInformation/0,,30_118_4699_7980%5E875%5E4622,00.html">
AMD's AMD64 documentation on CD-ROM (U.S. and Canada only) and downloadable PDF format</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.amd.com/us-en/Processors/ProductInformation/0,,30_118_4699_7980%5E875%5E4622,00.html">
AMD64 Technology: Overview of the AMD64 Architecture</weblink> (<link xlink:type="simple" xlink:href="../077/24077.xml">
PDF</link>)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.xbitlabs.com/news/other/display/20041227094638.html">
AMD's "Enhanced Virus Protection"</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.theregister.co.uk/2005/08/23/intel_fixes_em64t/">
Intel tweaks EM64T for full AMD64 compatibility</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.extremetech.com/article2/0,3973,1561875,00.asp?kc=ETRSS02129TX1K0000532">
Analyst: Intel Reverse-Engineered AMD64</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://marc.info/?l=linux-kernel&amp;m=107766481408468&amp;w=2">
Early report of differences between Intel IA32e and AMD64</weblink></entry>
<entry level="1" type="bullet">

Porting to 64-bit GNU/Linux Systems, by Andreas Jaeger from <social_group wordnetid="107950920" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<meeting wordnetid="108307589" confidence="0.8">
<gathering wordnetid="107975026" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<conference wordnetid="108308497" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../687/3666687.xml">
GCC Summit</link></psychological_feature>
</conference>
</group>
</gathering>
</meeting>
</event>
</social_group>
 2003 <weblink xlink:type="simple" xlink:href="http://www.linux.org.uk/~ajh/gcc/gccsummit-2003-proceedings.pdf">
http://www.linux.org.uk/~ajh/gcc/gccsummit-2003-proceedings.pdf</weblink>. An excellent paper explaining almost all practical aspects for a transition from 32-bit to 64-bit. </entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://techreport.com/reviews/2005q1/64-bits/index.x?pg=1">
Tech Report article: 64-bit computing in theory and practice</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.intel.com/technology/intel64/index.htm">
Intel 64 Architecture</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.turboirc.com/asm">
TurboIRC.COM tutorial of entering the protected and the long mode the raw way from DOS</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.x64freeware.co.uk/">
X64freeware - A directory of 64 bit freeware</weblink></entry>
</list>
</p>



</sec>
</bdy>
</commodity>
</merchandise>
</artifact>
</article>
