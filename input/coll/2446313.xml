<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:33:15[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<idea  confidence="0.8" wordnetid="105833840">
<concept  confidence="0.8" wordnetid="105835747">
<property  confidence="0.8" wordnetid="105849040">
<feature  confidence="0.8" wordnetid="105849789">
<header>
<title>Word wrap</title>
<id>2446313</id>
<revision>
<id>234580686</id>
<timestamp>2008-08-27T15:17:44Z</timestamp>
<contributor>
<username>David Eppstein</username>
<id>2051880</id>
</contributor>
</revision>
<categories>
<category>Text editor features</category>
<category>Typography</category>
<category>Dynamic programming</category>
</categories>
</header>
<bdy>

For word wrap handling on Wikipedia, see .<p>

<b>Word wrap</b> or <b>line wrap</b> is the feature, supported by most <link xlink:type="simple" xlink:href="../310/30310.xml">
text editor</link>s, <link xlink:type="simple" xlink:href="../236/33236.xml">
word processors</link>, and <link xlink:type="simple" xlink:href="../173/33173.xml">
web browser</link>s, of automatically replacing some of the blank spaces between words by line breaks, such that each line fits in the viewable window, allowing text to be read from top to bottom without any horizontal <link xlink:type="simple" xlink:href="../183/913183.xml">
scrolling</link>.</p>
<p>

It is usually done <link xlink:type="simple" xlink:href="../147/348147.xml">
on the fly</link> when viewing or printing a document, so no line break code is manually entered, or stored. If the user changes the margins, the editor will either automatically reposition the line breaks to ensure that all the text will "flow" within the margins and remain visible, or provide the typist some convenient way to reposition the line breaks.</p>
<p>

Compare <link xlink:type="simple" xlink:href="../426/1030426.xml">
soft return</link> and <link xlink:type="simple" xlink:href="../858/5124858.xml">
hard return</link>.</p>

<sec>
<st>
Word boundaries, hyphenation, and hard spaces</st>
<p>

The soft returns are usually placed after the end of complete words, or after the punctuation that follows complete words. However, word wrap may also occur following a <link xlink:type="simple" xlink:href="../347/59347.xml">
hyphen</link>.</p>
<p>

Word wrap following hyphens is sometimes not desired, and can be avoided by using a so-called non-breaking hyphen instead of a regular hyphen. On the other hand, when using word processors, invisible hyphens, called soft hyphens, can also be inserted inside words so that word wrap can occur following the soft hyphens.</p>
<p>

Sometimes, word wrap is not desirable between words. In such cases, word wrap can usually be avoided by using a <link xlink:type="simple" xlink:href="../852/933852.xml">
hard space</link> or non-breaking space between the words, instead of regular spaces.</p>

</sec>
<sec>
<st>
Word wrapping in text containing Chinese, Japanese, and Korean</st>
<p>

In <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../751/5751.xml">
Chinese</link></language>
, <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../606/15606.xml">
Japanese</link></language>
, and <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../756/16756.xml">
Korean</link></language>
, each <link xlink:type="simple" xlink:href="../231/91231.xml">
Han character</link> is normally considered a word, and therefore word wrapping can usually occur before and after any Han character.</p>
<p>

Under certain circumstances, however, word wrapping is not desired. For instance,
<list>
<entry level="1" type="bullet">

 word wrapping might not be desired within personal names, and</entry>
<entry level="1" type="bullet">

 word wrapping might not be desired within any compound words (when the text is flush left but only in some styles).</entry>
</list>
</p>
<p>

Most existing word processors and <link xlink:type="simple" xlink:href="../180/169180.xml">
typesetting</link> software cannot handle either of the above scenarios.</p>
<p>

<link xlink:type="simple" xlink:href="../987/160987.xml">
CJK</link> punctuation may or may not follow rules similar to the above-mentioned special circumstances; such rules are usually referred to by the Japanese term <link xlink:type="simple" xlink:href="../971/15117971.xml">
kinsoku shori</link> (, literally “prohibition rule handling”).</p>
<p>

A special case of kinsoku shori, however, always applies: line wrap must never occur inside the CJK dash and ellipsis. Even though each of these punctuation marks must be represented by two characters due to a limitation of all existing <link xlink:type="simple" xlink:href="../295/5295.xml">
character encoding</link>s, each of these are intrinsically a single punctuation mark that is two <link xlink:type="simple" xlink:href="../949/927949.xml">
em</link>s wide, not two one-em-wide punctuation marks.</p>

</sec>
<sec>
<st>
Algorithm</st>

<ss1>
<st>
 Greedy algorithm </st>
<p>

The naive way to solve the problem is to use a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link> that puts as many words on a line as possible, then moving on to the next line to do the same until there are no more words left to place. This method is used by many modern word processors, such as <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../287/20287.xml">
Microsoft Word</link></software>
 and <link xlink:type="simple" xlink:href="../227/68227.xml">
Open Office</link>. The following pseudocode implements this algorithm:</p>
<p>

SpaceLeft := LineWidth
for each Word in Text
if Width(Word) &amp;gt; SpaceLeft
insert line break before Word in Text
SpaceLeft := LineWidth - Width(Word)
else
SpaceLeft := SpaceLeft - (Width(Word) + SpaceWidth)</p>
<p>

Where LineWidth is the width of a line, SpaceLeft is the remaining width of space on the line to fill, SpaceWidth is the width of a single space character, Text is the input text to iterate over and Word is a word in this text.</p>

</ss1>
<ss1>
<st>
 Optimal solution </st>

<p>

<link xlink:type="simple" xlink:href="../065/30065.xml">
TeX</link> uses a different "breaking algorithm" that considers the entire paragraph as a whole,
breaking it into lines in a way that is often considered "more aesthetically pleasing" than the greedy algorithm. (TeX also uses a <link xlink:type="simple" xlink:href="../189/2842189.xml">
hyphenation algorithm</link> to break words across lines).</p>
<p>

While the greedy algorithm is often adequate, it doesn't give the optimal solution if you want the remaining space on the end of each line to be as small as possible. Consider the following text:</p>
<p>

aaa bb cc ddddd </p>
<p>

If the cost function of a line is defined by the remaining space squared, the greedy algorithm would yield a sub-optimal solution for the problem (for simplicity, consider a <link xlink:type="simple" xlink:href="../501/53501.xml">
fixed-width</link> font):</p>
<p>

------    Line width: 6
aaa bb    Remaining space: 0 (cost = 0 squared = 0)
cc        Remaining space: 4 (cost = 4 squared = 16)
ddddd     Remaining space: 1 (cost = 1 squared = 1)</p>
<p>

Summing to a total cost of 17, while the optimal solution would look like this:</p>
<p>

------    Line width: 6
aaa       Remaining space: 3 (cost = 3 squared = 9)
bb cc     Remaining space: 1 (cost = 1 squared = 1)
ddddd     Remaining space: 1 (cost = 1 squared = 1)</p>
<p>

The difference here is that the first line is broken before bb instead of after it, yielding a better right margin and a lower cost 11.</p>
<p>

To solve the problem we need to define a cost function <math>c(i, j)</math> that computes the cost of a line consisting of the words <math>\text{Word}[i]</math> to <math>\text{Word}[j]</math> from the text:</p>
<p>

<indent level="1">

<math>c(i, j) = \left(\text{LineWidth}-\text{SpaceWidth}(j-i)-\sum_{k=i}^j \text{Width}(\text{Word}[k])\right)^P</math>
</indent>

Where <math>P</math> typically is <math>2</math> or <math>3</math>. There are some special cases to consider: If the result is negative (that is, the sequence of words cannot fit on a line), the cost needs to reflect the cost of <link xlink:type="simple" xlink:href="../180/1711180.xml">
tracking</link> or condensing the text it to fit; if that is not possible, it needs to return <math>\infty</math>. </p>
<p>

The cost of the optimal solution can be defined as a <link xlink:type="simple" xlink:href="../106/48106.xml">
recurrence</link>:</p>
<p>

<indent level="1">

<math>f(j) = \begin{cases} 
  c(1, j), &amp; \text{if } c(1, j) &amp;lt; \infty \\ 
  \displaystyle \min_{1 \leq k &amp;lt; j} \big(f(k) + c(k + 1, j)\big), &amp; \text{if } c(1, j) = \infty
\end{cases}</math>
</indent>

Computation can be greatly optimized using <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>. In terms of implementation, it seems that the computation of <math>c(i, j)</math> is unnecessary when <math>c(i, k) &amp;lt; 0</math> (where <math>k &amp;lt; j</math>); it will be infinite anyway.</p>

</ss1>
</sec>
<sec>
<st>
 External links </st>

<p>

Knuth's algorithm:</p>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://defoe.sourceforge.net/folio/knuth-plass.html">
"Knuth &amp; Plass line-breaking Revisited"</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://oedipus.sourceforge.net/texlib/">
"tex_wrap": "Implements TeX's algorithm for breaking paragraphs into lines."</weblink> Reference: "Breaking Paragraphs into Lines", D.E. Knuth and M.F. Plass, chapter 3 of _Digital Typography_, CSLI Lecture Notes #78.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/~mward/Text-Reflow-1.05/Reflow.pm">
Text::Reflow - Perl module for reflowing text files using Knuth's paragraphing algorithm.</weblink> "The reflow algorithm tries to keep the lines the same length but also tries to break at punctuation, and avoid breaking within a proper name or after certain connectives ("a", "the", etc.). The result is a file with a more "ragged" right margin than is produced by fmt or Text::Wrap but it is easier to read since fewer phrases are broken across line breaks."</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nabble.com/Initial-soft-hyphen-support-t2970713.html">
adjusting the Knuth algorithm</weblink> to recognize the <link xlink:type="simple" xlink:href="../347/59347.xml#xpointer(//*[./st=%22Hyphens_in_computing+%22])">
 "soft hyphen"</link>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://wiki.apache.org/xmlgraphics-fop/KnuthsModel">
Knuth's breaking algorithm.</weblink> "The detailed description of the model and the algorithm can be found on the paper "Breaking Paragraphs into Lines" by Donald E. Knuth, published in the book "Digital Typography" (Stanford, California: Center for the Study of Language and Information, 1999), (CSLI Lecture Notes, no. 78.)" ; part of <weblink xlink:type="simple" xlink:href="http://wiki.apache.org/xmlgraphics-fop/GoogleSummerOfCode2006/FloatsImplementationProgress">
Google Summer Of Code 2006</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/23630.html">
"Bridging the Algorithm Gap: A Linear-time Functional Program for Paragraph Formatting"</weblink> by Oege de Moor, Jeremy Gibbons, 1999</entry>
</list>
</p>
<p>

Other word-wrap links:</p>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.efg2.com/Lab/Library/Graphics/CircleWordWrap.htm">
circular word wrap</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codecomments.com/message230162.html">
the reverse problem -- picking columns just wide enough to fit (wrapped) text</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://api.kde.org/4.x-api/kdelibs-apidocs/kdeui/html/classKWordWrap.html">
KWordWrap Class Reference</weblink> used in the KDE GUI</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.leverkruid.eu/GKPLinebreaking/elements.html">
"Knuth linebreaking elements for Formatting Objects"</weblink> by Simon Pepping 2006. Extends the Knuth model to handle a few enhancements.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://wiki.apache.org/xmlgraphics-fop/PageLayout/">
"Page breaking strategies"</weblink> Extends the Knuth model to handle a few enhancements.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.techwr-l.com/archives/0504/techwhirl-0504-00203.html">
"a Knuth-Plass-like linebreaking algorithm</weblink> ... The *really* interesting thing is how Adobe's algorithm differs from the Knuth-Plass algorithm. It must differ, since Adobe has managed to patent its algorithm (6,510,441)."<weblink xlink:type="simple" xlink:href="http://www.techwr-l.com/archives/0504/techwhirl-0504-00206.html"></weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://blogs.msdn.com/murrays/archive/2006/11/15/lineservices.aspx">
"Murray Sargent: Math in Office"</weblink></entry>
</list>
</p>


</sec>
</bdy>
</feature>
</property>
</concept>
</idea>
</article>
