<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:38:05[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Channel I/O</title>
<id>2470370</id>
<revision>
<id>239233155</id>
<timestamp>2008-09-18T09:41:15Z</timestamp>
<contributor>
<username>Kbdank71</username>
<id>197953</id>
</contributor>
</revision>
<categories>
<category>Mainframe computers</category>
<category>IBM System/360 mainframe line</category>
<category>Wikipedia articles needing clarification</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>channel I/O</b> is a generic term that refers to a high-performance <link xlink:type="simple" xlink:href="../558/14558.xml">
input/output</link> (I/O) architecture that is implemented in various forms on a number of computer architectures, especially on <link xlink:type="simple" xlink:href="../266/20266.xml">
mainframe computer</link>s. In the past they were generally implemented with a custom processor, known alternately as <b>peripheral processor</b>, <b>I/O processor</b>, <b>I/O controller</b>, or <b>DMA controller</b>.
<sec>
<st>
 Basic principles </st>
<p>

Many I/O tasks can be fairly complex and require logic to be applied to the data to convert formats and other similar duties. In these situations the simplest solution is to ask the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> to handle the logic, but due to the fact that the I/O devices are very slow, the CPU would end up wasting a huge amount of time (in computer perspective) sitting idle waiting for the data from the device. A channel I/O architecture avoids this problem by using a separate, low-cost processor with enough logic and memory onboard&#91;&#93; to handle these tasks. They are typically not powerful or flexible enough to be used as a computer on their own, and are actually a form of <link xlink:type="simple" xlink:href="../193/378193.xml">
co-processor</link>. The CPU sends small programs to the controller to handle an I/O job, which the channel controller can then complete without any help from the CPU. When it is complete, or there is an error, the channel controller communicates with the CPU using a selection of <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>s. Since the channel controller has direct access to the main memory, it is also often referred to as <it>DMA controller</it> (where DMA stands for <link xlink:type="simple" xlink:href="../717/57717.xml">
direct memory access</link>), but that term is somewhat more loose in definition and is often applied to non-programmable devices as well.</p>

</sec>
<sec>
<st>
 History </st>
<p>

The first use of channel I/O was with the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../778/206778.xml">
IBM 709</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 <weblink xlink:type="simple" xlink:href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP709.html">
http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP709.html</weblink> vacuum tube mainframe, whose Model 766 Data Synchronizer was the first channel in 1957. Its transistorized successor the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../332/147332.xml">
IBM 7090</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 <weblink xlink:type="simple" xlink:href="http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP7090B.html">
http://www-03.ibm.com/ibm/history/exhibits/mainframe/mainframe_PP7090B.html</weblink> had channels (the 7607) and a channel multiplexor (the 7606) which could control up to eight channels.</p>
<p>

Later, for larger <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../294/29294.xml">
IBM System/360</link></horizontal_surface>
</surface>
</artifact>
</platform>
 computers, and even for early <link xlink:type="simple" xlink:href="../785/59785.xml">
System/370</link> models, the selector channels and the multiplexor channels still were bulky and expensive separate processors, such as the <link>
IBM 2860</link> 'selector channel' and the <link>
IBM 2870</link> 'multiplexer channel'. For the smaller System/360 computers, the multiplexor channels were implemented in CPU's <link xlink:type="simple" xlink:href="../999/19999.xml">
microcode</link>.  Later, the channels were implemented in onboard processors sitting in the same box as the CPU.</p>
<p>

One of the earlier non-IBM channel systems was provided in 1964 with the <link xlink:type="simple" xlink:href="../661/58661.xml">
CDC 6600</link> <link xlink:type="simple" xlink:href="../153/37153.xml">
supercomputer</link>, which used 10 logically independent computers called peripheral processors, or PPs for this role. The PPs were quite powerful, basically a modern version of CDC's first 'personal computer', the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../245/7650245.xml">
CDC 160A</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
. The operating system resided and executed in one of the PPs (specifically PP0). Since the 1960s channel controllers have been a standard part of almost all mainframe designs, and the primary reason why anyone buys one. Channel controllers have also been made as small as single-chip designs with multiple channels on them, used in the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
 computers for instance. However with the rapid speed increases in computers today, combined with <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s that don't "block" when waiting for data, the channel controller has become somewhat redundant and are not commonly found on smaller machines.</p>
<p>

Channel controllers can be said to be making a comeback in the form of "<link xlink:type="simple" xlink:href="../749/201749.xml">
bus mastering</link>" peripheral devices, such as <link xlink:type="simple" xlink:href="../075/24075.xml">
PCI</link> <link xlink:type="simple" xlink:href="../717/57717.xml">
direct memory access</link> (DMA) devices. The rationale for these devices is the same as for the original channel controllers, namely off-loading interrupts and <link xlink:type="simple" xlink:href="../904/6904.xml">
context switching</link> from the main CPU.</p>

</sec>
<sec>
<st>
 Description </st>

<p>

The reference implementation of channel I/O is that of the IBM System/360 family of mainframes and its successors, but similar implementations have been adopted by other mainframe vendors, such as <link xlink:type="simple" xlink:href="../032/58032.xml">
Control Data</link>, <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/945024.xml">
Bull</link></institution>
</company>
 (<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../730/12730.xml">
General Electric</link></company>
/<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../721/225721.xml">
Honeywell</link></company>
) and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../274/61274.xml">
Unisys</link></company>
.</p>
<p>

Computer systems that use channel I/O have special hardware components that handle all input/output operations in their entirety independently of the systems' CPU(s).  The CPU of a system that uses channel I/O typically has only one <link xlink:type="simple" xlink:href="../683/20683.xml">
machine instruction</link> in its repertoire for input and output; this instruction is used to pass input/output commands to the specialized I/O hardware in the form of <link>
channel program</link>s. I/O thereafter proceeds without intervention from the CPU until an event requiring notification of the operating system occurs, at which point the I/O hardware signals an interrupt to the CPU.</p>
<p>

A channel is an independent hardware component that coordinates all I/O to a set of controllers or devices. It is not merely a medium of communication, despite the name; it is a <it>programmable</it> device that handles all details of I/O after being given a list of I/O operations to carry out (the channel program).</p>
<p>

Each channel may support one or more controllers and/or devices.  Channel programs contain lists of commands to the channel itself and to various controllers and devices to which it is connected.  Once the operating system has prepared a complete list of I/O commands, it executes a single I/O machine instruction to initiate the channel program; the channel thereafter assumes control of the I/O operations until they are completed.</p>
<p>

It is possible to develop very complex channel programs, initiating many different I/O operations on many different I/O devices simultaneously.  This flexibility frees the CPU from the overhead of starting, monitoring, and managing individual I/O operations.  The specialized channel hardware, in turn, is dedicated to I/O and can carry it out more efficiently than the CPU (and entirely in parallel with the CPU). Channel I/O is not unlike the <link>
Direct Memory Access</link> (DMA) of microcomputers, only more complex and advanced.  Most mainframe operating systems do not fully exploit all the features of channel I/O.</p>
<p>

On large mainframe computer systems, CPUs are only one of several powerful hardware components that work in parallel.  Special input/output controllers (the exact names of which vary from one manufacturer to another) handle I/O exclusively, and these in turn are connected to hardware channels that also are dedicated to input and output.  There may be several CPUs and several I/O processors. The overall architecture optimizes input/output performance without degrading pure CPU performance.  Since most real-world applications of mainframe systems are heavily I/O-intensive business applications, this architecture helps provide the very high levels of <link xlink:type="simple" xlink:href="../932/30932.xml">
throughput</link> that distinguish mainframes from other types of computer.</p>
<p>

In <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 <link xlink:type="simple" xlink:href="../266/1856266.xml">
ESA/390</link> terminology, a channel is a parallel data connection inside the tree-like or hierarchically organized I/O subsystem. In System/390 I/O cages, channels either directly connect to devices which are installed inside the cage (communication adapter such as <connection wordnetid="103091374" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../062/952062.xml">
ESCON</link></instrumentality>
</artifact>
</connection>
, <connection wordnetid="103091374" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../855/1061855.xml">
FICON</link></instrumentality>
</artifact>
</connection>
, <link>
open systems adapter</link> or they run outside of the cage, below the <link xlink:type="simple" xlink:href="../193/2931193.xml">
raised floor</link> as cables of the thickness of a thumb and directly connect to channel interfaces on bigger devices like tape subsystems, <link xlink:type="simple" xlink:href="../691/54691.xml">
direct access storage device</link>s (DASDs), terminal concentrators and other ESA/390 systems.</p>

</sec>
<sec>
<st>
 Channel command words </st>

<p>

A <b>channel command word</b> (<b>CCW</b>) is an <link xlink:type="simple" xlink:href="../801/3149801.xml">
instruction</link> for a specialized I/O channel processor. It is used to initiate an I/O operation on a channel-attached device, such as “read” or “seek”. On system architectures that implement channel I/O, typically all devices are connected by channels, and so <it>all</it> I/O requires the use of CCWs. </p>
<p>

CCWs are organized into <it>channel programs</it> by the operating system, an I/O subroutine, a utility program, or by standalone software (such as test and diagnostic programs).  </p>

</sec>
<sec>
<st>
 Channel Program </st>

<p>

A <b>channel program</b> is a sequence of I/O instructions executed by the input/output channel processor in the IBM System/360 and subsequent architectures.  The channel program consists of one or more channel command words.  The operating system signals the I/O channel processor to begin executing the channel program with a SSCH (start sub-channel) instruction.  The processor is then free to proceed with non-I/O instructions until interrupted.  When the operations are complete, the channel posts an interrupt.  In earlier models of the IBM mainframe line, the channel processor was an identifiable component, but in modern mainframes, the channels are implemented in a microcode running in multi-core processor-on-a-chip, called <b>System Assistance Processor</b> (<b>SAP</b>). Hence the earlier SIO (<it>start I/O</it>) and SIOF (<it>start I/O fast release</it>) <link xlink:type="simple" xlink:href="../448/466448.xml">
assembler</link> instructions are replaced by the SSCH (<it>start sub-channel</it>) instruction.</p>
<p>

Channel I/O provides considerable economies in input/output. For example, on IBM's <link xlink:type="simple" xlink:href="../604/1266604.xml">
Linux/390</link>, the formatting of an entire track of a <link xlink:type="simple" xlink:href="../691/54691.xml">
DASD</link> requires only one channel program (and thus only one I/O instruction). The program is executed by the <it>dedicated</it> I/O processor, while the <it>application</it> processor (the CPU) is free for other work.</p>

</sec>
<sec>
<st>
 Booting with channel I/O </st>

<p>

Even <link xlink:type="simple" xlink:href="../211/4211.xml">
bootstrapping</link> of the system, or <link>
Initial program load</link> (IPL) in IBM nomenclature, is carried out by channels: to load the system, a very small, simple channel program is loaded into memory and initiated, and this program causes the first portion of the system loading software to be loaded. The software is then executed once the I/O is completed, and an interrupt is signaled to the CPU.</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../909/40909.xml">
Booting</link></entry>
<entry level="1" type="bullet">

 <link>
Initial program load</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../294/29294.xml">
System/360</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../144/1856144.xml">
z/Architecture</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../002/195002.xml">
GCOS</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../147/201147.xml">
UNIVAC 1110</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../789/2458789.xml">
IBM System z9</link></entry>
<entry level="1" type="bullet">

 <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../912/15909912.xml">
IBM System z10</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>




</sec>
</bdy>
</article>
