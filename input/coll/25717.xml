<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:34:03[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<subject  confidence="0.8" wordnetid="106599788">
<language  confidence="0.8" wordnetid="106282651">
<header>
<title>Regular expression</title>
<id>25717</id>
<revision>
<id>244552464</id>
<timestamp>2008-10-11T11:37:15Z</timestamp>
<contributor>
<username>Tedickey</username>
<id>1942604</id>
</contributor>
</revision>
<categories>
<category>Wikipedia articles needing clarification</category>
<category>Programming language topics</category>
<category>Pattern matching</category>
<category>Formal languages</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../213/5213.xml">
computing</link>, <b>regular expressions</b> provide a concise and flexible means for identifying strings of text of interest, such as particular characters, words, or patterns of characters. Regular expressions (abbreviated as <b>regex</b> or <b>regexp</b>, with plural forms <b>regexes</b>, <b>regexps</b>, or <b>regexen</b>) are written in a formal language that can be interpreted by a regular expression processor, a program that either serves as a <link xlink:type="simple" xlink:href="../097/70097.xml">
parser generator</link> or examines text and identifies parts that match the provided specification.<p>

The following examples illustrate a few specifications that could be expressed in a regular expression:</p>
<p>

<list>
<entry level="1" type="bullet">

 the sequence of characters "car" in any context, such as "car", "cartoon", or "bicarbonate"</entry>
<entry level="1" type="bullet">

 the word "car" when it appears as an isolated word</entry>
<entry level="1" type="bullet">

 the word "car" when preceded by the word "blue" or "red"</entry>
<entry level="1" type="bullet">

 a dollar sign immediately followed by one or more digits, and then optionally a period and exactly two more digits</entry>
</list>
</p>
<p>

Regular expressions can be much more complex than these examples.</p>
<p>

Regular expressions are used by many <link xlink:type="simple" xlink:href="../310/30310.xml">
text editor</link>s, utilities, and programming languages to search and manipulate text based on <link xlink:type="simple" xlink:href="../351/68351.xml">
pattern</link>s. For example, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
, <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../237/30237.xml">
Tcl</link></programming_language>
 have a powerful regular expression engine built directly into their syntax. Several utilities provided by <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 distributions—including the editor <link xlink:type="simple" xlink:href="../771/9771.xml">
ed</link> and the filter <link xlink:type="simple" xlink:href="../642/46642.xml">
grep</link>—were the first to popularize the concept of regular expressions.</p>
<p>

As an example of the syntax, the regular expression \bex can be used to search for all instances of the string "<it>ex</it>" that occur after word boundaries (signified by the \b). Thus in the string "Texts for experts," \bex matches the "<it>ex</it>" in "experts" but not in "Texts" (because the "<it>ex</it>" occurs inside a word and not immediately after a word boundary).</p>
<p>

Many modern computing systems provide <link xlink:type="simple" xlink:href="../869/41869.xml">
wildcard character</link>s in matching filenames from a <link xlink:type="simple" xlink:href="../280/1010280.xml">
file system</link>. This is a core capability of many <link xlink:type="simple" xlink:href="../397/2281397.xml">
command-line shells</link> and is also known as <link xlink:type="simple" xlink:href="../117/484117.xml">
globbing</link>. Wildcards differ from regular expressions in that they generally only express very limited forms of alternatives.</p>

<sec>
<st>
Basic concepts</st>
<p>

A regular expression, often called a <b>pattern</b>, is an expression that describes a set of strings. They are usually used to give a concise description of a set, without having to list all elements. For example, the set containing the three strings "<it>Handel</it>", "<it>Händel</it>", and "<it>Haendel</it>" can be described by the pattern H(ä|ae?)ndel (or alternatively, it is said that the pattern <it>matches</it> each of the three strings). In most formalisms, if there is any regex that matches a particular set then there is an infinite number of such expressions. Most formalisms provide the following operations to construct regular expressions.</p>
<p>

<list>
<entry level="1" type="definition">

Alternation</entry>
<entry level="1" type="indent">

A <link xlink:type="simple" xlink:href="../073/641073.xml">
vertical bar</link> separates alternatives. For example, gray|grey can match "<it>gray</it>" or "<it>grey</it>".</entry>
<entry level="1" type="definition">

Grouping</entry>
<entry level="1" type="indent">

<link xlink:type="simple" xlink:href="../hem/Ledringhem.xml">
Parentheses</link> are used to define the scope and precedence of the operators (among other uses). For example, gray|grey and gr(a|e)y are equivalent patterns which both describe the set of "<it>gray</it>" and "<it>grey</it>".</entry>
<entry level="1" type="definition">

Quantification</entry>
<entry level="1" type="indent">

A quantifier after a token (such as a character) or group specifies how often that preceding element is allowed to occur. The most common quantifiers are the <link xlink:type="simple" xlink:href="../348/59348.xml">
question mark</link> ?, the <link xlink:type="simple" xlink:href="../152/59152.xml">
asterisk</link> * (derived from the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/16750.xml">
Kleene star</link></language>
), and the <link>
plus sign</link> +.</entry>
<entry level="1" type="indent">

|</entry>
</list>

|- style="vertical-align:top;"
|style="width:15px;"|<b>?</b>
|The question mark indicates there is <it>zero or one</it> of the preceding element. For example, colou?r matches both "<it>color</it>" and "<it>colour</it>".
|- style="vertical-align:top;"
|<b>*</b>
|The asterisk indicates there are <it>zero or more</it> of the preceding element. For example, ab*c matches "<it>ac</it>", "<it>abc</it>", "<it>abbc</it>", "<it>abbbc</it>", and so on.
|- style="vertical-align:top;"
|<b>+</b>
|The plus sign indicates that there is <it>one or more</it> of the preceding element. For example, ab+c matches "<it>abc</it>", "<it>abbc</it>", "<it>abbbc</it>", and so on, but not "<it>ac</it>".
|}</p>
<p>

These constructions can be combined to form arbitrarily complex expressions, much like one can construct arithmetical expressions from numbers and the operations <b>+</b>, <b>−</b>, <b>×</b>, and <b>÷</b>. For example, H(ae?|ä)ndel and H(a|ae|ä)ndel are both valid patterns which match the same strings as the earlier example, H(ä|ae?)ndel.</p>
<p>

The precise <link xlink:type="simple" xlink:href="../860/26860.xml">
syntax</link> for regular expressions varies among tools and with context; more detail is given in the <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Syntax%22])">
<it>Syntax</it> section</link>.</p>

</sec>
<sec>
<st>
History</st>
<p>

The origins of regular expressions lie in <link xlink:type="simple" xlink:href="../356/103356.xml">
automata theory</link> and <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language theory</link>, both of which are part of <link xlink:type="simple" xlink:href="../392/323392.xml">
theoretical computer science</link>. These fields study models of computation (automata) and ways to describe and classify formal languages. In the 1950s, mathematician <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Cole Kleene</link></scientist>
 described these models using his mathematical notation called <it>regular sets</it>. The <link xlink:type="simple" xlink:href="../515/29515.xml">
SNOBOL</link> language was an early implementation of <link xlink:type="simple" xlink:href="../688/279688.xml">
pattern matching</link>, but not identical to regular expressions. <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../747/10817747.xml">
Ken Thompson</link></scientist>
</person>
 built Kleene's notation into the editor <link xlink:type="simple" xlink:href="../256/25256.xml">
QED</link> as a means to match patterns in text files. He later added this capability to the Unix editor <link xlink:type="simple" xlink:href="../771/9771.xml">
ed</link>, which eventually led to the popular search tool <link xlink:type="simple" xlink:href="../642/46642.xml">
grep</link>'s use of regular expressions ("grep" is a word derived from the command for regular expression searching in the ed editor: g/<it>re</it>/p where <it>re</it> stands for regular expression). Since that time, many variations of Thompson's original adaptation of regular expressions have been widely used in Unix and Unix-like utilities including <link xlink:type="simple" xlink:href="../110/3961110.xml">
expr</link>, <link xlink:type="simple" xlink:href="../456/1456.xml">
AWK</link>, <skilled_worker wordnetid="110605985" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../234/18933234.xml">
Emacs</link></causal_agent>
</worker>
</editor>
</person>
</physical_entity>
</skilled_worker>
, <link xlink:type="simple" xlink:href="../494/32494.xml">
vi</link>, and <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/105985.xml">
lex</link></equipment>
</implement>
</generator>
</apparatus>
</tool>
</instrumentality>
</artifact>
.</p>
<p>

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../237/30237.xml">
Tcl</link></programming_language>
 regular expressions were derived from a regex library written by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../980/172980.xml">
Henry Spencer</link></causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
, though Perl later expanded on Spencer's library to add many new features.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../430/9915430.xml">
Philip Hazel</link></causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
 developed <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../290/1712290.xml">
PCRE</link></software>
 (Perl Compatible Regular Expressions), which attempts to closely mimic Perl's regular expression functionality, and is used by many modern tools including <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/24131.xml">
PHP</link></writer>
</language>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
 and <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../581/2581.xml">
Apache HTTP Server</link></software>
. Part of the effort in the design of <link xlink:type="simple" xlink:href="../638/1146638.xml">
Perl 6</link> is to improve Perl's regular expression integration, and to increase their scope and capabilities to allow the definition of <link xlink:type="simple" xlink:href="../899/892899.xml">
parsing expression grammar</link>s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> The result is a mini-language called <link xlink:type="simple" xlink:href="../556/7110556.xml">
Perl 6 rules</link>, which are used to define Perl 6 grammar as well as provide a tool to programmers in the language. These rules maintain existing features of Perl 5.x regular expressions, but also allow <link>
BNF</link>-style definition of a <link xlink:type="simple" xlink:href="../089/70089.xml">
recursive descent parser</link> via sub-rules.</p>
<p>

The use of regular expressions in structured information standards for document and database modeling started in the 1960s and expanded in the 1980s when industry standards like <link xlink:type="simple" xlink:href="../994/28994.xml">
ISO SGML</link> (precursored by ANSI "GCA 101-1983") consolidated.  The kernel of the <information wordnetid="105816287" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<datum wordnetid="105816622" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../623/846623.xml#xpointer(//*[./st=%22Validation%22])">
structure specification language</link></system_of_measurement>
</datum>
</standard>
</information>
 standards are regular expressions. Simple use is evident in the <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../537/8537.xml">
DTD</link></system_of_measurement>
</standard>
 element group syntax.</p>
<p>

See also .</p>

</sec>
<sec>
<st>
Formal language theory</st>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40px" src="Ambox_?.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>All or part of this article may be .</b>
Please help . Suggestions may be on the .</col>
</row>
</table>

</p>

<p>

Regular expressions can be expressed in terms of <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language theory</link>. Regular expressions consist of constants and operators that denote sets of strings and operations over these sets, respectively. Given a finite alphabet Σ the following constants are defined:
<list>
<entry level="1" type="bullet">

(<it>empty set</it>) ∅ denoting the set ∅</entry>
<entry level="1" type="bullet">

(<it>empty string</it>) ε denoting a string with no characters.</entry>
<entry level="1" type="bullet">

(<it><link xlink:type="simple" xlink:href="../706/199706.xml">
literal character</link></it>) <it>a</it> in Σ denoting a character in the language.</entry>
</list>
</p>
<p>

The following operations are defined:
<list>
<entry level="1" type="bullet">

 (<it>concatenation</it>) <it>RS</it> denoting the set { αβ | α in <it>R</it> and β in <it>S</it> }. For example {"ab", "c"}{"d", "ef"} = {"abd", "abef", "cd", "cef"}.</entry>
<entry level="1" type="bullet">

(<it>alternation</it>) <it>R|S</it> denoting the set union of <it>R</it> and <it>S</it>. Many textbooks use the symbols ∪, +, or ∨ for alternation instead of the vertical bar. For example {"ab", "c"}∪{"d", "ef"} = {"ab", "c", "d", "ef"}</entry>
<entry level="1" type="bullet">

(<it><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/16750.xml">
Kleene star</link></language>
</it>) <it>R</it>* denoting the smallest <link xlink:type="simple" xlink:href="../631/27631.xml">
superset</link> of <it>R</it> that contains ε and is <mathematical_relation wordnetid="113783581" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../802/293802.xml">
closed</link></function>
</operator>
</mathematical_relation>
 under string concatenation. This is the set of all strings that can be made by concatenating zero or more strings in <it>R</it>. For example, {"ab", "c"}* = {ε, "ab", "c", "abab", "abc", "cab", "cc", "ababab", "abcab", ... }.</entry>
</list>
</p>
<p>

The above constants and operators form a <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../430/155430.xml">
Kleene algebra</link></language>
.</p>
<p>

To avoid brackets it is assumed that the Kleene star has the highest priority, then concatenation and then set union. If there is no ambiguity then brackets may be omitted. For example, (ab)c can be written as abc, and a|(b(c*)) can be written as a|bc*.</p>
<p>

<b>Examples:</b>
<list>
<entry level="1" type="bullet">

a|b* denotes {ε, <it>a</it>, <it>b</it>, <it>bb</it>, <it>bbb</it>, ...}</entry>
<entry level="1" type="bullet">

(a|b)* denotes the set of all strings with no symbols other than <it>a</it> and <it>b</it>, including the empty string: {ε, <it>a</it>, <it>b</it>, <it>aa</it>, <it>ab</it>, <it>ba</it>, <it>bb</it>, <it>aaa</it>, ...}</entry>
<entry level="1" type="bullet">

ab*(c|ε) denotes the set of strings starting with <it>a</it>, then zero or more <it>b</it>s and finally optionally a <it>c</it>: {<it>a</it>, <it>ac</it>, <it>ab</it>, <it>abc</it>, <it>abb</it>, <it>abbc</it>, ...}</entry>
</list>
</p>
<p>

The formal definition of regular expressions is purposely parsimonious and avoids defining the redundant quantifiers ? and +, which can be expressed as follows: a+ = aa*, and a? = (a|ε). Sometimes the complement operator ~ is added;  ~<it>R</it> denotes the set of all strings over Σ* that are  not in <it>R</it>. The complement operator is redundant, as it can always be expressed by using the other operators (although the process for computing such a representation is complex, and the result may be exponentially larger).</p>
<p>

Regular expressions in this sense can express the <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>s, exactly the class of languages accepted by <link xlink:type="simple" xlink:href="../931/10931.xml">
finite state automata</link>. There is, however, a significant difference in compactness. Some classes of regular languages can only be described by automata that grow <link xlink:type="simple" xlink:href="../933/191933.xml">
exponentially</link> in size, while the length of the required regular expressions only grow linearly. Regular expressions correspond to the type-3 <link xlink:type="simple" xlink:href="../716/18020716.xml">
grammars</link> of the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky hierarchy</link></language>
. On the other hand, there is a simple mapping from regular expressions to <link xlink:type="simple" xlink:href="../406/653406.xml">
nondeterministic finite automata</link> (NFAs) that does not lead to such a blowup in size; for this reason NFAs are often used as alternative representations of regular expressions.</p>
<p>

We can also study expressive power within the formalism. As the examples show, different regular expressions can express the same language: the formalism is redundant.</p>
<p>

It is possible to write an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> which for two given regular expressions decides whether the described languages are essentially equal, reduces each expression to a minimal deterministic finite state machine, and determines whether they are <link xlink:type="simple" xlink:href="../828/14828.xml">
isomorphic</link> (equivalent).</p>
<p>

To what extent can this redundancy be eliminated? Can we find an interesting subset of regular expressions that is still fully expressive? Kleene star and set union are obviously required, but perhaps we can restrict their use. This turns out to be a surprisingly difficult problem. As simple as the regular expressions are, it turns out there is no method to systematically rewrite them to some normal form. The lack of axiomatization in the past led to the <link xlink:type="simple" xlink:href="../647/27647.xml">
star height problem</link>. Recently, Cornell University professor Dexter Kozen axiomatized regular expressions with <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../430/155430.xml">
Kleene algebra</link></language>
.</p>
<p>

It is worth noting that many real-world "regular expression" engines implement features that cannot be expressed in the regular expression algebra; see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Patterns+for+non-regular+languages%22])">
below</link> for more on this.</p>

</sec>
<sec>
<st>
Syntax</st>



<ss1>
<st>
POSIX</st>

<ss2>
<st>
POSIX Basic Regular Expressions</st>

<p>

Traditional <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 regular expression syntax followed common conventions but often differed from tool to tool. The <link xlink:type="simple" xlink:href="../938/56938.xml">
IEEE</link> <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../305/23305.xml">
POSIX</link></system_of_measurement>
</standard>
 Basic Regular Expressions (BRE) standard (released alongside an alternative flavor called Extended Regular Expressions or ERE) was designed mostly for backward compatibility with the traditional (Simple Regular Expression) syntax but provided a common standard which has since been adopted as the default syntax of many Unix regular expression tools, though there is often some variation or additional features. Many such tools also provide support for ERE syntax with <link xlink:type="simple" xlink:href="../991/780991.xml">
command line argument</link>s.</p>
<p>

In the BRE syntax, most characters are treated as <link xlink:type="simple" xlink:href="../778/428778.xml">
literal</link>s&nbsp;— they match only themselves (i.e., a matches "<it>a</it>"). The exceptions, listed below, are called <link xlink:type="simple" xlink:href="../959/81959.xml">
metacharacter</link>s or metasequences.</p>
<p>

<table>
<row valign="top">
<col>
.</col>
<col>
Matches any single character (many applications exclude newlines, and exactly which characters are considered newlines is flavor, character encoding, and platform specific, but it is safe to assume that the line feed character is included). Within POSIX bracket expressions, the dot character matches a literal dot. For example, a.c matches "<it>abc</it>", etc., but [a.c]matches only "<it>a</it>", "<it>.</it>", or "<it>c</it>".</col>
</row>
<row valign="top">
<col>
[&nbsp;]</col>
<col>
A bracket expression. Matches a single character that is contained within the brackets. For example, [abc] matches "<it>a</it>", "<it>b</it>", or "<it>c</it>". [a-z] specifies a range which matches any lowercase letter from "<it>a</it>" to "<it>z</it>". These forms can be mixed: [abcx-z] matches "<it>a</it>", "<it>b</it>", "<it>c</it>", "<it>x</it>", "<it>y</it>", and "<it>z</it>", as does [a-cx-z].
The - character is treated as a literal character if it is the last or the first character within the brackets, or if it is escaped with a backslash: [abc-], [-abc], or [a\-bc].</col>
</row>
<row valign="top">
<col>
[^&nbsp;]</col>
<col>
Matches a single character that is not contained within the brackets. For example, [^abc] matches any character other than "<it>a</it>", "<it>b</it>", or "<it>c</it>". [^a-z]matches any single character that is not a lowercase letter from "<it>a</it>" to "<it>z</it>". As above, literal characters and ranges can be mixed.</col>
</row>
<row valign="top">
<col>
^</col>
<col>
Matches the starting position within the string. In line-based tools, it matches the starting position of any line.</col>
</row>
<row valign="top">
<col>
$</col>
<col>
Matches the ending position of the string or the position just before a string-ending newline. In line-based tools, it matches the ending position of any line.</col>
</row>
<row valign="top">
<col>
\(&nbsp;\)</col>
<col>
Defines a marked subexpression. The string matched within the parentheses can be recalled later (see the next entry, \<it>n</it>).  A marked subexpression is also called a block or capturing group.</col>
</row>
<row valign="top">
<col>
\<it>n''</it></col>
<col>
Matches what the <it>n</it>th marked subexpression matched, where <it>n</it> is a digit from 1 to 9. This construct is theoretically <b>irregular</b> and was not adopted in the POSIX ERE syntax. Some tools allow referencing more than nine capturing groups.</col>
</row>
<row valign="top">
<col>
*</col>
<col>
Matches the preceding element zero or more times. For example, ab*c matches "<it>ac</it>", "<it>abc</it>", "<it>abbbc</it>", etc. [xyz]* matches "", "<it>x</it>", "<it>y</it>", "<it>z</it>", "<it>zx</it>", "<it>zyx</it>", "<it>xyzzy</it>", and so on. \(ab\)* matches "", "<it>ab</it>", "<it>abab</it>", "<it>ababab</it>", and so on.</col>
</row>
<row valign="top">
<col>
\{<it>m</it>,<it>n</it>\}</col>
<col>
Matches the preceding element at least <it>m</it> and not more than <it>n</it> times. For example, a\{3,5\} matches only "<it>aaa</it>", "<it>aaaa</it>", and "<it>aaaaa</it>". This is not found in a few, older instances of regular expressions.</col>
</row>
</table>
</p>
<p>

<b>Examples:</b>
<list>
<entry level="1" type="bullet">

.at matches any three-character string ending with "at", including "<it>hat</it>", "<it>cat</it>", and "<it>bat</it>".</entry>
<entry level="1" type="bullet">

[hc]at matches "<it>hat</it>" and "<it>cat</it>".</entry>
<entry level="1" type="bullet">

[^b]at matches all strings matched by .at except "<it>bat</it>".</entry>
<entry level="1" type="bullet">

^[hc]at matches "<it>hat</it>" and "<it>cat</it>", but only at the beginning of the string or line.</entry>
<entry level="1" type="bullet">

[hc]at$ matches "<it>hat</it>" and "<it>cat</it>", but only at the end of the string or line.</entry>
</list>
</p>

</ss2>
<ss2>
<st>
POSIX Extended Regular Expressions</st>
<p>

The meaning of metacharacters <link xlink:type="simple" xlink:href="../114/60114.xml">
escaped</link> with a backslash is reversed for some characters in the POSIX Extended Regular Expression (ERE) syntax. With this syntax, a backslash causes the metacharacter to be treated as a literal character. Additionally, support is removed for \n backreferences  and the following metacharacters are added:</p>
<p>

<table>
<row>
<col>
?</col>
<col>
Matches the preceding element zero or one time. For example, ba? matches "<it>b</it>" or "<it>ba</it>".</col>
</row>

<row>
<col>
Matches the preceding element one or more times. For example, ba+ matches "<it>ba</it>", "<it>baa</it>", "<it>baaa</it>", and so on.</col>
</row>
<row>
<col>
|</col>
<col>
The choice (aka alternation or set union) operator matches either the expression before or the expression after the operator. For example, abc|def matches "<it>abc</it>" or "<it>def</it>".</col>
</row>
</table>
</p>
<p>

<b>Examples:</b>
<list>
<entry level="1" type="bullet">

[hc]+at matches "<it>hat</it>", "<it>cat</it>", "<it>hhat</it>", "<it>chat</it>", "<it>hcat</it>", "<it>ccchat</it>", and so on, but not "<it>at</it>".</entry>
<entry level="1" type="bullet">

[hc]?at matches "<it>hat</it>", "<it>cat</it>", and "<it>at</it>".</entry>
<entry level="1" type="bullet">

cat|dog matches "<it>cat</it>" or "<it>dog</it>".</entry>
</list>
</p>
<p>

POSIX Extended Regular Expressions can often be used with modern Unix utilities by including the <link xlink:type="simple" xlink:href="../707/6707.xml">
command line</link> flag -E.</p>

</ss2>
<ss2>
<st>
POSIX character classes</st>
<p>

Since many ranges of characters depend on the chosen locale setting (i.e., in some settings letters are organized as <it>abc...zABC...Z</it>, while in some others as <it>aAbBcC...zZ</it>), the POSIX standard defines some classes or categories of characters as shown in the following table:</p>
<p>

<table class="wikitable">
<row>
<header>
POSIX</header>
<header>
Perl</header>
<header>
ASCII</header>
<header>
Description</header>
</row>
<row>
<col>
 [:alnum:]</col>

<col>
 [A-Za-z0-9]</col>
<col>
Alphanumeric characters</col>
</row>
<row>
<col>
 [:word:]</col>
<col>
\w</col>
<col>
 [A-Za-z0-9_]</col>
<col>
Alphanumeric characters plus "_"</col>
</row>
<row>

<col>
\W</col>
<col>
 [^\w]</col>
<col>
non-word character</col>
</row>
<row>
<col>
 [:alpha:]</col>

<col>
 [A-Za-z]</col>
<col>
Alphabetic characters</col>
</row>
<row>
<col>
 [:blank:]</col>

<col>
 [ \t]</col>
<col>
Space and tab</col>
</row>
<row>
<col>
 [:cntrl:]</col>

<col>
 [\x00-\x1F\x7F]</col>
<col>
Control characters</col>
</row>
<row>
<col>
 [:digit:]</col>
<col>
\d</col>
<col>
 [0-9]</col>
<col>
Digits</col>
</row>
<row>

<col>
\D</col>
<col>
 [^\d]</col>
<col>
non-digit</col>
</row>
<row>
<col>
 [:graph:]</col>

<col>
 [\x21-\x7E]</col>
<col>
Visible characters</col>
</row>
<row>
<col>
 [:lower:]</col>

<col>
 [a-z]</col>
<col>
Lowercase letters</col>
</row>
<row>
<col>
 [:print:]</col>

<col>
 [\x20-\x7E]</col>
<col>
Visible characters and spaces</col>
</row>
<row>
<col>
 [:punct:]</col>

<col>
[-!"#$%&amp;'()*+,./:;&amp;lt;=&amp;gt;?@[\\\]_`{|}~]</col>
<col>
Punctuation characters</col>
</row>
<row>
<col>
 [:space:]</col>
<col>
\s</col>
<col>
 [ \t\r\n\v\f]</col>
<col>
Whitespace characters</col>
</row>
<row>

<col>
\S</col>
<col>
 [^\s]</col>
<col>
non-whitespace character</col>
</row>
<row>
<col>
 [:upper:]</col>

<col>
 [A-Z]</col>
<col>
Uppercase letters</col>
</row>
<row>
<col>
 [:xdigit:]</col>

<col>
 [A-Fa-f0-9]</col>
<col>
Hexadecimal digits</col>
</row>
</table>
</p>
<p>

POSIX character classes can only be used within bracket expressions. For example, [[:upper:]ab] matches the uppercase letters and lowercase "<it>a</it>" and "<it>b</it>".</p>
<p>

In Perl regular expressions, [:print:] matches [:graph:] union [:space:]. An additional non-POSIX class understood by some tools is [:word:], which is usually defined as [:alnum:] plus underscore. This reflects the fact that in many programming languages these are the characters that may be used in identifiers. The editor <skilled_worker wordnetid="110605985" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../478/32478.xml">
Vim</link></causal_agent>
</worker>
</editor>
</person>
</physical_entity>
</skilled_worker>
 further distinguishes <it>word</it> and <it>word-head</it> classes (using the notation \w and \h) since in many programming languages the characters that can begin an identifier are not the same as those that can occur in other positions.</p>
<p>

Note that what the POSIX regular expression standards call <it>character classes</it> are commonly referred to as <it>POSIX character classes</it> in other regular expression flavors which support them. With most other regular expression flavors, the term <it>character class</it> is used to describe what POSIX calls <it>bracket expressions</it>.</p>

</ss2>
</ss1>
<ss1>
<st>
Perl-derivative regular expressions</st>
<p>

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 has a more consistent and richer syntax than the POSIX basic (BRE) and extended (ERE) regular expression standards. An example of its consistency is that \ always escapes a non-alphanumeric character. Another example of functionality possible with Perl but not POSIX-compliant regular expressions is the concept of lazy quantification (see the next section).</p>
<p>

Due largely to its expressive power, many other utilities and programming languages have adopted syntax similar to Perl's&nbsp;— for example, <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/9845.xml">
JavaScript</link></programming_language>
, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../290/1712290.xml">
PCRE</link></software>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
, <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
, <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../001/19001.xml">
Microsoft</link></company>
's <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/60402.xml">
.NET Framework</link></implement>
</horizontal_surface>
</tool>
</instrumentality>
</surface>
</artifact>
</platform>
, and the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../149/33149.xml">
W3C's</link></company>
 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../449/185449.xml">
XML Schema</link></format>
 all use regular expression syntax similar to Perl's. Some languages and tools such as <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/24131.xml">
PHP</link></writer>
</language>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
 support multiple regular expression flavors. Perl-derivative regular expression implementations are not identical, and many implement only a subset of Perl's features. With Perl 5.10, this process has come full circle with Perl incorporating syntax extensions originally from Python, PCRE, the .NET Framework, and Java.</p>

</ss1>
<ss1>
<st>
Simple Regular Expressions</st>

<p>

<b>Simple Regular Expressions</b> is a syntax that may be used by historical versions of application programs, and may be supported within some applications for the purpose of providing backward compatibility, These forms of regular expression syntax are considered to be deprecated<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> and should not be used.</p>

</ss1>
<ss1>
<st>
Lazy quantification</st>

<p>

The standard quantifiers in regular expressions are greedy, meaning they match as much as they can, only giving back as necessary to match the remainder of the regex. For example, someone new to regexes wishing to find the first instance of an item between  and &amp;gt; symbols in this example:</p>
<p>

Another whale explosion occurred on &amp;lt;January 26&amp;gt;, &amp;lt;2004&amp;gt;.</p>
<p>

...would likely come up with the pattern .*&amp;gt;, or similar. However, this pattern will actually return "<it>&amp;lt;January 26&amp;gt;, &amp;lt;2004&amp;gt;</it>" instead of the "<it>&amp;lt;January 26&amp;gt;</it>" which might be expected, because the * quantifier is greedy&nbsp;— it will consume as many characters as possible from the input, and "<it>January 26&amp;gt;, &amp;lt;2004</it>" has more characters than "<it>January 26</it>".</p>
<p>

Though this problem can be avoided in a number of ways (e.g., by specifying the text that is <it>not</it> to be matched: &amp;lt;[^&amp;gt;]*&amp;gt;), modern regular expression tools allow a quantifier to be specified as <it>lazy</it> (also known as <it>non-greedy</it>, <it>reluctant</it>, <it>minimal</it>, or <it>ungreedy</it>) by putting a question mark after the quantifier (e.g., .*?&amp;gt;), or by using a modifier which reverses the greediness of quantifiers (though changing the meaning of the standard quantifiers can be confusing). By using a lazy quantifier, the expression tries the minimal match first. Though in the previous example lazy matching is used to select one of many matching results, in some cases it can also be used to improve performance when greedy matching would require more <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link>.</p>

</ss1>
</sec>
<sec>
<st>
Patterns for non-regular languages</st>
<p>

Many features found in modern regular expression libraries provide an expressive power that far exceeds the <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>s. For example, the ability to group subexpressions with parentheses and recall the value they match in the same expression means that a pattern can match strings of repeated words like "<it>papa</it>" or "<it>WikiWiki</it>", called <it>squares</it> in formal language theory. The pattern for these strings is (.*)\1. However, the language of squares is not regular, nor is it <link xlink:type="simple" xlink:href="../867/6867.xml">
context-free</link>. <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../688/279688.xml">
Pattern matching</link></concept>
</idea>
 with an unbounded number of back references, as supported by numerous modern tools, is <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
.</p>
<p>

However, many tools, libraries, and engines that provide such constructions still use the term <it>regular expression</it> for their patterns. This has led to a nomenclature where the term regular expression has different meanings in <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language theory</link> and pattern matching. For this reason, some people have taken to using the term <it>regex</it> or simply <it>pattern</it> to describe the latter. <person wordnetid="100007846" confidence="0.9508927676800064">
<programmer wordnetid="110481268" confidence="0.9173553029164789">
<writer wordnetid="110794014" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../519/17519.xml">
Larry Wall</link></writer>
</programmer>
</person>
 (author of Perl) writes in Apocalypse 5:</p>

<p>

<table style="margin:auto; border-collapse:collapse; border-style:none; background-color:transparent; " class="cquote">
<row>
<col style="color:#B2B7F2;font-size:35px;font-family:'Times New Roman',serif;font-weight:bold;text-align:left;padding:10px 10px;" width="20" valign="top">
“</col>
<col style="padding:4px 10px;" valign="top">
 'Regular expressions' [...]are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I'm not going to try to fight linguistic necessity here. I will, however, generally call them "regexes" (or "regexen", when I'm in an Anglo-Saxon mood).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></col>
<col style="color:#B2B7F2;font-size:36px;font-family:'Times New Roman',serif;font-weight:bold;text-align:right;padding:10px 10px;" width="20" valign="bottom">
”</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
Implementations and running times</st>
<p>

There are at least three essentially different <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s that decide if and how a given regular expression matches a string.</p>
<p>

The oldest and fastest two rely on a result in formal language theory that allows every <link xlink:type="simple" xlink:href="../406/653406.xml">
nondeterministic finite state machine</link> (NFA) to be transformed into a <link xlink:type="simple" xlink:href="../404/653404.xml">
deterministic finite state machine</link> (DFA). The DFA can be constructed explicitly and then run on the resulting input string one symbol at a time. Constructing the DFA for a regular expression of size <it>m</it> has the time and memory cost of <link xlink:type="simple" xlink:href="../578/44578.xml">
<it>O''</it></link>(<it>2m</it>), but it can be run on a string of size <it>n</it> in time <it>O</it>(<it>n</it>). An alternative approach is to simulate the NFA directly, essentially building each DFA state on demand and then discarding it at the next step, possibly with caching. This keeps the DFA implicit and avoids the exponential construction cost, but running cost rises to <it>O</it>(<it>nm</it>). The explicit approach is called the DFA algorithm and the implicit approach the NFA algorithm. As both can be seen as different ways of executing the same DFA, they are also often called the DFA algorithm without making a distinction. These algorithms are fast, but can only be used for matching and not for recalling grouped subexpressions, lazy quantification, and several other features commonly found in modern regular expression libraries.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>
<p>

The third algorithm is to match the pattern against the input string by <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link>. This algorithm is commonly called NFA, but this terminology can be confusing. Its running time can be exponential, which simple implementations exhibit when matching against expressions like (a|aa)*b that contain both alternation and unbounded quantification and force the algorithm to consider an exponentially increasing number of sub-cases. More complex implementations will often identify and speed up or abort common cases where they would otherwise run slowly.</p>
<p>

Although backtracking implementations give an exponential guarantee in the worst case, they provide much greater flexibility and expressive power. For example, any implementation which allows the use of backreferences, or implements the various extensions introduced by Perl, must use a backtracking implementation.</p>
<p>

Some implementations try to provide the best of both algorithms by first running a fast DFA match to see if the string matches the regular expression at all, and only in that case perform a potentially slower backtracking match.</p>

</sec>
<sec>
<st>
Regular expressions and Unicode</st>
<p>

Regular expressions were originally used with <link xlink:type="simple" xlink:href="../586/586.xml">
ASCII</link> characters. Many regular expression engines can now handle <link xlink:type="simple" xlink:href="../742/31742.xml">
Unicode</link>. In most respects it makes no difference what the character set is, but some issues do arise when extending regular expressions to support Unicode.</p>
<p>

<list>
<entry level="1" type="bullet">

 Supported encoding. Some regular expression libraries expect the <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../188/32188.xml">
UTF-8</link></database>
</wordnet>
</format>
</lexical_database>
</electronic_database>
</information>
</message>
 encoding, while others might expect <link xlink:type="simple" xlink:href="../317/40317.xml">
UTF-16</link>, or <link xlink:type="simple" xlink:href="../928/183928.xml">
UTF-32</link>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Supported Unicode range. Many regular expression engines support only the <link xlink:type="simple" xlink:href="../649/1005649.xml#xpointer(//*[./st=%22Basic+Multilingual+Plane%22])">
Basic Multilingual Plane</link>, that is, the characters which can be encoded with only 16 bits. Currently, only a few regular expression engines can handle the full 21-bit Unicode range.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Extending ASCII-oriented constructs to Unicode. For example, in ASCII-based implementations, character ranges of the form [x-y] are valid wherever <it>x</it> and <it>y</it> are codepoints in the range [0x00,0x7F] and codepoint(x) ≤ codepoint(y). The natural extension of such character ranges to Unicode would simply change the requirement that the endpoints lie in [0x00,0x7F] to the requirement that they lie in [0,0x10FFFF]. However, in practice this is often not the case. Some implementations, such as that of <link xlink:type="simple" xlink:href="../456/1456.xml">
gawk</link>, do not allow character ranges to cross Unicode blocks. A range like [0x61,0x7F] is valid since both endpoints fall within the Basic Latin block, as is [0x0530,0x0560] since both endpoints fall within the Armenian block, but a range like [0x0061,0x0532] is invalid since it includes multiple Unicode blocks. Other engines, such as that of the <skilled_worker wordnetid="110605985" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../478/32478.xml">
Vim</link></causal_agent>
</worker>
</editor>
</person>
</physical_entity>
</skilled_worker>
 editor, allow block-crossing but limit the number of characters in a range to 128.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Case insensitivity. Some case-insensitivity flags affect only the ASCII characters. Other flags affect all characters. Some engines have two different flags, one for ASCII, the other for Unicode. Exactly which characters belong to the POSIX classes also varies.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Cousins of case insensitivity. As the English alphabet has case distinction, case insensitivity became a logical feature in text searching. Unicode introduced alphabetic scripts without case like Devanagari. For these, case sensitivity is not applicable. For scripts like Chinese, another distinction seems logical: between traditional and simplified. In Arabic scripts, insensitivity to initial, medial, final and isolated position may be desired.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Normalization. Unicode introduced combining characters. Like old typewriters, plain letters can be followed by non-spacing accent symbols to form a single accented letter. As a consequence, two different code sequences can result in identical character display.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 New control codes. Unicode introduced amongst others, byte order marks and text direction markers. These codes might have to be dealt with in a special way.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Introduction of character classes for Unicode blocks and Unicode general character properties. In <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 and the <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/regex/package-summary.html">
java.util.regex</weblink> library, classes of the form \p{InX} match characters in block <it>X</it> and \P{InX} match the opposite. Similarly, \p{Armenian} matches any character in the Armenian block, and \p{X} matches any character with the general character property <it>X</it>. For example, \p{Lu} matches any upper-case letter.</entry>
</list>
</p>

</sec>
<sec>
<st>
Uses of regular expressions</st>
<p>

Regular expressions are useful in the production of <link xlink:type="simple" xlink:href="../079/265079.xml">
syntax highlighting</link> systems, data validation, and many other tasks.</p>
<p>

While regular expressions would be useful on <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../804/27804.xml">
search engine</link></machine>
</device>
</motor>
</engine>
</instrumentality>
</artifact>
s such as <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../923/1092923.xml">
Google</link></company>
 or <web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../491/4325491.xml">
Live Search</link></web_site>
, processing them across the entire database could consume excessive computer resources depending on the complexity and design of the regex. Although in many cases system administrators can run regex-based queries internally, most search engines do not offer regex support to the public. A notable exception is <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../470/7301470.xml">
Google Code Search</link></software>
.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../422/10930422.xml">
Comparison of regular expression engines</link></entry>
<entry level="1" type="bullet">

<link>
Extended Backus–Naur form</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../631/14885631.xml">
List of regular expression software</link></entry>
<entry level="1" type="bullet">

<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../898/1631898.xml">
Regular expression examples</link></subject>
</message>
</entry>
<entry level="1" type="bullet">

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../522/5078522.xml">
Regular tree grammar</link></language>
</entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>

<p>

<reflist>
<entry id="1">
<person wordnetid="100007846" confidence="0.9508927676800064">
<programmer wordnetid="110481268" confidence="0.9173553029164789">
<writer wordnetid="110794014" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../519/17519.xml">
Wall, Larry</link></writer>
</programmer>
</person>
 and the Perl 5 development team&#32;(2006).&#32;"<weblink xlink:type="simple" xlink:href="http://perldoc.perl.org/perlre.html">
perlre: Perl regular expressions</weblink>".</entry>
<entry id="2">
<person wordnetid="100007846" confidence="0.9508927676800064">
<programmer wordnetid="110481268" confidence="0.9173553029164789">
<writer wordnetid="110794014" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../519/17519.xml">
Wall, Larry</link></writer>
</programmer>
</person>
&#32;(2002-06-04).&#32;"<weblink xlink:type="simple" xlink:href="http://dev.perl.org/perl6/doc/design/apo/A05.html">
Apocalypse 5: Pattern Matching</weblink>".</entry>
<entry id="3">
The Single Unix Specification (Version 2)</entry>
<entry id="4">
Cox, Russ&#32;(2007).&#32;"<weblink xlink:type="simple" xlink:href="http://swtch.com/~rsc/regexp/regexp1.html">
Regular Expression Matching Can Be Simple and Fast</weblink>".</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREF1997" style="font-style:normal"><weblink xlink:type="simple" xlink:href="http://www.opengroup.org/onlinepubs/007908799/xbd/re.html">
"Regular Expressions"</weblink>,&#32;<it>The Single UNIX ® Specification, Version 2</it>, The Open Group, 1997, </cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../192/6227192.xml">
Forta, Ben</link></writer>
</causal_agent>
</person>
</communicator>
</physical_entity>
. Sams Teach Yourself Regular Expressions in 10 Minutes.&#32;Sams. ISBN 0-672-32566-7.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../969/1801969.xml">
Friedl, Jeffrey</link></person>
. <weblink xlink:type="simple" xlink:href="http://regex.info/">
Mastering Regular Expressions</weblink>.&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../827/216827.xml">
O'Reilly</link></company>
. ISBN 0-596-00289-0.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><link>
Habibi, Mehran</link>. Real World Regular Expressions with Java 1.4.&#32;Springer. ISBN 1-59059-107-0.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><link>
Liger, Francois</link>;&#32;<link>
Craig McQueen</link>, <link>
Paul Wilton</link>. Visual Basic .NET Text Manipulation Handbook.&#32;<link xlink:type="simple" xlink:href="../853/1898853.xml">
Wrox Press</link>. ISBN 1-86100-730-2.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Sipser, Michael</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
.&#32;"Chapter 1: Regular Languages", Introduction to the Theory of Computation.&#32;PWS Publishing,&#32;31–90. ISBN 0-534-94728-X.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><link>
Stubblebine, Tony</link>. Regular Expression Pocket Reference.&#32;O'Reilly. ISBN 0-596-00415-X.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>




<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:RegExp">
JavaScript RegExp Object Reference</weblink> at the <link xlink:type="simple" xlink:href="../963/5235963.xml">
Mozilla Developer Center</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://java.sun.com/docs/books/tutorial/essential/regex/index.html">
Java Tutorials: Regular Expressions</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://perldoc.perl.org/perlre.html">
Perl Regular Expressions documentation</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/ms974570.aspx">
VBScript and Regular Expressions</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/en-us/library/hs600312.aspx">
.NET Framework Regular Expressions</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.dmoz.org/Computers/Programming/Languages/Regular_Expressions/">
Regular Expressions</weblink> at the <work wordnetid="100575741" confidence="0.8">
<possession wordnetid="100032613" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<company wordnetid="108058098" confidence="0.8">
<undertaking wordnetid="100795720" confidence="0.8">
<property wordnetid="113244109" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<subsidiary_company wordnetid="108003935" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../501/18949501.xml">
Open Directory Project</link></institution>
</subsidiary_company>
</activity>
</psychological_feature>
</act>
</property>
</undertaking>
</company>
</event>
</possession>
</work>
</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.regular-expressions.info/">
Regular-Expressions.info</weblink>&nbsp;— tutorial and reference which covers many popular regex flavors</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://billposer.org/Linguistics/Computation/Resources.html#patterns">
Pattern matching tools and libraries</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.seeingwithc.org/topic7html.html">
Regular Expressions writeup explaining math. and computer notations.</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://regexlib.com/">
Regular Expressions Library</weblink></entry>
</list>
</p>


</sec>
</bdy>
</language>
</subject>
</message>
</article>
