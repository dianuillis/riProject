<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:33:42[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Radiosity</title>
<id>25974</id>
<revision>
<id>240782660</id>
<timestamp>2008-09-24T23:44:57Z</timestamp>
<contributor>
<username>Dhatfield</username>
<id>4371729</id>
</contributor>
</revision>
<categories>
<category>3D computer graphics</category>
</categories>
</header>
<bdy>

This article is about the rendering algorithm.&#32;&#32;For the thermodynamic quantity, see <link xlink:type="simple" xlink:href="../182/11709182.xml">
Radiosity (heat transfer)</link>.&#32;&#32;
<b>Radiosity</b> is a <link xlink:type="simple" xlink:href="../629/12629.xml">
global illumination</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> used in <process wordnetid="100029677" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<phenomenon wordnetid="100034213" confidence="0.8">
<consequence wordnetid="111410625" confidence="0.8">
<link xlink:type="simple" xlink:href="../073/10175073.xml">
3D computer graphics</link></consequence>
</phenomenon>
</physical_entity>
</process>
 <link xlink:type="simple" xlink:href="../604/6604.xml">
rendering</link>.  Radiosity is an application of the <link xlink:type="simple" xlink:href="../581/18233581.xml">
finite element method</link> to solving the <link xlink:type="simple" xlink:href="../669/1502669.xml">
rendering equation</link> for scenes with purely diffuse surfaces.  Unlike <technique wordnetid="105665146" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../098/56098.xml">
Monte Carlo algorithms</link></method>
</know-how>
</technique>
 (such as <link xlink:type="simple" xlink:href="../223/2057223.xml">
path tracing</link>) which handle all types of light paths, typical radiosity methods only account for paths of the form LD*E, i.e., paths which leave a light source and are reflected diffusely some number of times (possibly zero) before hitting the eye.  Radiosity calculations are viewpoint independent which increases the computations involved, but makes them useful for all viewpoints.<p>

Radiosity methods were first developed in about 1950 in the engineering field of <link xlink:type="simple" xlink:href="../726/184726.xml">
heat transfer</link>. They were later refined specifically for application to the problem of rendering computer graphics in 1984 by researchers at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../422/7954422.xml">
Cornell University</link></university>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.</p>
<p>

Notable commercial radiosity engines are Lightscape (now incorporated into the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../584/180584.xml">
Autodesk</link></company>
 <link xlink:type="simple" xlink:href="../216/313216.xml">
3D Studio Max</link> internal render engine),  Radiozity by <link>
Auto*Des*Sys</link>, and <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../932/191932.xml">
ElAS</link></software>
 (Electric Image Animation System). </p>

<sec>
<st>
Visual characteristics</st>
<p>

<image location="right" width="225px" src="Radiosity_Comparison.jpg" type="thumb">
<caption>

Difference between standard direct illumination and radiosity
</caption>
</image>

The inclusion of radiosity calculations in the rendering process often lends an added element of realism to the finished scene, because of the way it mimics real-world phenomena. Consider a simple room scene.</p>
<p>

The image on the left was rendered with a typical direct illumination renderer. There are three types of lighting in this scene, chosen and placed by the artist in an attempt to create realistic lighting: Spot Lighting with Shadows (to create the light shining on the floor), Ambient Lighting (without which the rest of the room would be totally dark), and Omnidirectional lighting without shadows (to reduce the flatness of the ambient lighting). </p>
<p>

The image on the right was rendered using a radiosity algorithm. There is only one source of light, an image of the sky placed outside the window. The difference is marked. The room glows with light. Soft shadows are visible on the floor, and subtle lighting effects are noticeable around the room. Furthermore, the red color from the carpet has bled onto the grey walls, giving them a slightly warm appearance. None of these effects were specifically chosen or designed by the artist.</p>

</sec>
<sec>
<st>
 Overview of the radiosity algorithm </st>

<p>

The surfaces of the scene to be rendered are each divided up into one or more smaller surfaces (patches).
A <link xlink:type="simple" xlink:href="../779/14861779.xml">
view factor</link> is computed for each pair of patches.  View factors (also known as <it>form factors</it>) are coefficients describing how well the patches
can see each other.  Patches that are far away from each other, or oriented at oblique angles relative to one another,
will have smaller view factors.  If other patches are in the way, the view factor will be reduced or zero, depending
on whether the occlusion is partial or total.</p>
<p>

The view factors are used as coefficients in a linearized form of the rendering equation, which yields
a linear system of equations.  Solving this system yields the radiosity, or brightness, of each patch,
taking into account diffuse interreflections and soft shadows.</p>
<p>

Progressive radiosity solves the system iteratively in such a way that after each iteration we have intermediate
radiosity values for the patch.  These intermediate values correspond to bounce levels.  That is, after one iteration,
we know how the scene looks after one light bounce, after two passes, two bounces, and so forth.  Progressive radiosity
is useful for getting an interactive preview of the scene.  Also, the user can stop the iterations once the image looks good
enough, rather than wait for the computation to numerically converge.</p>
<p>

<image location="center" width="680px" src="Radiosity_Progress.png" type="thumb">
<caption>

As the algorithm iterates, light can be seen to flow into the scene, as multiple bounces are computed. Individual patches are visible as squares on the walls and floor.
</caption>
</image>
</p>
<p>

Another common method for solving the radiosity equation is "shooting radiosity," which iteratively solves the radiosity equation by "shooting" light from the patch with the most error at each step.  After the first pass, only those patches which are in direct line of sight of a light-emitting patch will be illuminated. After the second pass, more patches will become illuminated as the light begins to bounce around the scene.  The scene continues to grow brighter and eventually reaches a steady state.</p>

</sec>
<sec>
<st>
Mathematical formulation</st>
<p>

The basic radiosity method has its basis in the theory of <link xlink:type="simple" xlink:href="../167/19593167.xml">
thermal radiation</link>, since radiosity relies on computing the amount of light energy transferred among surfaces.  In order to simplify computations, the method assumes that all scattering is <link xlink:type="simple" xlink:href="../306/41306.xml">
perfectly diffuse</link>.  Surfaces are typically discretized into quadrilateral or triangular <link xlink:type="simple" xlink:href="../581/18233581.xml">
elements</link> over which a piecewise polynomial function is defined.</p>
<p>

After this breakdown, the amount of light energy transfer can be computed by using the known reflectivity of the reflecting patch, combined with the <link xlink:type="simple" xlink:href="../779/14861779.xml">
view factor</link> of the two patches. This <link xlink:type="simple" xlink:href="../331/51331.xml">
dimensionless quantity</link> is computed from the geometric orientation of two patches, and can be thought of as the fraction of the total possible emitting area of the first patch which is covered by the second patch.</p>
<p>

More correctly, radiosity is the energy leaving the patch surface per discrete time interval and is the combination of emitted and reflected energy:</p>
<p>

<indent level="1">

<math>B_i\, d A_i = E_i\, d A_i + R_i \int_j B_j F_{ji}\, d A_j,\,\!</math>
</indent>

where:
<list>
<entry level="1" type="bullet">

 <it>Bi</it> is the <link xlink:type="simple" xlink:href="../182/11709182.xml">
radiosity</link> of patch <it>i</it>.</entry>
<entry level="1" type="bullet">

 <it>Ei</it> is emitted energy.</entry>
<entry level="1" type="bullet">

 <it>Ri</it> is the reflectivity of the patch, giving reflected energy by multiplying by the incident energy (the energy which arrives from other patches).</entry>
<entry level="1" type="bullet">

 All <it>j</it> (<math>j \ne i</math>) in the rendered environment are integrated for <it>BjFji</it>&nbsp;<it>dAj</it>, to determine the energy leaving each patch <it>j</it> that arrives at patch <it>i</it>.</entry>
<entry level="1" type="bullet">

 <it>Fij</it> is the constant-valued <link xlink:type="simple" xlink:href="../779/14861779.xml">
view factor</link> for the radiation leaving <it>i</it> and hitting patch <it>j</it>.</entry>
</list>
</p>
<p>

The reciprocity:</p>
<p>

<indent level="1">

<math>A_i F_{ij} = A_j F_{ji} \,\!</math>
</indent>

gives:</p>
<p>

<indent level="1">

<math>B_i = E_i + R_i \int_j B_j F_{ij}\,\!</math>
</indent>

For ease of use the <link xlink:type="simple" xlink:href="../532/15532.xml">
integral</link> is replaced and uniform radiosity is assumed over the patch, creating the simpler:</p>
<p>

<indent level="1">

<math>B_i = E_i + R_i \sum_{j=1}^n B_j F_{ij}</math>
</indent>

This equation can then be applied to each patch. The equation is monochromatic, so color radiosity rendering requires calculation for each of the required colors.</p>
<p>

The <link xlink:type="simple" xlink:href="../779/14861779.xml">
view factor</link> Fji can be calculated in a number of ways. Early methods used a <it><link xlink:type="simple" xlink:href="../674/8819674.xml">
hemicube</link></it> (an imaginary cube centered upon the first surface to which the second surface was projected, devised by Cohen and Greenberg in 1985) to approximate the form factor, which also solved the intervening patch problem. This is quite <link xlink:type="simple" xlink:href="../926/5926.xml">
computation</link>ally expensive, because ideally <link xlink:type="simple" xlink:href="../630/3439630.xml">
form factor</link>s must be derived for every possible pair of patches, leading to a <link xlink:type="simple" xlink:href="../240/187240.xml">
quadratic</link> increase in computation with added geometry. New methods include adaptive integration<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

</sec>
<sec>
<st>
 Reducing computation time </st>
<p>

Although in its basic form, radiosity is assumed to have a quadratic increase in computation time with added geometry (surfaces and patches), this need not to be the case. The radiosity problem can be rephrased as a problem of rendering a <link xlink:type="simple" xlink:href="../903/146903.xml">
texture mapped</link> scene. In this case, the computation time increases only linearly with the number of patches (ignoring complex issues like <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link> use). Using a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../613/73613.xml">
binary space partitioning tree</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 can massively reduce the amount of time spent determining which patches are completely hidden from others in complex scenes.</p>
<p>

Since radiosity can be computed using standard texture mapping algorithms, it lends itself to acceleration using standard <link xlink:type="simple" xlink:href="../214/390214.xml">
graphics acceleration hardware</link>, available for a standard PC.</p>

</sec>
<sec>
<st>
 Advantages </st>
<p>

<image width="150px" src="Utah_teapot_simple_2.png" type="thumb">
<caption>

A modern render of the iconic <link xlink:type="simple" xlink:href="../964/236964.xml">
Utah teapot</link> model developed by <link xlink:type="simple" xlink:href="../309/581309.xml">
Martin Newell</link> (1975). <b>Radiosity</b> was used for all diffuse illumination in this scene.
</caption>
</image>

One of the advantages of the Radiosity algorithm is that it is relatively simple to explain and implement. This makes it a useful algorithm for teaching students about global illumination algorithms. A typical direct illumination renderer already contains nearly all of the algorithms (<link xlink:type="simple" xlink:href="../741/313741.xml">
perspective transform</link>ations, <link xlink:type="simple" xlink:href="../903/146903.xml">
texture mapping</link>, <link xlink:type="simple" xlink:href="../796/469796.xml">
hidden surface removal</link>) required to implement radiosity. A strong grasp of mathematics is not required to understand or implement this algorithm.</p>

</sec>
<sec>
<st>
 Limitations </st>
<p>

Typical radiosity methods only account for light paths of the form LD*E, i.e., paths which start at a light source and make multiple diffuse bounces before reaching the eye.  Although there are several approaches to integrating other illumination effects such as <organ wordnetid="105297523" confidence="0.8">
<sense_organ wordnetid="105299178" confidence="0.8">
<part wordnetid="109385911" confidence="0.8">
<eye wordnetid="105311054" confidence="0.8">
<body_part wordnetid="105220461" confidence="0.8">
<link xlink:type="simple" xlink:href="../297/679297.xml">
specular</link></body_part>
</eye>
</part>
</sense_organ>
</organ>
<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=37438&amp;coll=portal&amp;dl=ACM">
http://portal.acm.org/citation.cfm?id=37438&amp;coll=portal&amp;dl=ACM</weblink> and glossy<weblink xlink:type="simple" xlink:href="http://www.cs.huji.ac.il/labs/cglab/papers/clustering/">
http://www.cs.huji.ac.il/labs/cglab/papers/clustering/</weblink> reflections, radiosity-based methods are generally not used to solve the complete rendering equation.</p>
<p>

Basic radiosity also has trouble resolving sudden changes in visibility (e.g., hard-edged shadows) because coarse, regular discretization into piecewise constant elements corresponds to a <link xlink:type="simple" xlink:href="../484/56484.xml">
low-pass box filter</link> of the spatial domain.  Discontinuity meshing<weblink xlink:type="simple" xlink:href="http://www.cs.cmu.edu/~ph/discon.ps.gz">
http://www.cs.cmu.edu/~ph/discon.ps.gz</weblink> uses knowledge of visibility events to generate a more intelligent discretization.</p>

</sec>
<sec>
<st>
 Confusion about terminology </st>

<p>

Radiosity was perhaps the first rendering algorithm in widespread use which accounted for diffuse indirect lighting.  Earlier rendering algorithms, such as Whitted-style <link xlink:type="simple" xlink:href="../193/17884193.xml">
ray tracing</link> were capable of computing effects such as reflections, refractions, and shadows, but despite being highly global phenomena, these effects were not commonly referred to as "global illumination."  As a consequence, the term "global illumination" became confused with "diffuse interreflection," and "Radiosity" became confused with "global illumination" in popular parlance.  However, the three are distinct concepts.</p>
<p>

The radiosity method in the current computer graphics context derives from (and is fundamentally the same as) the radiosity method in <link xlink:type="simple" xlink:href="../726/184726.xml">
heat transfer</link>. In this context <link xlink:type="simple" xlink:href="../182/11709182.xml">
Radiosity (heat transfer)</link> is the total radiative flux (both reflected and re-radiated) leaving a surface, also sometimes known as <link xlink:type="simple" xlink:href="../970/556970.xml">
radiant exitance</link>. Calculation of Radiosity rather than surface temperatures is a key aspect of the radiosity method that permits linear matrix methods to be applied to the problem.</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
"<weblink xlink:type="simple" xlink:href="http://www.cs.rpi.edu/~cutler/classes/advancedgraphics/S07/lectures/goral.pdf">
Modeling the interaction of light between diffuse surfaces</weblink>", C. Goral, K. E. Torrance, D. P. Greenberg and B. Battaile, <it><link xlink:type="simple" xlink:href="../092/1781092.xml">
Computer Graphics</link></it>, Vol. 18, No. 3.</entry>
<entry id="2">
G Walton, <it>Calculation of Obstructed View Factors by Adaptive Integration</it>, <weblink xlink:type="simple" xlink:href="http://www.bfrl.nist.gov/IAQanalysis/docs/NISTIR-6925.pdf">
NIST Report NISTIR-6925</weblink></entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<table style="background:#f9f9f9; font-size:85%; line-height:110%; ">
<row>
<col>
 <image width="32x28px" src="5-cell.gif">
</image>
</col>
<col style="padding:0 0.2em;">
 <b><it>
Computer graphics&#32;portal</it></b></col>
</row>
</table>
</p>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.siggraph.org/education/materials/HyperGraph/radiosity/overview_1.htm">
Radiosity Overview, from HyperGraph of SIGGRAPH</weblink> (provides full matrix radiosity algorithm and progressive radiosity algorithm)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://freespace.virgin.net/hugo.elias/radiosity/radiosity.htm">
Radiosity, by Hugo Elias</weblink> (also provides a general overview of lighting algorithms, along with programming examples)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://web.cs.wpi.edu/~matt/courses/cs563/talks/radiosity.html">
Radiosity, by Allen Martin</weblink> (a slightly more mathematical explanation of radiosity)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cse.iitd.ernet.in/~parag/projects/CG2/asign2/report/RADical.shtml">
RADical, by Parag Chaudhuri</weblink> (an implementation of shooting &amp; sorting variant of progressive radiosity algorithm with OpenGL acceleration, extending from GLUTRAD by Colbeck)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.tralvex.com/pub/rover/abs-mnu.htm">
ROVER, by Tralvex Yeap</weblink> (Radiosity Abstracts &amp; Bibliography Library)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://dudka.cz/rrv">
Radiosity Renderer and Visualizer</weblink> (simple implementation of radiosity renderer based on <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../497/22497.xml">
OpenGL</link></software>
)</entry>
</list>

</p>

</sec>
</bdy>
</article>
