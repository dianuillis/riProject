<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:50:41[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Hungarian algorithm</title>
<id>2609001</id>
<revision>
<id>242858184</id>
<timestamp>2008-10-03T23:39:24Z</timestamp>
<contributor>
<username>BOTijo</username>
<id>3729068</id>
</contributor>
</revision>
<categories>
<category>Combinatorial optimization</category>
</categories>
</header>
<bdy>

The <b>Hungarian algorithm</b> is a <link xlink:type="simple" xlink:href="../033/52033.xml">
combinatorial optimization</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> which solves <link xlink:type="simple" xlink:href="../592/140592.xml">
assignment problem</link>s in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link> (<math>O(n^3)</math>). The first version, known as the <b>Hungarian method</b>, was invented and published by <link xlink:type="simple" xlink:href="../090/1199090.xml">
Harold Kuhn</link> in 1955. This was revised by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/7615776.xml">
James Munkres</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 in 1957, and has been known since as the <b>Hungarian algorithm</b>, the <b>Munkres assignment algorithm</b>, or the <b>Kuhn-Munkres algorithm</b>.<p>

The algorithm developed by Kuhn was largely based on the earlier works of two <country wordnetid="108544813" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../275/13275.xml">
Hungarian</link></country>
 mathematicians: <link>
Dénes König</link> and <link>
Jenő Egerváry</link>. The great advantage of Kuhn’s method is that it is strongly <link xlink:type="simple" xlink:href="../000/23000.xml">
polynomial</link> (see <link xlink:type="simple" xlink:href="../543/7543.xml">
Computational complexity theory</link> for details). The main innovation of the algorithm was to combine two separate parts in Egerváry’s proof into one.</p>
<p>

The algorithm appearing in some <link xlink:type="simple" xlink:href="../476/43476.xml">
operations research</link> textbooks is a simplified version which is easier to code and to carry out by hand for small examples. see <weblink xlink:type="simple" xlink:href="http://www.cse.ust.hk/~golin/COMP572/Notes/Matching.pdf">
http://www.cse.ust.hk/~golin/COMP572/Notes/Matching.pdf</weblink>.</p>

<sec>
<st>
Laymen’s Explanation</st>
<p>

Say you have three workers: <b>Jim</b>, <b>Steve</b> &amp; <b>Allan</b>.
You need to have them clean the bathroom, sweep the floors &amp; wash the windows.
What’s the best way to assign the jobs?
First we need a matrix of the time it takes for each to do each job.
<table class="wikitable" border="1">
<row>

<header>
Jim</header>
<header>
Steve</header>
<header>
Allan</header>
</row>
<row>
<col>
Clean bathroom</col>
<col>
1 hour</col>
<col>
3 hours</col>
<col>
3 hours</col>
</row>
<row>
<col>
Sweep floors</col>
<col>
2 hours</col>
<col>
3 hours</col>
<col>
3 hours</col>
</row>
<row>
<col>
Wash windows</col>
<col>
3 hours</col>
<col>
3 hours</col>
<col>
2 hours</col>
</row>
</table>
</p>
<p>

Then the Hungarian algorithm, when applied to the above table would give us the shortest time it can be done in: Jim cleans the bathroom, Steve sweeps the floors and Allan washes the windows.</p>

</sec>
<sec>
<st>
Modeling</st>

<p>

The algorithm models an assignment problem as an <it>n</it>×<it>m</it> cost <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrix</link>, where each element represents the cost of assigning the <it>i</it>th worker to the <it>j</it>th job. By default, the algorithm performs minimization on the elements of the matrix. In the case of a price-minimization problem, it is sufficient to make zeros appear. At least one zero per line and per column is needed. However, in the case of a profit-maximization problem, the cost matrix needs to be modified so that minimization of its elements results in maximizing the original cost values. In an infinite-cost problem, the initial cost matrix can be re-modelled by subtracting every element of each line from the maximum value of the element of that line (or column respectively). In a finite-cost problem, all the elements are subtracted from the maximum value of the whole matrix.</p>

</sec>
<sec>
<st>
Algorithm</st>

<p>

The algorithm works by increasing the number of zeros in the matrix and searching for a set of starred zeros, one in every row and column. Zeros are primed, starred, or neither during the algorithm. If there are insufficient zeros a quick addition and subtraction process adds more. If there are not enough starred zeros, the primed zeros are starred and the starred zeros primed. Primed zeros are zeros in a column without any more zeros, which, because they are in the same row as another zero were not starred.</p>
<p>

The procedure of obtaining the prime zeros can be implemented in a <link xlink:type="simple" xlink:href="../676/645676.xml">
flow network</link>, and automated by means of the <link xlink:type="simple" xlink:href="../777/53777.xml">
Ford-Fulkerson algorithm</link>. The <it>n</it>×<it>m</it> matrix is transformed in a <math>G=(U,V)</math> bipartite graph, with I/O capacity equal to 1. Each arc joining the nodes of the flow network represents a zero in the cost matrix. After the maximum flow is obtained, the affected arcs represent the prime zeros. The <link xlink:type="simple" xlink:href="../130/78130.xml">
minimum cut</link> obtained by Ford-Fulkerson automates the process of marking the independent zeros. Each node that gets "cut" on the max-flow graph represents a marked column or line on the cost matrix. In the Hungarian method, assignment can be easily found on the cost matrix, yet the expansion into a max-flow sub-problem is a useful method in more complex scenarios.</p>

</sec>
<sec>
<st>
Bipartite graph representation</st>

<p>

Given <math>n</math> worker and <math>n</math> task vertices, and non-negative edges</p>
<p>

<math>e(i, j) \quad i, j = 1,...,n</math></p>
<p>

representing the cost of assigning worker <math>i</math> to task <math>j</math>, find the cost minimizing assignment.</p>
<p>

If using only those edges of cost 0 we can find an assignment (using, for example, the <link>
Hopcroft–Karp algorithm</link>) then obviously that assignment is the best available.</p>
<p>

If such a matching doesn't exist, the Hungarian algorithm adjusts the costs associated with each edge to introduce zeros without changing which edges will be used in the optimal assignment.</p>
<p>

(1) for each worker <math>i</math>, the minimal cost associated with that worker (<math>m_i = min \{c(i,j) | j = 1,...,n\}</math>) can be subtracted from the cost of each edge associated with that worker (<math>c(i, j) \leftarrow c(i, j) - m_i \quad \forall j=1,...,n</math>). This replaces the minimal cost with a 0. Since in the final matching the worker must perform exactly one job, uniformly shifting the cost of all jobs associated with a worker doesn't change the optimal assignment.</p>
<p>

(2) Likewise, for each job, the minimal associated cost can be subtracted from the cost of each edge associated with that job.</p>
<p>

(3) We now find a maximal unweighted matching using only edges of cost 0. If this is a full matching (assignment) we are done. Otherwise, let <math>V</math> be a minimal <link xlink:type="simple" xlink:href="../382/391382.xml">
vertex cover</link> of the 0 cost edges, which may be computed at the same time as the matching using <link>
König's algorithm</link>.</p>
<p>

(4) Partition the edges into three sets: those with no vertices in <math>V</math> (call this <math>E_0</math>), those with one vertex in V (call this <math>E_1</math>), and those with both vertices in V (call this <math>E_2</math>). We find the edge of smallest cost in <math>E_0</math>, subtract this cost from all edges in <math>E_0</math> and add it to all edges in <math>E_2</math>. We now return to step (3).</p>
<p>

In the above algorithm, adjusting the costs is guaranteed to add at least one zero to the matrix, so this step can occur at most <math>n^2</math> times. Each time the maximum cardinality matching is found as a subproblem, which takes <math>O(n^3)</math> operations. Thus the overall algorithm is guaranteed to be <math>O(n^5)</math>.</p>
<p>

This can be improved to <math>O(n^4)</math> by keeping track of the maximum cardinality matching, since it is guaranteed that edges used in this matching will not be removed by adjusting the matrix. Instead of finding this matching from scratch after each step 3, the existing matching can simply be extended.</p>

</sec>
<sec>
<st>
A minimization problem</st>

<p>

Given <math>n</math> workers and tasks, and an <it>n</it>×<it>n</it>  matrix containing the cost of assigning each worker to a task, find the cost minimizing assignment.</p>
<p>

First the problem is written in the form of a matrix as given below</p>
<p>

<indent level="1">

<math>\begin{bmatrix}
a1 &amp; a2 &amp; a3 &amp; a4\\
b1 &amp; b2 &amp; b3 &amp; b4\\
c1 &amp; c2 &amp; c3 &amp; c4\\
d1 &amp; d2 &amp; d3 &amp; d4\end{bmatrix}</math>
</indent>

where a, b, c and d are the workers who have to perform tasks 1, 2, 3 and 4. a1, a2, a3, a4 denote the penalties incurred when worker "a" does task 1, 2, 3, 4 respectively. Same hold true for the other symbols as well. The matrix is square: each agent can perform only one task.</p>
<p>

Then we perform row operations on the matrix. To do this, the lowest of all <it>ai</it> (i belonging to 1-4) is taken and is subtracted from the other elements in that row. This will lead to at least one zero in that row (We get multiple zeros when there are two equal elements which also happen to be the lowest in that row). This procedure is repeated for all rows. We now have a matrix with at least one zero per row. Now we try to assign tasks to agents such that each agent is doing only one task and  the penalty incurred in each case is zero. This is illustrated below.</p>
<p>

<table style="text-align:center" class="wikitable">
<row>
<col>
0</col>
<col>
a2'</col>
<col>
0'</col>
<col>
a4'</col>
</row>
<row>
<col>
b1'</col>
<col>
b2'</col>
<col>
b3'</col>
<col>
0'</col>
</row>
<row>
<col>
0'</col>
<col>
c2'</col>
<col>
c3'</col>
<col>
c4'</col>
</row>
<row>
<col>
d1'</col>
<col>
0'</col>
<col>
d3'</col>
<col>
d4'</col>
</row>
</table>
</p>
<p>

The zeros that are indicated as 0' are the assigned tasks.</p>
<p>

Sometimes it may turn out that the matrix at this stage cannot be used for assigning, as is the case in for the matrix below.</p>
<p>

<table style="text-align:center" class="wikitable">
<row>
<col>
0</col>
<col>
a2'</col>
<col>
a3'</col>
<col>
a4'</col>
</row>
<row>
<col>
b1'</col>
<col>
b2'</col>
<col>
b3'</col>
<col>
0'</col>
</row>
<row>
<col>
0</col>
<col>
c2'</col>
<col>
c3'</col>
<col>
c4'</col>
</row>
<row>
<col>
d1'</col>
<col>
0</col>
<col>
d3'</col>
<col>
d4'</col>
</row>
</table>
</p>
<p>

In the above case, no assignment can be made. Note that task 1 is done efficiently by both agent a and c. Both can't be assigned the same task. Also note that no one does task 3 efficiently.
To overcome this, we repeat the above procedure for all columns (i.e. the minimum element in each column is subtracted from all the elements in that column) and then check if an assignment is possible. In most situations this will give the result, but if it is still not possible to assign then the procedure described below must be followed.</p>
<p>

Initially assign as many tasks as possible then do the following (assign tasks in rows 2, 3 and 4)</p>
<p>

<table style="text-align:center" class="wikitable">
<row>
<col>
0</col>
<col>
a2'</col>
<col>
a3'</col>
<col>
a4'</col>
</row>
<row>
<col>
b1'</col>
<col>
b2'</col>
<col>
b3'</col>
<col>
0'</col>
</row>
<row>
<col>
0'</col>
<col>
c2'</col>
<col>
c3'</col>
<col>
c4'</col>
</row>
<row>
<col>
d1'</col>
<col>
0'</col>
<col>
d3'</col>
<col>
d4'</col>
</row>
</table>
</p>
<p>

Mark all rows having no assignments (row 1). Then mark all columns having zeros in that row (column 1). Then mark all rows having assignments in the given column (row 3). Repeat this till a closed loop is obtained.</p>

<p>

<table style="text-align:center" class="wikitable">
<row style="background: white">
<col>
&amp;times;</col>




</row>
<row>
<col>
0</col>
<col>
a2'</col>
<col>
a3'</col>
<col>
a4'</col>
<col style="background: white">
&amp;times;</col>
</row>
<row>
<col>
b1'</col>
<col>
b2'</col>
<col>
b3'</col>
<col>
0'</col>
<col style="background: white"></col>
</row>
<row>
<col>
0'</col>
<col>
c2'</col>
<col>
c3'</col>
<col>
c4'</col>
<col style="background: white">
&amp;times;</col>
</row>
<row>
<col>
d1'</col>
<col>
0'</col>
<col>
d3'</col>
<col>
d4'</col>
<col style="background: white"></col>
</row>
</table>
</p>
<p>

Now draw lines through all marked columns and unmarked rows. </p>
<p>

<table style="text-align:center" class="wikitable">
<row style="background: white">
<col>
&amp;times;</col>




</row>
<row>
<col style="background:lightgrey">
0</col>
<col>
a2'</col>
<col>
a3'</col>
<col>
a4'</col>
<col style="background: white">
&amp;times;</col>
</row>
<row style="background:lightgrey">
<col>
b1'</col>
<col>
b2'</col>
<col>
b3'</col>
<col>
0'</col>
</row>
<row>
<col style="background:lightgrey">
0'</col>
<col>
c2'</col>
<col>
c3'</col>
<col>
c4'</col>
<col style="background: white">
&amp;times;</col>
</row>
<row style="background:lightgrey">
<col>
d1'</col>
<col>
0'</col>
<col>
d3'</col>
<col>
d4'</col>
</row>
</table>
</p>
<p>

From the elements that are left, find the lowest value. Subtract this from all elements that are not struck. Add this to elements that are present at the intersection of two lines. Leave other elements unchanged. Now assign the tasks using above rules. Repeat the procedure till an assignment is possible.</p>
<p>

Basically you find the second minimum cost among the two rows. The procedure is repeated until you are able to distinguish among the workers in terms of least cost.</p>

</sec>
<sec>
<st>
Bibliography</st>
<p>

<list>
<entry level="1" type="bullet">

 Harold W. Kuhn, "The Hungarian Method for the assignment problem", <it><link>
Naval Research Logistics Quarterly</link></it>, <b>2</b>:83-97, 1955.  Kuhn's original publication.</entry>
<entry level="1" type="bullet">

 Harold W. Kuhn, "Variants of the Hungarian method for assignment problems", <it>Naval Research Logistics Quarterly</it>, <b>3</b>: 253-258, 1956.</entry>
<entry level="1" type="bullet">

 J. Munkres, "Algorithms for the Assignment and Transportation Problems", <it><link>
Journal of the Society of Industrial and Applied Mathematics</link></it>, <b>5</b>(1):32-38, 1957 March.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 M. Fischetti, "Lezioni di Ricerca Operativa", Edizioni Libreria Progetto Padova, Italia, 1995.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 R. Ahuja, T. Magnanti, J. Orlin, "Network Flows", Prentice Hall, 1993.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 Mordecai J. Golin, <weblink xlink:type="simple" xlink:href="http://www.cse.ust.hk/~golin/COMP572/Notes/Matching.pdf">
Bipartite Matching and the Hungarian Method</weblink>, Course Notes, <link xlink:type="simple" xlink:href="../987/268987.xml">
Hong Kong University of Science and Technology</link>.</entry>
<entry level="1" type="bullet">

 <link>
R. A. Pilgrim</link>, <it><weblink xlink:type="simple" xlink:href="http://csclab.murraystate.edu/bob.pilgrim/445/munkres.html">
Munkres' Assignment Algorithm. Modified for Rectangular Matrices</weblink></it>, Course notes, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../252/305252.xml">
Murray State University</link></university>
.</entry>
<entry level="2" type="bullet">

 Or: <weblink xlink:type="simple" xlink:href="http://www.public.iastate.edu/~ddoty/HungarianAlgorithm.html">
Step-by-step description of algorithm</weblink></entry>
<entry level="1" type="bullet">

 <link>
Mike Dawes</link>, <it><weblink xlink:type="simple" xlink:href="http://www.math.uwo.ca/~mdawes/courses/344/kuhn-munkres.pdf">
The Optimal Assignment Problem</weblink></it>, Course notes, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../136/169136.xml">
University of Western Ontario</link></university>
.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.elte.hu/egres/tr/egres-04-14.pdf">
On Kuhn's Hungarian Method - A tribute from Hungary</weblink>, Andras Frank, Egrervary Research Group, Pazmany P. setany 1/C, H1117, Budapest, Hungary.</entry>
</list>

</p>
<ss1>
<st>
 Implementations </st>

<p>

(Note that not all of these satisfy the <math>O(n^3)</math> time constraint.)</p>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.clapper.org/software/python/munkres/">
Python implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ifors.ms.unimelb.edu.au/tutorial/hungarian/welcome_frame.html">
Online interactive implementation</weblink> Please note that this implements a variant of the algorithm as described above.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://web.axelero.hu/szilardandras/gaps.html">
Graphical implementation with options</weblink> (<link xlink:type="simple" xlink:href="../593/13593.xml">
Java applet</link>)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.netlib.org/utk/lsi/pcwLSI/text/node220.html">
Serial and parallel implementations.</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mathworks.com/matlabcentral/fileexchange/loadFile.do?objectId=6543">
Implementation in Matlab and C</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/src/ANAGHAKK/Algorithm-Munkres-0.06/lib/Algorithm/Munkres.pm">
Perl implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.koders.com/lisp/fid7C3730AF4E356C65F93F20A6410814CBF5F40854.aspx?s=iso+3166">
Lisp implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://johnweaver.zxdevelopment.com/2007/05/22/munkres-code-v2/">
C++ implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=hungarianAlgorithm">
Another C++ implementation with unit tests</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sites.google.com/site/garybaker/hungarian-algorithm/assignment">
Java implementation (GPLv3)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://timefinder.svn.sourceforge.net/viewvc/timefinder/trunk/timefinder-core/src/main/java/de/timefinder/core/algo/assignment/KuhnMunkresAlgorithm.java?view=markup">
Another Java implementation with JUnit tests (Apache 2.0)</weblink></entry>
</list>
</p>




</ss1>
</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
