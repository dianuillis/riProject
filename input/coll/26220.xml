<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:33:58[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.9511911446218017" wordnetid="104377057">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Relational model</title>
<id>26220</id>
<revision>
<id>244099843</id>
<timestamp>2008-10-09T10:28:48Z</timestamp>
<contributor>
<username>RandorXeus</username>
<id>404352</id>
</contributor>
</revision>
<categories>
<category>Relational model</category>
<category>Databases</category>
<category>Database management systems</category>
<category>Articles with specifically-marked weasel-worded phrases</category>
</categories>
</header>
<bdy>

The <b>relational model</b> for <link xlink:type="simple" xlink:href="../377/8377.xml">
database</link> management is a <link xlink:type="simple" xlink:href="../170/1659170.xml">
database model</link> based on <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order predicate logic</link>,  first formulated and proposed in 1969 by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../548/93548.xml">
Edgar Codd</link></scientist>
</person>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><p>

<table style="padding:0.3em; margin-left:15px; border:1px solid #A3B1BF; background:#f5faff; text-align:center; font-size:95%; line-height1.5em; width:160px;" align="right">
<header style="background:#cedff2; padding:0.3em;">
<link xlink:type="simple" xlink:href="../170/1659170.xml">
Database model</link></header>
<row>
<col style="padding:0.1em; font-size:0.9em; background-color:#cedff2">
Common models</col>
</row>
<row>
<col>
<link xlink:type="simple" xlink:href="../075/247075.xml">
Hierarchical</link>
<link xlink:type="simple" xlink:href="../098/185098.xml">
Network</link>
<link xlink:type="simple" xlink:href="../220/26220.xml">
Relational</link>
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../960/68960.xml">
Object-relational</link></instrumentality>
</artifact>
</system>

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../826/22826.xml">
Object</link></instrumentality>
</artifact>
</system>
</col>
</row>
<row>
<col style="padding:0.1em; font-size:0.9em; background-color:#cedff2">
Other models</col>
</row>
<row>
<col>
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../803/1532803.xml">
Associative</link></instrumentality>
</artifact>
</system>

<link xlink:type="simple" xlink:href="../366/1183366.xml">
Concept-oriented</link>
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../290/519290.xml">
Multi-dimensional</link></instrumentality>
</artifact>
</system>

<link xlink:type="simple" xlink:href="../680/19558680.xml">
Semantic</link>
<link xlink:type="simple" xlink:href="../738/872738.xml">
Star schema</link>
<link xlink:type="simple" xlink:href="../351/1442351.xml">
XML database</link></col>
</row>
</table>
</p>

<sec>
<st>
 Overview </st>
<p>

Its core idea is to describe a database as a collection of <link xlink:type="simple" xlink:href="../280/203280.xml">
predicate</link>s over a finite set of predicate variables, describing <link>
constraints</link> on the possible values and combinations of values.  The content of the database at any given time is a finite <link xlink:type="simple" xlink:href="../858/19858.xml">
model (logic)</link> of the database, i.e. a set of <link xlink:type="simple" xlink:href="../220/26220.xml">
relation</link>s, one per predicate variable, such that all predicates are satisfied.  A request for information from the database (a <link xlink:type="simple" xlink:href="../377/8377.xml">
database query</link>) is also a predicate.
<image width="360px" src="Relational_model_concepts.png" type="thumb">
<caption>

Relational model concepts.
</caption>
</image>
</p>
<p>

The purpose of the relational model is to provide a <link xlink:type="simple" xlink:href="../926/1546926.xml">
declarative</link> method for specifying data and queries: we directly state what information the database contains and what information we want from it, and let the database management system software take care of describing data structures for storing the data and retrieval procedures for getting queries answered.</p>
<p>

IBM implemented Codd's ideas with the <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../983/142983.xml">
DB2</link></instrumentality>
</artifact>
</system>
 database management system; it introduced the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
 data definition and query language.  Other relational database management systems followed, most of them using SQL as well.  A <it>table</it> in an SQL database schema corresponds to a predicate variable; the contents of a table to a relation; key constraints, other constraints, and SQL queries correspond to predicates.  However, it must be noted that SQL databases, including DB2, deviate from the relational model in many details; Codd fiercely argued against deviations that compromise the original principles.</p>



<ss1>
<st>
 Alternatives to the relational model </st>
<p>

Other <link xlink:type="simple" xlink:href="../795/3224795.xml">
models</link> are the <link xlink:type="simple" xlink:href="../075/247075.xml">
hierarchical model</link> and <link xlink:type="simple" xlink:href="../098/185098.xml">
network model</link>. Some <link xlink:type="simple" xlink:href="../675/8286675.xml">
system</link>s using these older architectures are still in use today in <link xlink:type="simple" xlink:href="../730/579730.xml">
data center</link>s with high data volume needs or where existing systems are so complex and abstract it would be cost prohibitive to migrate to systems employing the relational model; also of note are newer <link xlink:type="simple" xlink:href="../826/22826.xml">
object-oriented databases</link>, even though many of them are DBMS-construction kits, rather than proper <link xlink:type="simple" xlink:href="../513/8513.xml">
DBMS</link>s. 
A recent development is the Object-Relation type-Object model, which is based on the assumption that any fact can be expressed in the form of one or more binary relationships. The model is used in <link xlink:type="simple" xlink:href="../006/827006.xml">
Object Role Modeling</link> (ORM), <link xlink:type="simple" xlink:href="../034/19522034.xml">
RDF</link>/<link xlink:type="simple" xlink:href="../123/2906123.xml">
Notation 3</link> (N3) and in <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../331/6112331.xml">
Gellish English</link></language>
.</p>
<p>

The relational model was the first formal database model. After it was defined, informal models were made to describe hierarchical databases (the hierarchical model) and network databases (the network model). Hierarchical and network databases existed <it>before</it> relational databases, but were only described as models <it>after</it> the relational model was defined, in order to establish a basis for comparison.</p>

</ss1>
<ss1>
<st>
 Implementation </st>
<p>

There have been several attempts to produce a true implementation of the relational database model as originally defined by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../548/93548.xml">
Codd</link></scientist>
</person>
 and explained by <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../364/84364.xml">
Date</link></employee>
</causal_agent>
</worker>
</specialist>
</person>
</expert>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../392/84392.xml">
Darwen</link></employee>
</causal_agent>
</worker>
</person>
</physical_entity>
 and others, but none have been popular successes so far.  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../552/3946552.xml">
Rel</link></instrumentality>
</artifact>
</system>
 is one of the more recent attempts to do this.</p>

</ss1>
</sec>
<sec>
<st>
 History </st>
<p>

The relational model was invented by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../548/93548.xml">
E.F. (Ted) Codd</link></scientist>
</person>
 as a general model of data, and subsequently maintained and developed by <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../364/84364.xml">
Chris Date</link></employee>
</causal_agent>
</worker>
</specialist>
</person>
</expert>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../392/84392.xml">
Hugh Darwen</link></employee>
</causal_agent>
</worker>
</person>
</physical_entity>
 among others.  In <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../481/84481.xml">
The Third Manifesto</link></instrumentality>
</artifact>
</system>
 (first published in 1995) Date and Darwen show how the relational model can accommodate certain desired <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented</link> features.</p>

<ss1>
<st>
 Controversies </st>
<p>

Codd himself, some years after publication of his 1970 model, proposed a three-valued logic (True, False, Missing or NULL) version of it in order to deal with missing information, and in his <it>The Relational Model for Database Management Version 2</it> (1990) he went a step further with a four-valued logic (True, False, Missing but Applicable, Missing but Inapplicable) version.  But these have never been implemented, presumably because of attending complexity.  SQL's <link xlink:type="simple" xlink:href="../712/21712.xml">
NULL</link> construct was intended to be part of a three-valued logic system, but fell short of that due to logical errors in the standard and in its implementations.  See the section "<link xlink:type="simple" xlink:href="../220/26220.xml#xpointer(//*[./st=%22SQL+standard%22])">
SQL standard</link>", above.</p>

</ss1>
</sec>
<sec>
<st>
 The model </st>
<p>

The fundamental assumption of the relational model is that all <link xlink:type="simple" xlink:href="../040/18985040.xml">
data</link> is represented as <link xlink:type="simple" xlink:href="../509/19509.xml">
mathematical <it>n</it>-ary <b>relations</b></link>, an <it>n</it>-ary relation being a <link xlink:type="simple" xlink:href="../631/27631.xml">
subset</link> of the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../795/5795.xml">
Cartesian product</link></concept>
</idea>
 of <it>n</it> domains.  In the mathematical model, <link xlink:type="simple" xlink:href="../755/89755.xml">
reasoning</link> about such data is done in two-valued <link xlink:type="simple" xlink:href="../970/74970.xml">
predicate logic</link>, meaning there are two possible <link xlink:type="simple" xlink:href="../433/62433.xml">
evaluation</link>s for each <link xlink:type="simple" xlink:href="../094/81094.xml">
proposition</link>: either <it>true</it> or <it>false</it> (and in particular no third value such as <it>unknown</it>, or <it>not applicable</it>, either of which are often associated with the concept of <link xlink:type="simple" xlink:href="../540/2002540.xml">
NULL</link>). Some think two-valued <link xlink:type="simple" xlink:href="../225/3729225.xml">
logic</link> is an important part of the relational model, where others think a system that uses a form of <link xlink:type="simple" xlink:href="../904/249904.xml">
three-valued logic</link> can still be considered relational. &#91;&#93;</p>
<p>

Data are operated upon by means of a <link xlink:type="simple" xlink:href="../769/175769.xml">
relational calculus</link> or <link xlink:type="simple" xlink:href="../285/175285.xml">
relational algebra</link>, these being equivalent in <link xlink:type="simple" xlink:href="../465/4669465.xml">
expressive power</link>.</p>
<p>

The relational model of data permits the database designer to create a consistent, logical representation of <link xlink:type="simple" xlink:href="../062/18985062.xml">
information</link>.  Consistency is achieved by including declared <b><it>constraints</it></b> in the database design, which is usually referred to as the logical schema.  The theory includes a process of <link xlink:type="simple" xlink:href="../640/8640.xml">
database normalization</link> whereby a design with certain desirable properties can be selected from a set of logically equivalent alternatives.  The <link xlink:type="simple" xlink:href="../792/1710792.xml">
access plan</link>s and other implementation and operation details are handled by the <link xlink:type="simple" xlink:href="../513/8513.xml">
DBMS</link> engine, and are not reflected in the logical model.  This contrasts with common practice for SQL DBMSs in which <link xlink:type="simple" xlink:href="../801/225801.xml">
performance tuning</link> often requires changes to the logical model.</p>
<p>

The basic relational building block is the <link xlink:type="simple" xlink:href="../190/4997190.xml">
domain</link> or <link xlink:type="simple" xlink:href="../817/93817.xml">
data type</link>, usually abbreviated nowadays to <b><it>type</it></b>.  A <it><link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link></it> is an unordered <link xlink:type="simple" xlink:href="../886/454886.xml">
set</link> of <b><it>attribute values</it></b>.  An <link xlink:type="simple" xlink:href="../738/40738.xml">
attribute</link> is an ordered pair of <b><it>attribute name</it></b> and <b><it>type name</it></b>.  An attribute value is a specific valid value for the type of the attribute. This can be either a scalar value or a more complex type.</p>
<p>

A relation consists of a <b><it>heading</it></b> and a <b><it>body</it></b>.  A heading is a set of attributes.  A body (of an <it>n</it>-ary  relation) is a set of <it>n</it>-tuples.  The heading of the relation is also the heading of each of its tuples.</p>
<p>

A relation is defined as a <link xlink:type="simple" xlink:href="../886/454886.xml">
set</link> of <it>n</it>-tuples. In both mathematics and the relational database model, a set is an <it>unordered</it> collection of items, although some DBMSs impose an order to their data. In mathematics, a <link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link> has an order, and allows for duplication. <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../548/93548.xml">
E.F. Codd</link></scientist>
</person>
 originally defined tuples using this mathematical definition.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> Later, it was one of <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../548/93548.xml">
E.F. Codd</link></scientist>
</person>
's great insights that using attribute names instead of an ordering would be so much more convenient (in general) in a computer language based on relations . This insight is still being used today. Though the concept has changed, the name "tuple" has not. An immediate and important consequence of this distinguishing feature is that in the relational model the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../795/5795.xml">
Cartesian product</link></concept>
</idea>
 becomes <link xlink:type="simple" xlink:href="../390/294390.xml">
commutative</link>.</p>
<p>

A <link xlink:type="simple" xlink:href="../163/1701163.xml">
table</link> is an accepted visual representation of a relation; a tuple is similar to the concept of <it><link xlink:type="simple" xlink:href="../142/1041142.xml">
row</link></it>, but note that in the database language <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
 the columns and the rows of a table are ordered.</p>
<p>

A <it><link xlink:type="simple" xlink:href="../120/1665120.xml">
relvar</link></it> is a named variable of some specific relation type, to which at all times some relation of that type is assigned, though the relation may contain zero tuples.</p>
<p>

The basic principle of the relational model is the <link xlink:type="simple" xlink:href="../377/8377.xml">
Information Principle</link>: all <link xlink:type="simple" xlink:href="../062/18985062.xml">
information</link> is represented by <link>
data values</link> in relations. In accordance with this Principle, a <link xlink:type="simple" xlink:href="../873/25873.xml">
relational database</link> is a set of relvars and the result of every query is presented as a relation.  </p>
<p>

The consistency of a relational database is enforced, not by rules built into the applications that use it, but rather by <it>constraints</it>, declared as part of the logical schema and enforced by the <link xlink:type="simple" xlink:href="../513/8513.xml">
DBMS</link> for all applications.  In general, constraints are expressed using relational comparison operators, of which just one, "is subset of" (⊆), is theoretically sufficient.  In practice, several useful shorthands are expected to be available, of which the most important are <link xlink:type="simple" xlink:href="../975/336975.xml">
candidate key</link> (really, <link xlink:type="simple" xlink:href="../952/1137952.xml">
superkey</link>) and <link xlink:type="simple" xlink:href="../065/259065.xml">
foreign key</link> constraints.</p>

</sec>
<sec>
<st>
 Interpretation </st>
<p>

To fully appreciate the relational model of data it is essential to understand the intended <it>interpretation</it> of a relation.</p>
<p>

The body of a relation is sometimes called its extension.  This is because it is to be interpreted as a representation of the <link xlink:type="simple" xlink:href="../566/3934566.xml">
extension</link> of some <link xlink:type="simple" xlink:href="../109/285109.xml">
predicate</link>, this being the set of true <link xlink:type="simple" xlink:href="../094/81094.xml">
proposition</link>s that can be formed by replacing each <link>
free variable</link> in that predicate by a name (a term that designates something).</p>
<p>

There is a one-to-one correspondence between the free variables of the predicate and the attribute names of the relation heading.  Each tuple of the relation body provides attribute values to instantiate the predicate by substituting each of its free variables.  The result is a proposition that is deemed, on account of the appearance of the tuple in the relation body, to be true.  Contrariwise, every tuple whose heading conforms to that of the relation but which does not appear in the body is deemed to be false. This  assumption is known as the <link xlink:type="simple" xlink:href="../582/2526582.xml">
closed world assumption</link>.</p>
<p>

For a formal exposition of these ideas, see the section <b>Set Theory Formulation</b>, below.</p>

</sec>
<sec>
<st>
 Application to databases </st>
<p>

A <b>type</b> as used in a typical relational database might be the set of integers, the set of character strings, the set of dates, or the two boolean values <it>true</it> and <it>false</it>, and so on.  The corresponding <b>type names</b> for these types might be the strings "int", "char", "date", "boolean", etc.  It is important to understand, though, that relational theory does not dictate what types are to be supported; indeed, nowadays provisions are expected to be available for <it>user-defined</it> types in addition to the <it>built-in</it> ones provided by the system.  </p>
<p>

<b>Attribute</b> is the term used in the theory for what is commonly referred to as a <b>column</b>.  Similarly, <b>table</b> is commonly used in place of the theoretical term <b>relation</b> (though in SQL the term is by no means synonymous with relation).  A table data structure is specified as a list of column definitions, each of which specifies a unique column name and the type of the values that are permitted for that column.   An <b>attribute value</b> is the entry in a specific column and row, such as "John Doe" or "35".   </p>
<p>

A <b>tuple</b> is basically the same thing as a <b>row</b>, except in an SQL DBMS, where the column values in a row are ordered. (Tuples are not ordered; instead, each attribute value is identified solely by the <b>attribute name</b> and never by its ordinal position within the tuple.)  An attribute name might be "name" or "age".</p>
<p>

A <b>relation</b> is a <b>table</b> structure definition (a set of column definitions) along with the data appearing in that structure.  The structure definition is the <b>heading</b> and the data appearing in it is the <b>body</b>, a set of rows.  A database <b>relvar</b> (relation variable) is commonly known as a <b>base table</b>.  The heading of its assigned value at any time is as specified in the table declaration and its body is that most recently assigned to it by invoking some <b>update operator</b> (typically, INSERT, UPDATE, or DELETE).  The heading and body of the table resulting from evaluation of some query are determined by the definitions of the operators used in the expression of that query.  (Note that in SQL the heading is not always a set of column definitions as described above, because it is possible for a column to have no name and also for two or more columns to have the same name.  Also, the body is not always a set of rows because in SQL it is possible for the same row to appear more than once in the same body.)</p>

</sec>
<sec>
<st>
 SQL and the relational model </st>
<p>

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
, initially pushed as the <link xlink:type="simple" xlink:href="../065/27065.xml">
standard</link> language for <link xlink:type="simple" xlink:href="../873/25873.xml">
relational database</link>s, deviates from the relational model in several places. The current <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../934/14934.xml">
ISO</link></organization>
 SQL standard doesn't mention the relational model or use relational terms or concepts. However, it is possible to create a database conforming to the relational model using SQL if one does not use certain SQL features.</p>
<p>

The following deviations from the relational model have been noted in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
. Note that few database servers implement the entire SQL standard and in particular do not allow some of these deviations. Whereas NULL is nearly ubiquitous, for example, allowing duplicate column names within a table or anonymous columns is uncommon.</p>
<p>

<list>
<entry level="1" type="definition">

Duplicate rows</entry>
<entry level="1" type="indent">

The same row can appear more than once in an SQL table.  The same tuple cannot appear more than once in a relation.</entry>
<entry level="1" type="definition">

Anonymous columns</entry>
<entry level="1" type="indent">

A column in an SQL table can be unnamed and thus unable to be referenced in expressions.  The relational model requires every attribute to be named and referenceable.</entry>
<entry level="1" type="definition">

Duplicate column names</entry>
<entry level="1" type="indent">

Two or more columns of the same SQL table can have the same name and therefore cannot be referenced, on account of the obvious ambiguity.  The relational model requires every attribute to be referenceable.</entry>
<entry level="1" type="definition">

Column order significance</entry>
<entry level="1" type="indent">

The order of columns in an SQL table is defined and significant, one consequence being that SQL's implementations of Cartesian product and union are both noncommutative.  The relational model requires there to be no significance to any ordering of the attributes of a relation.</entry>
<entry level="1" type="definition">

Views without CHECK OPTION</entry>
<entry level="1" type="indent">

Updates to a view defined without CHECK OPTION can be accepted but the resulting update to the database does not necessarily have the expressed effect on its target.  For example, an invocation of INSERT can be accepted but the inserted rows might not all appear in the view, or an invocation of UPDATE can result in rows disappearing from the view.  The relational model requires updates to a view to have the same effect as if the view were a base relvar.</entry>
<entry level="1" type="definition">

Columnless tables unrecognized</entry>
<entry level="1" type="indent">

SQL requires every table to have at least one column, but there are two relations of degree zero (of cardinality one and zero) and they are needed to represent extensions of predicates that contain no free variables.</entry>
<entry level="1" type="definition">

NULL</entry>
<entry level="1" type="indent">

This special mark can appear instead of a value wherever a value can appear in SQL, in particular in place of a column value in some row. The deviation from the relational model arises from the fact that the implementation of this <it>ad hoc</it> concept in SQL involves the use of <link xlink:type="simple" xlink:href="../024/38024.xml">
three-valued logic</link>, under which the comparison of NULL with itself does not yield <it>true</it> but instead yields the third truth value, <it>unknown</it>; similarly the comparison NULL with something other than itself does not yield <it>false</it> but instead yields <it>unknown</it>.  It is because of this behaviour in comparisons that NULL is described as a mark rather than a value.  The relational model depends on the <link xlink:type="simple" xlink:href="../637/17637.xml">
law of excluded middle</link> under which anything that is not true is false and anything that is not false is true; it also requires every tuple in a relation body to have a value for every attribute of that relation.  This particular deviation is disputed by some if only because E.F. Codd himself eventually advocated the use of special marks and a 4-valued logic, but this was based on his observation that there are two distinct reasons why one might want to use a special mark in place of a value, which led opponents of the use of such logics to discover more distinct reasons and at least as many as 19 have been noted, which would require a 21-valued logic.  SQL itself uses NULL for several purposes other than to represent "value unknown".  For example, the sum of the empty set is NULL, meaning zero, the average of the empty set is NULL, meaning undefined, and NULL appearing in the result of a LEFT JOIN can mean "no value because there is no matching row in the right-hand operand".</entry>
<entry level="1" type="definition">

Concepts</entry>
<entry level="1" type="indent">

SQL uses concepts "table", "column", "row" instead of "relvar", "attribute", "tuple".  These are not merely differences in terminology.  For example, a "table" may contain duplicate rows, whereas the same tuple cannot appear more than once in a relation.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Example database </st>
<p>

An idealized, very simple example of a description of some relvars and their attributes:</p>
<p>

<list>
<entry level="1" type="bullet">

Customer(<b>Customer ID</b>, Tax ID, Name, Address, City, State, Zip, Phone)</entry>
<entry level="1" type="bullet">

Order(<b>Order No</b>, Customer ID, Invoice No, Date Placed, Date Promised, Terms, Status)</entry>
<entry level="1" type="bullet">

Order Line(<b>Order No</b>, <b>Order Line No</b>, Product Code, Qty)</entry>
<entry level="1" type="bullet">

Invoice(<b>Invoice No</b>, Customer ID, Order No, Date, Status)</entry>
<entry level="1" type="bullet">

Invoice Line(<b>Invoice No</b>, <b>Line No</b>, Product Code, Qty Shipped)</entry>
<entry level="1" type="bullet">

Product(<b>Product Code</b>, Product Description)</entry>
</list>
</p>
<p>

In this <link xlink:type="simple" xlink:href="../560/8560.xml">
design</link> we have six <link xlink:type="simple" xlink:href="../120/1665120.xml">
relvars</link>: Customer, Order, Order Line, Invoice, Invoice Line and Product. The bold, underlined attributes are <it><link xlink:type="simple" xlink:href="../975/336975.xml">
candidate key</link>s</it>. The non-bold, underlined attributes are <it><link xlink:type="simple" xlink:href="../065/259065.xml">
foreign key</link>s</it>.</p>
<p>

Usually one <link xlink:type="simple" xlink:href="../975/336975.xml">
candidate key</link> is arbitrarily chosen to be called the <link xlink:type="simple" xlink:href="../099/6850099.xml">
primary key</link> and used in <link xlink:type="simple" xlink:href="../162/170162.xml">
preference</link> over the other candidate keys, which are then called <link xlink:type="simple" xlink:href="../349/1763349.xml">
alternate key</link>s.</p>
<p>

A <it>candidate key</it> is a unique <link xlink:type="simple" xlink:href="../250/41250.xml">
identifier</link> enforcing that no <link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link> will be duplicated; this would make the <link xlink:type="simple" xlink:href="../509/19509.xml">
relation</link> into something else, namely a <link xlink:type="simple" xlink:href="../303/305303.xml">
bag</link>, by violating the basic definition of a <link xlink:type="simple" xlink:href="../886/454886.xml">
set</link>.  Both foreign keys and superkeys (which includes candidate keys) can be composite, that is, can be composed of several attributes.  Below is a tabular depiction of a relation of our example Customer relvar; a relation can be thought of as a value that can be attributed to a relvar.</p>

</sec>
<sec>
<st>
Example: customer relation</st>
<p>


Customer ID     Tax ID              Name                 Address                 [More fields....]
==================================================================================================
1234567890      555-5512222         Munmun               323 Broadway            ...
2223344556      555-5523232         SS4 Vegeta           1200 Main Street        ...
3334445563      555-5533323         Ekta                 871 1st Street          ...
4232342432      555-5325523         E. F. Codd           123 It Way              ...
</p>
<p>

If we attempted to <it>insert</it> a new customer with the ID <it>1234567890</it>, this would violate the design of the relvar since <b>Customer ID</b> is a <it>primary key</it> and we already have a customer <it>1234567890</it>.  The <link xlink:type="simple" xlink:href="../513/8513.xml">
DBMS</link> must reject a <link xlink:type="simple" xlink:href="../240/234240.xml">
transaction</link> such as this that would render the <link xlink:type="simple" xlink:href="../377/8377.xml">
database</link> inconsistent by a <link xlink:type="simple" xlink:href="../327/215327.xml">
violation</link> of an <link>
integrity constraint</link>.</p>
<p>

<it><link xlink:type="simple" xlink:href="../065/259065.xml">
Foreign key</link>s</it> are <link>
integrity constraint</link>s enforcing that the <information wordnetid="105816287" confidence="0.8">
<datum wordnetid="105816622" confidence="0.8">
<link xlink:type="simple" xlink:href="../331/338331.xml">
value</link></datum>
</information>
 of the <link>
attribute set</link> is drawn from a <it><link xlink:type="simple" xlink:href="../975/336975.xml">
candidate key</link></it> in another relation. For example in the Order relation the attribute <b>Customer ID</b> is a foreign key. A <it><link xlink:type="simple" xlink:href="../374/303374.xml">
join</link></it> is the <link xlink:type="simple" xlink:href="../245/4140245.xml">
operation</link> that draws on <link xlink:type="simple" xlink:href="../062/18985062.xml">
information</link> from several relations at once. By joining relvars from the example above we could <it>query</it> the database for all of the Customers, Orders, and Invoices. If we only wanted the tuples for a specific customer, we would specify this using a <link>
restriction condition</link>.</p>
<p>

If we wanted to retrieve all of the Orders for Customer <it>1234567890</it>, we could <link xlink:type="simple" xlink:href="../390/679390.xml">
query</link> the database to return every row in the Order table with <b>Customer ID</b> <it>1234567890</it> and join the Order table to the Order Line table based on <b>Order No</b>.</p>
<p>

There is a flaw in our <link xlink:type="simple" xlink:href="../387/1040387.xml">
database design</link> above. The Invoice relvar contains an Order No <link xlink:type="simple" xlink:href="../738/40738.xml">
attribute</link>. So, each tuple in the Invoice relvar will have one Order No, which implies that there is precisely one Order for each Invoice. But in <link xlink:type="simple" xlink:href="../854/43854.xml">
reality</link> an invoice can be created against many orders, or indeed for no particular order.  Additionally the Order relvar contains an Invoice No attribute, implying that each Order has a corresponding Invoice. But again this is not always true in the real world. An order is sometimes paid through several invoices, and sometimes paid without an invoice.  In other words there can be many Invoices per Order and many Orders per Invoice. This is a <b><link xlink:type="simple" xlink:href="../605/13317605.xml">
many-to-many</link></b> relationship between Order and Invoice (also called a <it>non-specific relationship</it>). To represent this relationship in the database a new relvar should be introduced whose <link xlink:type="simple" xlink:href="../191/170191.xml">
role</link> is to specify the <link xlink:type="simple" xlink:href="../956/392956.xml">
correspondence</link> between Orders and Invoices:</p>
<p>

OrderInvoice(<b>Order No</b>,<b>Invoice No</b>)</p>
<p>

Now, the Order relvar has a <it><link xlink:type="simple" xlink:href="../383/2621383.xml">
one-to-many</link></it> relationship to the OrderInvoice table, as does the Invoice relvar.  If we want to retrieve every Invoice for a particular Order, we can query for all orders where <b>Order No</b> in the Order relation equals the <b>Order No</b> in OrderInvoice, and where <b>Invoice No</b> in OrderInvoice equals the <b>Invoice No</b> in Invoice.</p>

</sec>
<sec>
<st>
Set-theoretic formulation</st>

<p>

Basic notions in the relational model are <it>relation names</it> and <it>attribute names</it>. We will represent these as strings such as "Person" and "name" and we will usually use the variables <math>r, s, t, \ldots</math> and <math>a, b, c</math> to range over them. Another basic notion is the set of <it>atomic values</it> that contains values such as numbers and strings.</p>
<p>

Our first definition concerns the notion of <it>tuple</it>, which formalizes the notion of row or record in a table:</p>
<p>

<list>
<entry level="1" type="definition">

 <series wordnetid="108457976" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<sequence wordnetid="108459252" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/132729.xml">
Tuple</link></group>
</ordering>
</sequence>
</arrangement>
</concept>
</idea>
</series>
</entry>
<entry level="1" type="indent">

 A tuple is a <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link> from attribute names to atomic values.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Header</entry>
<entry level="1" type="indent">

 A header is a finite set of attribute names.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Projection</entry>
<entry level="1" type="indent">

 The projection of a tuple <math>t</math> on a <link xlink:type="simple" xlink:href="../742/11742.xml">
finite</link> <link xlink:type="simple" xlink:href="../886/454886.xml">
set</link> of attributes <math>A</math> is <math>t[A] = \{ (a, v) : (a, v) \in t, a \in A \}</math>.</entry>
</list>
</p>
<p>

The next definition defines <it>relation</it> which formalizes the contents of a table as it is defined in the relational model.</p>
<p>

<list>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../509/19509.xml">
Relation</link></entry>
<entry level="1" type="indent">

 A relation is a tuple <math>(H, B)</math> with <math>H</math>, the header, and <math>B</math>, the body, a set of tuples that all have the domain <math>H</math>.</entry>
</list>
</p>
<p>

Such a relation closely corresponds to what is usually called the extension of a predicate in <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link> except that here we identify the places in the predicate with attribute names. Usually in the relational model a <link xlink:type="simple" xlink:href="../380/1040380.xml">
database schema</link> is said to consist of a set of relation names, the headers that are associated with these names and the <link>
constraints</link> that should hold for every instance of the database schema.</p>
<p>

<list>
<entry level="1" type="definition">

 Relation universe</entry>
<entry level="1" type="indent">

 A relation universe <math>U</math> over a header <math>H</math> is a non-empty set of relations with header <math>H</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Relation schema</entry>
<entry level="1" type="indent">

 A relation schema <math>(H, C)</math> consists of a header <math>H</math> and a predicate <math>C(R)</math> that is defined for all relations <math>R</math> with header <math>H</math>.  A relation satisfies a relation schema <math>(H, C)</math> if it has header <math>H</math> and satisfies <math>C</math>.</entry>
</list>
</p>

<ss1>
<st>
 Key constraints and functional dependencies </st>
<p>

One of the simplest and most important types of relation constraints is the <it>key constraint</it>. It tells us that in every instance of a certain relational schema the tuples can be identified by their values for certain attributes.</p>
<p>

<list>
<entry level="1" type="definition">

 Superkey</entry>
<entry level="1" type="indent">

 A superkey is written as a finite set of attribute names.</entry>
<entry level="1" type="indent">

 A superkey <math>K</math> holds in a relation <math>(H, B)</math> if:</entry>
<entry level="2" type="bullet">

 <math>K \subseteq H</math> and </entry>
<entry level="2" type="bullet">

 there exist no two distinct tuples <math>t_1, t_2 \in B</math> such that <math>t_1[K] = t_2[K]</math>.</entry>
<entry level="1" type="indent">

 A superkey holds in a relation universe <math>U</math> if it holds in all relations in <math>U</math>.</entry>
<entry level="1" type="indent">

 <b>Theorem:</b> A superkey <math>K</math> holds in a relation universe <math>U</math> over <math>H</math> if and only if <math>K \subseteq H</math> and <math>K \rightarrow H</math> holds in <math>U</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../975/336975.xml">
Candidate key</link></entry>
<entry level="1" type="indent">

 A superkey <math>K</math> holds as a candidate key for a relation universe <math>U</math> if it holds as a superkey for <math>U</math> and there is no <link xlink:type="simple" xlink:href="../631/27631.xml">
proper subset</link> of <math>K</math> that also holds as a superkey for <math>U</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 <relationship wordnetid="113928668" confidence="0.8">
<confinement wordnetid="113998576" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<subjugation wordnetid="113996300" confidence="0.8">
<constraint wordnetid="113998781" confidence="0.8">
<link xlink:type="simple" xlink:href="../784/205784.xml">
Functional dependency</link></constraint>
</subjugation>
</state>
</confinement>
</relationship>
</entry>
<entry level="1" type="indent">

 A functional dependency (FD for short) is written as <math>X \rightarrow Y</math> for <math>X, Y</math> finite sets of attribute names.</entry>
<entry level="1" type="indent">

 A functional dependency <math>X \rightarrow Y</math> holds in a relation <math>(H, B)</math> if:</entry>
<entry level="2" type="bullet">

 <math>X, Y \subseteq H</math> and </entry>
<entry level="2" type="bullet">

 <math>\forall</math> tuples <math>t_1, t_2 \in B</math>, <math>t_1[X] = t_2[X]~\Rightarrow~t_1[Y] = t_2[Y]</math></entry>
<entry level="1" type="indent">

 A functional dependency <math>X \rightarrow Y</math> holds in a relation universe <math>U</math> if it holds in all relations in <math>U</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Trivial functional dependency</entry>
<entry level="1" type="indent">

 A functional dependency is trivial under a header <math>H</math> if it holds in all relation universes over <math>H</math>.</entry>
<entry level="1" type="indent">

 <b>Theorem:</b> An FD <math>X \rightarrow Y</math> is trivial under a header <math>H</math> if and only if <math>Y \subseteq X \subseteq H</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Closure</entry>
<entry level="1" type="indent">

 <maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<link xlink:type="simple" xlink:href="../793/3425793.xml">
Armstrong's axioms</link></auditory_communication>
</saying>
</speech>
</maxim>
: The closure of a set of FDs <math>S</math> under a header <math>H</math>, written as <math>S^+</math>, is the smallest superset of <math>S</math> such that:</entry>
<entry level="2" type="bullet">

 <math>Y \subseteq X \subseteq H~\Rightarrow~X \rightarrow Y \in S^+</math> (reflexivity)</entry>
<entry level="2" type="bullet">

 <math>X \rightarrow Y \in S^+ \land Y \rightarrow Z \in S^+~\Rightarrow~X \rightarrow Z \in S^+</math> (transitivity) and</entry>
<entry level="2" type="bullet">

 <math>X \rightarrow Y \in S^+ \land Z \subseteq H~\Rightarrow~(X \cup Z) \rightarrow (Y \cup Z) \in S^+</math> (augmentation)</entry>
<entry level="1" type="indent">

 <b>Theorem:</b> Armstrong's axioms are sound and complete; given a header <math>H</math> and a set <math>S</math> of FDs that only contain subsets of <math>H</math>, <math>X \rightarrow Y \in S^+</math> if and only if <math>X \rightarrow Y</math> holds in all relation universes over <math>H</math> in which all FDs in <math>S</math> hold.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Completion</entry>
<entry level="1" type="indent">

 The completion of a finite set of attributes <math>X</math> under a finite set of FDs <math>S</math>, written as <math>X^+</math>, is the smallest superset of <math>X</math> such that:</entry>
<entry level="2" type="bullet">

 <math>Y \rightarrow Z \in S \land Y \subseteq X^+~\Rightarrow~Z \subseteq X</math></entry>
<entry level="1" type="indent">

 The completion of an attribute set can be used to compute if a certain dependency is in the closure of a set of FDs.</entry>
<entry level="1" type="indent">

 <b>Theorem:</b> Given a set <math>S</math> of FDs, <math>X \rightarrow Y \in S^+</math> if and only if <math>Y \subseteq X^+</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Irreducible cover</entry>
<entry level="1" type="indent">

 An irreducible cover of a set <math>S</math> of FDs is a set <math>T</math> of FDs such that:</entry>
<entry level="2" type="bullet">

 <math>S^+ = T^+</math></entry>
<entry level="2" type="bullet">

 there exists no <math>U \subset T</math> such that <math>S^+ = U^+</math></entry>
<entry level="2" type="bullet">

 <math>X \rightarrow Y \in T~\Rightarrow Y</math> is a singleton set and</entry>
<entry level="2" type="bullet">

 <math>X \rightarrow Y \in T \land Z \subset X~\Rightarrow~Z \rightarrow Y \notin S^+</math>.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Algorithm to derive candidate keys from functional dependencies </st>
<p>

<b>INPUT:</b> a set <it>S</it> of FDs that contain only subsets of a header <it>H</it>
<b>OUTPUT:</b> the set <it>C</it> of superkeys that hold as candidate keys in
all relation universes over <it>H</it> in which all FDs in <it>S</it> hold
<b>begin</b>
<it>C</it> := ∅;          // found candidate keys
<it>Q</it> := { <it>H</it> };      // superkeys that contain candidate keys
<b>while</b> <it>Q</it> &amp;gt; ∅ <b>do</b>
let <it>K</it> be some element from <it>Q</it>;
<it>Q</it> := <it>Q</it> - { <it>K</it> };  
<it>minimal</it> := <b>true</b>;
<b>for each</b> <it>X-&amp;gt;Y</it> <b>in</b> <it>S</it> <b>do</b> 
<it>K' </it>:= (<it>K</it> - <it>Y</it>) ∪ <it>X</it>;   // derive new superkey
<b>if</b> <it>K' </it>⊂ <it>K</it> <b>then</b>
<it>minimal</it> := <b>false</b>;
<it>Q</it> := <it>Q</it> ∪ { <it>K' </it>};
<b>end if</b>
<b>end for</b>
<b>if</b> <it>minimal</it> <b>and</b> there is not a subset of <it>K</it> in <it>C</it> <b>then</b>
remove all supersets of <it>K</it> from <it>C</it>;
<it>C</it> := <it>C</it> ∪ { <it>K</it> };
<b>end if</b>
<b>end while</b>
<b>end</b></p>

</ss1>
</sec>
<sec>
<st>
See also</st>

<p>

<table style="background:transparent; width:100%;" cellpadding="0" class=" multicol" cellspacing="0">
<row>
<col align="left" width="" valign="top">
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../680/217680.xml">
Domain relational calculus</link></entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../614/3850614.xml">
Life cycle of a relational database</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../820/1568820.xml">
List of relational database management systems</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../528/494528.xml">
Query language</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../528/494528.xml">
Database query language</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../530/494530.xml">
Information retrieval query language</link></entry>
</list>
</col>
<col align="left" width="" valign="top">
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../509/19509.xml">
Relation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../873/25873.xml">
Relational database</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../743/98743.xml">
Relational database management system</link></entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../481/84481.xml">
The Third Manifesto</link></instrumentality>
</artifact>
</system>
 (<link xlink:type="simple" xlink:href="../711/762711.xml">
TTM</link>)</entry>
<entry level="1" type="bullet">

 TransRelational model</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../509/1127509.xml">
Tuple-versioning</link></entry>
</list>
</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
<it>"Derivability, Redundancy, and Consistency of Relations Stored in Large Data Banks"</it>, E.F. Codd, IBM Research Report, 1969</entry>
<entry id="2">
<it>"A Relational Model of Data for Large Shared Data Banks"</it>, in <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
, 1970.</entry>
<entry id="3">
White, Colin.  <it>In the Beginning: An RDBMS History</it>.  Teradata Magazine Online.  September 2004 edition.  URL: <weblink xlink:type="simple" xlink:href="http://www.teradata.com/t/page/127057">
http://www.teradata.com/t/page/127057</weblink></entry>
<entry id="4">
 <cite style="font-style:normal">Codd, E.F.&#32;(1970).&#32;"<weblink xlink:type="simple" xlink:href="http://www.acm.org/classics/nov95/toc.html">
A Relational Model of Data for Large Shared Data Banks</weblink>". <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>&#32;<b>13</b>&#32;(6): 377&ndash;387. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F362384.362685">
10.1145/362384.362685</weblink>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading  </st>
<p>

<list>
<entry level="1" type="bullet">

 Date, C. J., Darwen, H. (2000). <it>Foundation for Future Database Systems: The Third Manifesto</it>, 2nd edition, <link xlink:type="simple" xlink:href="../080/1180080.xml">
Addison-Wesley</link> Professional. ISBN 0-201-70928-7.</entry>
<entry level="1" type="bullet">

 Date, C. J. (2003). <it>Introduction to Database Systems</it>. 8th edition, Addison-Wesley. ISBN 0-321-19784-4.</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.thethirdmanifesto.com/">
The Third Manifesto (TTM)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://dmoz.org/Computers/Software/Databases/Relational/">
DMoz category</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://c2.com/cgi/wiki?RelationalModel">
Relational Model</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://blogs.sun.com/bblfish/entry/why_binary_relations_beat_tuples">
binary relations and tuples compared with respect to the semantic web</weblink></entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../513/8513.xml">
Database management system</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../520/10973520.xml">
Database models</link></instrumentality>
</artifact>
</system>

&nbsp;·  <relationship wordnetid="113928668" confidence="0.8">
<confinement wordnetid="113998576" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<subjugation wordnetid="113996300" confidence="0.8">
<constraint wordnetid="113998781" confidence="0.8">
<link xlink:type="simple" xlink:href="../640/8640.xml">
Database normalization</link></constraint>
</subjugation>
</state>
</confinement>
</relationship>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../365/10983365.xml">
Database storage</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../515/1990515.xml">
Distributed DBMS</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../718/445718.xml">
Referential integrity</link>&nbsp;·  <link xlink:type="simple" xlink:href="../285/175285.xml">
Relational algebra</link>&nbsp;·  <link xlink:type="simple" xlink:href="../769/175769.xml">
Relational calculus</link>&nbsp;·  <link xlink:type="simple" xlink:href="../873/25873.xml">
Relational database</link>&nbsp;·  <link xlink:type="simple" xlink:href="../743/98743.xml">
Relational DBMS</link>&nbsp;·  <link xlink:type="simple" xlink:href="../220/26220.xml">
Relational model</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../960/68960.xml">
Object-relational database</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../409/212409.xml">
Transaction processing</link></col>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
Concepts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../377/8377.xml">
Database</link>&nbsp;·  <link xlink:type="simple" xlink:href="../776/60776.xml">
ACID</link>&nbsp;·  <link xlink:type="simple" xlink:href="../180/287180.xml">
CRUD</link>&nbsp;·  <link xlink:type="simple" xlink:href="../540/2002540.xml">
Null</link>&nbsp;·  <link xlink:type="simple" xlink:href="../975/336975.xml">
Candidate key</link>&nbsp;·  <link xlink:type="simple" xlink:href="../065/259065.xml">
Foreign key</link>&nbsp;·  <link xlink:type="simple" xlink:href="../099/6850099.xml">
Primary key</link>&nbsp;·  <link xlink:type="simple" xlink:href="../952/1137952.xml">
Superkey</link>&nbsp;·  <link xlink:type="simple" xlink:href="../950/472950.xml">
Surrogate key</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Objects</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../316/1384316.xml">
Trigger</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/1960226.xml">
View</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../163/1701163.xml">
Table</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../836/2104836.xml">
Cursor</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../974/245974.xml">
Log</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../953/233953.xml">
Transaction</link>&nbsp;·  <link xlink:type="simple" xlink:href="../076/1711076.xml">
Index</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../251/277251.xml">
Stored procedure</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../101/1983101.xml">
Partition</link></instrumentality>
</artifact>
</system>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../285/665285.xml">
Select</link>&nbsp;·  <link xlink:type="simple" xlink:href="../237/903237.xml">
Insert</link>&nbsp;·  <link xlink:type="simple" xlink:href="../573/1220573.xml">
Update</link>&nbsp;·  <link xlink:type="simple" xlink:href="../931/4347931.xml">
Merge</link>&nbsp;·  <link xlink:type="simple" xlink:href="../216/1701216.xml">
Delete</link>&nbsp;·  <link xlink:type="simple" xlink:href="../204/665204.xml">
Join</link>&nbsp;·  <link xlink:type="simple" xlink:href="../258/11308258.xml">
Union</link>&nbsp;·  <link xlink:type="simple" xlink:href="../018/452018.xml">
Create</link>&nbsp;·  <link xlink:type="simple" xlink:href="../018/452018.xml">
Drop</link>&nbsp;·  <link xlink:type="simple" xlink:href="../953/233953.xml#xpointer(//*[./st=%22In+SQL%22])">
Begin work</link>&nbsp;·  <link xlink:type="simple" xlink:href="../958/1626958.xml">
Commit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../240/1015240.xml">
Rollback</link>&nbsp;·  <link xlink:type="simple" xlink:href="../664/2554664.xml">
Truncate</link>&nbsp;·  <link xlink:type="simple" xlink:href="../018/452018.xml">
Alter</link>&nbsp;·  <link xlink:type="simple" xlink:href="../499/19041499.xml">
XSQL</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Implementations</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../873/25873.xml">
Relational</link>&nbsp;·  <link xlink:type="simple" xlink:href="../973/573973.xml">
Flat file</link>&nbsp;·  <link xlink:type="simple" xlink:href="../069/1971069.xml">
Deductive</link>&nbsp;·  <link xlink:type="simple" xlink:href="../079/12321079.xml">
Dimensional</link>&nbsp;·  <link xlink:type="simple" xlink:href="../075/247075.xml">
Hierarchical</link>&nbsp;·  <link xlink:type="simple" xlink:href="../098/185098.xml">
Network</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../414/15002414.xml">
Document-oriented</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../826/22826.xml">
Object-oriented</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../960/68960.xml">
Object-relational</link></instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../471/1252471.xml">
Temporal</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../351/1442351.xml">
XML data stores</link>&nbsp;·  <link xlink:type="simple" xlink:href="../386/16727386.xml">
Triple stores</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Components</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../356/217356.xml">
Concurrency control</link>&nbsp;·  <link xlink:type="simple" xlink:href="../139/645139.xml">
Data dictionary</link>&nbsp;·  <link xlink:type="simple" xlink:href="../755/42755.xml">
JDBC</link>&nbsp;·  <link xlink:type="simple" xlink:href="../701/168701.xml">
ODBC</link>&nbsp;·  <link xlink:type="simple" xlink:href="../528/494528.xml">
Query language</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../441/1732441.xml">
Query optimizer</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../792/1710792.xml">
Query plan</link></instrumentality>
</artifact>
</system>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
<b>Database products:</b> <link xlink:type="simple" xlink:href="../860/1568860.xml">
Object-oriented</link> (<link xlink:type="simple" xlink:href="../534/1593534.xml">
comparison</link>)
&nbsp;·  <link xlink:type="simple" xlink:href="../820/1568820.xml">
Relational</link> (<link xlink:type="simple" xlink:href="../036/1569036.xml">
comparison</link>)&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../414/15002414.xml">
Document-oriented</link></instrumentality>
</artifact>
</system>
</col>
</row>
</table>
</col>
</row>
</table>

</p>


</sec>
</bdy>
</entity>
</system>
</article>
