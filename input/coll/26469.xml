<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:34:28[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Μ-recursive function</title>
<id>26469</id>
<revision>
<id>230491252</id>
<timestamp>2008-08-07T21:55:54Z</timestamp>
<contributor>
<username>TaBOT-zerem</username>
<id>7359933</id>
</contributor>
</revision>
<categories>
<category>Wikipedia articles needing style editing from March 2008</category>
<category>Articles to be expanded since June 2008</category>
<category>All articles needing style editing</category>
<category>Theory of computation</category>
<category>All articles to be expanded</category>
<category>Recursion theory</category>
</categories>
</header>
<bdy>
<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_style.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This article or section may contain too much repetition.</b>
Please help <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=%CE%9C-recursive_function&amp;action=edit">
improve this article</weblink>, or discuss the issue on its . is available.
<it>(March 2008)''</it></col>
</row>
</table>


In <link xlink:type="simple" xlink:href="../636/19636.xml">
mathematical logic</link> and <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>μ-recursive functions</b> are a class of <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link>s from <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s to <link xlink:type="simple" xlink:href="../474/21474.xml">
natural number</link>s which are "computable" in an intuitive sense. In fact, in <link xlink:type="simple" xlink:href="../136/442136.xml">
computability theory</link> it is shown that the μ-recursive functions are precisely the functions that can be computed by <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s.  The μ-recursive functions are closely related to <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s, and their inductive definition (below) builds upon that of the primitive recursive functions. However, not every μ-recursive function is a primitive recursive function &mdash; the most famous example is the <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
.</p>
<p>

Other equivalent classes of functions are the <link xlink:type="simple" xlink:href="../203/18203.xml">
&amp;lambda;-recursive functions</link> and the functions that can be computed by <link xlink:type="simple" xlink:href="../156/198156.xml">
Markov algorithm</link>s.</p>
<p>

The set of all recursive functions is known as <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../763/3106763.xml">
R</link></group>
</collection>
</class>
 in <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>.</p>

<sec>
<st>
Definition</st>

<p>

The <b>μ-recursive functions</b> (or <b>partial μ-recursive functions</b>) are partial functions that take finite tuples of natural numbers and return a single natural number.  They are the smallest class of partial functions that includes the initial functions and is closed under composition, primitive recursion, and the <link>
μ operator</link>.</p>
<p>

The smallest class of functions including the initial functions and closed under composition and primitive recursion (i.e. defined by use of the first five functions) is the class of <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive functions</link>.  All primitive recursive functions are <link xlink:type="simple" xlink:href="../577/23577.xml">
total</link> functions. The sixth or "μ operator" is required because not all total functions that can be calculated can be done so with only the five primitive recursive functions (e.g. the <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
 ). In these instances the μ operator terminates the calculation. It serves as an <it>unbounded</it> search operator, unbounded but yet (by definition of a total function) shown by <it>some</it> means (e.g. an induction proof) to eventually produce a number and terminate the calculation. </p>
<p>

However, if the unbounded μ operator itself is partial — that is, some numbers exist for which it fails to return a number — the function that makes use of it will also be a partial function — undefined for some numbers. In these instances, because it is unbounded, the μ operator will search forever, never terminating the calculation by producing a number. (Some algorithms may employ a u-operator that can produce the  symbols "u" indicating "undecided" and thereby terminate the calculation (cf Kleene (1952) pp. 328ff)). Said another way: A partial μ-recursive function which uses a partial μ operator may not be total.  The set of <b>total μ-recursive functions</b> is the subset of partial μ-recursive functions which are total.   </p>
<p>

The first three functions are called the "initial" or "basic" functions: (In the following the subscripting is per Kleene (1952) p. 219. For more about some of the various symbolisms found in the literature see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Symbolism%22])">
Symbolism</link> below.)
<list>
<entry level="1" type="bullet">

 (1)  <b>Constant function:</b> For each natural number <it>n</it> and every <it>k</it>:</entry>
<entry level="2" type="indent">

<math>f(x_1,\ldots,x_k) = n</math>.</entry>
<entry level="3" type="indent">

Sometimes the constant is generated by repeated use of the successor function and the object called the  "initial object 0 (zero)" (Kleene (1952) p.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 (2)  <b>Successor function S:</b> The successive passage "from an object already generated to another object n+1 or n' (the <it>successor</it> of <it>n</it>)" (ibid). </entry>
<entry level="2" type="indent">

 S(x) ≡def  f(x) = x' = x +1</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 (3)  <b>Projection function Pik</b> (also called the <b>Identity function Iik</b> ): For all natural numbers <it>i</it> such that <math>1 \le i \le k</math>:</entry>
<entry level="2" type="indent">

 Pik<math>(x_1,\ldots,x_k)</math> =def    <math>f(x_1,\ldots,x_k) = x_i</math>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 (4)  <b>Composition operator:</b> Composition, also called <b>substitution</b> takes a function <math>h(x_1,\ldots,x_m)</math> and functions <math>g_i(x_1,\ldots,x_k)</math> for each <it>i</it> with <math>1 \le i \leq m</math> and returns the function which maps <it>x</it>1, ... <it>x</it>k to</entry>
<entry level="2" type="indent">

<math>f(x_1,\ldots,x_k) = h(g_1(x_1,\ldots,x_k),\ldots,g_m(x_1,\ldots,x_k))</math>.</entry>
<entry level="1" type="bullet">

 (5)  <b>Primitive recursion operator:</b> Takes functions <math>g(x_1,\ldots,x_k)</math> and <math>h(y,z,x_1,\ldots,x_k)</math> and returns the unique function <math>f</math> such that</entry>
<entry level="2" type="indent">

 <math>f(0,x_1,\ldots,x_k) = g(x_1,\ldots,x_k)</math>,</entry>
<entry level="2" type="indent">

 <math>f(y+1,x_1,\ldots,x_k) = h(y,f(y,x_1,\ldots,x_k),x_1,\ldots,x_k)</math>.</entry>
<entry level="1" type="bullet">

 (6)  <b>μ operator</b>: The μ operator takes a function <math>f(y,x_1,\ldots, x_k)</math> and returns the function <math>\mu y f(y,x_1,\ldots,x_k)</math> whose arguments are x1 , . . ., xk . The function <math>f</math> is either a number-theoretic function from natural numbers { 0, 1, ... n } to natural numbers { 0, 1, ... n } or a <link xlink:type="simple" xlink:href="../790/240790.xml">
representing function</link> that operates on a <link xlink:type="simple" xlink:href="../336/7178336.xml">
predicate</link> (with output { t, f } ) to yield { 0, 1 }. </entry>
<entry level="2" type="indent">

 In either case: this function μ<it>y</it> <it>f</it> returns the smallest natural number <math>y</math> such that <it>f</it>(0,<it>x</it>1,<it>x</it>2,...,<it>xk</it>), <it>f</it>(1,<it>x</it>1,<it>x</it>2,...,<it>xk</it>), ..., <it>f</it>(<it>y</it>,<it>x</it>1,<it>x</it>2,...,<it>xk</it>) are all defined and <it>f</it>(<it>y</it>,<it>x</it>1,<it>x</it>2,...,<it>xk</it>) = 0, if such an <it>y</it> exists; if no such <it>y</it> exists, then μ<it>y</it> <it>f</it> is not defined for the particular arguments <it>x</it>1,...,<it>xk</it>.</entry>
</list>
</p>
<p>

The <b>strong equality</b> operator <math>\simeq</math> is used to compare partial μ-recursive functions.  This is defined for all partial functions <it>f</it> and <it>g</it> so  that
<indent level="1">

<math>f(x_1,\ldots,x_k) \simeq g(x_1,\ldots,x_l)</math> 
</indent>
holds if and only if for any choice of arguments either both functions are defined and their values are equal or both functions are undefined.</p>

</sec>
<sec>
<st>
 The problem of decidability </st>
<p>

The question immediately arises: Suppose the algorithm we design to calculate our numbers is not terminating? Do we or do we not have a "calculable" function? How would we decide this? Kleene describes it this way: </p>
<p>

We start with the notion of an "effectively decidable predicate":
<indent level="1">

εyR(x,y) = IF (Ey)R(x,y) THEN ε ="least y such that R(x,y)" ELSE 0.
</indent>

Kleene proposes that "we can search through the propositions R(x,0), R(x,1), R(x,2), ... in succession, looking for one that is true, as far as we please: 
<indent level="1">

But if x is such that NOT_(Ey)R(x,y), we shall never learn this by persisting in the search, which will remain forever uncompleted. The completion of the examination of all aleph0 propostions, which the classical definition envisages, is impossible for a human computer.
</indent>

<indent level="1">

     But, for some choices of R(x,y) the function εyR(x,y) may nevertheless be effectively calculable ... because of some other procedure...[which] is effective.
</indent>

<indent level="1">

[Thus] the function εyR(x,y) is effectively calculable, if and only if the predicate (Ey)R(x,y) is effectively decidable. (Kleene pp. 317-318) 
</indent>

So how do we determine if our misbehaving algorithm is "decidable"? Can we submit it to a "termination-analysis" algorithm that will render "the decision" YES or NO? The proof why the answer is "<link xlink:type="simple" xlink:href="../795/54795.xml">
undecidable</link>" is complex because of all the definitions. The point of it is that Kleene can enumerate all the total recursive functions and show, by Cantor's diagonal method, that more functions exist than can be defined recursively. An adventureous reader may want to read <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Kleene+Theorem+IV%22])">
Theorem IV</link> below. (For more background see the discussion at <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s.)</p>
<p>

<list>
<entry level="1" type="definition">

Theorem IV (the enumeration theorem): We can enumerate (assign a number to) all the (total) recursive functions.</entry>
</list>
</p>
<p>

The following is a verbal account of Kleene's theorem. In the following we abbreviate the string of <it>n</it> parameters (number-variables) x1, ... xn as <b>x</b>. A <link xlink:type="simple" xlink:href="../336/7178336.xml">
predicate</link> function yields { true, false } rather than a number. The <link xlink:type="simple" xlink:href="../806/228806.xml">
quantifier</link> expressions are Kleene's 'intuitive symbolism' (cf p. 225):</p>
<p>

<indent level="1">

For example: (<it>y</it>)R(<it>y</it>) means "for all <it>y</it> R(<it>y</it>) is true, and (E<it>y</it>)R(<it>y</it>) means "there exists a unique <it>y</it> such that R(<it>y</it>) is true."
</indent>

We start with a total μ-recursive function R(<b>x</b>, y). The fact that R is total μ-recursive means it is defined by a "system" (a sequence) of primitive recursive operators D and a <link xlink:type="simple" xlink:href="../197/693197.xml">
mu operator</link> E. Kleene calls this "system" F. F is equipped with the variables <b>x</b> that take place of the numbers we will use as parameters. For this F, Kleene shows how we can calculate a number <it>f</it>, the <link>
Gödel number</link> of the system of equations F with the variables <b>x</b> embedded in the number. </p>
<p>

Suppose we have some natural numbers that we want to plug into the various <b>x</b> of our recursive function R. As our function R is total recursive we should be able to plug <it>any</it> numbers into the various xi and have our function R(<b>x</b>, y) yield a single number <it>y</it> as output (by the definition of a total μ-recursive function). This <it>y</it> represents the "the deduction Y" from F, given the parameters <b>x</b>. </p>
<p>

Ditto for a new predicate Tn that Kleene defines in terms of (i) the Gödel number <it>f</it> of "system of equations" F, (ii) system F's parameters <b>x</b>, and (iii) a final number <it>y</it> that should pop out after we choose some natural numbers to plug into the <b>x</b> and apply function Tn to <it>f</it>, <b>x</b>, and <it>y</it>:</p>
<p>

<indent level="1">

(<it>y</it>)R(<b>x</b>, <it>y</it>) ≡ (E<it>y</it>) Tn (<it>f</it>, <b>x</b>, <it>y</it>)  
</indent>

Kleene shows that, given an <it>f</it> and an instance of parameters <b>x</b>, the predicate Tn is true for at most one Gödel number <it>y</it>. In other words, we don't expect that if <it>f</it> as the legitimate Gödel number of a system of equations F, that an single instance of parameters Tn would yield two or three numbers e.g. <it>y</it>1, <it>y</it>2,  <it>y</it>3, or a different number <it>y</it> than we would get from R.</p>
<p>

From these considerations he derives the following "enumeration theorem":</p>
<p>

<indent level="1">

Theorem IV: For each n ≥ 0: Given any general recursive predicate R(<b>x</b>, <it>y</it>), numbers f and g exist such that:
</indent>
::(E<it>y</it>)R( <b>x</b>, <it>y</it>) ≡ (E<it>y</it>)Tn(<it>f</it>, <b>x</b>, <it>y</it>)
<indent level="2">

(<it>y</it>)R( <b>x</b>, <it>y</it>) ≡ (<it>y</it>) NOT_(Tn)(<it>g</it>, <b>x</b>, <it>y</it>)
</indent>

<indent level="1">

where Tn(<it>z</it>, <b>x</b>, <it>y</it>) is the particular primitive recursive predicate defined above.... (p. 281)
</indent>

Kleene describes the theorem this way:
<indent level="1">

Briefly, (E<it>y</it>)Tn(<it>f</it>, <b>x</b>, <it>y</it>) 'enumerates' the predicates of the form (E<it>y</it>)R( <b>x</b>, <it>y</it>) with a general recursive R. Similarly, (<it>y</it>) NOT_(Tn)(<it>g</it>, <b>x</b>, <it>y</it>) enumerates the predicates of the form (<it>y</it>)R( <b>x</b>, <it>y</it>). (p. 282)
</indent>

<list>
<entry level="1" type="definition">

Theorem V: There are more number-theoretic predicates than recursive functions.</entry>
</list>
</p>
<p>

Kleene now reduces the problem from a sequence of variables <b>x</b> a single variable x that will accept any natural number. By use of Cantor's diagonal argument, Kleene's Theorem V shows that there is a problem that appears when we let <it>x</it> = Gödel number <it>f</it> in the first formula and <it>x</it> = Gödel number <it>g</it> in the second formula. In other words, for its "parameter" <it>x</it>, we plug in the "system" F's very own Gödel number <it>f</it>. There is nothing that says we cannot do this; if the function Y (repesented by Gödel number <it>y</it>) is a total recursive function derivable from F (represented by Gödel number <it>f</it>) we should be able to plug in <it>any</it> number into <it>x</it> and satisfy the equation, but we cannot:</p>
<p>

<indent level="1">

 (E<it>y</it>)R( <it>f</it>, <it>y</it> ) ≠ (<it>y</it>) NOT_(T1)(<it>f</it>, <it>f</it>, <it>y</it>) 
</indent>
: (<it>y</it>)R( <it>g</it>, <it>y</it> ) ≠ (E<it>y</it>) T1(<it>g</it>, <it>g</it>, <it>y</it>)</p>
<p>

Kleene explains the proof this way:
<indent level="1">

The proof ... amounts simply to this: (Ey)T1(<it>z</it>, x, <it>y</it>) for <it>z</it> = 0, 1, 2, ... is an enumeration (with repetitions) of all predicates of the form (E<it>y</it>)R(<it>x</it>,<it>y</it>) with R recursive. By Cantor's diagonal method, NOT_(E<it>y</it>)T1(<it>x</it>, <it>x</it>, <it>y</it>) is a predicate not in the enumeration. The latter is equivalent to (<it>y</it>)NOT_T1 (<it>x</it>, <it>x</it>, <it>y</it>).
</indent>

<indent level="1">

From the eunumerability of all systems <it>E</it> of equations, we can conclude without the present theory that the general recursive predicates are enumerable... hence by Cantor's results ... they cannot constitute all number-theoretic predicates. (p. 283)    
</indent>
(This is analogous to what happens to a universal Turing machine running a <it>generalized</it> decision-program to answer the question "For all programs, 'Will this program enter a pernicious "circle"?'" When the machine arrives at its <it>own</it> number to test (i.e. the number representing the UTM + the number of the program: "For all programs, 'Will this program enter a pernicious 'circle'?" ) it cannot "answer YES" because by definition/premise it is circle-free (and designed to answer the question FOR ALL instances). So to test for NO — "When I test my own number, will I end in a circle?" — it must test its own behavior. So it starts from scratch and tests all the numbers up to and including itself (time #2). Once there, it must retest itself again (time #3 — why is this time any different than time #2), etc. It has entered an infinitely regressive "circle" and never answers the question. (<link xlink:type="simple" xlink:href="../272/175272.xml">
Turing</link>'s 1936 proof reprinted in <it>The Undecidable</it>, page 133)</p>

<ss1>
<st>
The consequences with respect to algorithms</st>

<p>

These results lead to two theorems with respect to <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s:</p>
<p>

<indent level="1">

Theorem XII: There is no decision procedure (or algorithm) for either of the predicates (<it>y</it>)NOT_T1 (<it>x</it>, <it>x</it>, <it>y</it>) or (E<it>y</it>)T1(<it>x</it>, <it>x</it>, <it>y</it>). (p. 301)
</indent>

<indent level="1">

Theorem XIII (Part 1): There is no correct and complete <link xlink:type="simple" xlink:href="../102/396102.xml">
formal system</link> for the predicate:
</indent>
::(<it>y</it>)NOT_T1(<it>x</it>, <it>x</it>, <it>y</it>). (A generalized form of Gödel's Theorem, Kleene 1943.) (p. 302)</p>
<p>

And these lead to the following conclusions if we accept <link xlink:type="simple" xlink:href="../854/6854.xml">
Church's thesis</link>:</p>
<p>

<indent level="1">

Hence any algorithm which will lead to the number μ<it>y</it>T1(<it>x</it>, <it>x</it>, <it>y</it>) for every <it>x</it> such that (E<it>y</it>)T1(<it>x</it>, <it>x</it>, <it>y</it>) cannot terminate for every <it>x</it> (using Thesis I [Church's Thesis]). (p. 324) 
</indent>

<indent level="1">

 Hence, there is no algorithm for deciding, given <it>x</it>, whether μ<it>y</it>T1 (<it>x</it>, <it>x</it>, <it>y</it>) is defined or not. (p.325) 
</indent>

Thus we are confronted with the problem of <link xlink:type="simple" xlink:href="../795/54795.xml">
undecidability</link> — the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link>. There is no testing-algorithm we can build that will tell us "YES" = 0 or "NO" = 1, for all algorithms starting with Gödel number 1, whether each algorithm will terminate or not. When the testing algorithm arrives at its own number, it will not terminate.</p>
<p>

<list>
<entry level="1" type="definition">

Kleene's answer to Hilbert's 2nd Problem: Church's thesis, by supplying a precise delimitation of 'all effectively calculable functions' make it possble to prove, for certain predicates R(<it>x</it>, <it>y</it>) e.g. T1(<it>x</it>, <it>x</it>, <it>y</it>) ( Theorem XII ), that there is no uniform method of solving the problem whether or not (E<it>y</it>)R(<it>x</it>,<it>y</it>). Thereby Brouwer's argument, that Hilbert's belief in the solvability of every mathematical problem is unproven, is now strengthened to an actual <b>disproof</b>, when solvability is taken to mean uniform solvability and Church's thesis is accepted. (boldface added, p. 318)</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 Equivalence with other models of computability </st>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-notice" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="36px" src="Wiki_letter_w.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>Please help <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=%CE%9C-recursive_function&amp;action=edit">
improve this section</weblink> by expanding it.</b> Further information might be found on the  or at . 
<it>(June 2008)''</it></col>
</row>
</table>


Kleene's proof of the equivalence of "computable functions by Turing machine" to "partial functions" that are arrived by "use of the primitive recursive operators and the u-operator" can be expressed in its final form as a Theorem:</p>
<p>

<indent level="1">

Theorem XXX ( = Theorems XXVIII + XXIX). The following classes of partial functions are coextensive, i.e. have the same members: 9a) the partial recursive functions, (b) the computable [by ''some'' machine] functions, (c) the 1/1 [Turing machine reduced to one-way tape, 1-symbol ] functions. Similarly with l completely defined assumed functions Ψ. (Kleene p. 376)
</indent>

To prove formal equivalence, Kleene is required to prove the two parts of this Theorem XXX. Theorem XXVIII (Kleene pp. 363 ff) proceeds by showing how to convert the five primitive-recursive operators and the μ-operator to their Turing equivalents so a Turing machine can emulate an algorithm using the recursion operators. Theorem XXIX (Kleene pp 373-376) proceeds by arithematizing the actions of a Turing machine and showing that this number can be arrived at by use of various primitive recursive functions and a u-operator at the end to terminate the calculation. </p>
<p>

Equivalence of various computational models (e.g. <link xlink:type="simple" xlink:href="../218/505218.xml">
register machine</link>s) usually proceed with a demonstration that the machine is equivalent to a Turing machine (i.e. two proofs are required — for all instances (i) the machine-in-question implies a Turing machine AND (ii) a Turing machine implies the machine-in-question.  </p>
<p>

As noted above: In the <link xlink:type="simple" xlink:href="../854/6854.xml">
equivalence of models of computability</link>, a parallel is drawn between <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s which do not terminate for certain inputs and an undefined result for that input in the corresponding partial recursive function.
The unbounded search operator is not definable by the rules of primitive recursion as those do not provide a mechanism for "infinite loops" (undefined values).</p>

</sec>
<sec>
<st>
 Normal form theorem </st>

<p>

A <b>normal form theorem</b> due to Kleene says that there for each <it>k</it> there are primitive recursive functions <math>U(y)\!</math> and <math>T(y,e,x_1,\ldots,x_k)\!</math> such that for any μ-recursive function <math>f(x_1,\ldots,x_k)\!</math> with <it>k</it> free variables there is an <it>e</it> such that  
<indent level="1">

<math>f(x_1,\ldots,x_k) \simeq U(\mu y\, T(y,e,x_1,\ldots,x_k))</math>.
</indent>
The number <it>e</it> is called an <b>index</b> or <b>Gödel number</b> for the function <it>f</it>.  A consequence of this result is that any μ-recursive function can be defined using a single instance of the μ operator applied to a (total) primitive recursive function.</p>
<p>

Minsky (1967) observes (as does Boolos-Burgess-Jeffrey (2002) pp. 94-95) that the U defined above is in essence the μ-recursive equivalent of the <link xlink:type="simple" xlink:href="../435/71435.xml">
universal Turing machine</link>:
<indent level="1">

To construct U is to write down the definition of a general-recursive function U(n, x) that correctly interprets the number n and computes the appropriate function of x. to construct U directly would involve essentially the same amount of effort, <it>and essentially the same ideas</it>, as we have invested in constructing the universal Turing machine. (italics in original, Minsky (1967) p. 189)
</indent>

</p>
</sec>
<sec>
<st>
 Footnotes </st>

<ss1>
<st>
 Symbolism </st>
<p>

A number of different symbolisms are used in the literature. An advantage to using the symbolism is a derivation of a function by "nesting" of the operators one inside the other is easier to write in a compact form. In the following we will abbreviate the string of parameters x1, ..., xn as <b>x</b>:  
<list>
<entry level="1" type="bullet">

 <b>Constant function</b>: Kleene uses " Cqn(<b>x</b>) = q " and Boolos-Burgess-Jeffry (2002) (B-B-J) use the abbreviation " constn( <b>x</b>) = n ": </entry>
<entry level="2" type="indent">

 e.g. C137 ( r, s, t, u, v, w, x ) = 13</entry>
<entry level="2" type="indent">

 e.g. const13 ( r, s, t, u, v, w, x ) = 13</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Successor function</b>: Kleene uses x' and S for "Successor". As "successor" is considered to be primitive, most texts use the apostrophe as follows: </entry>
<entry level="2" type="indent">

 S(a) = a +1 =def a', where 1 =def  0', 2 =def 0 ' ', etc.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Identity function</b>: Kleene (1952) uses " Uin " to indicate the identity function over the variables xi; B-B-J use the identity function idin over the variables x1 to xn:</entry>
<entry level="1" type="indent">

 Uin( <b>x</b> ) = idin( <b>x</b> ) = xi </entry>
<entry level="1" type="indent">

 e.g. U37 = id37 ( r, s, t, u, v, w, x ) = t </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Composition (Substitution) operator</b>: Kleene uses a bold-face <b>S</b>nm (not to be confused with his S for "successor" <b>!</b> ). The superscript "m" refers to the mth of function "fm", whereas the subscript "n" refers to the nth variable "xn":</entry>
<entry level="1" type="indent">

If we are given h( <b>x</b> )= g( f1(<b>x</b>), ... , fm(<b>x</b>) )</entry>
<entry level="2" type="indent">

  h(<b>x</b>) = <b>S</b>mn(g, f1, ... , fm )</entry>
</list>
</p>
<p>

<indent level="1">

In a similar manner, but without the sub- and superscripts, B-B-J write: 
</indent>
:: h(<it>x</it>')= Cn[g, f1 ,..., fm](<b>x</b>)</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Primitive Recursion</b>: Kleene uses the symbol " <b>R</b>n(base step, induction step) " where n indicates the number of variables, B-B-J use " Pr(base step, induction step)(<b>x</b>)". Given:</entry>
<entry level="2" type="bullet">

 base step: h( 0, <b>x</b> )= f( <b>x</b> ), and</entry>
<entry level="2" type="bullet">

 induction step: h( y+1, <b>x</b> ) = g( y, h(x,y),<b>x</b> )</entry>
</list>
</p>
<p>

<indent level="1">

 Example: primitive recursion definition of a + b:
</indent>
::* base step: f( 0, a ) = a = U11(a)
<list>
<entry level="3" type="bullet">

 induction step: f( b' , a ) = ( f ( b, a ) )' = g( b, f( b, a), a ) = g( b, c, a ) = c' = S(U23( b, c, a )</entry>
<entry level="3" type="indent">

 R2 { U11(a), S [ (U23( b, c, a ) ] }</entry>
<entry level="3" type="indent">

 Pr{ U11(a), S[ (U23( b, c, a ) ] }</entry>
</list>
</p>
<p>

<b>Example</b>: Kleene gives an example of how to perform the recursive derivation of f(b, a) = b + a (notice reversal of variables a and b). He starting with 3 initial functions 
<list>
<entry level="2" type="number">

 S(a) = a'</entry>
<entry level="2" type="number">

 U11(a) = a</entry>
<entry level="2" type="number">

 U23( b, c, a ) = c</entry>
<entry level="2" type="number">

 g(b, c, a) = S(U23( b, c, a )) = c'</entry>
<entry level="2" type="number">

 base step: h( 0, a ) = U11(a)</entry>
<entry level="2" type="indent">

 induction step: h( b', a ) = g( b, h( b, a ), a )</entry>
</list>
</p>
<p>

He arrives at:
<indent level="2">

 a+b = <b>R</b>2[ U11, '''S'''13(S, U23) ]
</indent>

</p>
</ss1>
<ss1>
<st>
 Kleene Theorem IV </st>

<p>

<b>Theorem IV: We can enumerate all the (total) recursive functions</b>.</p>
<p>

In theorem IV (p. 281) he proves that, given a recursive function R(<b>x</b>, y) — where <b>x</b> is our abbreviation for a string of <it>n</it> parameters (number-variables) x1, ... xn  — there exists a <link>
Gödel number</link> <it>f</it> that can satisfy a special <it>predicate</it> T (i.e. T is a function yielding { true, false } ). By use of this predicate he can "enumerate" (assign a number to) all the recursive functions R(<b>x</b>, <it>y</it>) in the following manner:</p>
<p>

The definitions begin with this: 
<list>
<entry level="2" type="bullet">

 (1) G is defined in terms of a sequence of functions (recursive operators) operating on the parameters <b>x</b> that make up "a deduction" of <it>Y</it> from <it>Z</it>: G(<it>Z</it>, <b>x</b>, <it>Y</it>)</entry>
</list>
</p>
<p>

<it>D</it> is the system of equations that recursively define the <link xlink:type="simple" xlink:href="../790/240790.xml">
representing function</link> ψ of R. The (slightly expanded) system of equations <it>F</it> is defined as <it>DE</it>, where <it>E</it> represents the u-operator that terminates the calcuation.
<list>
<entry level="2" type="bullet">

(2) (Ey)R(<b>x</b>,<it>y</it>)≡ (EY)<b>G</b>(<it>F</it>, <b>x</b>, <it>Y</it>) </entry>
</list>
</p>
<p>

<it>f</it> is the Gödel number of the system of equations <it>F</it>. <it>y</it> is the Gödel number of "an entity <it>Y</it>" deduced from <it>F</it>. A second equation is defined as follows: 
<indent level="1">

 Sn(<it>f</it>, <b>x</b>, <it>y</it>)≡ { <it>y</it> is the Gödel number of an entity <it>Y</it> such that G(<it>F</it>, <b>x</b>, <it>Y</it>), where the subscript n of Sn indicates S has n parameters
</indent>
:*(3)  (EY) G(<it>F</it>, <b>x</b>, <it>Y</it>) ≡ (E<it>y</it>) Sn(<it>f</it>, <b>x</b>, <it>y</it>) </p>
<p>

Equating equations (2) and the one immediately above:
<list>
<entry level="2" type="bullet">

(4)  (E<it>y</it>)R(<b>x</b>,<it>y</it>)≡ (E<it>y</it>)n(<it>f</it>, <b>x</b>, <it>y</it>) </entry>
</list>
</p>
<p>

Kleene replaces Sn with a predicate Tn defined from it. The predicate means: 
<indent level="1">

For given [numbers] <it>z</it> [and] <b>x</b>, Tn(<it>z</it>, <b>x</b>, <it>y</it>) is true for at most one [number] <it>y</it>. (p. 281). 
</indent>

Thus we see that if <it>y</it> is a Gödel number of the deduction Y, then Tn is true for only this one <it>y</it> given Gödel number <it>z</it>. And Tn is primitive recursive, Sn is recursive. This allows Kleene to write:
<indent level="1">

Tn (<it>z</it>, <b>x</b>, <it>y</it>) ≡ Sn (<it>z</it>, <b>x</b>, <it>y</it>) &amp; ( t )t NOT_Sn (<it>z</it>, <b>x</b>, t)
</indent>

Theorem IV: For each n ≥ 0: Given any general recursive predicate R(<b>x</b>, <it>y</it>), numbers f and g exist such that:
<indent level="1">

(E<it>y</it>)R( <b>x</b>, <it>y</it>) ≡ (E<it>y</it>)Tn(<it>f</it>, <b>x</b>, <it>y</it>)
</indent>
: (<it>y</it>)R( <b>x</b>, <it>y</it>) ≡ (<it>y</it>) NOT_(Tn)(<it>g</it>, <b>x</b>, <it>y</it>)</p>
<p>

Kleene describes the theorem this way:
<indent level="1">

Briefly, (E<it>y</it>)Tn(<it>f</it>, <b>x</b>, <it>y</it>) 'enumerates' the predicates of the form (E<it>y</it>)R( <b>x</b>, <it>y</it>) with a general recursive R. Similarly, (<it>y</it>) NOT_(Tn)(<it>g</it>, <b>x</b>, <it>y</it>) enumerates the predicates of the form (<it>y</it>)R( <b>x</b>, <it>y</it>). (p. 282)
</indent>

</p>
</ss1>
</sec>
<sec>
<st>
Examples</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../918/10918.xml">
Fibonacci number</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../665/222665.xml">
McCarthy 91 function</link></entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../414/155414.xml">
Recursion theory</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../407/25407.xml">
Recursion</link></entry>
<entry level="1" type="bullet">

 <parlance wordnetid="107081177" confidence="0.8">
<formulation wordnetid="107069948" confidence="0.8">
<expressive_style wordnetid="107066659" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/4044867.xml">
Recursion (computer science)</link></expressive_style>
</formulation>
</parlance>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://plato.stanford.edu/entries/recursive-functions/">
Stanford Encyclopedia of Philosophy entry</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link> (1952) <it>Introduction to Metamathematics</it>. Walters-Noordhoff &amp; North-Holland, with corrections (6th imprint 1971); Tenth impression 1991, ISBN 0-7204-2103-9.</entry>
<entry level="1" type="bullet">

Soare, R.  Recursively enumerable sets and degrees. Springer-Verlag 1987.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin L. Minsky</link> (1967), <it>Computation: Finite and Infinite Machines</it>, Prentice-Hall, Inc. Englewood Cliffs, N.J. </entry>
<entry level="1" type="indent">

On pages 210-215 Minsky shows how to create the μ-operator using the register machine model, thus demonstrating its equivalence to the general recursive functions.</entry>
<entry level="1" type="bullet">

<person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../621/340621.xml">
George Boolos</link></person>
, <link xlink:type="simple" xlink:href="../094/14386094.xml">
John Burgess</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../354/4294354.xml">
Richard Jeffrey</link></logician>
</causal_agent>
</person>
</expert>
</physical_entity>
 (2002), <it>Computability and Logic: Fourth Edition</it>, Cambridge University Press, Cambridge, UK. Cf pp. 70-71.</entry>
</list>
</p>


</sec>
</bdy>
</article>
