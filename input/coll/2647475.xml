<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:52:38[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Unbounded nondeterminism</title>
<id>2647475</id>
<revision>
<id>232541782</id>
<timestamp>2008-08-17T19:43:13Z</timestamp>
<contributor>
<username>Charles Matthews</username>
<id>12978</id>
</contributor>
</revision>
<categories>
<category>Denotational semantics</category>
<category>Computational models</category>
<category>Process calculi</category>
<category>Actor model</category>
<category>Concurrency</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>unbounded nondeterminism</b> or <b>unbounded indeterminacy</b> is a property of <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrency</link> by which the amount of delay in servicing a request can become unbounded as a result of arbitration of contention for shared resources <it>while still guaranteeing that the request will eventually be serviced</it>.  Unbounded nondeterminism became an important issue in the development of the <link xlink:type="simple" xlink:href="../275/55275.xml#xpointer(//*[./st=%22Denotational+semantics+of+concurrency%22])">
denotational semantics of concurrency</link>, and later became part of research into the theoretical concept of <link xlink:type="simple" xlink:href="../613/175613.xml">
hypercomputation</link>.
<sec>
<st>
Fairness</st>
<p>

Discussion of unbounded nondeterminism tends to get involved with discussions of <it>fairness</it>. The basic concept is that all computation paths must be "fair" in the sense that if the machine enters a state infinitely often, it must take every possible transition from that state. This amounts to requiring that the machine be guaranteed to service a request if it can, since an infinite sequence of states will only be allowed if there is no transition that leads to the request being serviced. Equivalently, every possible transition must occur eventually in an infinite computation, although it may take an unbounded amount of time for the transition to occur. This concept is to be distinguished from the local fairness of flipping a "fair" coin, by which it is understood that it is possible (in some views; it <link xlink:type="simple" xlink:href="../908/351908.xml">
almost surely</link> won't happen) for the outcome always to be heads. </p>
<p>

An example of the role of fair or unbounded nondeterminism in the merging of strings was given by William D. Clinger, in his 1981 thesis. He defined a "fair merge" of two strings to be a third string in which each character of each string must occur eventually. He then considered the set of all fair merges of two strings <it>merge</it>(S, T), assuming it to be a monotone function. Then he argued that <it>merge</it>(⊥,1&amp;omega;)&amp;sube; <it>merge</it>(0,1&amp;omega;), where ⊥ is the empty stream. Now <it>merge</it>(⊥,1&amp;omega;) = 1&amp;omega;, so it must be that 1&amp;omega; is an element of <it>merge</it>(0,1&amp;omega;), a contradiction. He concluded that:
<indent level="1">

It appears that a fair <link xlink:type="simple" xlink:href="../362/20362.xml">
merge</link> cannot be written as a nondeterministic data flow program operating on streams.
</indent>

</p>
</sec>
<sec>
<st>
On the possibility of implementing unbounded nondeterminism</st>
<p>

<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> [1976] argued that it is impossible to implement systems with unbounded nondeterminism. For this reason, <link xlink:type="simple" xlink:href="../434/39434.xml">
Tony Hoare</link> [1978] suggested that "an efficient implementation should try to be reasonably fair."</p>

</sec>
<sec>
<st>
Nondeterministic automata</st>
<p>

<link>
Nondeterministic Turing machine</link>s have only bounded nondeterminism.  Likewise sequential programs containing guarded commands as the only sources of nondeterminism have only bounded nondeterminism <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> [1976].  Briefly, choice nondeterminism is bounded.  <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../720/2671720.xml">
Gordon Plotkin</link></scientist>
</person>
 gave a proof in his original 1976 paper on power domains:</p>
<p>

<indent level="1">

Now the set of initial segments of execution sequences of a given nondeterministic program P, starting from a given state, will form a tree.  The branching points will correspond to the choice points in the program.  Since there are always only finitely many alternatives at each choice point, the branching factor of the tree is always finite.  That is, the tree is finitary.  Now <link>
König's lemma</link> says that if every branch of a <link xlink:type="simple" xlink:href="../456/404456.xml">
finitary</link> tree is finite, then so is the tree itself.  In the present case this means that if every execution sequence of P terminates, then there are only finitely many execution sequences.  So if an output set of P is infinite, it must contain [a nonterminating computation].
</indent>

</p>
</sec>
<sec>
<st>
Indeterminacy versus nondeterministic automata</st>
<p>

William Clinger [1981] provided the following analysis of the above proof by Plotkin:
<indent level="1">

This proof depends upon the premise that if every node x of a certain infinite branch can be reached by some computation c, then there exists a computation c that visits every node x on the branch. ... Clearly this premise follows not from logic but rather from the interpretation given to choice points.  This premise fails for arrival nondeterminism [in the arrival of messages in the Actor model] because of finite delay [in the arrival of messages].  Though each node on an infinite branch must lie on a branch with a limit, the infinite branch need not itself have a limit.  Thus the existence of an infinite branch does not necessarily imply a nonterminating computation.
</indent>

</p>
</sec>
<sec>
<st>
Unbounded nondeterminism and noncomputability</st>
<p>

Spaan et al [1989] have argued that it is possible for an unboundedly nondeterministic program to solve the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link>; their algorithm consists of two parts defined as follows: </p>
<p>

The first part of the program requests a natural number from the second part; after receiving it, it will iterate the desired Turing machine for that many steps, and accept or reject according to whether the machine has yet halted.</p>
<p>

The second part of the program nondeterministically chooses a natural number on request. The number is stored in a variable which is initialized to 0; then the program repeatedly chooses whether to increment the variable, or service the request. The fairness constraint requires that the request eventually be serviced, for otherwise there is an infinite loop in which only the "increment the variable" branch is ever taken.</p>
<p>

Clearly, if the machine does halt, this algorithm has a path which accepts. If the machine does not halt, this algorithm will always reject, no matter what number the second part of the program returns.</p>

</sec>
<sec>
<st>
Arguments for dealing with unbounded nondeterminism</st>
<p>

Clinger and <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../592/2055592.xml">
Carl Hewitt</link></person>
 have developed a model (known as the <link xlink:type="simple" xlink:href="../868/1637868.xml">
Actor model</link>) of concurrent computation with the property of unbounded nondeterminism built in [Clinger 1981; Hewitt 1985; Hewitt and Agha 1991; Hewitt 2006b]; this allow <it>computations</it> that cannot be implemented by Turing Machines, as seen above. However, these researchers emphasize that their model of concurrent computations cannot implement any <it>functions</it> that are outside the class of <link xlink:type="simple" xlink:href="../264/5987264.xml">
recursive function</link>s defined by Church, Kleene, Turing, <it>etc.</it>  (See <link xlink:type="simple" xlink:href="../863/2681863.xml">
Indeterminacy in concurrent computation</link>.)</p>
<p>

Hewitt [2006] justified his use of unbounded nondeterminism by arguing that there is no bound that can be placed on how long it takes a computational circuit called an <link xlink:type="simple" xlink:href="../226/2827226.xml">
<it>arbiter''</it></link> to settle (see <link xlink:type="simple" xlink:href="../871/2277871.xml">
metastability in electronics</link>).  Arbiters are used in computers to deal with the circumstance that computer clocks operate asynchronously with input from outside, <it>e.g..</it>, keyboard input, disk access, network input, <it>etc.</it>  So it could take an unbounded time for a message sent to a computer to be received and in the meantime the computer could traverse an unbounded number of states.</p>
<p>

He further argued that <link xlink:type="simple" xlink:href="../738/9738.xml">
Electronic mail</link> enables unbounded nondeterminism since mail can be stored on servers indefinitely before being delivered, and that <link xlink:type="simple" xlink:href="../700/156700.xml">
Communication links</link> to <generic wordnetid="107899976" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../116/42116.xml">
server</link></generic>
s on the <link xlink:type="simple" xlink:href="../539/14539.xml">
Internet</link> can likewise be out of service indefinitely. This gave rise to the <link xlink:type="simple" xlink:href="../868/1637868.xml#xpointer(//*[./st=%22Unbounded+nondeterminism+controversy%22])">
Unbounded nondeterminism controversy</link></p>

</sec>
<sec>
<st>
Hewitt's analysis of fairness</st>

<p>

Hewitt argued that issues in fairness derive in part from the global state point of view.  The oldest models of computation (e.g.. <link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machines</link>, Post productions, the <link xlink:type="simple" xlink:href="../203/18203.xml">
lambda calculus</link>, etc.) are based on mathematics that makes use of a global state to represent a computational <it>step</it>.  Each computational step is from one global state of the computation to the next global state.  The global state approach was continued in <link xlink:type="simple" xlink:href="../356/103356.xml">
automata theory</link> for <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/10931.xml">
finite state</link></method>
</know-how>
 machines and <link xlink:type="simple" xlink:href="../078/510078.xml">
push down stack</link> machines including their <link xlink:type="simple" xlink:href="../198/452198.xml">
nondeterministic</link> versions.  All of these models have the property of bounded nondeterminism: if a machine always halts when started in its initial state, then there is a bound on the number of states in which it can halt.</p>
<p>

Hewitt argued that there is a fundamental difference between choices in global state nondeterminism and the arrival order indeterminacy (nondeterminism) of his <link xlink:type="simple" xlink:href="../868/1637868.xml">
Actor model</link>.  In global state nondeterminism, a "choice" is made for the "next" global state.  In arrival order indeterminacy, arbitration locally decides each arrival order in an unbounded amount of time. While a local arbitration is proceeding, unbounded activity can take place elsewhere.  There is no global state and consequently no "choice" to be made as to the "next" global state.</p>


</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Carl Hewitt, Peter Bishop and Richard Steiger. <it>A Universal Modular Actor Formalism for Artificial Intelligence</it> IJCAI 1973.</entry>
<entry level="1" type="bullet">

 Robin Milner. <it>Processes: A Mathematical Model of Computing Agents</it> in Logic Colloquium 1973.</entry>
<entry level="1" type="bullet">

 Carl Hewitt, <it>et al.</it> <it>Actor Induction and Meta-evaluation</it> Conference Record of ACM Symposium on Principles of Programming Languages, January 1974.</entry>
<entry level="1" type="bullet">

 Carl Hewitt, <it>et al.</it> <it>Behavioral Semantics of Nonrecursive Control Structure</it>   Proceedings of Colloque sur la Programmation, April 1974.</entry>
<entry level="1" type="bullet">

 Irene Greif.  <it>Semantics of Communicating Parallel Professes</it> MIT EECS Doctoral Dissertation.  August 1975.</entry>
<entry level="1" type="bullet">

 Gordon D. Plotkin.  <it>A powerdomain construction</it> SIAM Journal of Computing, 5:452-487,  September 1976.</entry>
<entry level="1" type="bullet">

 Edsger Dijkstra.  <it>A Discipline of Programming</it> <link xlink:type="simple" xlink:href="../050/5421050.xml">
Prentice Hall</link>.  1976. </entry>
<entry level="1" type="bullet">

 Carl Hewitt and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../643/2203643.xml">
Henry Baker</link></research_worker>
</scientist>
</causal_agent>
</person>
</physical_entity>
 <it>Actors and Continuous Functionals</it>  Proceeding of IFIP Working Conference on Formal Description of Programming Concepts. August 1-5, 1977.</entry>
<entry level="1" type="bullet">

 Gilles Kahn and David MacQueen. <it>Coroutines and networks of parallel processes</it> IFIP. 1977</entry>
<entry level="1" type="bullet">

 Henry Baker. <it>Actor Systems for Real-Time Computation</it> MIT EECS Doctoral Dissertation. January 1978.</entry>
<entry level="1" type="bullet">

 Michael Smyth.  <it>Power domains</it>  Journal of Computer and System Sciences.  1978.</entry>
<entry level="1" type="bullet">

 George Milne and Robin Milner.  <it>Concurrent processes and their syntax</it>  JACM.  April, 1979.</entry>
<entry level="1" type="bullet">

 CAR Hoare.  <it>Communicating Sequential Processes</it> CACM.  August, 1978.</entry>
<entry level="1" type="bullet">

 Nissim Francez, CAR Hoare, Daniel Lehmann, and Willem de Roever.  <it>Semantics of nondeterminism, concurrency, and communication</it>  Journal of Computer and System Sciences.  December 1979.</entry>
<entry level="1" type="bullet">

 Nancy Lynch and Michael Fischer.  <it>On describing the behavior of distributed systems</it> in Semantics of Concurrent Computation.  Springer-Verlag.  1979.</entry>
<entry level="1" type="bullet">

 Jerald Schwartz <it>Denotational semantics of parallelism</it> in Semantics of Concurrent Computation.  Springer-Verlag.  1979.</entry>
<entry level="1" type="bullet">

 William Wadge.  <it>An extensional treatment of dataflow deadlock</it> Semantics of Concurrent Computation.  Springer-Verlag.  1979.</entry>
<entry level="1" type="bullet">

 Ralph-Johan Back. <it>Semantics of Unbounded Nondeterminism</it> ICALP 1980.</entry>
<entry level="1" type="bullet">

 David Park.  <it>On the semantics of fair parallelism</it> Proceedings of the Winter School on Formal Software Specification.  Springer-Verlarg.  1980.</entry>
<entry level="1" type="bullet">

 Dana Scott.  <it>What is Denotational Semantics?</it>  MIT Laboratory for Computer Science Distinguished Lecture Series.  April 17, 1980.</entry>
<entry level="1" type="bullet">

 William D. Clinger, <it>Foundations of Actor Semantics</it>. MIT Mathematics Doctoral Dissertation, June 1981.</entry>
<entry level="1" type="bullet">

 William D. Clinger, <it>Nondeterministic call by need is neither lazy nor by name</it> Pages 226-234 in <it>Symposium on LISP and Functional Programming</it>. Pittsburgh, Penn., 1982.</entry>
<entry level="1" type="bullet">

 Stephen Brookes, Tony Hoare and Bill Roscoe <it>A Theory of Communicating Sequential Processes</it> JACM.  July 1984.</entry>
<entry level="1" type="bullet">

 Carl Hewitt, <it>The Challenge of Open Systems</it> Byte Magazine. April 1985.  Reprinted in <it>The foundation of artificial intelligence---a sourcebook</it> Cambridge University Press. 1990.</entry>
<entry level="1" type="bullet">

 Bill Roscoe. <it>Unbounded nondeterminism in CSP</it> in `Two papers on CSP', technical monograph PRG-67, Oxford University Computing Laboratory. July 1988.</entry>
<entry level="1" type="bullet">

 Carl Hewitt and Gul Agha <it>Guarded Horn clause languages: are they deductive and Logical?</it> International Conference on Fifth Generation Computer Systems, Ohmsha 1988. Tokyo.  Also in <it>Artificial Intelligence at MIT</it>, Vol. 2. MIT Press 1991.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../676/1276676.xml">
A. W. Roscoe</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
: <it>The Theory and Practice of Concurrency</it>, Prentice Hall, ISBN 0-13-674409-5.</entry>
<entry level="1" type="bullet">

 Edith Spaan, Leen Torenvliet and Peter van Emde Boas. <it>Nondeterminism, Fairness and a Fundamental Analogy</it>. EATCS bulletin, 37:186-193, 1989.</entry>
<entry level="1" type="bullet">

 David A. Schmidt, <it>The Structure of Typed Programming Languages</it>. MIT Press, Cambridge, Massachusetts, 1994.</entry>
<entry level="1" type="bullet">

 Butler, M. J. and Morgan, C. C. <it>Action Systems, Unbounded Nondeterminism, and Infinite Traces</it> Formal Aspect of Computing.  1995</entry>
<entry level="1" type="bullet">

 Thomas A. Sudkamp, <it>Languages and Machines</it>. 2nd Edition. Addison-Wesley, Reading, Mass., 1997.</entry>
<entry level="1" type="bullet">

 Luca Aceto and Andrew D. Gordon (editors). <it>Algebraic Process Calculi: The First Twenty Five Years and Beyond</it>' Process Algebra. Bertinoro, Forl`ı, Italy, August 1–5, 2005</entry>
<entry level="1" type="bullet">

 Stephen Brooke.  <it>Retracing CSP</it> in <it>Algebraic Process Calculi: The First Twenty Five Years and Beyond</it>.  August 2005.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../676/1276676.xml">
A. W. Roscoe</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
: <it>The Theory and Practice of Concurrency</it>, Prentice Hall, ISBN 0-13-674409-5.  Revised 2005.</entry>
<entry level="1" type="bullet">

 Carl Hewitt.  <it>The repeated demise of logic programming and why it will be reincarnated</it>   What Went Wrong and Why: Lessons from AI Research and Applications.  Technical Report SS-06-08. AAAI Press.  March 2006.</entry>
<entry level="1" type="bullet">

 Carl Hewitt, <weblink xlink:type="simple" xlink:href="http://www.pcs.usp.br/~coin-aamas06/10_commitment-43_16pages.pdf">
<it>What is Commitment? Physical, Organizational, and Social''</it></weblink>  COIN@AAMAS.  April 27, 2006.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Toby Ord. <weblink xlink:type="simple" xlink:href="http://arxiv.org/abs/math/0209332">
<it>Hypercomputation: Computing more than the Turing machine can compute''</it></weblink> on <link xlink:type="simple" xlink:href="../751/38751.xml">
arxiv.org</link>.</entry>
</list>
</p>

</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
