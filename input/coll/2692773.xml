<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:50:30[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Shunting yard algorithm</title>
<id>2692773</id>
<revision>
<id>235644358</id>
<timestamp>2008-09-01T18:51:31Z</timestamp>
<contributor>
<username>Darktemplar</username>
<id>787102</id>
</contributor>
</revision>
<categories>
<category>Parsing algorithms</category>
</categories>
</header>
<bdy>

The <b>shunting yard algorithm</b> is a method for parsing mathematical equations specified in <link xlink:type="simple" xlink:href="../014/199014.xml">
infix notation</link>. It can be used to produce output in <link xlink:type="simple" xlink:href="../513/26513.xml">
Reverse Polish notation</link> (RPN) or as an <link xlink:type="simple" xlink:href="../629/75629.xml">
abstract syntax tree</link> (AST). The <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> was invented by 
<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> and named the "shunting yard" algorithm because its operation resembles that of a <link xlink:type="simple" xlink:href="../863/292863.xml">
railroad shunting yard</link>.<p>

Like the evaluation of RPN, the shunting yard algorithm is <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link>-based. Infix expressions are the form of math most people are used to, for instance 3+4 or 3+4*(2−1). For the conversion there are two text <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s (<link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link>), the input and the output. There is also a stack holding operators not yet added to the output stack. To convert, the program reads each letter in order and does something based on that letter.</p>

<sec>
<st>
A simple conversion</st>

<p>

<indent level="1">

Input: 3+4
</indent>
#Add 3 to the output <link xlink:type="simple" xlink:href="../265/25265.xml">
queue</link> (whenever a number is read it is added to the output)
<list>
<entry level="1" type="number">

<link xlink:type="simple" xlink:href="../993/273993.xml#xpointer(//*[./st=%22Basic+architecture+of+a+stack%22])">
Push</link> + (or its ID) onto the operator <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link></entry>
<entry level="1" type="number">

Add 4 to the output queue</entry>
<entry level="1" type="number">

After reading expression <link xlink:type="simple" xlink:href="../993/273993.xml#xpointer(//*[./st=%22Basic+architecture+of+a+stack%22])">
pop</link> the operators off the stack and add them to the output. </entry>
<entry level="1" type="number">

    In this case there is only one, "+".</entry>
<entry level="1" type="number">

Output 3 4 +</entry>
</list>
</p>
<p>

This already shows a couple of rules:
<list>
<entry level="1" type="bullet">

 All numbers are added to the output when they are read.</entry>
<entry level="1" type="bullet">

 At the end of reading the expression, pop all operators off the stack and onto the output.</entry>
</list>
</p>

</sec>
<sec>
<st>
The algorithm in detail</st>

<p>

<list>
<entry level="1" type="bullet">

 While there are tokens to be read:</entry>
<entry level="2" type="bullet">

 Read a <link xlink:type="simple" xlink:href="../251/81251.xml">
token</link>.</entry>
<entry level="2" type="bullet">

 If the token is a number, then add it to the output queue.</entry>
<entry level="2" type="bullet">

 If the token is a <link xlink:type="simple" xlink:href="../427/185427.xml">
function</link> token, then push it onto the stack.</entry>
<entry level="2" type="bullet">

 If the token is a function argument separator (e.g., a comma):</entry>
<entry level="3" type="bullet">

 Until the topmost element of the stack is a left parenthesis, pop the element from the stack and push it onto the output queue. If no left parentheses are encountered, either the separator was misplaced or parentheses were mismatched.</entry>
<entry level="2" type="bullet">

 If the token is an operator, o1, then:</entry>
<entry level="3" type="bullet">

 while there is an operator, o2, at the top of the stack, and either</entry>
<entry level="5" type="indent">

 o1 is <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../474/459474.xml">
associative</link></subject>
</message>
 or left-associative and its <link xlink:type="simple" xlink:href="../980/212980.xml">
precedence</link> is less than (lower precedence) or equal to that of o2, or</entry>
<entry level="5" type="indent">

 o1 is right-associative and its precedence is less than (lower precedence) that of o2,</entry>
<entry level="4" type="indent">

 pop o2 off the stack, onto the output queue;</entry>
<entry level="3" type="bullet">

 push o1 onto the stack.</entry>
<entry level="2" type="bullet">

 If the token is a left parenthesis, then push it onto the stack.</entry>
<entry level="2" type="bullet">

 If the token is a right parenthesis:</entry>
<entry level="3" type="bullet">

 Until the token at the top of the stack is a left parenthesis, pop operators off the stack onto the output queue.</entry>
<entry level="3" type="bullet">

 Pop the left parenthesis from the stack, but not onto the output queue.</entry>
<entry level="3" type="bullet">

 If the token at the top of the stack is a function token, pop it and onto the output queue.</entry>
<entry level="3" type="bullet">

 If the stack runs out without finding a left parenthesis, then there are mismatched parentheses.</entry>
<entry level="1" type="bullet">

 When there are no more tokens to read:</entry>
<entry level="2" type="bullet">

 While there are still operator tokens in the stack:</entry>
<entry level="3" type="bullet">

 If the operator token on the top of the stack is a parenthesis, then there are mismatched parenthesis.</entry>
<entry level="3" type="bullet">

 Pop the operator onto the output queue.</entry>
<entry level="1" type="bullet">

 Exit.</entry>
</list>
</p>

</sec>
<sec>
<st>
Complex example</st>
<p>

<table class="wikitable">
<caption>
Input:   3 + 4 * 2 / ( 1 − 5 ) ^ 2 ^ 3</caption>
<header>
Token</header>
<header>
Action</header>
<header>
 Output (in <link xlink:type="simple" xlink:href="../513/26513.xml">
RPN</link>)</header>
<header>
Operator Stack</header>
<header>
Notes</header>
<row>
<col>
3</col>
<col>
Add token to output</col>
<col>
3</col>


</row>
<row>
<col>
+</col>
<col>
Push token to stack</col>
<col>
3</col>
<col align="right">
+</col>

</row>
<row>
<col>
4</col>
<col>
Add token to output</col>
<col>
3 4</col>
<col align="right">
+</col>

</row>
<row>
<col>
*</col>
<col>
Push token to stack</col>
<col>
3 4</col>
<col align="right">
<list>
<entry level="1" type="bullet">

 +</entry>
</list>
</col>
<col>
<list>
<entry level="1" type="bullet">

 has higher precedence than +</entry>
</list>
</col>
</row>
<row>
<col>
2</col>
<col>
Add token to output</col>
<col>
3 4 2</col>
<col align="right">
<list>
<entry level="1" type="bullet">

 +</entry>
</list>
</col>

</row>
<row>
<col rowspan="2">
/</col>
<col>
Pop stack to output</col>
<col>
3 4 2 *</col>
<col align="right">
+</col>
<col>
/ and * have same precedence</col>
</row>
<row>
<col>
Push token to stack</col>
<col>
3 4 2 *</col>
<col align="right">
/ +</col>
<col>
/ has higher precedence than +</col>
</row>
<row>
<col>
(</col>
<col>
Push token to stack</col>
<col>
3 4 2 *</col>
<col align="right">
( / +</col>

</row>
<row>
<col>
1</col>
<col>
Add token to output</col>
<col>
3 4 2 * 1</col>
<col align="right">
( / +</col>

</row>
<row>
<col>
-</col>
<col>
Push token to stack</col>
<col>
3 4 2 * 1</col>
<col align="right">
- ( / +</col>

</row>
<row>
<col>
5</col>
<col>
Add token to output</col>
<col>
3 4 2 * 1 5</col>
<col align="right">
- ( / +</col>

</row>
<row>
<col rowspan="2">
)</col>
<col>
Pop stack to output</col>
<col>
3 4 2 * 1 5 -</col>
<col align="right">
( / +</col>
<col>
Repeated until "(" found</col>
</row>
<row>
<col>
Pop stack</col>
<col>
3 4 2 * 1 5 -</col>
<col align="right">
/ +</col>
<col>
Discard matching parenthesis</col>
</row>
<row>
<col>
^</col>
<col>
Push token to stack</col>
<col>
3 4 2 * 1 5 -</col>
<col align="right">
^ / +</col>
<col>
^ has higher precedence than /</col>
</row>
<row>
<col>
2</col>
<col>
Add token to output</col>
<col>
3 4 2 * 1 5 - 2</col>
<col align="right">
^ / +</col>

</row>
<row>
<col>
^</col>
<col>
Push token to stack</col>
<col>
3 4 2 * 1 5 - 2</col>
<col align="right">
^ ^ / +</col>
<col>
^ is evaluated right-to-left</col>
</row>
<row>
<col>
3</col>
<col>
Add token to output</col>
<col>
3 4 2 * 1 5 - 2 3</col>
<col align="right">
^ ^ / +</col>

</row>
<row>
<col>
<it>end''</it></col>
<col>
Pop entire stack to output</col>
<col>
3 4 2 * 1 5 - 2 3 ^ ^ / +</col>


</row>
</table>
</p>
<p>

If you were writing an <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreter</link>, this output would be <link xlink:type="simple" xlink:href="../251/81251.xml">
tokenize</link>d and written to a compiled file to be later <link xlink:type="simple" xlink:href="../868/59868.xml">
interpreted</link>.  Conversion from infix to RPN can also allow for easier simplification of expressions.  To do this, act like you are solving the RPN expression, however, whenever you come to a variable its value is null, and whenever an operator has a null value, it and its parameters are written to the output (this is a simplification, problems arise when the parameters are operators).  When an operator has no null parameters its value can simply be written to the output.  This method obviously doesn't include all the simplifications possible: It's more of a <link xlink:type="simple" xlink:href="../347/113347.xml">
constant folding</link> optimization.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../946/1301946.xml">
Operator-precedence parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../513/26513.xml">
Reverse Polish notation</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.chris-j.co.uk/parsing.php">
Java Applet demonstrating the Shunting yard algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm">
Parsing Expressions by Recursive Descent</weblink> Theodore Norvell (C) 1999–2001. Access data September 14, 2006.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://montcs.bloomu.edu/~bobmon/Information/RPN/infix2rpn.shtml">
Infix to RPN Algorithm</weblink> </entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/~EWD/MCReps/MR35.PDF">
Original description of the Shunting yard algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.kallisti.net.nz/blog/2008/02/extension-to-the-shunting-yard-algorithm-to-allow-variable-numbers-of-arguments-to-functions/">
 Extension to the ‘Shunting Yard’ algorithm to allow variable numbers of arguments to functions</weblink></entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
