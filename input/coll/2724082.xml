<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:47:52[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<idea  confidence="0.8" wordnetid="105833840">
<concept  confidence="0.8" wordnetid="105835747">
<rule  confidence="0.8" wordnetid="105846054">
<header>
<title>Resolution (logic)</title>
<id>2724082</id>
<revision>
<id>244185961</id>
<timestamp>2008-10-09T18:20:04Z</timestamp>
<contributor>
<username>Matt Kovacs</username>
<id>1809089</id>
</contributor>
</revision>
<categories>
<category>Logic</category>
<category>Rules of inference</category>
<category>1965 introductions</category>
<category>Automated theorem proving</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../636/19636.xml">
mathematical logic</link> and <link xlink:type="simple" xlink:href="../546/2546.xml">
automated theorem proving</link>, <b>resolution</b> is a rule of <link xlink:type="simple" xlink:href="../465/317465.xml">
inference</link> leading to a <link xlink:type="simple" xlink:href="../418/25418.xml">
refutation</link> <link xlink:type="simple" xlink:href="../546/2546.xml">
theorem-proving</link> technique for sentences in <link xlink:type="simple" xlink:href="../335/5597335.xml">
propositional logic</link> and <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link>. In other words, iteratively applying the resolution rule in a suitable way allows for telling whether a <link xlink:type="simple" xlink:href="../634/1557634.xml">
propositional formula</link> is satisfiable and for proving that a first-order formula is unsatisfiable; this method may prove the satisfiability of a first-order satisfiable formula, but not always, as it is the case for all methods for first-order logic. Resolution was introduced by <skilled_worker wordnetid="110605985" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<exile wordnetid="110071332" confidence="0.8">
<absentee wordnetid="109757653" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<editor wordnetid="110044879" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../114/8895114.xml">
John Alan Robinson</link></scholar>
</mathematician>
</causal_agent>
</alumnus>
</worker>
</editor>
</associate>
</absentee>
</exile>
</scientist>
</colleague>
</traveler>
</intellectual>
</person>
</physical_entity>
</peer>
</skilled_worker>
 in <link xlink:type="simple" xlink:href="../750/34750.xml">
1965</link>.
<sec>
<st>
 Resolution in propositional logic </st>


<ss1>
<st>
 Resolution rule </st>
<p>

The <b>resolution rule</b> in propositional logic is a single valid <link xlink:type="simple" xlink:href="../465/317465.xml">
inference</link> rule that produces a new clause implied by two <link xlink:type="simple" xlink:href="../484/4638484.xml">
clauses</link> containing complementary literals. A literal is a propositional variable or the negation of a propositional variable. Two literals are said to be complements if one is the negation of the other. The resulting clause contains all the literals that do not have complements. 
Formally:
<indent level="1">

<math>\frac{
a_1 \lor \ldots \vee a_i \vee \ldots \lor a_n, 
\quad b_1 \lor \ldots \vee b_j \vee \ldots \lor b_m}
{a_1 \lor \ldots \lor a_{i-1} \lor a_{i+1} \lor \ldots \lor a_n  \lor  b_1 \lor \ldots \lor b_{j-1} \lor b_{j+1} \lor \ldots \lor b_m}</math>
</indent>
where
<indent level="1">

 all <math>a</math>s and <math>b</math>s are literals,
</indent>
: <math>a_i</math> is the complement to <math>b_j</math>, and
<indent level="1">

 the dividing line stands for <link xlink:type="simple" xlink:href="../842/44842.xml">
entails</link>
</indent>
</p>
<p>

The clause produced by the resolution rule is called the <it>resolvent</it> of the two input clauses.</p>
<p>

When the two clauses contain more than one pair of complementary literals, the resolution rule can be applied (independently) for each such pair. However, only the pair of literals that are resolved upon can be removed: all other pair of literals remain in the resolvent clause.</p>
<p>

The resolution rule is similar in spirit to the <it>cut rule</it> of <link xlink:type="simple" xlink:href="../329/252329.xml">
sequent calculus</link>.</p>

</ss1>
<ss1>
<st>
 A resolution technique </st>
<p>

When coupled with a complete <link xlink:type="simple" xlink:href="../249/28249.xml">
search algorithm</link>, the resolution rule yields a sound and complete algorithm for deciding the <it>satisfiability</it> of a propositional formula, and, by extension, the <link xlink:type="simple" xlink:href="../366/32366.xml">
validity</link> of a sentence under a set of axioms.</p>
<p>

This resolution technique uses <link xlink:type="simple" xlink:href="../418/25418.xml">
proof by contradiction</link> and is based on the fact that any sentence in propositional logic can be transformed into an equivalent sentence in <link xlink:type="simple" xlink:href="../342/73342.xml">
conjunctive normal form</link>. The steps are as follows:</p>
<p>

<list>
<entry level="1" type="bullet">

 All sentences in the knowledge base and the <it>negation</it> of the sentence to be proved (the <it>conjecture</it>) are conjunctively connected.</entry>
<entry level="1" type="bullet">

 The resulting sentence is transformed into a conjunctive normal form with the conjuncts viewed as elements in a set, <it>S</it>, of clauses.</entry>
<entry level="2" type="bullet">

For example   <math> (A_1 \lor A_2) \land (B_1 \lor B_2 \lor B_3) \land (C_1)</math> would give rise to a set <math>S=\{A_1 \lor A_2, B_1 \lor B_2 \lor B_3, C_1\}</math>.</entry>
<entry level="1" type="bullet">

 The resolution rule is applied to all possible pairs of clauses that contain complementary literals. After each application of the resolution rule, the resulting sentence is simplified by removing repeated literals. If the sentence contains complementary literals, it is discarded (as a <link xlink:type="simple" xlink:href="../335/4495335.xml">
tautology</link>). If not, and if it is not yet present in the clause set <it>S</it>, it is added to <it>S</it>, and is considered for further resolution inferences.</entry>
<entry level="1" type="bullet">

 If after applying a resolution rule the <it>empty clause</it> is derived, the complete formula is unsatisfiable (or <it>contradictory</it>), and hence it can be concluded that the initial conjecture follows from the axioms.</entry>
<entry level="1" type="bullet">

 If, on the other hand, the empty clause cannot be derived, and the resolution rule cannot be applied to derive any more new clauses, the conjecture is not a theorem of the original knowledge base. </entry>
</list>
</p>
<p>

One instance of this algorithm is the original <link>
Davisâ€“Putnam algorithm</link> that was later refined into the <link xlink:type="simple" xlink:href="../094/2745094.xml">
DPLL algorithm</link> that removed the need for explicit representation of the resolvents.</p>
<p>

This description of the resolution technique uses a set <it>S</it> as the underlying data-structure to represent resolution derivations. Lists, Trees and Directed Acyclic Graphs are other possible and common alternatives. Tree representations are more faithful to the fact that the resolution rule is binary. Together with a sequent notation for clauses, a tree representation also makes it clear to see how the resolution rule is related to a special case of the cut-rule, restricted to atomic cut-formulas. However, tree representations are not as compact as set or list representations, because they explicitly show redundant subderivations of clauses that are used more than once in the derivation of the empty clause. Graph representations can be as compact in the number of clauses as list representations and they also store structural information regarding which clauses were resolved to derive each resolvent.</p>

</ss1>
</sec>
<sec>
<st>
 A simple example </st>

<p>

<math>
\frac{a \vee b, \quad \neg a \vee c}
{b \vee c}
</math></p>
<p>

In English: if a or b is true, and a is false or c is true, then either b or c is true.</p>
<p>

If a is true, then for the second premise to hold, c must be true. If a is false, then for the first premise to hold, b must be true.</p>
<p>

So regardless of a, if both premises hold, then b or c is true.</p>

</sec>
<sec>
<st>
 Resolution in first order logic </st>

<p>

In first order logic, resolution condenses the traditional <link xlink:type="simple" xlink:href="../046/48046.xml">
syllogism</link>s of <link xlink:type="simple" xlink:href="../311/252311.xml">
logical inference</link> down to a single rule.</p>
<p>

To understand how resolution works, consider the following example syllogism of <link xlink:type="simple" xlink:href="../652/321652.xml">
term logic</link>:</p>
<p>

<indent level="1">

 All Greeks are Europeans.
</indent>
: Homer is a Greek.
<indent level="1">

 Therefore, Homer is a European.
</indent>

Or, more generally:</p>
<p>

<indent level="1">

 <math>\forall x. P(x) \Rightarrow Q(x)</math>.
</indent>
: <it>P</it>(<it>a</it>).
<indent level="1">

 Therefore, <it>Q</it>(<it>a</it>).
</indent>

To recast the reasoning using the resolution technique, first the clauses must be converted to <link xlink:type="simple" xlink:href="../342/73342.xml">
conjunctive normal form</link>. In this form, all <link xlink:type="simple" xlink:href="../806/228806.xml">
quantification</link> becomes implicit: <link xlink:type="simple" xlink:href="../174/76174.xml">
universal quantifiers</link> on variables (<it>X</it>, <it>Y</it>, â€¦) are simply omitted as understood, while <link xlink:type="simple" xlink:href="../420/91420.xml">
existentially-quantified</link> variables are replaced by <link xlink:type="simple" xlink:href="../074/421074.xml">
Skolem function</link>s.</p>
<p>

<indent level="1">

 <math>\neg P(x) \vee Q(x)</math>
</indent>
: <it>P</it>(<it>a</it>) 
<indent level="1">

 Therefore, <it>Q</it>(<it>a</it>)
</indent>

So the question is, how does the resolution technique derive the last clause from the first two? The rule is simple:</p>
<p>

<list>
<entry level="1" type="bullet">

 Find two clauses containing the same predicate, where it is negated in one clause but not in the other.</entry>
<entry level="1" type="bullet">

 Perform a <link xlink:type="simple" xlink:href="../432/54432.xml">
unification</link> on the two predicates. (If the unification fails, you made a bad choice of predicates. Go back to the previous step and try again.)</entry>
<entry level="1" type="bullet">

 If any unbound variables which were bound in the unified predicates also occur in other predicates in the two clauses, replace them with their bound values (terms) there as well.</entry>
<entry level="1" type="bullet">

 Discard the unified predicates, and combine the remaining ones from the two clauses into a new clause, also joined by the "âˆ¨" operator.</entry>
</list>
</p>
<p>

To apply this rule to the above example, we find the predicate <it>P</it> occurs in negated form</p>
<p>

<indent level="1">

 Â¬<it>P</it>(<it>X</it>)
</indent>

in the first clause, and in non-negated form</p>
<p>

<indent level="1">

 <it>P</it>(<it>a</it>)
</indent>

in the second clause. <it>X</it> is an unbound variable, while a is a bound value (atom). Unifying the two produces the substitution</p>
<p>

<indent level="1">

 <it>X</it> =&amp;gt; <it>a</it>
</indent>

Discarding the unified predicates, and applying this substitution to the remaining predicates (just <it>Q</it>(<it>X</it>), in this case), produces the conclusion:</p>
<p>

<indent level="1">

 <it>Q</it>(<it>a</it>)
</indent>

For another example, consider the syllogistic form</p>
<p>

<indent level="1">

 All Cretans are islanders.
</indent>
: All islanders are liars.
<indent level="1">

 Therefore all Cretans are liars.
</indent>

Or more generally,</p>
<p>

<indent level="1">

 âˆ€<it>X</it> <it>P</it>(<it>X</it>) implies <it>Q</it>(<it>X</it>)
</indent>
: âˆ€<it>X</it> <it>Q</it>(<it>X</it>) implies <it>R</it>(<it>X</it>)
<indent level="1">

 Therefore, âˆ€<it>X</it> <it>P</it>(<it>X</it>) implies <it>R</it>(<it>X</it>)
</indent>

In CNF, the antecedents become:</p>
<p>

<indent level="1">

 Â¬<it>P</it>(<it>X</it>) âˆ¨ <it>Q</it>(<it>X</it>)
</indent>
: Â¬<it>Q</it>(<it>Y</it>) âˆ¨ <it>R</it>(<it>Y</it>)</p>
<p>

(Note that the variable in the second clause was renamed to make it clear that variables in different clauses are distinct.)</p>
<p>

Now, unifying <it>Q</it>(<it>X</it>) in the first clause with Â¬<it>Q</it>(<it>Y</it>) in the second clause means that <it>X</it> and <it>Y</it> become the same variable anyway. Substituting this into the remaining clauses and combining them gives the conclusion:</p>
<p>

<indent level="1">

 Â¬<it>P</it>(<it>X</it>) âˆ¨ <it>R</it>(<it>X</it>)
</indent>

The resolution rule, as defined by Robinson, also incorporated <link xlink:type="simple" xlink:href="../341/82341.xml">
factoring</link>, which unifies two literals in the same clause, before or during the application of resolution as defined above. The resulting inference rule is refutation complete, in that a set of clauses is unsatisfiable if and only if there exists a derivation of the empty clause using resolution alone.</p>

</sec>
<sec>
<st>
Implementations</st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../255/1258255.xml">
Carine</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../046/162046.xml">
Gandalf</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../263/265263.xml">
Otter</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../763/13456763.xml">
Prover9</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../810/11617810.xml">
SNARK</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../508/17642508.xml">
SPASS</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../408/720408.xml">
Vampire</link></entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../342/73342.xml">
Conjunctive normal form</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../754/16075754.xml">
Inverse resolution</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 J. Alan Robinson (1965), A Machine-Oriented Logic Based on the Resolution Principle. <it><magazine wordnetid="106595351" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/2321845.xml">
Journal of the ACM</link></magazine>
</it> (JACM), Volume 12, Issue 1, pp. 23â€“41.</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Leitsch-1997" style="font-style:normal" class="book">Leitsch, Alexander&#32;(1997). The Resolution Calculus.&#32;<link xlink:type="simple" xlink:href="../949/1418949.xml">
Springer-Verlag</link>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite id="Reference-Gallier-1986" style="font-style:normal" class="book">Gallier, Jean H.&#32;(1986). <weblink xlink:type="simple" xlink:href="http://www.cis.upenn.edu/~jean/gbooks/logic.html">
Logic for Computer Science: Foundations of Automatic Theorem Proving</weblink>.&#32;<link>
Harper &amp; Row Publishers</link>.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Mathworld-Resolution Principle">Alex Sakharov, <it><weblink xlink:type="simple" xlink:href="http://mathworld.wolfram.com/ResolutionPrinciple.html">
Resolution Principle</weblink></it> at <computer wordnetid="103082979" confidence="0.8">
<work wordnetid="104599396" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<encyclopedia wordnetid="106427387" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../235/374235.xml">
MathWorld</link></web_site>
</device>
</book>
</instrumentality>
</artifact>
</product>
</encyclopedia>
</publication>
</reference_book>
</machine>
</creation>
</work>
</computer>
.</cite></entry>
<entry level="1" type="bullet">

  <cite id="Reference-Mathworld-Resolution">Alex Sakharov, <it><weblink xlink:type="simple" xlink:href="http://mathworld.wolfram.com/Resolution.html">
Resolution</weblink></it> at <computer wordnetid="103082979" confidence="0.8">
<work wordnetid="104599396" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<encyclopedia wordnetid="106427387" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../235/374235.xml">
MathWorld</link></web_site>
</device>
</book>
</instrumentality>
</artifact>
</product>
</encyclopedia>
</publication>
</reference_book>
</machine>
</creation>
</work>
</computer>
.</cite></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.uu.nl/docs/vakken/pv/resources/computational_prop_of_fol.pdf">
Notes on computability and resolution</weblink></entry>
</list>
</p>


</sec>
</bdy>
</rule>
</concept>
</idea>
</article>
