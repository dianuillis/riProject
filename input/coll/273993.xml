<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:41:11[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Stack (data structure)</title>
<id>273993</id>
<revision>
<id>244512121</id>
<timestamp>2008-10-11T04:39:25Z</timestamp>
<contributor>
<username>Jpatokal</username>
<id>8155</id>
</contributor>
</revision>
<categories>
<category>Wikipedia articles incorporating text from public domain works of the United States Government</category>
<category>Articles with example pseudocode</category>
<category>Data structures</category>
</categories>
</header>
<bdy>

<image location="right" width="200px" src="Data_stack.svg" type="thumb">
<caption>

Simple representation of a stack
</caption>
</image>

<p>

<table style="font-size: smaller;" class="infobox">
<header style="font-size:larger; background: #ccc;">
 Linear <link xlink:type="simple" xlink:href="../519/8519.xml">
data structures</link></header>
<row>
<col>
<link xlink:type="simple" xlink:href="../052/2052.xml">
Array</link> 
<link xlink:type="simple" xlink:href="../904/8904.xml">
Deque</link> 
<link xlink:type="simple" xlink:href="../996/13996.xml">
Heap</link> 
<link xlink:type="simple" xlink:href="../167/18167.xml">
Linked list</link> 
<link xlink:type="simple" xlink:href="../265/25265.xml">
Queue</link> 
<link xlink:type="simple" xlink:href="../993/273993.xml">
Stack</link></col>
</row>
</table>
</p>
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>stack</b> is an <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
abstract data type</link> and <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link> based on the principle of <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../937/4690937.xml">
Last In First Out</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (LIFO)</it>. Stacks are used extensively at every level of a modern computer system. For example, a modern PC uses stacks at the <link xlink:type="simple" xlink:href="../509/6509.xml">
architecture level</link>, which are used in the basic design of an operating system for interrupt handling and operating system function calls. Among other uses, stacks are used to run a <message wordnetid="106598915" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../389/16389.xml">
Java Virtual Machine</link></machine>
</device>
</request>
</instrumentality>
</artifact>
</message>
, and the <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java </link></request>
</message>
 language itself has a class called "Stack", which can be used by the programmer. The stack is ubiquitous.</p>
<p>

A <it>stack-based</it> computer system is one that stores temporary information primarily in stacks, rather than <link xlink:type="simple" xlink:href="../432/486432.xml">
hardware CPU registers</link> (a <it>register-based</it> computer system).</p>

<sec>
<st>
 History </st>
<p>

The stack method of expression evaluation was first proposed in 1955 and then patented in 1957 by early German computer scientist <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../375/2702375.xml">
Friedrich L. Bauer</link></scientist>
, who received the <link xlink:type="simple" xlink:href="../938/56938.xml">
IEEE</link> Computer Society Pioneer Award in 1988 for his work on <it>Computer Stacks.</it></p>

</sec>
<sec>
<st>
 Abstract data type </st>
<p>

As an <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
abstract data type</link>, the stack is a <link xlink:type="simple" xlink:href="../615/5170615.xml">
container</link> of <link xlink:type="simple" xlink:href="../074/998074.xml">
node</link>s and has two basic operations: <it>push</it> and <it>pop</it>. <it>Push</it> adds a given node to the top of the stack leaving previous nodes below. <it>Pop</it> removes and returns the current top node of the stack. A frequently used metaphor is the idea of a stack of plates in a spring loaded cafeteria stack. In such a stack, only the top plate is visible and accessible to the user, all other plates remain hidden. As new plates are added, each new plate becomes the top of the stack, hiding each plate below, <it>pushing</it> the stack of plates down. As the top plate is removed from the stack, they can be used, the plates <it>pop</it> back up, and the second plate becomes the top of the stack. Two important principles are illustrated by this metaphor: the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../937/4690937.xml">
Last In First Out</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 principle is one; the second is that the contents of the stack are hidden. Only the top plate is visible, so to see what is on the third plate, the first and second plates will have to be removed. This can also be written as FILO-First In Last Out, i.e. the record inserted first will be popped out at last.</p>

<ss1>
<st>
Operations</st>
<p>

In modern computer languages, the stack is usually implemented with more operations than just "push" and "pop". The length of a stack can often be returned as a parameter. Another helper operation <it>top</it><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> (also known as <it>peek</it> or  <it>peak</it>) can return the current top element of the stack without removing it from the stack.</p>
<p>

This section gives <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link> for adding or removing nodes from a stack, as well as the length and top functions. Throughout we will use <link xlink:type="simple" xlink:href="../712/21712.xml">
null</link> to refer to an end-of-list marker or <link xlink:type="simple" xlink:href="../948/3364948.xml">
sentinel value</link>, which may be implemented in a number of ways using <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../018/459018.xml">
pointers</link></kind>
</type>
</category>
</concept>
</idea>
.</p>
<p>

<b>record</b> <it>Node</it> {
data <it>// The data being stored in the node</it>
next <it>// A <link xlink:type="simple" xlink:href="../717/49717.xml">
reference</link> to the next node; null for last node</it>
}</p>
<p>

<b>record</b> <it>Stack</it> {
<it>Node</it> stackPointer   <it>// points to the 'top' node; null for an empty stack</it>
}</p>
<p>

<b>function</b> push(<it>Stack</it> stack, <it>Element</it> element) { <it>// push element onto stack</it>
new(newNode)            <it>// Allocate memory to hold new node
newNode.data   := element
newNode.next   := stack.stackPointer
stack.stackPointer := newNode
}</it></p>
<p>

<b>function</b> pop(<it>Stack</it> stack) { <it>// increase the stack pointer and return 'top' node</it>
<it>// You could check if stack.stackPointer is null here.</it>
<it>// If so, you may wish to error, citing the stack underflow.</it>
node := stack.stackPointer
stack.stackPointer := node.next
element := node.data      
<b>return</b> element
}</p>
<p>

<b>function</b> top(<it>Stack</it> stack) { <it>// return 'top' node</it>
<b>return</b> stack.stackPointer.data
}</p>
<p>

<b>function</b> length(<it>Stack</it> stack) { <it>// return the amount of nodes in the stack</it>
length := 0
node := stack.stackPointer
<b>while</b> node not null {
length := length + 1
node := node.next
}
<b>return</b> length
}</p>
<p>

As you can see, these functions pass the stack and the data elements as parameters and return values, not the data nodes that, in this implementation, include pointers. A stack may also be implemented as a linear section of memory (i.e. an array), in which case the function headers would not change, just the internals of the functions.</p>

</ss1>
<ss1>
<st>
Implementation</st>
<p>

(this is wrtten by mirwais abdullah)
A typical storage requirement for a stack of <it>n</it> elements is <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(n)</it>. The typical time requirement of <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(1) operations is also easy to satisfy with a <link xlink:type="simple" xlink:href="../434/1456434.xml">
dynamic array</link> or (singly) <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link> implementation.</p>
<p>

C++'s <link xlink:type="simple" xlink:href="../777/156777.xml">
Standard Template Library</link> provides a "stack" templated class which is restricted to only push/pop operations.  Java's library contains a <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Stack.html">
Stack</weblink> class that is a specialization of <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Vector.html">
Vector</weblink>. This could be considered a design flaw because the inherited get() method from <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Vector.html">
Vector</weblink> ignores the LIFO constraint of the <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Stack.html">
Stack</weblink>.</p>
<p>

Here is a simple example of a stack with the operations described above (but no error checking) in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
.</p>

<p>

class Stack(object):
def __init__(self):
self.stack_pointer = None</p>
<p>

def push(self, element):
self.stack_pointer = Node(element, self.stack_pointer)</p>
<p>

def pop(self):
e = self.stack_pointer.element
self.stack_pointer = self.stack_pointer.next
return e</p>
<p>

def peek(self):
return self.stack_pointer.element</p>
<p>

def __len__(self):
i = 0
sp = self.stack_pointer
while sp:
i += 1
sp = sp.next
return i</p>
<p>

class Node(object):
def __init__(self, element=None, next=None):
self.element = element
self.next = next</p>
<p>

if __name__ == '__main__':
<list>
<entry level="1" type="number">

 small use example</entry>
</list>

s = Stack()
[s.push(i) for i in xrange(10)]
print [s.pop() for i in xrange(len(s))]</p>

<p>

The above is admittedly redundant as Python supports the 'pop' and 'append' functions to lists.</p>

</ss1>
<ss1>
<st>
Related data structures</st>
<p>

The abstract data type and data structure of the <it><link xlink:type="simple" xlink:href="../347/11347.xml">
First In First Out</link> (FIFO)</it> principle is the <link xlink:type="simple" xlink:href="../265/25265.xml">
queue</link>, and the combination of stack and queue operations is provided by the <link xlink:type="simple" xlink:href="../904/8904.xml">
deque</link>. For example, changing a stack into a queue in a <link xlink:type="simple" xlink:href="../249/28249.xml">
search algorithm</link> can change the algorithm from <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link> (DFS) into a <link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link> (BFS).  A <b>bounded stack</b> is a stack limited to a fixed size.</p>
<p>

<table class="wikitable">
<row>
<header>
header 1</header>
<header>
header 2</header>
<header>
header 3</header>
</row>
<row>
<col>
row 1, cell 1</col>
<col>
row 1, cell 2</col>
<col>
row 1, cell 3</col>
</row>
<row>
<col>
row 2, cell 1</col>
<col>
row 2, cell 2</col>
<col>
row 2, cell 3</col>
</row>
</table>
</p>

</ss1>
</sec>
<sec>
<st>
 Hardware stacks </st>
<p>

A common use of stacks at the Architecture level is as a means of allocating and accessing memory.</p>

<ss1>
<st>
 Basic architecture of a stack </st>
<p>

<image location="right" width="350px" src="ProgramCallStack2.png" type="thumb">
<caption>

A typical stack, storing local data and call information for nested procedures. This stack grows downward from its origin. The stack pointer points to the current topmost <link xlink:type="simple" xlink:href="../040/18985040.xml">
datum</link> on the stack. A push operation decrements the pointer and copies the data to the stack; a pop operation copies data from the stack and then increments the pointer. Each procedure called in the program stores procedure return information (in yellow) and local data (in other colors) by pushing them onto the stack. This type of stack implementation is extremely common, but it is vulnerable to <link xlink:type="simple" xlink:href="../373/4373.xml">
buffer overflow</link> attacks (see the text).
</caption>
</image>

A typical stack is an area of computer memory with a fixed origin and a variable size.  Initially the size of the stack is zero.  A <it>stack pointer,</it> usually in the form of a hardware register, points to the most recently referenced location on the stack; when the stack has a size of zero, the stack pointer points to the origin of the stack.</p>
<p>

The two operations applicable to all stacks are:</p>
<p>

<list>
<entry level="1" type="bullet">

 a <it>push</it> operation, in which a data item is placed at the location pointed to by the stack pointer, and the address in the stack pointer is adjusted by the size of the data item; </entry>
<entry level="1" type="bullet">

 a <it>pop</it> or <it>pull</it> operation: a data item at the current location pointed to by the stack pointer is removed, and the stack pointer is adjusted by the size of the data item.</entry>
</list>
</p>
<p>

There are many variations on the basic principle of stack operations.  Every stack has a fixed location in memory at which it begins. As data items are added to the stack, the stack pointer is displaced to indicate the current extent of the stack, which expands away from the origin (either up or down, depending on the specific implementation).</p>
<p>

For example, a stack might start at a memory location of one thousand, and expand towards lower addresses, in which case new data items are stored at locations ranging below 1000, and the stack pointer is decremented each time a new item is added.  When an item is removed from the stack, the stack pointer is incremented.</p>
<p>

Stack pointers may point to the origin of a stack or to a limited range of addresses either above or below the origin (depending on the direction in which the stack grows); however, the stack pointer cannot cross the origin of the stack.  In other words, if the origin of the stack is at address 1000 and the stack grows downwards (towards addresses 999, 998, and so on), the stack pointer must never be incremented beyond 1000 (to 1001, 1002, etc.).  If a pop operation on the stack causes the stack pointer to move past the origin of the stack, a <it>stack underflow</it> occurs.  If a push operation causes the stack pointer to increment or decrement beyond the maximum extent of the stack, a <it>stack overflow</it> occurs.</p>
<p>

Some environments that rely heavily on stacks may provide additional operations, for example:</p>
<p>

<list>
<entry level="1" type="bullet">

 <it>Dup(licate)</it>: the top item is popped and pushed again so that an additional copy of the former top item is now on top, with the original below it. </entry>
<entry level="1" type="bullet">

 <it>Peek</it>: the topmost item is popped, but the stack pointer is not changed, and the stack size does not change (meaning that the item remains on the stack). This is also called <b>top</b> operation in many articles.</entry>
<entry level="1" type="bullet">

 <it>Swap</it> or <it>exchange</it>: the two topmost items on the stack exchange places.</entry>
<entry level="1" type="bullet">

 <it>Rotate</it>: the <it>n</it> topmost items are moved on the stack in a rotating fashion. For example, if <it>n</it>=3, items 1, 2, and 3 on the stack are moved to positions 2, 3, and 1 on the stack, respectively.  Many variants of this operation are possible, with the most common being called <it>left rotate</it> and <it>right rotate.''</it></entry>
</list>
</p>
<p>

Stacks are either visualized growing from the bottom up (like real-world stacks), or, with the top of the stack in a fixed position (see image), a coin holder (<weblink xlink:type="simple" xlink:href="http://www.containerstore.com/browse/Product.jhtml?CATID=77006&amp;PRODID=64041">
http://www.containerstore.com/browse/Product.jhtml?CATID=77006&amp;PRODID=64041</weblink>) or growing from left to right, so that "topmost" becomes "rightmost". This visualization may be independent of the actual structure of the stack in memory. This means that a <it>right rotate</it> will move the first element to the third position, the second to the first and the third to the second. Here are two equivalent visualisations of this process:</p>
<p>

apple                                     banana
banana                 ==right rotate==&amp;gt;  cucumber
cucumber                                  apple</p>
<p>

cucumber                                 apple
banana            ==left rotate==&amp;gt;       cucumber 
apple                                    banana</p>
<p>

A stack is usually represented in computers by a block of memory cells, with the "bottom" at a fixed location, and the stack pointer holding the address of the current "top" cell in the stack.  The top and bottom terminology are used irrespective of whether the stack actually grows towards lower memory addresses or towards higher memory addresses.</p>
<p>

Pushing an item on to the stack adjusts the stack pointer by the size of the item (either decrementing or incrementing, depending on the direction in which the stack grows in memory), pointing it to the next cell, and copies the new top item to the stack area. Depending again on the exact implementation, at the end of a push operation, the stack pointer may point to the next unused location in the stack, or it may point to the topmost item in the stack.  If the stack points to the current topmost item, the stack pointer will be updated before a new item is pushed onto the stack; if it points to the next available location in the stack, it will be updated <it>after</it> the new item is pushed onto the stack.</p>
<p>

Popping the stack is simply the inverse of pushing.  The topmost item in the stack is removed and the stack pointer is updated, in the opposite order of that used in the push operation.</p>

</ss1>
<ss1>
<st>
 Hardware support </st>

<p>

Many <link xlink:type="simple" xlink:href="../218/5218.xml">
CPUs</link> have registers that can be used as stack pointers. Some, like the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link></company>
 <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>, have special instructions that implicitly use a register dedicated to the job of being a stack pointer. Others, like the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../952/7952.xml">
DEC</link></company>
 <link xlink:type="simple" xlink:href="../399/24399.xml">
PDP-11</link> and the <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/20319.xml">
Motorola</link></company>
 <link xlink:type="simple" xlink:href="../826/64826.xml">
68000 family</link> have addressing modes that make it possible to use any of a set of registers as a stack pointer. The <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link></company>
 <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../726/924726.xml">
80x87</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 series of numeric coprocessors has a set of registers that can be accessed either as a stack or as a series of numbered registers. Some <link xlink:type="simple" xlink:href="../017/21017.xml">
microcontroller</link>s, for example some <link xlink:type="simple" xlink:href="../588/184588.xml">
PIC</link>s, have a fixed-depth stack that is not directly accessible. Sun's <link xlink:type="simple" xlink:href="../954/36954.xml">
SPARC</link> has a number of register windows organized as a stack which significantly reduces the need to use memory for passing function's arguments and return values.</p>
<p>

There are also a number of microprocessors which implement a stack directly in hardware:</p>
<p>

<list>
<entry level="1" type="bullet">

 Computer Cowboys MuP21 </entry>
<entry level="1" type="bullet">

 Harris RTX line</entry>
<entry level="1" type="bullet">

 Novix NC4016</entry>
</list>
</p>
<p>

Many stack-based microprocessors were used to implement the programming language <link xlink:type="simple" xlink:href="../012/11012.xml">
Forth</link> at the <link xlink:type="simple" xlink:href="../999/19999.xml">
microcode</link> level. Stacks were also used as a basis of a number of mainframes and mini computers. Such machines were called <link xlink:type="simple" xlink:href="../078/510078.xml">
stack machines</link>, the most famous being the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../693/332693.xml">
Burroughs B5000</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
.</p>

</ss1>
</sec>
<sec>
<st>
 Software support </st>
<p>

In application programs written in a <link xlink:type="simple" xlink:href="../842/189842.xml">
high level language</link>, a stack can be implemented efficiently using either <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>s or <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link>s. In <link xlink:type="simple" xlink:href="../016/18016.xml">
LISP</link> there is no need to implement the stack, as the functions <b>push</b> and <b>pop</b> are available for any list.  <link xlink:type="simple" xlink:href="../080/24080.xml">
Adobe PostScript</link> is also designed around a stack that is directly visible to and manipulated by the programmer. </p>

</sec>
<sec>
<st>
Applications</st>
<p>

Stacks are ubiquitous in the computing world.</p>

<ss1>
<st>
 Expression evaluation and syntax parsing </st>
<p>

Calculators employing <link xlink:type="simple" xlink:href="../513/26513.xml">
reverse Polish notation</link> use a stack structure to hold values. Expressions can be represented in prefix, postfix or infix notations. Conversion from one form of the expression to another form needs a stack. Many compilers use a stack for parsing the syntax of expressions, program blocks etc. before translating into low level code. Most of the programming languages are <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free languages</link> allowing them to be parsed with stack based machines.</p>
<p>

For example, The calculation: ((1 + 2) * 4) + 3 can be written down like this in postfix notation with the advantage of no precedence rules and parentheses needed:
1 2 + 4 * 3 +
The expression is evaluated from the left to right using a stack: 
<list>
<entry level="1" type="bullet">

 push when encountering an operand and </entry>
<entry level="1" type="bullet">

 pop two operands and evaluate the value when encountering an operation. </entry>
<entry level="1" type="bullet">

 push the result</entry>
</list>

Like the following way (the <it>Stack</it> is displayed after <it>Operation</it> has taken place):</p>
<p>

<table>
<header>
Input</header>
<header>
Operation</header>
<header>
Stack</header>
<row>
<col>
1</col>
<col>
Push operand</col>
<col>
1</col>
</row>
<row>
<col>
2</col>
<col>
Push operand</col>
<col>
1, 2</col>
</row>
<row>
<col>
+</col>
<col>
Add</col>
<col>
3</col>
</row>
<row>
<col>
4</col>
<col>
Push operand</col>
<col>
3, 4</col>
</row>
<row>
<col>
*</col>
<col>
Multiply</col>
<col>
12</col>
</row>
<row>
<col>
3</col>
<col>
Push operand</col>
<col>
12, 3</col>
</row>
<row>
<col>
+</col>
<col>
Add</col>
<col>
15</col>
</row>
</table>
</p>
<p>

The final result, 15, lies on the top of the stack at the end of the calculation.</p>
<p>

example : 
implementation in pascal. using marked sequential file as data archives.</p>

<p>

{
programmer : clx321
file  : stack.pas
unit  : Pstack.tpu
}
program TestStack;
{this program use ADT of Stack, i will assume that the unit of ADT of Stack has already existed}</p>
<p>

uses
PStack;   {ADT of STACK}</p>
<p>

{dictionary}
const
mark = '.';</p>
<p>

var
data : stack;
f : text;
cc : char;
ccInt, cc1, cc2 : integer;</p>
<p>

{functions}
IsOperand (cc : char) : boolean;    {JUST  Prototype}
{return TRUE if cc is operand}
ChrToInt (cc : char) : integer;     {JUST Prototype}
{change char to integer}
Operator (cc1, cc2 : integer) : integer;     {JUST Prototype}
{operate two operands}</p>
<p>

{algorithms}
begin
assign (f, cc);
reset (f);
read (f, cc);  {first elmt}
if (cc = mark) then
begin
writeln ('empty archives !');
end
else   
begin
repeat
if (IsOperand (cc)) then
begin
ccInt := ChrToInt (cc);
push (ccInt, data);               
end
else
begin
pop (cc1, data);
pop (cc2, data);
push (data, Operator (cc2, cc1));
end;
read (f, cc);   {next elmt}
until (cc = mark);
end;
close (f);
end.</p>


</ss1>
<ss1>
<st>
 Runtime memory management </st>

<p>

<indent level="1">

<it>Main articles: <link xlink:type="simple" xlink:href="../265/1836265.xml">
Stack-based memory allocation</link>&#32;and&#32;<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../078/510078.xml">
Stack machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</it>
</indent>

A number of <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s are <link xlink:type="simple" xlink:href="../837/910837.xml">
stack-oriented</link>, meaning they define most basic operations (adding two numbers, printing a character) as taking their arguments from the stack, and placing any return values back on the stack. For example, <link xlink:type="simple" xlink:href="../080/24080.xml">
PostScript</link> has a return stack and an operand stack, and also has a graphics state stack and a dictionary stack.</p>
<p>

<link xlink:type="simple" xlink:href="../012/11012.xml">
Forth</link> uses two stacks, one for argument passing and one for subroutine <link xlink:type="simple" xlink:href="../099/970099.xml">
return address</link>es. The use of a return stack is extremely commonplace, but the somewhat unusual use of an argument stack for a human-readable programming language is the reason Forth is referred to as a <it><link xlink:type="simple" xlink:href="../837/910837.xml">
stack-based</link></it> language.</p>
<p>

Many <link xlink:type="simple" xlink:href="../353/32353.xml">
virtual machine</link>s are also stack-oriented, including the <link xlink:type="simple" xlink:href="../722/24722.xml">
p-code machine</link> and the <link xlink:type="simple" xlink:href="../389/16389.xml">
Java virtual machine</link>..</p>
<p>

Almost all computer runtime memory environments use a special stack (the "<link xlink:type="simple" xlink:href="../105/1718105.xml">
call stack</link>") to hold information about procedure/function calling and nesting in order to switch to the context of the called function and restore to the caller function when the calling finishes. They follow a runtime protocol between caller and callee to save arguments and return value on the stack. Stacks are an important way of supporting nested or <link xlink:type="simple" xlink:href="../407/25407.xml">
recursive</link> function calls. This type of stack is used implicitly by the compiler to support CALL and RETURN statements (or their equivalents) and is not manipulated directly by the programmer.</p>
<p>

Some programming languages use the stack to store data that is local to a procedure. Space for local data items is allocated from the stack when the procedure is entered, and is deallocated when the procedure exits. The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
 is typically implemented in this way. Using the same stack for both data and procedure calls has important security implications (see below) of which a programmer must be aware in order to avoid introducing serious security bugs into a program.</p>

</ss1>
<ss1>
<st>
 Solving search problems </st>
<p>

Solving a <link xlink:type="simple" xlink:href="../816/1471816.xml">
search problem</link>, regardless of whether the approach is exhaustive or optimal, needs stack space. Examples of exhaustive search methods are bruteforce and backtracking. Examples of optimal search exploring methods are branch and bound and <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic solutions</link>. All of these <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s use stacks to remember the search nodes that have been noticed but not explored yet. The only alternative to using a stack is to use recursion and let the compiler do the remembering for you (but in this case the compiler is still using a stack internally). The use of stacks is prevalent in many problems, ranging from simple in-order traversals of trees or depth-first traversals of graphs to a <link xlink:type="simple" xlink:href="../760/69760.xml">
crossword puzzle</link> solver or <link xlink:type="simple" xlink:href="../367/68367.xml">
computer chess</link> game.  Some of these problems can be solved by alternative data structures like a <link xlink:type="simple" xlink:href="../265/25265.xml">
queue</link>, when a different order of traversal is required.</p>

</ss1>
</sec>
<sec>
<st>
 Security </st>
<p>

Some computing environments use stacks in ways that may make them vulnerable to security breaches and attacks.  Programmers working in such environments must take special care to avoid the pitfalls of these implementations.</p>
<p>

For example, some programming languages use a common stack to store both data local to a called procedure and the linking information that allows the procedure to return to its caller.  This means that the program moves data into and out of the same stack that contains critical return addresses for the procedure calls.  If data is moved to the wrong location on the stack, or an oversized data item is moved to a stack location that is not large enough to contain it, return information for procedure calls may be corrupted, causing the program to fail.</p>
<p>

Malicious parties may attempt to take advantage of this type of implementation by providing oversized data input to a program that does not check the length of input.  Such a program may copy the data in its entirety to a location on the stack, and in so doing it may change the return addresses for procedures that have called it.  An attacker can experiment to find a specific type of data that can be provided to such a program such that the return address of the current procedure is reset to point to an area within the stack itself (and within the data provided by the attacker), which in turn contains instructions that carry out unauthorized operations.</p>
<p>

This type of attack is a variation on the <link xlink:type="simple" xlink:href="../373/4373.xml">
buffer overflow</link> attack and is an extremely frequent source of security breaches in software, mainly because some of the most popular programming languages (such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
) use a shared stack for both data and procedure calls, and do not verify the length of data items.  Frequently programmers do not write code to verify the size of data items, either, and when an oversized or undersized data item is copied to the stack, a security breach may occur.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 Compare with <link>
queue</link>, <link xlink:type="simple" xlink:href="../904/8904.xml">
deque</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../105/1718105.xml">
Call stack</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../265/1836265.xml">
Stack-based memory allocation</link></entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../592/4122592.xml">
computer network</link>ing term <link xlink:type="simple" xlink:href="../882/23882.xml">
protocol stack</link></entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../078/510078.xml">
Stack machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 </entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
Horowitz, Ellis: "Fundamentals of Data Structures in Pascal", page 67. Computer Science Press, 1984</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading </st>
<p>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
. <it>The Art of Computer Programming</it>, Volume 1: <it>Fundamental Algorithms</it>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89683-4. Section 2.2.1: Stacks, Queues, and Deques, pp. 238&ndash;243.</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 10.1: Stacks and queues, pp.200&ndash;204.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://24bytes.com/stack.html">
Stack program in c++ </weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ece.cmu.edu/~koopman/stack_computers/index.html">
Stack Machines - the new wave</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.utah.edu/~regehr/stacktool">
Bounding stack depth</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://research.avayalabs.com/project/libsafe/">
Libsafe - Protecting Critical Elements of Stacks</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.ucla.edu/~palsberg/paper/sas03.pdf">
Stack Size Analysis for Interrupt-driven Programs</weblink> (322 KB)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mycplus.com/utilitiesdetail.asp?iPro=1">
Stack Implementation ( Graphical &amp; Text Mode)</weblink> C Language implementation of Stack</entry>
<entry level="1" type="bullet">

 Pointers to <weblink xlink:type="simple" xlink:href="http://web-cat.cs.vt.edu/AlgovizWiki/Stacks">
stack visualizations</weblink></entry>
<entry level="1" type="bullet">

 Paul E. Black, <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/boundedstack.html">
Bounded stack</weblink> at the <link xlink:type="simple" xlink:href="../888/21888.xml">
NIST</link> <link xlink:type="simple" xlink:href="../551/1661551.xml">
Dictionary of Algorithms and Data Structures</link>.</entry>
</list>


</p>

</sec>
</bdy>
</article>
