<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:48:51[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>DPLL algorithm</title>
<id>2745094</id>
<revision>
<id>235098057</id>
<timestamp>2008-08-30T00:55:18Z</timestamp>
<contributor>
<username>Linas</username>
<id>159886</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Constraint satisfaction</category>
<category>Automated theorem proving</category>
</categories>
</header>
<bdy>

The <b>DPLL/Davis-Putnam-Logemann-Loveland</b> algorithm is a complete, <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link>-based <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for deciding the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
satisfiability</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 of <link xlink:type="simple" xlink:href="../335/5597335.xml">
propositional logic formulae</link> in <link xlink:type="simple" xlink:href="../342/73342.xml">
conjunctive normal form</link>, i.e. for solving the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
CNF-SAT</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 problem. <p>

It was introduced in <link xlink:type="simple" xlink:href="../717/34717.xml">
1962</link> by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../233/75233.xml">
Hilary Putnam</link></philosopher>
</person>
, <link>
George Logemann</link> and <link>
Donald W. Loveland</link>, and is a refinement of the earlier <link xlink:type="simple" xlink:href="../435/2732435.xml">
Davis-Putnam algorithm</link>, which is a resolution-based procedure developed by Davis and Putnam in <link xlink:type="simple" xlink:href="../664/34664.xml">
1960</link>. Especially in older publications, the Davis-Logemann-Loveland algorithm is often referred to as the “Davis-Putnam method” or the “DP algorithm”. Other common names that maintain the distinction are DLL and DPLL.</p>
<p>

DPLL is a highly efficient procedure, and after more than 40 years still forms the basis for most efficient complete SAT solvers, as well as for many <link xlink:type="simple" xlink:href="../546/2546.xml">
theorem provers</link> for fragments of <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link>.</p>

<sec>
<st>
The algorithm</st>

<p>

The basic backtracking algorithm runs by choosing a literal, assigning a truth value to it, simplifying the formula and then recursively checking if the simplified formula is satisfiable; if this is the case, the original formula is satisfiable; otherwise, the same recursive check is done assuming the opposite truth value. This is known as the <it>splitting rule</it>, as it splits the problem into two simpler sub-problems. The simplification step  essentially removes all clauses which become true under the assignment from the formula, and all literals that become false from the remaining clauses. </p>
<p>

The DPLL algorithm enhances over the backtracking algorithm by the eager use of the following rules at each step:</p>
<p>

<list>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../761/2730761.xml">
Unit propagation</link> : If a clause is a <it>unit clause</it>, i.e. it contains only a single unassigned literal, this clause can only be satisfied by assigning the necessary value to make this literal true. Thus, no choice is necessary. In practice, this often leads to deterministic cascades of units, thus avoiding a large part of the naive search space.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Pure literal elimination : If a <link xlink:type="simple" xlink:href="../562/1557562.xml">
propositional variable</link> occurs with only one polarity in the formula, it is called <it>pure</it>. Pure literals can always be assigned in a way that makes all clauses containing them true. Thus, these clauses do not constrain the search anymore and can be deleted. While this optimization is part of the original DPLL algorithm, most current implementations omit it, as the effect for efficient implementations now is negligible or, due to the overhead for detecting purity, even negative.</entry>
</list>
</p>
<p>

Unsatisfiability of a given partial assignment is  detected if one clause becomes empty, i.e. if all its variables have been assigned in a way that makes the corresponding literals false. Satisfiability of the formula is detected either when all variables are assigned without generating the empty clause, or, in modern implementations, if all clauses are satisfied. Unsatisfiability of the complete formula can only be detected after exhaustive search.</p>
<p>

The DPLL algorithm can be summarized in the following pseudocode, where Φ is the CNF formula:</p>
<p>

function DPLL(Φ)
if Φ is a consistent set of literals
then return true;
if Φ contains an empty clause 
then return false;
for every unit clause l in Φ
Φ=unit-propagate(l, Φ);
for every literal l that occurs pure in Φ
Φ=pure-literal-assign(l, Φ);
l := choose-literal(Φ);
return DPLL(ΦΛl) OR DPLL(ΦΛnot(l));</p>
<p>

In this pseudocode, unit-propagate(l, Φ) and pure-literal-assign(l, Φ) are functions that return the result of applying unit propagation and the pure literal rule, respectively, to the literal l and the formula Φ. In other words, they replace every occurrence of l with "true" and every occurrence of not l with "false" in the formula Φ, and simplify the resulting formula. The pseudocode DPLL function only returns whether the final assignment satisfies the formula or not. In a real implementation, the partial satisfying assignment typically is also returned on success; this can be derived from the consistent set of literals of the first if statement of the function.</p>
<p>

The Davis-Logemann-Loveland algorithm depends on the choice of <it>branching literal</it>, which is the literal considered in the backtracking step. As a result, this is not exactly an algorithm, but rather a family of algorithms, one for each possible way of choosing the branching literal. Efficiency is strongly affected by the choice of the branching literal: there exist instances for which the running time is constant or exponential depending on the choice of the branching literals.</p>

</sec>
<sec>
<st>
Current work</st>

<p>

Current work on improving the algorithm has been done on three directions: defining different policies for choosing the branching literals; defining new data structures to make the algorithm faster, especially the part on unit propagation; and defining variants of the basic backtracking algorithm. The latter direction include <it>non-chronological backtracking</it> and <it><link xlink:type="simple" xlink:href="../484/4638484.xml">
clause</link> learning</it>. These refinements describe a method of backtracking after reaching a conflict clause which "learns" the root causes (assignments to variables) of the conflict in order to avoid reaching the same conflict again.</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../435/2732435.xml">
Davis-Putnam algorithm</link></entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<problem_solver wordnetid="110458111" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<thinker wordnetid="110708454" confidence="0.8">
<link xlink:type="simple" xlink:href="../930/2045930.xml">
Chaff algorithm</link></thinker>
</causal_agent>
</intellectual>
</person>
</problem_solver>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../284/2801284.xml">
Proof complexity</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../699/5821699.xml">
Herbrandization</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Davis, Martin</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
; <link xlink:type="simple" xlink:href="../233/75233.xml">
Putnam, Hillary</link>&#32;(1960).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl=GUIDE&amp;id=321034">
A Computing Procedure for Quantification Theory</weblink>". <it><magazine wordnetid="106595351" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../845/2321845.xml">
Journal of the ACM</link></magazine>
</it>&#32;<b>7</b>&#32;(1): 201–215. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F321033.321034">
10.1145/321033.321034</weblink>.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal">Davis, Martin; Logemann, George, and Loveland, Donald&#32;(1962).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=368273.368557">
A Machine Program for Theorem Proving</weblink>". <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>&#32;<b>5</b>&#32;(7): 394–397. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F368273.368557">
10.1145/368273.368557</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal">Ouyang, Ming&#32;(1998).&#32;"How Good Are Branching Rules in DPLL?". <it>Discrete Applied Mathematics</it>&#32;<b>89</b>&#32;(1–3): 281–286. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2FS0166-218X%2898%2900045-6">
10.1016/S0166-218X(98)00045-6</weblink>.</cite>&nbsp;</entry>
</list>
</p>


</sec>
</bdy>
</article>
