<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:42:55[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Type inference</title>
<id>279690</id>
<revision>
<id>240780691</id>
<timestamp>2008-09-24T23:34:08Z</timestamp>
<contributor>
<username>MrBlueSky</username>
<id>7476536</id>
</contributor>
</revision>
<categories>
<category>Type theory</category>
</categories>
</header>
<bdy>

<b>Type inference</b>, or <b>implicit typing</b>, refers to the ability to deduce automatically the type of a value in a <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>. It is a feature present in some <link xlink:type="simple" xlink:href="../585/919585.xml">
strongly</link> <link>
statically typed</link> languages.  It is often characteristic of — but not limited to — <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming language</link>s in general. Some languages that include type inference are:  <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../242/1242.xml">
Ada</link></causal_agent>
</physical_entity>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../624/1147624.xml">
Boo</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml#xpointer(//*[./st=%22C.23_3.0_new_language_features%22])">
C# 3.0</link></programming_language>
, <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../823/6528823.xml">
Cayenne</link></language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../878/161878.xml">
Clean</link></programming_language>
, <link xlink:type="simple" xlink:href="../555/13862555.xml">
Cobra</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../881/243881.xml">
D</link></programming_language>
, <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../143/1933143.xml">
Epigram</link></language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../964/239964.xml">
F#</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../607/20607.xml">
ML</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../708/493708.xml">
Nemerle</link></programming_language>
 , <link xlink:type="simple" xlink:href="../652/39652.xml">
OCaml</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../746/4249746.xml">
Oxygene</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/3254510.xml">
Scala</link></programming_language>
, and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link>
Visual Basic .NET 9.0</link></programming_language>
.  This feature is planned for <link xlink:type="simple" xlink:href="../171/1822171.xml">
Fortress</link>, <link xlink:type="simple" xlink:href="../447/5481447.xml">
C++0x</link> and <link xlink:type="simple" xlink:href="../638/1146638.xml">
Perl 6</link>. The ability to infer types automatically makes many programming tasks easier, leaving the programmer free to omit <link xlink:type="simple" xlink:href="../693/279693.xml">
type annotations</link> while maintaining some level of type safety. Explicitly converting to another data type is called "<link xlink:type="simple" xlink:href="../390/555390.xml">
casting</link>" (or a "<link xlink:type="simple" xlink:href="../390/555390.xml">
cast</link>").
<sec>
<st>
Nontechnical explanation</st>

<p>

In most programming languages, all values have a <link xlink:type="simple" xlink:href="../817/93817.xml">
type</link> which describes the kind of data a particular value describes. In some languages, the type is known only at <link xlink:type="simple" xlink:href="../263/192263.xml">
runtime</link>; these languages are <link xlink:type="simple" xlink:href="../701/199701.xml">
dynamically typed</link>. In other languages, the type is known at <link xlink:type="simple" xlink:href="../766/191766.xml">
compile time</link>; these languages are <link>
statically typed</link>. In statically typed languages, the input and output types of functions and <link xlink:type="simple" xlink:href="../152/1718152.xml">
local variable</link>s ordinarily must be explicitly provided by type annotations. For example, in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
:</p>
<p>

int addone(int x) {
int result; /*declare integer result (C language)*/</p>
<p>

result = x+1;
return result;
}</p>
<p>

The beginning of this function definition, int addone(int x) declares that addone is a function which takes one argument, an <link xlink:type="simple" xlink:href="../794/14794.xml">
integer</link>, and returns an integer. int result; declares that the local variable result is an integer. In a proposed language where type inference is available, the code might be written like this instead:
addone(x) {
val result;  /*inferred-type result (in proposed language)*/
val result2; /*inferred-type result #2 */</p>
<p>

result = x+1;
result2 = x+1.0;  /* this line won't work */
return result;
}
This looks very similar to how code is written in a dynamically typed language, yet all types are known at compile time. In the imaginary language in which the last example is written, + always takes two integers and returns one integer. (This is how it works in, for example, <link xlink:type="simple" xlink:href="../652/39652.xml">
OCaml</link>.) From this, the type inferencer can infer that the value of x+1 is an integer, therefore result is an integer, therefore the return value of addone is an integer. Similarly, since + requires that both of its arguments be integers, x must be an integer, and therefore addone accepts one integer as an argument.</p>
<p>

However, in the subsequent line, <it>result2</it> is calculated by adding a decimal "1.0" with floating-point arithmetic, causing a conflict in the use of x for both integer and floating-point expressions. Such a situation would generate a compile-time error message. In older languages, <it>result2</it> might have been implicitly declared as a floating-point variable, from implicitly converting integer x in the expression, simply because a decimal point was accidentally placed after the integer 1.  Such a situation shows the difference between <it>type inference</it>, which does not involve type conversion, and <it><link xlink:type="simple" xlink:href="../390/555390.xml">
implicit type conversion</link></it>, which forces data to the higher-precision data type, often without restrictions.</p>

</sec>
<sec>
<st>
Technical description</st>

<p>

Type inference refers to the ability to deduce automatically, either partially or fully, the type of a value derived from the eventual evaluation of an expression.  As this process is systematically performed at compile time, the compiler is often able to infer the type of a variable or the <link xlink:type="simple" xlink:href="../693/279693.xml">
type signature</link> of a function, without explicit type annotations having been given.  In many cases, it is possible to omit type annotations from a program completely if the type inference system is robust enough, or the program or language simple enough.</p>
<p>

To obtain the information required to infer correctly the type of an expression lacking an explicit type annotation, the compiler either gathers this information as an aggregate and subsequent reduction of the type annotations given for its subexpressions (which may themselves be variables or functions), or through an implicit understanding of the type of various atomic values (e.g., () : <link xlink:type="simple" xlink:href="../268/3646268.xml">
Unit</link>; true : Bool; 42 : Integer; 3.14159 : Real; etc.).  It is through recognition of the eventual reduction of expressions to implicitly typed atomic values that the compiler for a type inferring language is able to compile a program completely without type annotations.  In the case of highly complex forms of <link xlink:type="simple" xlink:href="../963/2855963.xml">
higher order programming</link> and  <link xlink:type="simple" xlink:href="../811/261811.xml">
polymorphism</link>, it is not always possible for the compiler to infer as much, however, and type annotations are occasionally necessary for disambiguation.</p>

</sec>
<sec>
<st>
Example</st>
<p>

For example, let us consider the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
 function map, which applies a procedure to each element of a list, and may be defined as:
map f  = 
map f (first:rest) = f first : map f rest</p>
<p>

From this, it is evident that the function map takes a list as its second argument, that its first argument f is a function that can be applied to the type of elements of that list, and that the result of map is constructed as a list with elements that are results of f.
So assuming that a list contains elements of the same type, we can reliably construct a type signature
map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]
where the syntax "a -&amp;gt; b" denotes a function that takes an a as its parameter and produces a b.  "a -&amp;gt; b -&amp;gt; c" is equivalent to "a -&amp;gt; (b -&amp;gt; c)".</p>
<p>

Note that the inferred type of map is <link xlink:type="simple" xlink:href="../811/261811.xml">
parametrically polymorphic</link>: The type of the arguments and results of f are not inferred, but left as type variables, and so map can be applied to functions and lists of various types, as long as the actual types match in each invocation.</p>

</sec>
<sec>
<st>
Hindley–Milner type inference algorithm</st>
<p>

The common algorithm used to perform type inference is the one now commonly referred to as Hindley–Milner, Damas–Milner algorithm. It has been referred to in the past as polymorphic type checking or Algorithm W.</p>
<p>

The origin of this algorithm is the type inference algorithm for the <link xlink:type="simple" xlink:href="../011/1986011.xml">
simply typed lambda calculus</link>, which was devised by <link xlink:type="simple" xlink:href="../182/42182.xml">
Haskell B. Curry</link> and <person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../962/5154962.xml">
Robert Feys</link></person>
 in 1958.
In 1969 <link>
Roger Hindley</link> extended this work and proved that their algorithm always inferred the most general type.
In 1978 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../547/93547.xml">
Robin Milner</link></scientist>
</person>
 <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, independently of Hindley's work, provided an equivalent algorithm, Algorithm W. 
In 1982 <link>
Luis Damas</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> finally proved that Milner's algorithm is complete and extended it to support systems with polymorphic references.</p>

<ss1>
<st>
The algorithm</st>
<p>

The algorithm proceeds in two steps. First, we need to generate a number of equations to solve, then we need to solve them.</p>

<ss2>
<st>
Generating the equations</st>
<p>

The algorithm used for generating the equations is similar to a regular type checker, so let's consider first a regular type checker for the <link xlink:type="simple" xlink:href="../208/366208.xml">
typed lambda calculus</link> given by</p>
<p>

<math>e \, ::= E \mid v \mid (\lambda v:\tau. e) \mid (e\, e)</math></p>
<p>

and</p>
<p>

<math>\tau \, ::= T \mid \tau \to \tau </math></p>
<p>

where <math>E</math> is a primitive expression (such as "3") and <math>T</math> is a primitive type (such as "Integer").</p>
<p>

We want to construct a function <math>f</math> which maps a pair <math>(\epsilon, t)</math>, where <math>\epsilon</math> is a type environment and <math>t</math> is a term, to some type <math>\tau</math>. We assume that this function is already defined on primitives. The other cases are:</p>
<p>

<list>
<entry level="1" type="bullet">

 <math>f(\epsilon, v) = \tau</math> where <math>(v, \tau)</math> is in <math>\epsilon</math></entry>
<entry level="1" type="bullet">

 <math>f(\epsilon, g\, e) = \tau</math> where <math>f(\epsilon, g) = \tau_1 \to \tau</math> and <math>f(\epsilon, e) = \tau_1</math></entry>
<entry level="1" type="bullet">

 <math>f(\epsilon, \lambda v:\tau. e) = \tau \to f(\epsilon_1, e)</math> where <math>\epsilon_1 = \epsilon \cup (v, \tau)</math></entry>
</list>
</p>
<p>

Note that so far we do not specify what to do when we fail to meet the various conditions. This is because, in the simple type <it>checking</it> algorithm, the check simply fails whenever anything goes wrong.</p>
<p>

Now, we develop a more sophisticated algorithm that can deal with type variables and constraints on them. Therefore, we extend the set T of primitive types to include an infinite supply of variables, denoted by lowercase Greek letters <math>\alpha, \beta, ...</math></p>
<p>

See <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> for more details.</p>

</ss2>
<ss2>
<st>
Solving the equations</st>
<p>

Solving the equations proceeds by <link xlink:type="simple" xlink:href="../432/54432.xml">
unification</link>. This is&mdash;maybe surprisingly&mdash;a rather simple algorithm. The function <math>u</math> operates on type equations and returns a structure called a "substitution". A substitution is simply a mapping from type variables to types. Substitutions can be composed and extended in the obvious ways.</p>
<p>

Unifying the empty set of equations is easy enough: <math>u\, \emptyset = \mathbf{i}</math>, where <math>\mathbf{i}</math> is the identity substitution.</p>
<p>

Unifying a variable with a type goes this way: <math>u\, ([\alpha = T] \cup C) = u\, (C') \cdot (\alpha \mapsto T)</math>, where <math>\cdot</math> is the substitution composition operator, and <math>C'</math> is the set of remaining constraints <math>C</math> with the new substitution <math>\alpha \mapsto T</math> applied to it.</p>
<p>

Of course, <math>u\, ([T = \alpha] \cup C) = u ([\alpha = T] \cup C)</math>.</p>
<p>

The interesting case remains as <math>u\, ([S \to S' = T \to T']\cup C) = u \, (\{[S = T], [S' = T']\}\cup C)</math>.</p>
<p>

A simple example would be a[i] = b[i] (assume this to be c-like syntax for this example). First Hindley-Milner would find that i must be of type int, further more that 'a' must be an "array of <math>\alpha</math>" and 'b' must an "array of <math>\beta</math>". Now, since there is an assignment of <math>\beta</math> to <math>\alpha</math>, <math>\alpha</math> must be of the same type (assuming no implicit type conversions) as <math>\beta</math>. In the very least <math>\alpha</math> must be a supertype of <math>\beta</math>.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
 <cite id="CITEREFMilner1978" style="font-style:normal">Milner, Robin&#32;(1978),&#32;"A Theory of Type Polymorphism in Programming",&#32;<it>jcss</it>&#32;<b>17</b>:  348-375</cite>&nbsp;</entry>
<entry id="2">
 <cite id="CITEREFDamasMilner1982" style="font-style:normal">Damas, Luis&#32;&amp;&#32;Milner, Robin&#32;(1982),&#32;<weblink xlink:type="simple" xlink:href="http://groups.csail.mit.edu/pag/6.883/readings/p207-damas.pdf">
"Principal type-schemes for functional programs"</weblink>,&#32;<it>POPL '82: Proceedings of the 9th ACM SIGPLAN-SIGACT symposium on Principles of programming languages</it>, ACM, pp. 207--212, </cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../961/1381961.xml">
Pierce, Benjamin C.</link></scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(2002).&#32;"Chapter 22", Types and Programming Languages.&#32;MIT Press. ISBN 0-262-16209-1.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../018/440018.xml">
Duck typing</link>, an analogous concept in languages with dynamic or weak typing</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cis.upenn.edu/~bcpierce/types/archives/1988/msg00042.html">
Archived e-mail message</weblink> by Roger Hindley explaining the history of type inference</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://web.archive.org/web/20050911123640/http://www.cs.berkeley.edu/~nikitab/courses/cs263/hm.html">
Implementation</weblink> of Hindley-Milner in Perl 5, by Nikita Borisov (via <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<facility wordnetid="103315023" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<depository wordnetid="103177349" confidence="0.8">
<archive wordnetid="102735086" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/176931.xml">
Internet Archive</link></room>
</archive>
</depository>
</library>
</facility>
</area>
</artifact>
</structure>
, version <link xlink:type="simple" xlink:href="../935/27935.xml">
Sep 11</link><link xlink:type="simple" xlink:href="../984/35984.xml">
2005</link>)</entry>
</list>
</p>


</sec>
</bdy>
</article>
