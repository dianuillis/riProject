<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:35:08[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Search algorithm</title>
<id>28249</id>
<revision>
<id>237797096</id>
<timestamp>2008-09-11T21:21:08Z</timestamp>
<contributor>
<username>TaBOT-zerem</username>
<id>7359933</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
</categories>
</header>
<bdy>
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>search algorithm</b>, broadly speaking, is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that takes a problem as <link xlink:type="simple" xlink:href="../264/41264.xml">
input</link> and returns a solution to the problem, usually after evaluating a number of possible solutions. Most of the algorithms studied by computer scientists that solve problems are kinds of search algorithms. The set of all possible solutions to a problem is called the <link xlink:type="simple" xlink:href="../707/389707.xml">
search space</link>. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../127/103127.xml">
Brute-force search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 or "na√Øve"/uninformed search algorithms use the simplest method of searching through the search space, whereas informed search algorithms use <link xlink:type="simple" xlink:href="../629/14220629.xml">
heuristic function</link>s to apply knowledge about the structure of the <link xlink:type="simple" xlink:href="../707/389707.xml">
search space</link> to try to reduce the amount of time spent searching.</p>

<sec>
<st>
 Uninformed search </st>
<p>

An uninformed search algorithm is one that does not take into account the specific nature of the problem. As such, they can be implemented in general, and then the same <link xlink:type="simple" xlink:href="../704/407704.xml">
implementation</link> can be used in a wide range of problems thanks to <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/60491.xml">
abstraction</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
. The drawback is that most <link xlink:type="simple" xlink:href="../707/389707.xml">
search space</link>s are extremely large, and an uninformed search (especially of a tree) will take a reasonable amount of time only for small examples. As such, to speed up the process, sometimes only an informed search will do.</p>

</sec>
<sec>
<st>
 List search </st>
<p>

List search algorithms are perhaps the most basic kind of search algorithm. The goal is to find one element of a set by some key (perhaps containing other information related to the key).  As this is a common problem in <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link> of these algorithms has been well studied. The simplest such  algorithm is <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link>, which simply examines each element of the list in order.  It has expensive <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(n) running time, where <it>n</it> is the number of items in the list, but can be used directly on any unprocessed list. A more sophisticated list search algorithm is <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link>; it runs in <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(log <it>n</it>) time.  This is significantly better than <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link> for large lists of data, but it requires that the list be sorted before searching (see <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>) and also be <link xlink:type="simple" xlink:href="../612/25612.xml">
random access</link>. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../895/69895.xml">
Interpolation search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is better than binary search for large sorted lists with fairly even distributions, but has a worst-case running time of O(<it>n</it>).</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../498/58498.xml">
Grover's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a <link xlink:type="simple" xlink:href="../220/25220.xml">
quantum algorithm</link> that offers quadratic speedup over the classical linear search for unsorted lists. However, it requires a currently non-existent quantum computer on which to run.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../833/13833.xml">
Hash table</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s are also used for list search, requiring only <link xlink:type="simple" xlink:href="../550/5257550.xml">
constant time</link> for search in the average case, but more space overhead and terrible O(<it>n</it>) worst-case search time. Another search based on specialized data structures uses <link xlink:type="simple" xlink:href="../310/378310.xml">
self-balancing binary search tree</link>s and requires O(log <it>n</it>) time to search; these can be seen as extending the main ideas of binary search to allow fast insertion and removal. See <link xlink:type="simple" xlink:href="../154/95154.xml">
associative array</link> for more discussion of list search data structures. </p>
<p>

Most list search algorithms, such as linear search, binary search, and self-balancing binary search trees, can be extended with little additional cost to find all values less than or greater than a given key, an operation called <it>range search</it>. The glaring exception is hash tables, which cannot perform such a search efficiently.</p>

</sec>
<sec>
<st>
 Tree search </st>
<p>

<link xlink:type="simple" xlink:href="../584/597584.xml">
Tree search algorithm</link>s are the heart of searching techniques for structured data. These search <link xlink:type="simple" xlink:href="../560/48560.xml">
tree</link>s of <link xlink:type="simple" xlink:href="../074/998074.xml">
node</link>s, whether that tree is explicit or implicit (generated on the go). The basic principle is that a <link xlink:type="simple" xlink:href="../074/998074.xml">
node</link> is taken from a <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link>, its successors examined and added to the data structure. By manipulating the data structure, the tree is explored in different orders - for instance, level by level (<link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link>) or reaching a <link xlink:type="simple" xlink:href="../228/18228.xml">
leaf node</link> first and backtracking (<link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link>). Other examples of tree-searches include <link xlink:type="simple" xlink:href="../326/433326.xml">
iterative-deepening search</link>, <link xlink:type="simple" xlink:href="../285/890285.xml">
depth-limited search</link>, <link xlink:type="simple" xlink:href="../516/3157516.xml">
bidirectional search</link>, and <link xlink:type="simple" xlink:href="../989/2801989.xml">
uniform-cost search</link>.</p>
<p>

It should be realized that the efficiency of a tree search (compared to other search methods) is highly dependent upon the number and structure of nodes in relation to the number of items on that node. If there are a large number of items on one or more nodes, there may well be a requirement to utilize a specific different search technique for locating items within that particular set. In other words, a tree search is not mutually exclusive with any other search technique that may be used for specific sets. It is simply a method of reducing the number of relevant items to be searched (by whatever method) to those within certain branches of the tree. For example, the <region wordnetid="108630039" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../249/12249.xml">
Greater London</link></region>
 telephone directory may still contain entries for 20,000+ people whose surname is 'SMITH' belonging on a tree branch 'surnames beginning S'. The list of names may, or may not be, further subdivided by subscribers initials. A <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> may be appropriate to locate a particular person with forename 'Alias' and perhaps thereafter a <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link> to locate a particular address.</p>

</sec>
<sec>
<st>
Graph search</st>
<p>

Many of the problems in <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link> can be solved using <link xlink:type="simple" xlink:href="../731/6263731.xml">
graph traversal</link> algorithms, such as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, the <link xlink:type="simple" xlink:href="../926/41926.xml">
nearest neighbour algorithm</link>, and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. These can be seen as extensions of the tree-search algorithms.</p>

</sec>
<sec>
<st>
 Informed search </st>
<p>

In an informed search, a <link xlink:type="simple" xlink:href="../629/14220629.xml">
heuristic</link> that is specific to the problem is used as a guide. A good heuristic will make an informed search dramatically out-perform any uninformed search.</p>
<p>

There are few prominent informed list-search algorithms. A possible member of that category is a hash table with a hashing function that is a heuristic based on the problem at hand. Most informed search algorithms explore trees . These include <link xlink:type="simple" xlink:href="../271/148271.xml">
best-first search</link>, and <link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link>. Like the uninformed algorithms, they can be extended to work for graphs as well.</p>

</sec>
<sec>
<st>
 Adversarial search </st>
<p>

In games such as <link xlink:type="simple" xlink:href="../134/5134.xml">
chess</link>, there is a <link xlink:type="simple" xlink:href="../355/267355.xml">
game tree</link> of all possible moves by both players and the resulting board configurations, and we can search this tree to find an effective playing strategy. This type of problem has the unique characteristic that we must account for any possible move our opponent might make. To account for this, game-playing computer programs, as well as other forms of <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link> like <link>
machine planning</link>, often use search algorithms like the <link xlink:type="simple" xlink:href="../589/19589.xml">
minimax algorithm</link>, <link xlink:type="simple" xlink:href="../075/5462075.xml">
search tree pruning</link>, and <link xlink:type="simple" xlink:href="../501/159501.xml">
alpha-beta pruning</link>.</p>

</sec>
<sec>
<st>
 Constraint satisfaction </st>
<p>

This is a type of search which solves <link xlink:type="simple" xlink:href="../652/211652.xml">
constraint satisfaction problem</link>s where, rather than looking for a path, the solution is simply a set of values assigned to a set of variables. Because the variables can be processed in any order, the usual tree search algorithms are too inefficient. Methods of solving constraint problems include <link xlink:type="simple" xlink:href="../555/420555.xml">
combinatorial search</link> and <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link>, both of which take advantage of the freedom associated with constraint problems. Common tricks or techniques involved in <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link> is Constraint propagation, which is a general form of Forward checking. Other local search algorithms, such as generic algorithm, which minimize the conflicts, also do a good job.</p>

</sec>
<sec>
<st>
 Other types </st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../648/28648.xml">
String searching algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s search for patterns within <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link>; one popular data structure that makes this more efficient is the <link xlink:type="simple" xlink:href="../679/794679.xml">
suffix tree</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../254/40254.xml">
Genetic algorithms</link> and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../424/12424.xml">
Genetic programming</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 use ideas from <link xlink:type="simple" xlink:href="../236/9236.xml">
evolution</link> as heuristics for reducing the search space</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../442/28442.xml">
Sorting algorithm</link>s necessary for executing certain search algorithms</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/172244.xml">
Simulated annealing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a <link xlink:type="simple" xlink:href="../934/22934.xml">
probabilistic</link> search algorithm</entry>
<entry level="1" type="bullet">

 <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../646/596646.xml">
Recommender system</link></web_site>
</machine>
</device>
</instrumentality>
</artifact>
</computer>
s also use statistical methods to rank results in very large data sets</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../937/381937.xml">
Tabu search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a technique to avoid discrete searches getting stuck in local minima</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../086/2421086.xml">
Federated search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../589/19589.xml">
Minimax</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 which can be highly optimized using <link xlink:type="simple" xlink:href="../501/159501.xml">
alpha-beta pruning</link> is an algorithm to search for good moves in <link xlink:type="simple" xlink:href="../417/34417.xml">
zero-sum</link> games</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../583/4032583.xml">
Ternary search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../786/552786.xml">
Selection algorithm</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../402/1297402.xml">
No free lunch in search and optimization</link></entry>
<entry level="1" type="bullet">

 <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/1971750.xml">
Secretary problem</link></method>
</know-how>
 is an online (ie sequentially presented) search problem with imperfect information, and a statistically optimal strategy.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.gp-field-guide.org.uk/">
A Field Guide to Genetic Programming</weblink> by Poli, Langdon, and McPhee.  Available as a free PDF, or in printed form from Lulu.com.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://en.wikiversity.org/wiki/Uninformed_Search_Project">
Self-Guided Lesson on Uninformed Search</weblink> Go to the Wikiversity and teach yourself to program an uninformed search solution.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</article>
