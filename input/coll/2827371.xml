<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:52:16[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Immerman–Szelepcsényi theorem</title>
<id>2827371</id>
<revision>
<id>237269612</id>
<timestamp>2008-09-09T12:22:45Z</timestamp>
<contributor>
<username>EmilJ</username>
<id>94981</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
</categories>
</header>
<bdy>

The <b>Immerman–Szelepcsényi Theorem</b> was proven independently by <peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/1370768.xml">
Neil Immerman</link></scholar>
</causal_agent>
</alumnus>
</laureate>
</associate>
</recipient>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</physical_entity>
</peer>
 and <link>
Róbert Szelepcsényi</link> in <link xlink:type="simple" xlink:href="../760/34760.xml">
1987</link>, for which they shared the <link xlink:type="simple" xlink:href="../658/34658.xml">
1995</link> <link>
Gödel Prize</link>. In its general form the theorem states that <assets wordnetid="113329641" confidence="0.8">
<possession wordnetid="100032613" confidence="0.8">
<resource wordnetid="113331778" confidence="0.8">
<link xlink:type="simple" xlink:href="../518/658518.xml">
NSPACE</link></resource>
</possession>
</assets>
 = co-NSPACE. In other words, if a nondeterministic machine can solve a problem, it can solve its <link xlink:type="simple" xlink:href="../955/1929955.xml">
complement</link> problem (with the <it>yes</it> and <it>no</it> answers reversed) in the same asymptotic amount of space. No similar result is known for time.
<sec>
<st>
Proof </st>
<p>

Let <it>s(n)</it> ≥ log n be a <link xlink:type="simple" xlink:href="../783/906783.xml">
space constructible</link> function. Then <it>NSPACE[s(n)]=co-NSPACE[s(n)]</it></p>
<p>

The first step is to demonstrate that <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
=<link>
co-NL</link>. This can be accomplished by taking the <link xlink:type="simple" xlink:href="../034/2833034.xml">
st-connectivity</link>
problem (known to be <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../166/4595166.xml">
NL-complete</link></group>
</collection>
</class>
), and showing that the
complement of this problem (called <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link>) is also in
<mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
. </p>
<p>

<b>Definition:</b> <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link> is an algorithm
on <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link> <it>G</it> with <it>n</it> vertices that outputs "TRUE" if there is no
<link xlink:type="simple" xlink:href="../889/638889.xml">
path</link> between vertex <it>s</it> and <it>t</it> and "FALSE" if at least one path exists.
<link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link>={ <it>G=,s,t</it>&amp;gt;: there is no path from <it>s</it> to <it>t</it> in graph <it>G</it>}.</p>
<p>

In order to illustrate that <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link> is in <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
, one can construct an algorithm that, in logarithmic space, decides whether two given vertices are
not connected. To prove correctness of this algorithm, one must show two things:</p>
<p>

<list>
<entry level="1" type="bullet">

If the non-deterministic choices are made "correctly" and <it>s</it> and <it>t</it> are disconnected, then the algorithm accepts.</entry>
<entry level="1" type="bullet">

If <it>s</it> and <it>t</it> are connected, no matter what non-deterministic choices are made the algorithm does not accept.</entry>
</list>
</p>
<p>

Any reasonable algorithm satisfies the first condition, but satisfying the second condition is worth a <link>
Gödel Prize</link>.</p>
<p>

Here are the key ideas of the proof of the second condition. For sake of contradiction assume that <it>s</it> and <it>t</it> are connected but the algorithm accepts. To keep the adversary controlling the non-determinism "honest", the algorithm is designed so that if the non-determinism is uncooperative, the algorithm rejects at the end of the ENUMERATE subroutine. Therefore since we assumed that the algorithm accepts, the non-determinism must have been cooperative, which implies by the design of the algorithm that we should have rejected, a contradiction.</p>
<p>

First, define <it>Ai</it> as follows:
<it>Ai</it>={&nbsp;<it>v</it>&nbsp;: there is a path from <it>s</it> to <it>v</it> of length ≤ <it>i</it>&nbsp;}. In other words, <it>Ai</it> will include all vertices that are reachable from <it>s</it> in <it>i</it> or
fewer hops. Let <it>ri</it>&nbsp;=|&nbsp;<it>Ai</it>&nbsp;|. Note that if
<it>t</it> is not in <it>An-1</it>, where <it>n</it>&nbsp;=|&nbsp;<it>V</it>&nbsp;|, then there is no path from <it>s</it> to <it>t</it> in <it>G</it>, <it>i.e.</it> <it>G,s,t</it>&amp;gt; ∈ <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link>.</p>
<p>

<b>Lemma</b>: An algorithm can be constructed that given <it>ri</it> will enumerate vertices in <it>Ai</it> and ACCEPT in logarithmic space. Note that if the given <it>ri</it> is larger than the true number of vertices in <it>Ai</it>, then the algorithm REJECTs; however, if <it>ri</it> is less than the true number of vertices in <it>Ai</it> the algorithm would ACCEPT but enumerate only a subset of <it>Ai</it>. </p>
<p>

ENUMERATE(s,i,r_i,G)
1: Counter:=0 
2: FOR ALL vertices v in G
3:    Nondeterministically guess a path of length less than or equal to i from s to v
4:    IF path exists
5:       Counter:=Counter+1
6:       Output v
6:    IF Counter&amp;gt;=r_i
7:       ACCEPT
8: REJECT</p>
<p>

ENUMERATE goes through all vertices of graph <it>G</it> in logarithmic
space, since the representation of each vertex and the <b>Counter</b> requires
only log |&nbsp;<it>G</it>&nbsp;| bits and nondeterministically selecting a path also
requires only logarithmic space.</p>
<p>

Now, with ENUMERATE at hand it is possible to compute the actual <it>ri</it> in log-space using an algorithm that is based on the principle of <link xlink:type="simple" xlink:href="../881/18881.xml">
Mathematical induction</link>. When using ENUMERATE as a subroutine, replace ACCEPT in ENUMERATE with RETURN  while leaving REJECT as REJECT.</p>
<p>

Obviously <it>r0</it>=1 since <it>Ai</it> includes only the vertex <it>s</it> itself.</p>
<p>

Now, assume <it>ri</it> is given. Then <it>ri+1</it> = |&nbsp;<it>Ai+1</it> \ <it>Ai</it>&nbsp;| + <it>ri</it>&nbsp;, where \ is the <link xlink:type="simple" xlink:href="../347/54347.xml">
set difference</link> operator. The set difference can be calculated by the following algorithm in log-space:</p>
<p>

SET-DIFFERENCE (s,i,r_i,G)
1: diff:=0
2: FOR ALL vertices v:
3:    ENUMERATE (s,i,r_i,G)
4:    IF v is ever output
5:       CONTINUE
6:    FOR EACH u such that (u,v) is an edge in G
7:       ENUMERATE (s,i,r_i,G)
8:       IF u is ever output
9:          diff:=diff+1
10:          BREAK
11:       ELSE
12:         CONTINUE
13: Output diff</p>
<p>

This algorithm goes through all vertices of the graph <it>G</it> and ignores the vertices that are of distance of less than or equal to <it>ri</it> from <it>s</it> (lines 4-5), <it>i.e.</it> the vertices included in <it>Ai</it>. In lines 6-9 the algorithm tries to find a vertex <it>u</it> in <it>Ai</it> directly connected to the vertex <it>v</it> outside of <it>Ai</it> by simulating ENUMERATE again. If such vertex is found, that means that <it>v</it> is not in <it>Ai</it> but is in <it>Ai+1</it>, so it is output and the number of vertices in set difference is recorded. Note that the algorithm does not need to store all of the output of ENUMERATE every time it is called as a sub-routine. In lines 3 and 7 it can only store one vertex at a time and check if <it>v</it> and <it>u</it> are ever output. Thus, this algorithm runs in logarithmic space.</p>
<p>

With this algorithm at hand we can devise an algorithm for <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link> consisting of two parts. The first part would compute <it>rn</it> by starting with <it>r0</it>=1 and then using SET-DIFFERENCE n-1 times. In the second part the algorithm just simulates ENUMERATE with the computed <it>rn</it> and if <it>t</it> is ever output that means it can be reached from <it>v</it>, and the algorithm REJECTs.</p>
<p>

NOT-CONNECTED (G,s,t)
1: r_n:=1;
2: FOR i:=1 TO n
3:    r_n:=r_n+SET-DIFFERENCE (s,i,r_n,G)
4: ENUMERATE (s,n,r_n,G)
5: IF t is ever output
6:    REJECT
8: ELSE
9:    ACCEPT</p>
<p>

This algorithm runs in logarithmic space, since we need log |&nbsp;<it>G</it>&nbsp;| bits for storing <it>i and r_n</it>. As was shown above, the ENUMERATE and SET-DIFFERENCE algorithms also run in logarithmic space and again we do not need to store all of the output of ENUMERATE in line 4, but need only to check if <it>t</it> is ever output.  Thus, NOT-CONNECTED can decide if there exists no path from vertex <it>s</it> to <it>t</it> in logarithmic space. I.e. <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link> is in <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
. Since we can reduce each problem in <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
 to <link xlink:type="simple" xlink:href="../034/2833034.xml">
st-connectivity</link> and each problem in <link>
co-NL</link> to <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link> we conclude that <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
=<link>
co-NL</link>.</p>
<p>

Now, for <it>s(n)</it> ≥ log n we can transform the computations of any non-deterministic Turing Machine <it>M</it> on language <it>L</it> into a graph of its states and simulate <it>M</it> using <link xlink:type="simple" xlink:href="../034/2833034.xml">
st-connectivity</link> algorithm. Analogously we can transform any <it>co-language</it> into <link xlink:type="simple" xlink:href="../966/2832966.xml">
st-non-connectivity</link> problem.
Both of these graphs would have 2<it>O(s(n))</it> vertices if <it>L</it> ∈ <it>NSPACE(s(n))</it>. Thus, we can decide both reachability and non-reachability of the <it>Accept</it> state in log(2<it>O(s(n))</it>)=<it>O(s(n))</it> space and <it>NSPACE(s(n))=co-NSPACE(s(n))</it>.</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 N.Immerman, "<b><it><weblink xlink:type="simple" xlink:href="http://www.cs.umass.edu/~immerman/pub/space.ps">
Nondeterministic Space is Closed Under Complementation</weblink></it></b>", SIAM J. Comput. 17 1988, pp. 935-938</entry>
<entry level="1" type="bullet">

 R.Szelepcsenyi, "<b><it>The method of forcing for nondeterministic automata</it></b>", Bull. EATCS 33, 1987, pp. 96-100</entry>
</list>
</p>


</sec>
</bdy>
</article>
