<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:43:10[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Read-copy-update</title>
<id>284371</id>
<revision>
<id>219960180</id>
<timestamp>2008-06-17T17:18:43Z</timestamp>
<contributor>
<username>Nealcardwell</username>
<id>124321</id>
</contributor>
</revision>
<categories>
<category>Concurrency control</category>
<category>Operating system technology</category>
</categories>
</header>
<bdy>

"RCU" redirects here. For the record label, see <event wordnetid="100029378" confidence="0.8">
<description wordnetid="107201365" confidence="0.8">
<label wordnetid="107202579" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<speech_act wordnetid="107160883" confidence="0.8">
<link xlink:type="simple" xlink:href="../414/329414.xml">
RCU Records</link></speech_act>
</psychological_feature>
</act>
</label>
</description>
</event>
.
<b>Read-copy-update</b> (RCU) is an operating system kernel technology for improving performance on computers with more than one <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link>.<p>

More technically it is a <link xlink:type="simple" xlink:href="../017/4726017.xml">
synchronization</link> mechanism which can sometimes be used as an alternative to a <link xlink:type="simple" xlink:href="../235/4186235.xml">
readers-writer lock</link>. It allows extremely low overhead, <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/554867.xml">
wait-free</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 reads. However, RCU updates can be expensive, as they must leave the old versions of the data structure in place to accommodate pre-existing readers.  These old versions are reclaimed after all pre-existing readers finish their accesses. RCU can be put to a number of other tasks, including dynamically changing NMI (<link xlink:type="simple" xlink:href="../055/1250055.xml">
Non-Maskable interrupt</link>) handlers and implementing lazy <link xlink:type="simple" xlink:href="../263/4736263.xml">
barriers</link>, but it is most frequently used as replacement for reader-writer locking.</p>
<p>

RCU is available in a number of operating systems, including version 2.6 of the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/18510.xml">
Linux kernel</link></software>
.  The technique is covered by <link xlink:type="simple" xlink:href="../363/218363.xml">
U.S.</link> <link xlink:type="simple" xlink:href="../266/76266.xml">
software patent</link> 5,442,758, issued <link xlink:type="simple" xlink:href="../442/1442.xml">
August 15</link>, <link xlink:type="simple" xlink:href="../658/34658.xml">
1995</link> and assigned to <company wordnetid="108058098" confidence="0.8">
<subsidiary_company wordnetid="108003935" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../458/222458.xml">
Sequent Computer Systems</link></institution>
</subsidiary_company>
</company>
, as well as by 5,608,893, 5,727,528, 6,219,690, and 6,886,162.  The now-expired US Patent 4,809,168 covers a closely related technique. RCU is also the topic of one claim in the <link xlink:type="simple" xlink:href="../185/236185.xml#xpointer(//*[./st=%22Increased+damages+claims=2C+and+read-copy-update+claims%22])">
SCO v. IBM</link> <link xlink:type="simple" xlink:href="../258/113258.xml">
lawsuit</link>. </p>

<sec>
<st>
 Overview </st>
<p>

The basic idea behind RCU is to split updates into "removal" and "reclamation" phases. The removal phase removes references to data items within a data structure (possibly by replacing them with references to new versions of these data items), and can run concurrently with readers. The reason that it is safe to run the removal phase concurrently with readers is the semantics of modern CPUs guarantee that readers will see either the old or the new version of the data structure rather than a partially updated reference. The reclamation phase does the work of reclaiming (e.g., freeing) the data items removed from the data structure during the removal phase. Because reclaiming data items can disrupt any readers concurrently referencing those data items, the reclamation phase must not start until readers no longer hold references to those data items.</p>
<p>

Splitting an update into removal and reclamation phases allows the updater to perform the removal phase immediately, and to defer the reclamation phase until all readers active during the removal phase have completed, either by blocking until they finish or by registering a callback that is invoked after they finish. Only readers that are active during the removal phase need be considered, because any reader starting after the removal phase will be unable to gain a reference to the removed data items, and therefore cannot be disrupted by the reclamation phase.</p>
<p>

So the typical RCU update sequence goes something like the following: </p>
<p>

<list>
<entry level="1" type="number">

 Remove pointers to a data structure, so that subsequent readers cannot gain a reference to it.</entry>
<entry level="1" type="number">

 Wait for all previous readers to complete their RCU read-side critical sections.</entry>
<entry level="1" type="number">

 At this point, there cannot be any readers who hold references to the data structure, so it now may safely be reclaimed (e.g., freed, perhaps using kfree in the Linux kernel). </entry>
</list>
</p>
<p>

Step (2) above is the key idea underlying RCU's deferred destruction. The ability to wait until all readers are done allows RCU readers to use much lighter-weight synchronization &mdash; in some cases, absolutely no synchronization at all. In contrast, in more conventional lock-based schemes, readers must use heavy-weight synchronization in order to prevent an updater from deleting the data structure out from under them. This is because lock-based updaters typically update data items in place, and must therefore exclude readers. In contrast, RCU-based updaters typically take advantage of the fact that writes to single aligned pointers are atomic on modern CPUs, allowing atomic insertion, removal, and replacement of data items in a linked structure without disrupting readers. Concurrent RCU readers can then continue accessing the old versions, and can dispense with the atomic operations, memory barriers, and cache misses that are so expensive on modern <link xlink:type="simple" xlink:href="../318/50318.xml">
SMP</link> computer systems, even in absence of lock contention.</p>
<p>

In the three-step procedure shown above, the updater is performing both the removal and the reclamation step, but it is often helpful for an entirely different thread to do the reclamation, as is in fact the case in the Linux kernel's directory-entry cache (dcache). Even if the same thread performs both the update step (step (1) above) and the reclamation step (step (3) above), it is often helpful to think of them separately. For example, RCU readers and updaters need not communicate at all, but RCU provides implicit low-overhead communication between readers and reclaimers, namely, in step (2) above.</p>

</sec>
<sec>
<st>
 Example API </st>
<p>

The implementation of RCU in version 2.6 of the Linux kernel is among the better-known RCU implementations, and will be used as an example RCU API in the remainder of this article. The core Linux kernel RCU API (<link>
Application Programming Interface</link>) is quite small:</p>
<p>

<list>
<entry level="1" type="number">

 rcu_read_lock()</entry>
<entry level="1" type="number">

 rcu_read_unlock()</entry>
<entry level="1" type="number">

 synchronize_rcu() / call_rcu()</entry>
<entry level="1" type="number">

 rcu_assign_pointer()</entry>
<entry level="1" type="number">

 rcu_dereference()</entry>
</list>
</p>
<p>

The Linux kernel contains numerous other RCU-related APIs, and these may be found elsewhere <weblink xlink:type="simple" xlink:href="http://www.rdrop.com/users/paulmck/RCU/whatisRCU.html">
http://www.rdrop.com/users/paulmck/RCU/whatisRCU.html</weblink>.</p>

<ss1>
<st>
 rcu_read_lock </st>
<p>

Used by a reader to inform the reclaimer that the reader is entering an RCU read-side <link xlink:type="simple" xlink:href="../312/638312.xml">
critical section</link>. Any RCU-protected data structure accessed during an RCU read-side critical section is guaranteed to remain unreclaimed for the full duration of that critical section. Other schemes, such as reference counts, may be used in conjunction with RCU to maintain longer-term references to data structures.</p>

</ss1>
<ss1>
<st>
 rcu_read_unlock </st>
<p>

Used by a reader to inform the reclaimer that the reader is exiting an RCU read-side critical section. Note that RCU read-side critical sections may be nested and/or overlapping.</p>

</ss1>
<ss1>
<st>
 synchronize_rcu / call_rcu </st>
<p>

Marks the end of updater code and the beginning of reclaimer code. It does this by blocking until all pre-existing RCU read-side critical sections on all CPUs have completed. Note that synchronize_rcu will <it>not</it> necessarily wait for any subsequent RCU read-side critical sections to complete. For example, consider the following sequence of events:

	         CPU 0                  CPU 1                 CPU 2
	     ----------------- ------------------------- ---------------
	 1.  rcu_read_lock()
	 2.                    enters synchronize_rcu()
	 3.                                               rcu_read_lock()
	 4.  rcu_read_unlock()
	 5.                     exits synchronize_rcu()
	 6.                                              rcu_read_unlock()
</p>
<p>

To reiterate, synchronize_rcu waits only for ongoing RCU read-side critical sections to complete, not necessarily for any that begin after synchronize_rcu is invoked.</p>
<p>

Of course, synchronize_rcu does not necessarily return immediately after the last pre-existing RCU read-side critical section completes. For one thing, there might well be scheduling delays. For another thing, many RCU implementations process requests in batches in order to improve efficiencies, which can further delay synchronize_rcu.</p>
<p>

Since synchronize_rcu is the API that must figure out when readers are done, its implementation is key to RCU. For RCU to be useful in all but the most read-intensive situations, synchronize_rcu's overhead must also be quite small.</p>
<p>

The call_rcu API is a callback form of synchronize_rcu, and is described in more detail in a later section. Instead of blocking, it registers a function and argument which are invoked after all ongoing RCU read-side critical sections have completed. This callback variant is particularly useful in situations where it is illegal to block.</p>

</ss1>
<ss1>
<st>
 rcu_assign_pointer </st>
<p>

The updater uses this function to assign a new value to an RCU-protected pointer, in order to safely communicate the change in value from the updater to the reader. This function returns the new value, and also executes any <link xlink:type="simple" xlink:href="../216/728216.xml">
memory barrier</link> instructions required for a given CPU architecture.  Perhaps more importantly, it serves to document which pointers are protected by RCU.</p>

</ss1>
<ss1>
<st>
 rcu_dereference </st>
<p>

The reader uses rcu_dereference to fetch an RCU-protected pointer, which returns a value that may then be safely dereferenced. Note that rcu_deference does not actually dereference the pointer, instead, it protects the pointer for later dereferencing. It also executes any needed memory-barrier instructions for a given CPU architecture. Currently, only <link xlink:type="simple" xlink:href="../971/8971.xml">
DEC Alpha</link> needs memory barriers within rcu_dereference; on other CPUs, it compiles to nothing, not even a compiler directive.</p>
<p>

Note that the value returned by rcu_dereference is valid only within the enclosing RCU read-side critical section. For example, the following is not legal:

		rcu_read_lock();
		p = rcu_dereference(head.next);
		rcu_read_unlock();
		x = p-&amp;gt;address;
		rcu_read_lock();
		y = p-&amp;gt;data;
		rcu_read_unlock();
</p>
<p>

Holding a reference from one RCU read-side critical section to another is just as illegal as holding a reference from one lock-based critical section to another! Similarly, using a reference outside of the critical section in which it was acquired is just as illegal as doing so with normal locking.</p>
<p>

As with rcu_assign_pointer, an important function of rcu_dereference is to document which pointers are protected by RCU.</p>

</ss1>
<ss1>
<st>
 Relation Among RCU APIs </st>
<p>

The following diagram shows how each API communicates among the reader, updater, and reclaimer.
<image location="none" width="680px" src="rcu_api.jpg" type="thumb">
</image>

The RCU infrastructure observes the time sequence of rcu_read_lock, rcu_read_unlock, synchronize_rcu, and call_rcu invocations in order to determine when (1) synchronize_rcu invocations may return to their callers and (2) call_rcu callbacks may be invoked. Efficient implementations of the RCU infrastructure make heavy use of batching in order to amortize their overhead over many uses of the corresponding APIs.</p>

</ss1>
</sec>
<sec>
<st>
 What is a Simple Implementation of RCU? </st>
<p>

RCU has extremely simple "toy" implementations that can aid understanding of RCU.  This section presents one such "toy" implementation that is related to the "classic" RCU implementation in the Linux kernel.  Note that this implementation works only in a non-preemptive environment.

	void rcu_read_lock(void) { }

	void rcu_read_unlock(void) { }

	void synchronize_rcu(void)
	{
		int cpu;

		for_each_cpu(cpu)
			run_on(cpu);
	}

You can ignore rcu_assign_pointer and rcu_dereference without missing much. But here they are anyway. And whatever you do, don't forget about them when submitting Linux-kernel patches that make use of RCU!

	#define rcu_assign_pointer(p, v)	({ \
							smp_wmb(); \
							(p) = (v); \
						})

	#define rcu_dereference(p)     ({ \
					typeof(p) _________p1 = p; \
					smp_read_barrier_depends(); \
					(_________p1); \
					})

Note that rcu_read_lock and rcu_read_unlock do absolutely nothing. This is the great strength of classic RCU in a non-preemptive kernel: read-side overhead is precisely zero, at least on non-Alpha CPUs. And there is absolutely no way that rcu_read_lock can participate in a <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link> cycle, cause a realtime process to miss its scheduling deadline, precipitate <link xlink:type="simple" xlink:href="../507/521507.xml">
priority inversion</link>, or result in high <link xlink:type="simple" xlink:href="../593/244593.xml">
lock contention</link>.</p>
<p>

The implementation of synchronize_rcu simply schedules itself on each CPU in turn. This guarantees that all readers of the old version of the data structure have completed, because it is illegal to block while in an RCU read-side critical section. Therefore, if a given CPU executes a context switch (to schedule another process), we know that it must have completed all preceding RCU read-side critical sections. Once all CPUs have executed a context switch, then all preceding RCU read-side critical sections will have completed.</p>
<p>

For example, suppose that we remove a data item from its structure and then invoke synchronize_rcu. Once synchronize_rcu returns, we are guaranteed that there are no RCU read-side critical sections holding a reference to that data item, so we can safely reclaim it.</p>

</sec>
<sec>
<st>
 Analogy with Reader-Writer Locking </st>
<p>

Although RCU can be used in many different ways, a very common use of RCU is analogous to reader-writer locking. The following side-by-side code display shows how closely related reader-writer locking (on the left) and RCU (on the right) can be.

 1 struct el {                           1 struct el {
 2   struct list_head lp;                2   struct list_head lp;
 3   long key;                           3   long key;
 4   spinlock_t mutex;                   4   spinlock_t mutex;
 5   int data;                           5   int data;
 6   /* Other data fields */             6   /* Other data fields */
 7 };                                    7 };
 8 DEFINE_RWLOCK(listmutex);             8 DEFINE_SPINLOCK(listmutex);
 9 LIST_HEAD(head);                      9 LIST_HEAD(head);

 1 int search(long key, int *result)     1 int search(long key, int *result)
 2 {                                     2 {
 3   struct el *p;                       3   struct el *p;
 4                                       4
 5   read_lock(&amp;listmutex);              5   rcu_read_lock();
 6   list_for_each_entry(p, &amp;head, lp) { 6   list_for_each_entry_rcu(p, &amp;head, lp) {
 7     if (p-&amp;gt;key == key) {              7     if (p-&amp;gt;key == key) {
 8       *result = p-&amp;gt;data;              8       *result = p-&amp;gt;data;
 9       read_unlock(&amp;listmutex);        9       rcu_read_unlock();
10       return 1;                      10       return 1;
11     }                                11     }
12   }                                  12   }
13   read_unlock(&amp;listmutex);           13   rcu_read_unlock();
14   return 0;                          14   return 0;
15 }                                    15 }

 1 int delete(long key)                  1 int delete(long key)
 2 {                                     2 {
 3   struct el *p;                       3   struct el *p;
 4                                       4
 5   write_lock(&amp;listmutex);             5   spin_lock(&amp;listmutex);
 6   list_for_each_entry(p, &amp;head, lp) { 6   list_for_each_entry(p, &amp;head, lp) {
 7     if (p-&amp;gt;key == key) {              7     if (p-&amp;gt;key == key) {
 8       list_del(&amp;p-&amp;gt;lp);               8       list_del_rcu(&amp;p-&amp;gt;lp);
 9       write_unlock(&amp;listmutex);       9       spin_unlock(&amp;listmutex);
                                        10       synchronize_rcu();
10       kfree(p);                      11       kfree(p);
11       return 1;                      12       return 1;
12     }                                13     }
13   }                                  14   }
14   write_unlock(&amp;listmutex);          15   spin_unlock(&amp;listmutex);
15   return 0;                          16   return 0;
16 }                                    17 }

The differences between the two approaches are quite small.  Read-side locking moves to rcu_read_lock and rcu_read_unlock, update-side locking moves from a reader-writer lock to a simple spinlock, and a synchronize_rcu precedes the kfree.</p>
<p>

However, there is one potential catch: the read-side and update-side critical sections can now run concurrently. In many cases, this will not be a problem, but it is necessary to check carefully regardless. For example, if multiple independent list updates must be seen as a single atomic update, converting to RCU will require special care.</p>
<p>

Also, the presence of synchronize_rcu means that the RCU version of delete can now block. If this is a problem, there is a callback-based mechanism that never blocks, namely call_rcu, that can be used in place of synchronize_rcu.</p>

</sec>
<sec>
<st>
 Why Call it "Read-Copy Update"? </st>
<p>

The name comes from the way that RCU is used to update a linked structure in place.
A thread wishing to do this uses the following steps: 
<list>
<entry level="1" type="bullet">

 create a new structure, </entry>
<entry level="1" type="bullet">

 copy the data from the old structure into the new one, and save a <link xlink:type="simple" xlink:href="../018/459018.xml">
pointer</link> to the old structure,</entry>
<entry level="1" type="bullet">

 modify the new, copied, structure</entry>
<entry level="1" type="bullet">

 update the global pointer to refer to the new structure, and then </entry>
<entry level="1" type="bullet">

 sleep until the operating system kernel determines that there are no readers left using the old structure, for example, in the Linux kernel, by using synchronize_rcu().  </entry>
</list>
</p>
<p>

When the thread which made the copy is awakened by the kernel, it can safely deallocate the old structure.</p>
<p>

So the structure is <it>read</it> concurrently with a thread <it>copying</it> in order to do an <it>update</it>, hence the name "read-copy update". The abbreviation "RCU" was one of many contributions by the Linux community. Other names for similar techniques include <it>passive serialization</it> and <it>MP defer</it> by <link xlink:type="simple" xlink:href="../018/315018.xml">
VM/XA</link> programmers and <it>generations</it> by <link xlink:type="simple" xlink:href="../056/1157056.xml">
K42</link> and <weblink xlink:type="simple" xlink:href="http://www.eecg.toronto.edu/~tornado">
Tornado</weblink> programmers.</p>

</sec>
<sec>
<st>
History</st>
<p>

Techniques and mechanisms resembling RCU have been independently invented multiple times:
<list>
<entry level="1" type="number">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../825/1400825.xml">
H. T. Kung</link></research_worker>
</scientist>
</causal_agent>
</person>
</physical_entity>
 and Q. Lehman described use of garbage collectors to implement RCU-like access to a binary search tree in the September 1980 issue of ACM Transactions on Database Systems.</entry>
<entry level="1" type="number">

 <physical_entity wordnetid="100001930" confidence="0.8">
<executive wordnetid="110069645" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<leader wordnetid="109623038" confidence="0.8">
<administrator wordnetid="109770949" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<head wordnetid="110162991" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../574/474574.xml">
Udi Manber</link></employee>
</head>
</writer>
</scientist>
</causal_agent>
</worker>
</administrator>
</leader>
</person>
</communicator>
</executive>
</physical_entity>
 and Richard Ladner extended Kung's and Lehman's work to non-garbage-collected environments by deferring reclamation until all threads running at removal time have terminated, which works in environments that do not have long-lived threads.  This was published as a technical report in 1982 and in the September 1987 issue of ACM Transactions on Database Systems.</entry>
<entry level="1" type="number">

 J. Hennessy, D. Osisek, and J. Seigh were granted US Patent 4,809,168 in 1989 (since lapsed).  This patent describes an RCU-like mechanism that was apparently used in <link xlink:type="simple" xlink:href="../018/315018.xml">
VM/XA</link> on <link xlink:type="simple" xlink:href="../872/14872.xml">
IBM Mainframe</link>s.</entry>
<entry level="1" type="number">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../645/1910645.xml">
William Pugh</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
 described an RCU-like mechanism that relied on explicit flag-setting by readers in a technical report entitled "Concurrent Maintenance of Skip Lists" published in 1990.</entry>
<entry level="1" type="number">

 Gregory R. Adams described "chaotic relaxation" in his 1991 book entitled "Concurrent programming, principles, and practices".  Chaotic relaxation is a <link xlink:type="simple" xlink:href="../660/7330660.xml">
Numerical linear algebra</link> technique that reduces synchronization overhead among CPUs computing results using successive approximations.  This technique has some resemblance to RCU in that readers may be referring to different versions of data concurrently.</entry>
<entry level="1" type="number">

 J. Slingwine and P. E. McKenney received US Patent 5,442,758 in August 1995, which describes RCU as implemented in DYNIX/ptx and later in the Linux kernel.</entry>
<entry level="1" type="number">

 B. Gamsa, O. Krieger, J. Appavoo, and M. Stumm described an RCU-like mechanism used in the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../325/7955325.xml">
University of Toronto</link></university>
 <weblink xlink:type="simple" xlink:href="http://www.eecg.toronto.edu/~tornado/">
Tornado research operating system</weblink> and the closely related <link xlink:type="simple" xlink:href="../666/551666.xml">
IBM Research</link> <link xlink:type="simple" xlink:href="../056/1157056.xml">
K42</link> research operating systems.  See their <weblink xlink:type="simple" xlink:href="http://www.usenix.org/events/osdi99/full_papers/gamsa/gamsa.pdf">
1999 OSDI paper.</weblink></entry>
<entry level="1" type="number">

 D. Sarma added RCU to <weblink xlink:type="simple" xlink:href="http://www.kernel.org/pub/linux/kernel/v2.5/ChangeLog-2.5.43">
version 2.5.43 of the Linux kernel</weblink> in October 2002.</entry>
</list>
</p>
<p>

A number of researchers, including <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../186/1206186.xml">
Van Jacobson</link></research_worker>
</scientist>
</causal_agent>
</person>
</physical_entity>
, Aju John, and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../822/2164822.xml">
Richard Rashid</link></employee>
</causal_agent>
</worker>
</person>
</physical_entity>
 have proposed deferring reclamation for a fixed period of time, an approach that might be useful in <link xlink:type="simple" xlink:href="../767/25767.xml">
hard real time</link> software.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../356/217356.xml">
Concurrency control</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../954/40954.xml">
Contention</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../181/105181.xml">
Deadlock</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../593/244593.xml">
Lock (software engineering)</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../864/554864.xml">
Lock-free and wait-free algorithms</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../216/728216.xml">
Memory barrier</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../827/36827.xml">
Mutual exclusion</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/554867.xml">
Non-blocking synchronization</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../566/2204566.xml">
Pre-emptive multitasking</link></entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<invertebrate wordnetid="101905661" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<arthropod wordnetid="101767661" confidence="0.8">
<bug wordnetid="102236355" confidence="0.8">
<insect wordnetid="102159955" confidence="0.8">
<animal wordnetid="100015388" confidence="0.8">
<link xlink:type="simple" xlink:href="../507/521507.xml">
Priority inversion</link></animal>
</insect>
</bug>
</arthropod>
</instrumentality>
</artifact>
</invertebrate>
</system>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../767/25767.xml">
Real-time computing</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../591/501591.xml">
Starvation</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../738/28738.xml">
Synchronization</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://lwn.net/Articles/262464/">
Paul McKenney and Jonathan Walpole: What is RCU, Fundamentally?</weblink>, <weblink xlink:type="simple" xlink:href="http://lwn.net/Articles/263130/">
What is RCU? Part 2: Usage</weblink>, and <weblink xlink:type="simple" xlink:href="http://lwn.net/Articles/264090/">
RCU part 3: the RCU API</weblink>. <it><link xlink:type="simple" xlink:href="../718/1556718.xml">
Linux Weekly News</link>.''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.rdrop.com/users/paulmck/RCU/">
Paul McKenney's RCU Page</weblink></entry>
<entry level="1" type="bullet">

 Hart, McKenney, and Demke Brown (2006). <it><weblink xlink:type="simple" xlink:href="http://www.rdrop.com/users/paulmck/RCU/hart_ipdps06.pdf">
Making Lockless Synchronization Fast: Performance Implications of Memory Reclamation</weblink></it> An <weblink xlink:type="simple" xlink:href="http://www.ipdps.org/ipdps2006/2006_advance_program.html">
IPDPS 2006 Best Paper</weblink> comparing RCU's performance to that of other lockless synchronization mechanisms.  <it><weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016/j.jpdc.2007.04.010">
Journal version</weblink></it> (including Walpole as author).</entry>
<entry level="1" type="bullet">

 Paul E. McKenney (2004). <it><weblink xlink:type="simple" xlink:href="http://www.rdrop.com/users/paulmck/rclock/RCUdissertation.2004.07.14e1.pdf">
Exploiting Deferred Destruction: An Analysis of Read-Copy-Update Techniques in Operating System Kernels</weblink></it> Dissertation.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://patft.uspto.gov/netacgi/nph-Parser?patentnumber=5442758">
U.S. Patent 5,442,758</weblink><weblink xlink:type="simple" xlink:href="http://www.pat2pdf.org/pat2pdf/foo.pl?number=5442758">
&nbsp;</weblink> (1995) "Apparatus and method for achieving reduced overhead mutual exclusion and maintaining coherency in a multiprocessor system utilizing execution history and thread monitoring"</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.toronto.edu/~tomhart/perflab/ipdps06.tgz">
Tom Hart's user-application-level implementation of RCU</weblink> along with some performance microbenchmark infrastructure by Tom Hart and Paul McKenney.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Paul McKenney&#32;(2003).&#32;"<weblink xlink:type="simple" xlink:href="http://www.linuxjournal.com/article.php?sid=6993">
Using RCU in the Linux 2.5 Kernel</weblink>". <it><work wordnetid="104599396" confidence="0.8">
<computer wordnetid="103082979" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<print_media wordnetid="106263609" confidence="0.8">
<press wordnetid="106263369" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<medium wordnetid="106254669" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<magazine wordnetid="106595351" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../831/233831.xml">
Linux Journal</link></web_site>
</device>
</instrumentality>
</artifact>
</product>
</magazine>
</publication>
</medium>
</machine>
</press>
</print_media>
</creation>
</computer>
</work>
</it>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://lwn.net/Articles/202847/">
Paul McKenney: Sleepable RCU</weblink>. <it><link xlink:type="simple" xlink:href="../718/1556718.xml">
Linux Weekly News</link>.''</it></entry>
</list>


</p>

</sec>
</bdy>
</article>
