<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:43:17[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Dining philosophers problem</title>
<id>285344</id>
<revision>
<id>240794294</id>
<timestamp>2008-09-25T00:46:10Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Concurrency</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>dining philosophers problem</b> is an illustrative example of a common computing problem in <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrency</link>. It is a classic <link xlink:type="simple" xlink:href="../162/145162.xml">
multi-process</link> <link xlink:type="simple" xlink:href="../738/28738.xml">
synchronization</link> problem.<p>

In <link xlink:type="simple" xlink:href="../748/34748.xml">
1971</link>, <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> set an examination question on a synchronization problem where five computers competed for access to five shared tape drive peripherals. Soon afterwards the problem was retold by <link xlink:type="simple" xlink:href="../434/39434.xml">
Tony Hoare</link> as the dining philosophers problem.</p>
<p>

This is a theoretical explanation of deadlock and resource starvation by assuming that each philosopher takes a different fork as a first priority and then looks for another.</p>

<sec>
<st>
Problem</st>

<p>

The dining philosophers problem is summarized as five philosophers sitting at a table doing one of two things - eating or thinking.  While eating, they are not thinking, and while thinking, they are not eating.  The five philosophers sit at a circular table with a large bowl of spaghetti in the center.  A fork is placed in between each philosopher, and as such, each philosopher has one fork to his or her left and one fork to his or her right.  As spaghetti is difficult to serve and eat with a single fork, it is assumed that a philosopher must eat with two forks.  The philosopher can only use the fork on his or her immediate left or right.</p>
<p>

<image width="200px" src="Dining_philosophers.png" type="thumb">
<caption>

Illustration of the dining philosophers problem
</caption>
</image>
</p>
<p>

The dining philosophers problem is sometimes explained using rice and chopsticks as opposed to spaghetti and two forks, as this seems more logical as two chopsticks are required to eat, and not two forks.</p>
<p>

The philosophers never speak to each other, which creates a dangerous possibility of <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link> when every philosopher holds a left fork and waits perpetually for a right fork (or vice versa).</p>
<p>

Originally used as a means of illustrating the problem of deadlock, this system reaches deadlock when there is a 'cycle of unwarranted requests'. In this case philosopher <it>P1</it> waits for the fork grabbed by philosopher <it>P2</it> who is waiting for the fork of philosopher <it>P3</it> and so forth, making a circular chain. </p>
<p>

<link xlink:type="simple" xlink:href="../591/501591.xml">
Starvation</link> (and the pun was intended in the original problem description) might also occur independently of deadlock if a philosopher is unable to acquire both forks due to a timing issue. For example there might be a rule that the philosophers put down a fork after waiting five minutes for the other fork to become available and wait a further five minutes before making their next attempt. This scheme eliminates the possibility of deadlock (the system can always advance to a different state) but still suffers from the problem of <link xlink:type="simple" xlink:href="../181/105181.xml#xpointer(//*[./st=%22Livelock%22])">
livelock</link>. If all five philosophers appear in the dining room at <it>exactly</it> the same time and each picks up their left fork at the same time the philosophers will wait five minutes until they all put their forks down and then wait a further five minutes before they all pick them up again.</p>
<p>

The lack of available forks is an analogy to the locking of shared resources in real computer programming, a situation known as <link xlink:type="simple" xlink:href="../605/2581605.xml">
concurrency</link>. Locking a resource is a common technique to ensure the resource is accessed by only one program or chunk of code at a time. When the resource a program is interested in is already locked by another one, the program waits until it is unlocked. When several programs are involved in locking resources, deadlock might happen, depending on the circumstances. For example, one program needs two files to process. When two such programs lock one file each, both programs wait for the other one to unlock the other file, which will never happen.</p>
<p>

In general the dining philosophers problem is a generic and abstract problem used for explaining various issues which arise in problems which hold <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> as a core idea. For example, as in the above case deadlock/livelock is well explained with the dining philosophers problem.</p>

</sec>
<sec>
<st>
Solutions</st>


<ss1>
<st>
 Waiter Solution </st>
<p>

A simple solution is achieved by introducing a waiter at the table. Philosophers must ask his permission before taking up any forks. Because the waiter is aware of which forks are in use, he is able to arbitrate and prevent deadlock. When four of the forks are in use, the next philosopher to request one has to wait for the waiter's permission, which is not given until a fork has been released. The logic is kept simple by specifying that philosophers always seek to pick up their left hand fork before their right hand fork (or vice versa).</p>
<p>

To envisage how this works, consider the philosophers are labelled clockwise from A to E. If A and C are eating, four forks are in use. B sits between A and C so has neither fork available, whereas D and E have one unused fork between them. Suppose D wants to eat. Were he to take up the fifth fork, deadlock becomes likely. If instead he asks the waiter and is told to wait, we can be sure that next time two forks are released there will certainly be at least one philosopher who could successfully request a pair of forks. Therefore deadlock cannot happen.</p>

</ss1>
<ss1>
<st>
 Resource hierarchy solution </st>
<p>

Another simple solution is achieved by assigning a <link xlink:type="simple" xlink:href="../572/23572.xml">
partial order</link>, or hierarchy, to the resources (the forks, in this case), and establishing the convention that all resources will be requested in order, and released in reverse order, and that no two resources unrelated by order will ever be used by a single unit of work at the same time.  Here, the resources (forks) will be numbered 1 through 5, in some order, and each unit of work (philosopher) will always pick up the lower-numbered fork first, and then the higher-numbered fork, from among the two forks he plans to use.  Then, he will always put down the higher numbered fork first, followed by the lower numbered fork.  In this case, if four of the five philosophers simultaneously pick up their lower-numbered fork, only the highest numbered fork will remain on the table, so the fifth philosopher will not be able to pick up any fork.  Moreover, only one philosopher will have access to that highest-numbered fork, so he will be able to eat using two forks.  When he finishes using the forks, he will put down the highest-numbered fork first, followed by the lower-numbered fork, freeing another philosopher to grab the latter and begin eating.</p>
<p>

While the resource hierarchy solution avoids deadlocks, it is not always practical, especially when the list of required resources is not completely known in advance.  For example, if a unit of work holds resources 3 and 5 and then determines it needs resource 2, it must release 5, then 3 before acquiring 2, and then it must re-acquire 3 and 5 in that order.  Computer programs that access large numbers of database records would not run efficiently if they were required to release all higher-numbered records before accessing a new record, making the method impractical for that purpose.</p>
<p>

This is often the most practical solution for real world Computer Science problems; by assigning a constant hierarchy of locks, and by enforcing the ordering of obtaining the locks this problem can be avoided.</p>

</ss1>
<ss1>
<st>
 Chandy / Misra Solution </st>
<p>

In 1984, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../678/9385678.xml">
K. Mani Chandy</link></employee>
</scientist>
</causal_agent>
</worker>
</person>
</physical_entity>
 and J. Misra proposed a different solution to the Dining Philosophers problem to allow for arbitrary agents (numbered P1, ..., Pn) to contend for an arbitrary number of resources. Unlike in Dijkstra's solution, these labelings can be arbitrary. </p>
<p>

<list>
<entry level="1" type="number">

For every pair of philosophers contending for a resource, create a fork and give it to the philosopher with the lower ID. Each fork can either be <it>dirty</it> or <it>clean.</it> Initially, all forks are dirty.</entry>
<entry level="1" type="number">

When a philosopher wants to use a set of resources (<it>i.e.</it> eat), he must obtain the forks from his contending neighbours. For all such forks he does not have, he sends a request message. </entry>
<entry level="1" type="number">

When a philosopher with a fork receives a request message, he keeps the fork if it is clean, but gives it up when it is dirty. If he sends the fork over, he cleans the fork before doing so. </entry>
<entry level="1" type="number">

After a philosopher is done eating, all his forks become dirty. If another philosopher had previously requested one of the forks, he cleans the fork and sends it.</entry>
</list>
</p>
<p>

This solution also allows for a large degree of concurrency, and will solve an arbitrarily large problem.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../958/2991958.xml">
Cigarette smokers problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../405/8843405.xml">
Producers-consumers problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../100/4189100.xml">
Readers-writers problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../196/363196.xml">
Sleeping barber problem</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book">Silberschatz, Abraham; Peterson, James L.&#32;(1988). Operating Systems Concepts.&#32;Addison-Wesley. ISBN 0-201-18760-4.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

Chandy, K.M.; Misra, J. (1984). <weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/users/misra/scannedPdf.dir/DrinkingPhil.pdf">
The Drinking Philosophers Problem</weblink>. ACM Transactions on Programming Languages and Systems.</entry>
<entry level="1" type="bullet">

Dijkstra, E. W. (1971, June). <weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/users/EWD/ewd03xx/EWD310.PDF">
Hierarchical ordering of sequential processes</weblink>. Acta Informatica 1(2): 115-138.</entry>
<entry level="1" type="bullet">

Lehmann, D. J., Rabin M. O, (1981). On the Advantages of Free Choice: A Symmetric and Fully Distributed Solution to the Dining Philosophers Problem. Principles Of Programming Languages 1981 (<social_group wordnetid="107950920" confidence="0.8">
<meeting wordnetid="108307589" confidence="0.8">
<gathering wordnetid="107975026" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<conference wordnetid="108308497" confidence="0.8">
<link xlink:type="simple" xlink:href="../893/7251893.xml">
POPL</link></conference>
</group>
</gathering>
</meeting>
</social_group>
'81), pages 133-138.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://laser.cs.umass.edu/verification-examples/dp_standard/dp.html">
Discussion of the problem with solution code for 2 or 4 philosophers</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?Dining+Philosophers+Problem">
Discussion of various solutions 1</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.utk.edu/~plank/plank/classes/cs560/560/notes/Dphil/lecture.html">
Discussion of various solutions 2</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://64.233.183.104/search?q=cache:MYHZ-zyFVdEJ:www.cs.purdue.edu/homes/clifton/cs603/Philosophers.ppt">
Distributed symmetric solutions</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://jason.mchu.com/SDP/index.html">
Programming the Dining Philosophers with Simulation</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.doc.ic.ac.uk/~jnm/concurrency/classes/Diners/Diners.html">
Interactive example</weblink> of the Philosophers problem (<weblink xlink:type="simple" xlink:href="http://jdl.sun.com/webapps/getjava/BrowserRedirect?locale=en&amp;host=www.java.com:80">
Java</weblink> required)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.crockford.com/ec/dining.html">
Satan Comes to Dinner</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.kent.ac.uk/projects/ofa/java-threads/0.html">
Wot No Chickens?</weblink> - <link>
Peter H. Welch</link> proposed the Starving Philosophers variant that demonstrates an unfortunate consequence of the behaviour of Java thread monitors is to make <link xlink:type="simple" xlink:href="../591/501591.xml">
thread starvation</link> more likely than strictly necessary.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.mtu.edu/~shene/NSF-3/e-Book/MUTEX/TM-example-philos-1.html">
ThreadMentor</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
