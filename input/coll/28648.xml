<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:34:26[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>String searching algorithm</title>
<id>28648</id>
<revision>
<id>241254489</id>
<timestamp>2008-09-27T02:27:26Z</timestamp>
<contributor>
<username>Sz-iwbot</username>
<id>7780295</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

<b>String searching algorithms</b>, sometimes called <b>string matching algorithms</b>, are an important class of <link xlink:type="simple" xlink:href="../701/27701.xml">
string algorithm</link>s that try to find a place where one or several <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link> (also called <link xlink:type="simple" xlink:href="../351/68351.xml">
pattern</link>s) are found within a larger string or text.<p>

Let Σ be an <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../269/4292269.xml">
alphabet</link></language>
 (finite set). Formally, both the pattern and searched text are concatenations of elements of Σ. The Σ may be a usual human alphabet (for example, the letters A through Z in English). Other applications may use <it>binary alphabet</it> (Σ = {0,1}) or <it>DNA alphabet</it> (Σ = {A,C,G,T}) in <link xlink:type="simple" xlink:href="../214/4214.xml">
bioinformatics</link>.</p>
<p>

In practice how the string is encoded can affect the feasible string search algorithms. In particular if a <link xlink:type="simple" xlink:href="../226/1307226.xml">
variable width encoding</link> is in use then it is slow (time proportional to N) to find the Nth character. This will significantly slow down many of the more advanced search algorithms. A possible solution is to search for the sequence of code units instead, but doing so may produce false matches unless the encoding is specifically designed to avoid it.</p>

<sec>
<st>
 Basic classification </st>
<p>

The various <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s can be classified by the number of patterns each uses.</p>

<ss1>
<st>
 Single pattern algorithms </st>
<p>

Let <it>m</it> be the length of the pattern and let <it>n</it> be the length of the searchable text.</p>
<p>

<table class="wikitable">
<row>
<header>
Algorithm</header>
<header>
Preprocessing time</header>
<header>
Matching time1</header>
</row>
<row>
<header>
Naïve string search algorithm</header>
<col>
0  (no preprocessing)</col>
<col>
Θ((n-m+1) m)</col>
</row>
<row>
<header>
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../698/684698.xml">
Rabin-Karp string search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</header>
<col>
Θ(m)</col>
<col>
average Θ(n+m),worst Θ((n-m+1) m)</col>
</row>
<row>
<header>
 <link xlink:type="simple" xlink:href="../931/10931.xml">
Finite state automaton</link>based search</header>
<col>
Θ(m &amp;#x7c;Σ&amp;#x7c;)</col>
<col>
Θ(n)</col>
</row>
<row>
<header>
 <link xlink:type="simple" xlink:href="../227/253227.xml">
Knuth-Morris-Pratt algorithm</link></header>
<col>
Θ(m)</col>
<col>
Θ(n)</col>
</row>
<row>
<header>
 <link xlink:type="simple" xlink:href="../709/684709.xml">
Boyer-Moore string search algorithm</link></header>
<col>
Θ(m + &amp;#x7c;Σ&amp;#x7c;)</col>
<col>
Ω(n/m), O(n)</col>
</row>
<row>
<header>
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../223/2242223.xml">
Bitap algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
(<it>shift-or</it>, <it>shift-and</it>, <it>Baeza-Yates-Gonnet</it>)</header>
<col>
Θ(m + &amp;#x7c;Σ&amp;#x7c;)</col>
<col>
O(mn)</col>
</row>
</table>

1Asymptotic times are expressed using <link xlink:type="simple" xlink:href="../578/44578.xml">
O, Ω, and Θ notation</link></p>
<p>

The <b>Boyer–Moore string search algorithm</b> has been the standard benchmark for the practical string search literature.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</ss1>
<ss1>
<st>
 Algorithms using finite set of patterns </st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../607/184607.xml">
Aho-Corasick algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link>
Commentz-Walter algorithm</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../698/684698.xml">
Rabin-Karp string search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Algorithms using infinite number of patterns </st>
<p>

Naturally, the patterns can not be enumerated in this case. They are represented usually by a <link xlink:type="simple" xlink:href="../855/25855.xml">
regular grammar</link> or <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link>.</p>

</ss1>
</sec>
<sec>
<st>
 Other classification </st>
<p>

Other classification approaches are possible. One of the most common uses preprocessing as main criteria.</p>
<p>

<table class="wikitable">
<caption>
Classes of string searching algorithms</caption>

<header>
Text not preprocessed</header>
<header>
Text preprocessed</header>
<row>
<header>
Patterns not preprocessed</header>
<col>
Elementary algorithms</col>
<col>
Index methods</col>
</row>
<row>
<header>
Patterns preprocessed</header>
<col>
Constructed search engines</col>
<col>
Signature methods</col>
</row>
</table>
</p>

<ss1>
<st>
 Naïve string search </st>
<p>

The simplest and least efficient way to see where one string occurs inside another is to check each place it could be, one by one, to see if it's there.  So first we see if there's a copy of the needle in the first character of the haystack; if not, we look to see if there's a copy of the needle starting at the second character of the haystack; if not, we look starting at the third character, and so forth.  In the normal case, we only have to look at one or two characters for each wrong position to see that it is a wrong position, so in the average case, this takes <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it> + <it>m</it>) steps, where <it>n</it> is the length of the haystack and <it>m</it> is the length of the needle; but in the worst case, searching for a string like "aaaab" in a string like "aaaaaaaaab", it takes <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>nm</it>) steps.</p>

</ss1>
<ss1>
<st>
 Finite state automaton based search </st>
<p>

<image location="right" width="200px" src="DFA_search_mommy.svg">
</image>

In this approach, we avoid backtracking by constructing a <link xlink:type="simple" xlink:href="../404/653404.xml">
deterministic finite automaton</link> that recognizes strings containing the desired search string. These are expensive to construct—they are usually created using the <link xlink:type="simple" xlink:href="../167/1163167.xml">
powerset construction</link>—but very quick to use. For example, the DFA shown to the right recognizes the word "MOMMY". This approach is frequently generalized in practice to search for arbitrary <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link>s.</p>

</ss1>
<ss1>
<st>
Stubs</st>
<p>

<link>
Knuth-Morris-Pratt</link> computes a <link xlink:type="simple" xlink:href="../404/653404.xml">
deterministic finite automaton</link> that recognizes inputs with the string to search for as a suffix, <link xlink:type="simple" xlink:href="../709/684709.xml">
Boyer-Moore</link> starts searching from the end of the needle, so it can usually jump ahead a whole needle-length at each step. Baeza-Yates keeps track of whether the previous <it>j</it> characters were a prefix of the search string, and is therefore adaptable to <link xlink:type="simple" xlink:href="../881/308881.xml">
fuzzy string searching</link>. The <link xlink:type="simple" xlink:href="../223/2242223.xml">
bitap algorithm</link> is an application of Baeza-Yates' approach.</p>

</ss1>
<ss1>
<st>
 Index methods </st>
<p>

Faster search algorithms are based on preprocessing of the text. After building a <link xlink:type="simple" xlink:href="../005/3125005.xml">
substring index</link>, for example a <link xlink:type="simple" xlink:href="../679/794679.xml">
suffix tree</link> or <link xlink:type="simple" xlink:href="../494/1303494.xml">
suffix array</link>, the occurrences of a pattern can be found quickly. As an example, a suffix tree can be built in <math>\Theta(m)</math> time, and all <math>z</math> occurrences of a pattern can be found in <math>O(m+z)</math> time (if the alphabet size is viewed as a constant).</p>

</ss1>
<ss1>
<st>
 Other variants </st>
<p>

Some search methods, for instance <link xlink:type="simple" xlink:href="../022/864022.xml">
trigram search</link>, are intended to find a "closeness" score between the search string and the text rather than a "match/non-match". These are sometimes called "fuzzy" searches.</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../775/775.xml">
Algorithm</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Hume and Sunday (1991) <it>[Fast String Searching]</it> SOFTWARE—PRACTICE AND EXPERIENCE, VOL. 21(11), 1221–1248 (NOVEMBER 1991 )</entry>
</reflist>

<list>
<entry level="1" type="bullet">

R. S. Boyer and J. S. Moore, <it><weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf">
A fast string searching algorithm</weblink>,</it> Carom. ACM 20, (10), 262–272(1977).</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 32: String Matching, pp.906–932.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.ucr.edu/%7Estelo/pattern.html">
Huge (maintained) list of pattern matching links</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://johannburkard.de/software/stringsearch/">
StringSearch – high-performance pattern matching algorithms in Java</weblink> – Implementations of many String-Matching-Algorithms in Java (BNDM, Boyer-Moore-Horspool, Boyer-Moore-Horspool-Raita, Shift-Or)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-igm.univ-mlv.fr/~lecroq/string/index.html">
Exact String Matching Algorithms</weblink> — Animation in Java, Detailed description and C implementation of many algorithms.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.dcs.shef.ac.uk/~sam/stringmetrics.html">
String similarity metrics</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.concentric.net/~Ttwang/tech/stringscan.htm">
Boyer-Moore-Raita-Thomas</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Hume and Sunday (1991) <it>[Fast String Searching]</it> SOFTWARE—PRACTICE AND EXPERIENCE, VOL. 21(11), 1221–1248 (NOVEMBER 1991 )</entry>
</reflist>
</p>





</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
