<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 19:54:39[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<condition  confidence="0.8" wordnetid="113920835">
<state  confidence="0.8" wordnetid="100024720">
<problem  confidence="0.8" wordnetid="114410605">
<difficulty  confidence="0.8" wordnetid="114408086">
<header>
<title>True quantified Boolean formula</title>
<id>2877411</id>
<revision>
<id>226631471</id>
<timestamp>2008-07-19T14:04:33Z</timestamp>
<contributor>
<username>ChrisRuvolo</username>
<id>77508</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
<category>Satisfiability problems</category>
<category>Boolean algebra</category>
<category>PSPACE-complete problems</category>
</categories>
</header>
<bdy>

The language <b>TQBF</b> is a <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link> in computer science that contains <b>True Quantified Boolean Formulas</b>.  A fully quantified boolean formula is a formula in <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link> where every variable is quantified (or <link>
bound</link>), using either <link xlink:type="simple" xlink:href="../420/91420.xml">
existential</link> or <link xlink:type="simple" xlink:href="../174/76174.xml">
universal</link> quantifiers, at the beginning of the sentence. Any such formula is always either true or false (since there are no <link>
free</link> variables). If such a formula evaluates to true, then that formula is in the language TQBF. It is also known as <b>QSAT</b> (Quantified SAT).
<sec>
<st>
Overview</st>
<p>

In <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, the <b>quantified Boolean formula problem</b> (<b>QBF</b>) is a generalization of the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 in which both <link xlink:type="simple" xlink:href="../420/91420.xml">
existential quantifiers</link> and <link xlink:type="simple" xlink:href="../174/76174.xml">
universal quantifiers</link> can be applied to each variable. Put another way, it asks whether a <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link> sentential form over a set of Boolean variables is true or false. For example, the following is an instance of QBF:</p>
<p>

<indent level="1">

 <math>\forall x\  \exists y\  \exists z\  (x \lor y \lor z) \land (\lnot x \lor \lnot y \lor \lnot z)</math>
</indent>

QBF is the canonical <link xlink:type="simple" xlink:href="../530/1176530.xml">
complete problem</link> for <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
, the class of problems solvable by a deterministic or nondeterministic <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 in polynomial space and unlimited time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Given the formula in the form of an <link xlink:type="simple" xlink:href="../629/75629.xml">
abstract syntax tree</link>, the problem can be solved easily by a set of mutually recursive procedures which evaluate the formula. Such an algorithm uses space proportional to the height of the tree, which is linear in the worst case, but uses time exponential in the number of quantifiers.</p>
<p>

Provided that <link xlink:type="simple" xlink:href="../203/663203.xml">
MA</link> &amp;sub; PSPACE, which is widely believed, QBF cannot be solved, nor can a given solution even be verified, in either deterministic or <link xlink:type="simple" xlink:href="../812/197812.xml">
probabilistic</link> polynomial time (in fact, unlike the satisfiability problem, there's no known way to specify a solution succinctly). It is trivial to solve using an <link xlink:type="simple" xlink:href="../230/753230.xml">
alternating Turing machine</link> in linear time, which is no surprise since in fact <link xlink:type="simple" xlink:href="../351/39351.xml">
AP</link> = PSPACE, where AP is the class of problems alternating machines can solve in polynomial time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

When the seminal result <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP</link></group>
</collection>
</class>
 = PSPACE was shown (see <link xlink:type="simple" xlink:href="../255/160255.xml">
interactive proof system</link>), it was done by exhibiting an interactive proof system that could solve QBF by solving a particular arithmetization of the problem.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

QBF formulas have a number of useful canonical forms. For example, it can be shown that there is a <link xlink:type="simple" xlink:href="../695/159695.xml">
polynomial-time many-one reduction</link> that will move all quantifiers to the front of the formula and make them alternate between universal and existential quantifiers. There is another reduction that proved useful in the IP = PSPACE proof where no more than one universal quantifier is placed between each variable's use and the quantifier binding that variable. This was critical in limiting the number of products in certain subexpressions of the arithmetization.</p>

</sec>
<sec>
<st>
 Prenex normal form </st>

<p>

A fully quantified Boolean formula can be assumed to have a very specific form, called <link xlink:type="simple" xlink:href="../068/421068.xml">
prenex normal form</link>. It has two basic parts: a portion containing only quantifiers and a portion containing an unquantified Boolean formula usually denoted as <math>\phi</math>. If there are <it>n</it> Boolean variables, the entire formula can be written as</p>
<p>

<indent level="1">

<math> \exists x_1 \forall x_2 \exists x_3 \cdots Q_n x_n \phi(x_1, x_2, x_3, \dots, x_n)</math>
</indent>

where every variable falls within the <link>
scope</link> of some quantifier. By introducing dummy variables, any formula in prenex normal form can be converted into a sentence where existential and universal quantifiers alternate. Using the dummy variable <math>y_1</math>,</p>
<p>

<indent level="1">

<math> \exists x_1 \exists x_2 \phi(x_1, x_2) \quad \mapsto \quad
\exists x_1 \forall y_1 \exists x_2 \phi(x_1, x_2)</math>
</indent>

The second sentence has the same truth value but follows the restricted syntax. Assuming fully quantified Boolean formulas to be in prenex normal form is a frequent feature of proofs.</p>

</sec>
<sec>
<st>
 Solving </st>

<p>

There is a simple recursive algorithm for determining whether a TQBF is true.  Given some QBF</p>
<p>

<indent level="1">

<math>Q_1 x_1 Q_2 x_2 \cdots Q_n x_n \phi(x_1, x_2, \dots, x_n).</math>
</indent>

If the formula contains no quantifiers, we can just return the formula. Otherwise, we take off the first quantifier and check both possible values for the first variable:</p>
<p>

<indent level="1">

<math>A = Q_2 x_2 \cdots Q_n x_n \phi(0, x_2, \dots, x_n),</math>
</indent>
:<math>B = Q_2 x_2 \cdots Q_n x_n \phi(1, x_2, \dots, x_n).</math></p>
<p>

If <math>Q_1 = \exists</math>, then return <math>A \lor B</math>. If <math>Q_1 = \forall</math>, then return <math>A \land B</math>.</p>
<p>

How fast does this algorithm run?
For every quantifier in the initial QBF, the algorithm makes two recursive calls on only a linearly smaller subproblem. This gives the algorithm an exponential runtime <link xlink:type="simple" xlink:href="../578/44578.xml">
<it>O(2^n)''</it></link>.</p>
<p>

How much space does this algorithm use?
Within each invocation of the algorithm, it needs to store the intermediate results of computing A and B.  Every recursive call takes off one quantifier, so the total recursive depth is linear in the number of quantifiers.  Formulas that lack quantifiers can be evaluated in space logarithmic in the number of variables. The initial QBF was fully quantified, so there are at least as many quantifiers as variables.  Thus, this algorithm uses <it>O</it>(<it>n</it> + log <it>n</it>) = <it>O</it>(<it>n</it>) space. This makes the TQBF language part of the <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
 <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link>.</p>

</sec>
<sec>
<st>
 PSPACE-completeness </st>

<p>

The TQBF language serves in <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity theory</link> as the canonical <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../685/54685.xml">
PSPACE-complete</link></group>
</collection>
</class>
 problem. Being PSPACE-complete means that a language is in PSPACE and that the language is also <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../565/1283565.xml">
PSPACE-hard</link></group>
</collection>
</class>
.  The algorithm above shows that TQBF is in PSPACE.
Showing that TQBF is PSPACE-hard requires showing that any language in the complexity class PSPACE can be reduced to TQBF in polynomial time. I.e.,</p>
<p>

<indent level="1">

<math>\forall L\in \textrm{PSPACE}, L\leq_p \textrm{TQBF}.</math>
</indent>

This means that, for a PSPACE language L, whether an input <math>x</math> is in L can be decided by checking whether <math>f(x)</math> is in TQBF, for some function <math>f</math> that is required to run in polynomial time (relative to the length of the input) Symbolically,</p>
<p>

<indent level="1">

<math>x\in L\iff f(x)\in \textrm{TQBF}.</math>
</indent>

Proving that TQBF is PSPACE-hard, requires specification of <math>f</math>.</p>
<p>

So, suppose that L is a PSPACE language. This means that L can be decided by a polynomial space deterministic <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 (DTM). This is very important for the reduction of L to TQBF, because the configurations of any such Turing Machine can be represented as Boolean formulas, with Boolean variables representing the state of the machine as well as the contents of each cell on the Turing Machine tape, with the position of the Turing Machine head encoded in the formula by the formula's ordering. In particular, our reduction will use the variables <math>c_1</math> and <math>c_2</math>, which represent two possible configurations of the DTM for L, and a natural number t, in constructing a QBF <math>\phi_{c_1,c_2,t}</math> which is true if and only if the DTM for L can go from the configuration encoded in <math>c_1</math> to the configuration encoded in <math>c_2</math> in no more than t steps. The function <math>f</math>, then, will construct from the DTM for L a QBF <math>\phi_{c_{start},c_{accept},T}</math>, where <math>c_{start}</math> is the DTM's starting configuration, <math>c_{accept}</math> is the DTM's accepting configuration, and T is the maximum number of steps the DTM could need to move from one configuration to the other. We know that <it>T</it> = <link xlink:type="simple" xlink:href="../578/44578.xml">
<it>O</it>(exp(<it>n</it>))</link>, where n is the length of the input, because this bounds the total number of possible configurations of the relevant DTM. Of course, it cannot take the DTM more steps than there are possible configurations to reach <math>c_\mathrm{accept}</math> unless it enters a loop, in which case it will never reach <math>c_\mathrm{accept}</math> anyway.</p>
<p>

At this stage of the proof, we have already reduced the question of whether an input formula <math>w</math> (encoded, of course, in <math>c_{start}</math>) is in L to the question of whether the QBF <math>\phi_{c_{start},c_{accept},T}</math>, i.e., <math>f(w)</math>, is in TQBF. The remainder of this proof proves that <math>f</math> can be computed in polynomial time.</p>
<p>

For <math>t=1</math>, computation of <math>\phi_{c_1,c_2,t}</math> is straightforward--either one of the configurations changes to the other in one step or it does not. Since the Turing Machine that our formula represents is deterministic, this presents no problem.</p>
<p>

For <math>t&amp;gt;1</math>, computation of <math>\phi_{c_1,c_2,t}</math> involves a recursive evaluation, looking for a so-called "middle point" <math>m_1</math>. In this case, we rewrite the formula as follows:</p>
<p>

<indent level="1">

<math>\phi_{c_1,c_2,t}=\exists m_1(\phi_{c_1,m_1,\lceil t/2\rceil}\wedge\phi_{m_1,c_2,\lceil t/2\rceil}).</math>
</indent>

This converts the question of whether <math>c_1</math> can reach <math>c_2</math> in t steps to the question of whether <math>c_1</math> reaches a middle point <math>m_1</math> in <math>t/2</math> steps, which itself reaches <math>c_2</math> in <math>t/2</math> steps. The answer to the latter question of course gives the answer to the former.</p>
<p>

Now, t is only bounded by T, which is exponential (and so not polynomial) in the length of the input. Additionally, each recursive layer virtually doubles the length of the formula. (The variable <math>m_1</math> is only one midpoint--for greater t, there are more stops along the way, so to speak.) So the time required to recursively evaluate <math>\phi_{c_1,c_2,t}</math> in this manner could be exponential as well, simply because the formula could become exponentially large. This problem is solved by universally quantifying using variables <math>c_3</math> and <math>c_4</math> over the configuration pairs (e.g., <math>\{ (c_1,m_1),(m_1,c_2)\}</math>), which prevents the length of the formula from expanding due to recursive layers. This yields the following interpretation of <math>\phi_{c_1,c_2,t}</math>:</p>
<p>

<indent level="1">

<math>\phi_{c_1,c_2,t}=\exists m_1\forall (c_3,c_4)\in \{ (c_1,m_1),(m_1,c_2)\}(\phi_{c_3,c_4,\lceil t/2\rceil}).</math>
</indent>

This version of the formula can indeed be computed in polynomial time, since any one instance of it can be computed in polynomial time. The universally quantified ordered pair simply tells us that whichever choice of <math>(c_3,c_4)</math> is made, <math>\phi_{c_1,c_2,t}\iff\phi_{c_3,c_4,\lceil t/2\rceil}</math>.</p>
<p>

Thus, <math>\forall L\in \textrm{PSPACE}, L\leq_p \textrm{TQBF}</math>, so TQBF is PSPACE-hard. Together with the above result that TQBF is in PSPACE, this completes the proof that TQBF is a PSPACE-complete language.</p>
<p>

(This proof follows Sipser 2006 pp. 310-313 in all essentials. Papadimitriou 1994 also includes a proof.)</p>

</sec>
<sec>
<st>
  Miscellany </st>

<p>

<list>
<entry level="1" type="bullet">

One important subproblem in TQBF is the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
.  In this problem, you wish to know whether a given Boolean formula <math>\phi</math> can be made true with some assignment of variables.  This is equivalent to the TQBF using only existential quantifiers: </entry>
</list>
</p>
<p>

<indent level="2">

 <math>\exists x_1 \cdots \exists x_n \phi(x_1, \ldots, x_n).</math>
</indent>

<indent level="1">

This is also an example of the larger result NP <math>\subseteq</math> PSPACE which follows directly from the observation that a polynomial time   verifier for a proof of a language accepted by a NTM (Non-deterministic Turing Machine) requires polynomial space to store the proof.
</indent>

<list>
<entry level="1" type="bullet">

Any class in the <link xlink:type="simple" xlink:href="../651/658651.xml">
polynomial hierarchy</link> (<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../608/658608.xml">
PH</link></group>
</collection>
</class>
) has TQBF as its complete problem. In other words, for the class comprised of all languages L for which there exists a poly-time TM V, a verifier, such that for all input x and some constant i,</entry>
</list>
</p>
<p>

<indent level="2">

 <math>x \in L \Leftrightarrow \exists y_1 \forall y_2 \cdots Q_i y_i \  V(x,y_1,y_2,\dots,y_i)\ =\ 1</math> 
</indent>

<indent level="1">

 which has a specific QBF formulation that is given as
</indent>

<indent level="2">

 <math>\exists \phi</math>  such that <math>\exists \vec{x_1} \forall \vec{x_2} \cdots Q_i \vec{x_i}\  \phi(\vec{x_1},\vec{x_2},\dots,\vec{x_i})\ =\ 1</math> 
</indent>

<indent level="1">

where the <math>\vec{x_i}</math>'s are vectors of Boolean variables.
</indent>

<list>
<entry level="1" type="bullet">

It is important to note that while TQBF the language is defined as the collection of true quantified Boolean formulas, the abbreviation TQBF is often used (even in this article) to stand for a totally quantified Boolean formula, often simply called a QBF (quantified Boolean formula, understood as "fully" or "totally" quantified). It is important to distinguish contextually between the two uses of the abbreviation TQBF in reading the literature.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

A TQBF can be thought of as a game played between two players, with alternating moves. Existentially quantified variables are equivalent to the notion that a move is available to a player at a turn. Universally quantified variables mean that the outcome of the game does not depend on what move a player makes at that turn. Also, a TQBF whose first quantifier is existential corresponds to a <link xlink:type="simple" xlink:href="../138/2903138.xml">
formula game</link> in which the first player has a winning strategy.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Notes and references </st>
<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal" class="book">M. Garey and D. Johnson&#32;(1979). Computers and intractability: a guide to the theory of NP-completeness.&#32;W. H. Freeman, San Francisco, California. ISBN 0716710455.</cite>&nbsp;</entry>
<entry id="2">
 <cite style="font-style:normal">A. Chandra, D. Kozen, and L. Stockmeyer&#32;(1981).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=322243">
Alternation</weblink>". <it>Journal of the ACM</it>&#32;<b>28</b>&#32;(1): 114&ndash;133. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F322234.322243">
10.1145/322234.322243</weblink>.</cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal">Adi Shamir&#32;(1992).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=146585.146609">
Ip = Pspace</weblink>". <it>Journal of the ACM</it>&#32;<b>39</b>&#32;(4): 869&ndash;877. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F146585.146609">
10.1145/146585.146609</weblink>.</cite>&nbsp;</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 Fortnow &amp; Homer (2003) provides some historical background for PSPACE and TQBF.</entry>
<entry level="1" type="bullet">

 Zhang (2003) provides some historical background of Boolean formulas.</entry>
<entry level="1" type="bullet">

 Arora, Sanjeev. (2001). <weblink xlink:type="simple" xlink:href="http://www.cs.princeton.edu/~arora/pubs/aroracom.ps">
<it>COS 522: Computational Complexity''</it></weblink>.  Lecture Notes, Princeton University.  Retrieved October 10, 2005.</entry>
<entry level="1" type="bullet">

 Fortnow, Lance &amp; Steve Homer. (2003, June).  <weblink xlink:type="simple" xlink:href="http://people.cs.uchicago.edu/~fortnow/beatcs/column80.pdf">
A short history of computational complexity</weblink>.  <it>The Computational Complexity Column,</it> 80. Retrieved October 9, 2005.</entry>
<entry level="1" type="bullet">

 Papadimitriou, C. H.  (1994).  <it>Computational Complexity.</it>  Reading: Addison-Wesley.</entry>
<entry level="1" type="bullet">

 Sipser, Michael.  (2006).  <it>Introduction to the Theory of Computation.</it>  Boston: Thomson Course Technology.</entry>
<entry level="1" type="bullet">

 Zhang, Lintao. (2003).  <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/lintaoz/thesis_lintao_zhang.pdf">
<it>Searching for truth: Techniques for satisfiability of boolean formulas''</it></weblink>.  Retrieved October 10, 2005.</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Cookâ€“Levin theorem</link>, stating that <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
SAT</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 is <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../514/2841514.xml">
Generalized geography</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 The Quantified Boolean Formulas Library <weblink xlink:type="simple" xlink:href="http://www.qbflib.org">
(QBFLIB)</weblink></entry>
</list>
</p>


</sec>
</bdy>
</difficulty>
</problem>
</state>
</condition>
</article>
