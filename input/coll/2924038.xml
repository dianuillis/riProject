<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:05:28[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Ioctl</title>
<id>2924038</id>
<revision>
<id>244188025</id>
<timestamp>2008-10-09T18:30:05Z</timestamp>
<contributor>
<username>Philip Cross</username>
<id>124152</id>
</contributor>
</revision>
<categories>
<category>All pages needing cleanup</category>
<category>Unix</category>
<category>Cleanup from November 2007</category>
</categories>
</header>
<bdy>

In computing, an <b>ioctl</b> (pronounced  or "i-o-control") is part of the <link xlink:type="simple" xlink:href="../467/93467.xml">
user</link>-to-<link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link> interface of a conventional operating system. Short for "Input/output control", ioctls are typically employed to allow userspace code to communicate with hardware devices or kernel components.
<sec>
<st>
Background</st>

<p>

Conventional operating systems can be divided into two layers, <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> and the <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link>. Application code such as a <link xlink:type="simple" xlink:href="../310/30310.xml">
text editor</link> resides in <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link>, while the underlying facilities of the operating system, such as the <link xlink:type="simple" xlink:href="../882/23882.xml">
network stack</link>, reside in the kernel. Kernel code handles sensitive resources and implements the security and reliability barriers between applications; for this reason, user mode applications are prevented by the CPU from directly accessing kernel resources.</p>
<p>

<link xlink:type="simple" xlink:href="../467/93467.xml">
Userspace</link> applications make most requests of conventional kernels by means of <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link>s, which are special subroutine calls that transition the operating system from user mode to kernel mode. This is usually implemented with a system call vector, in which the requestor indicates the desired system call with an index number: for instance, "exit" might be system call 1, and "write" might be system call 4. The system call vector and index is used to look up a kernel function to handle the request. In this way, conventional operating systems typically provide several hundred system calls.</p>
<p>

Though an expedient design for system calls, this presents challenges for device drivers. By necessity, most hardware peripherals are directly addressable only within the kernel. But user code often must communicate with devices; for instance, an administrator might configure the media type on an <link xlink:type="simple" xlink:href="../499/9499.xml">
Ethernet</link> interface. Modern operating systems support a diversity of devices, many of which offer complex user-visible interfaces, and not all of which are known to the operating system vendor, so it is difficult to provide a device <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link> with hardcoded system call numbers.</p>
<p>

<b>Ioctl</b> interfaces skirt this problem by allocating a single system call shared by all device drivers. Through this system call, specific requests of various devices are vectored, typically with a handle to the device and a request number. The kernel can thus dynamically dispatch calls to devices without creating an unmanageable hardcoded system call table.</p>

</sec>
<sec>
<st>
Uses</st>

<ss1>
<st>
Terminals</st>

<p>

One use of ioctls exposed to end-user applications is terminal I/O.</p>
<p>

<family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 operating systems have traditionally made heavy use of <link xlink:type="simple" xlink:href="../707/6707.xml">
command line interface</link>s. The Unix command line interface is built on <link xlink:type="simple" xlink:href="../580/719580.xml">
pseudo terminal</link>s (ptys), which emulate hardware text terminals such as <artifact wordnetid="100021939" confidence="0.8">
<terminal wordnetid="104412901" confidence="0.8">
<facility wordnetid="103315023" confidence="0.8">
<station wordnetid="104306080" confidence="0.8">
<link xlink:type="simple" xlink:href="../207/56207.xml">
VT100</link></station>
</facility>
</terminal>
</artifact>
. Ptys are controlled and configured as if they were hardware devices, using ioctl calls. For instance, the window size of a pty is set using the TIOCSWINSZ ioctl.</p>

</ss1>
<ss1>
<st>
Hardware device configuration</st>

<p>

The most common use of ioctls is to control hardware devices. </p>
<p>

For example, on <link xlink:type="simple" xlink:href="../601/81601.xml">
Win32</link> systems, ioctl calls are used to communicate with <link>
USB</link> devices, or to discover drive geometry information for attached storage devices. </p>
<p>

Ioctls are used on Unix systems to configure the network interfaces. For example, on <link xlink:type="simple" xlink:href="../622/18932622.xml">
BSD Unix</link> systems such as <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>, the <link xlink:type="simple" xlink:href="../426/149426.xml">
IP subnet mask</link> for an interface is configured by opening a <link xlink:type="simple" xlink:href="../068/85068.xml">
network socket</link> and then invoking the SIOCSIFNETMASK ioctl on it.</p>

</ss1>
<ss1>
<st>
Kernel extensions</st>

<p>

When applications need to extend the kernel, for instance to accelerate network processing, ioctl calls provide a convenient way to bridge <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> code to kernel extensions. Kernel extensions can provide a location in the filesystem that can be opened by name, through which an arbitrary number of ioctl calls can be dispatched, allowing the extension to be programmed without adding system calls to the operating system.</p>
<p>

For example, on the <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/46145.xml">
Solaris</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 operating system, the <link xlink:type="simple" xlink:href="../568/876568.xml">
ipfilter</link> packet firewall is programmed using the SIOCIPF* ioctl calls.</p>

</ss1>
</sec>
<sec>
<st>
Implementations</st>

<ss1>
<st>
Unix</st>

<p>

A Unix <it>ioctl</it> call takes as <link xlink:type="simple" xlink:href="../065/25065.xml">
parameter</link>s:
<list>
<entry level="1" type="number">

 an open <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link></entry>
<entry level="1" type="number">

 a request code number</entry>
<entry level="1" type="number">

 either an integer value, possibly unsigned (going to the driver) or a <link xlink:type="simple" xlink:href="../018/459018.xml">
pointer</link> to data (either going to the driver or to come back from it).</entry>
</list>
</p>
<p>

The <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link> generally dispatches an ioctl straight to the device driver, which can interpret the request number and data in whatever way required.  The writers of each driver document request numbers for that particular driver and provide them as <link>
constant</link>s in a <link xlink:type="simple" xlink:href="../847/77847.xml">
header file</link>.</p>
<p>

Some Unix systems have conventions which encode within the request number the size of the data to be transferred to/from the device driver, the direction of the data transfer and the identity of the driver implementing the request.  Regardless of whether such a convention is followed, the kernel and the driver collaborate to deliver a uniform error code (denoted by the symbolic constant ENOTTY) to an application which makes a request of a driver which does not recognise it.</p>
<p>

The mnemonic ENOTTY (traditionally associated with the textual message "<it><link xlink:type="simple" xlink:href="../929/481929.xml">
Not a typewriter</link></it>") derives from the fact that in the earliest systems that incorporated an <it>ioctl</it> call, only the <link xlink:type="simple" xlink:href="../247/31247.xml">
teletype</link> (tty) device raised this error.  Though the symbolic mnemonic is fixed by compatibility requirements, some modern systems more helpfully render a more general message such as "<it>Inappropriate device control operation</it>" (or a <link xlink:type="simple" xlink:href="../844/126844.xml">
localisation</link> thereof).</p>
<p>

TCSETS exemplifies an ioctl on a <link xlink:type="simple" xlink:href="../359/77359.xml">
serial port</link>. The normal read and write calls on a serial port receive and send data bytes. An ioctl(fd,TCSETS,data) call, separate from such normal I/O, controls various driver options like handling of special <link xlink:type="simple" xlink:href="../443/73443.xml">
character</link>s, or the output signals on the port (such as the <link xlink:type="simple" xlink:href="../184/1847184.xml">
DTR</link> signal).</p>

</ss1>
<ss1>
<st>
Win32</st>

<p>

A Win32 <it>DeviceIoControl</it> takes as parameters:
<list>
<entry level="1" type="number">

 an open object handle (the Win32 equivalent of a file descriptor)</entry>
<entry level="1" type="number">

 a request code number (the "control code")</entry>
<entry level="1" type="number">

 a buffer for input parameters</entry>
<entry level="1" type="number">

 length of the input buffer</entry>
<entry level="1" type="number">

 a buffer for output results</entry>
<entry level="1" type="number">

 length of the output buffer</entry>
<entry level="1" type="number">

 an OVERLAPPED structure, if <link xlink:type="simple" xlink:href="../030/2489030.xml">
overlapped I/O</link> is being used.</entry>
</list>
</p>
<p>

The Win32 device control code takes into consideration the mode of the operation being performed. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

There are 4 defined modes of operation, impacting the security of the device driver - </p>
<p>

<list>
<entry level="1" type="number">

 METHOD_IN_DIRECT - The buffer address is verified to be readable by the user mode caller.</entry>
<entry level="1" type="number">

 METHOD_OUT_DIRECT - The buffer address is verified to be writable by the user mode caller.</entry>
<entry level="1" type="number">

 METHOD_NEITHER - User mode virtual addresses are passed to the driver without mapping or validation.</entry>
<entry level="1" type="number">

 METHOD_BUFFERED - IO Manager controlled shared buffers are used to move data to and from user mode.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Alternatives</st>

<ss1>
<st>
Other vectored call interfaces</st>

<p>

Devices and kernel extensions may be linked to <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> using additional new system calls, although this approach is rarely taken, because operating system developers try to keep the system call interface focused and efficient.</p>
<p>

On Unix operating systems, two other vectored call interfaces are popular: the <b>fcntl</b> ("file control") system call configures open files, and is used in situations such as enabling <link xlink:type="simple" xlink:href="../953/1880953.xml">
non-blocking I/O</link>; and the <b>setsockopt</b> ("set socket option") system call configures open <link xlink:type="simple" xlink:href="../068/85068.xml">
network sockets</link>, a facility used to configure the <it><link xlink:type="simple" xlink:href="../613/391613.xml">
ipfw</link></it> packet firewall on <link xlink:type="simple" xlink:href="../622/18932622.xml">
BSD Unix</link> systems.</p>

</ss1>
<ss1>
<st>
Memory mapping</st>


<ss2>
<st>
Unix</st>
<p>

Device interfaces and input/output capabilities are sometimes provided using <link xlink:type="simple" xlink:href="../248/8246248.xml">
memory-mapped file</link>s. Applications that interact with devices open a location on the filesystem corresponding to the device, as they would for an ioctl call, but then use memory mapping system calls to tie a portion of their address space to that of the kernel. </p>
<p>

This interface is a far more efficient way to provide bulk data transfer between a device and a <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> application; individual ioctl or read/write system calls inflict overhead due to repeated userspace-to-kernel transitions, where access to a memory-mapped range of addresses incurs no such overhead.</p>

</ss2>
<ss2>
<st>
Win32</st>
<p>

On <link xlink:type="simple" xlink:href="../601/81601.xml">
Win32</link> platforms, buffered IO methods or named file mapping objects can be used; however, for simple device drivers the standard DeviceIoControl METHOD_ accesses are sufficient.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
Implications</st>

<ss1>
<st>
Complexity</st>

<p>

Ioctl calls minimize the complexity of the kernel's system call interface. However, by providing a place for developers to "stash" bits and pieces of kernel programming interfaces, ioctls complicate the overall user-to-kernel API. A kernel that provides several hundred system calls may provide several thousand ioctl calls.</p>
<p>

Though the interface to ioctl calls appears somewhat different from conventional system calls, there is in practice little difference between an ioctl and a system call; an ioctl is simply a system call with a different dispatching mechanism. Many of the arguments against expanding the kernel system call interface could therefore be applied to ioctl interfaces. </p>
<p>

To application developers, system calls appear no different from application subroutines; they are simply function calls that take arguments and return values. The <link xlink:type="simple" xlink:href="../263/192263.xml">
runtime</link> libraries of the OS mask the complexity involved in invoking system calls. Unfortunately, runtime libraries do not make ioctl calls as transparent. Simple operations like discovering the <link xlink:type="simple" xlink:href="../921/14921.xml">
IP address</link>es for a machine often require tangled messes of ioctl calls, each requiring <link xlink:type="simple" xlink:href="../996/352996.xml">
magic number</link>s and argument structures. </p>
<p>

<link xlink:type="simple" xlink:href="../190/2475190.xml">
Libpcap</link> and <link>
libdnet</link> are two examples of third-party wrapper Unix libraries designed to mask the complexity of ioctl interfaces, for packet capture and packet I/O, respectively.</p>

</ss1>
<ss1>
<st>
Security</st>

<p>

The user-to-kernel interfaces of mainstream operating systems are often audited heavily for code flaws and security vulnerabilities prior to release. These audits typically focus on the well-documented system call interfaces; for instance, auditors might ensure that sensitive security calls such as changing user IDs are only available to administrative users.</p>
<p>

Ioctl interfaces are more complicated, more diverse, and thus harder to audit than system calls. Furthermore, because ioctls can be provided by third-party developers, often after the core operating system has been released, ioctl call implementations may receive less scrutiny and thus harbor more vulnerabilities. Finally, many ioctl calls, particularly for third-party device drivers, are undocumented.</p>
<p>

Because the handler for an ioctl call resides directly in kernel mode, the input from <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> should be validated carefully. Vulnerabilities in device drivers can be exploited by local users by passing invalid buffers to ioctl calls.</p>
<p>

<link xlink:type="simple" xlink:href="../601/81601.xml">
Win32</link> and <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 operating systems can protect a <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> device name from access by applications with specific access controls applied to the device. Security problems can arise when device driver developers do not apply appropriate access controls to the <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> accessible object.</p>
<p>

Some modern operating systems protect the kernel from hostile <link xlink:type="simple" xlink:href="../467/93467.xml">
userspace</link> code (such as applications that have been infected by <link xlink:type="simple" xlink:href="../373/4373.xml">
buffer overflow</link> exploits) using <link>
system call wrappers</link>. System call wrappers implement <link xlink:type="simple" xlink:href="../181/66181.xml">
role-based access control</link> by specifying which system calls can be invoked by which applications; wrappers can, for instance, be used to "revoke" the right of a mail program to spawn other programs. Ioctl interfaces complicate system call wrappers because there are large numbers of them, each taking different arguments, some of which may be required by normal programs.</p>

</ss1>
</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/aa363216.aspx">
"MSDN DeviceIoControl Documentation "</weblink></entry>
</reflist>
</p>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_style.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This section may require  to meet Wikipedia's .</b>
Please <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Ioctl&amp;action=edit">
improve this article</weblink>if you can. <it>(November 2007)''</it></col>
</row>
</table>

</p>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://linux.die.net/man/2/ioctl">
ioctl(2)</weblink>&nbsp;–&nbsp;<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 <link xlink:type="simple" xlink:href="../332/85332.xml">
man page</link></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://linux.die.net/man/2/ioctl_list">
ioctl_list(2)</weblink>&nbsp;–&nbsp;<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 <link xlink:type="simple" xlink:href="../332/85332.xml">
man page</link></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.freebsd.org/cgi/man.cgi?query=ioctl&amp;sektion=2">
ioctl(2)</weblink>&nbsp;–&nbsp;<platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/7580554.xml">
FreeBSD</link></horizontal_surface>
</surface>
</artifact>
</platform>
 System Calls <link xlink:type="simple" xlink:href="../332/85332.xml">
Manual</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
