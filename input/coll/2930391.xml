<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:02:01[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Term indexing</title>
<id>2930391</id>
<revision>
<id>168584194</id>
<timestamp>2007-11-01T20:55:51Z</timestamp>
<contributor>
<username>Escape Orbit</username>
<id>4788526</id>
</contributor>
</revision>
<categories>
<category>Orphaned articles from November 2006</category>
<category>Searching</category>
<category>All orphaned articles</category>
</categories>
</header>
<bdy>
<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="44px" src="Wiki_letter_w.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This article is  as few or no other articles <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Special:Whatlinkshere&amp;target=Term_indexing&amp;namespace=0">
link to it</weblink>.</b>
Please help  in articles on <weblink xlink:type="simple" xlink:href="http://www.google.com/search?hl=en&amp;as_qdr=all&amp;q=+site%3Aen.wikipedia.org+%22Term+indexing%22">
related topics</weblink>. <it>(November 2006)''</it></col>
</row>
</table>
</p>
<p>

 
In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>term indexing</b> is the task of creating an <link xlink:type="simple" xlink:href="../763/1603763.xml">
index</link> of terms and clauses in a collection.</p>
<p>

Many operations in automatic <link xlink:type="simple" xlink:href="../546/2546.xml">
theorem prover</link>s require search in huge 
collections of terms and clauses. Such operations typically fall into
the following scheme. Given a collection <math>S</math> of terms (clauses) and a query
term (clause) <math>q</math>, find in <math>S</math> some/all terms <math>t</math> related to <math>q</math> according to a
certain retrieval condition. Most interesting retrieval conditions
are formulated as existence of a substitution that relates in a special
way the query and the retrieved objects <math>t</math>. Here is a list of retrieval
conditions frequently used in provers:</p>
<p>

<list>
<entry level="1" type="bullet">

 term <math>q</math> is unifiable with term <math>t</math>, i.e., there exists a substitution <math> \theta </math>, such that <math>q\theta</math> = <math>t\theta</math></entry>
<entry level="1" type="bullet">

 term <math>t</math> is an instance of <math>q</math>, i.e., there exists a substitution <math>\theta</math>, such that <math>q\theta</math> = <math>t</math></entry>
<entry level="1" type="bullet">

 term <math>t</math> is a generalisation of <math>q</math>, i.e., there exists a substitution <math>\theta</math>, such that <math>q</math> = <math>t\theta</math></entry>
<entry level="1" type="bullet">

 clause <math>q</math> subsumes clause <math>t</math>, i.e., there exists a substitution <math>\theta</math>, such that <math>q\theta</math> is a subset/submultiset of <math>t</math> </entry>
<entry level="1" type="bullet">

 clause <math>q</math> is subsumed by <math>t</math>, i.e., there exists a substitution <math>\theta</math>, such that <math>t\theta</math> is a subset/submultiset of <math>q</math></entry>
</list>
</p>
<p>

More often than not, we are actually interested in finding the appropriate 
substitutions explicitly, together with the retrieved terms <math>t</math>,
rather than just in establishing existence of such substitutions. </p>
<p>

Very often the sizes of term sets to be searched are large, 
the retrieval calls are frequent and the retrieval condition test
is rather complex. In such situations linear search in <math>S</math>, when the retrieval
condition is tested on every term from <math>S</math>, becomes prohibitively costly. 
To overcome this problem, special data structures, called <it>indexes</it>, are 
designed in order to support fast retrieval. Such data structures, 
together with the accompanying algorithms for index maintenance
and retrieval, are called <it>term indexing techniques</it>.</p>

<sec>
<st>
Classic indexing techniques</st>

<p>

<list>
<entry level="1" type="bullet">

 <link>
discrimination tree</link>s</entry>
<entry level="1" type="bullet">

 <link>
substitution tree</link>s</entry>
<entry level="1" type="bullet">

 <link>
path indexing</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Modern indexing techniques</st>

<p>

<list>
<entry level="1" type="bullet">

 <link>
feature vector indexing</link></entry>
<entry level="1" type="bullet">

 <link>
code tree</link>s</entry>
<entry level="1" type="bullet">

 <link>
context tree</link>s</entry>
<entry level="1" type="bullet">

 <link>
relational path indexing</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

 P. Graf, Term Indexing, Lecture Notes in Computer Science 1053, 1996 (slightly outdated overview)</entry>
<entry level="1" type="bullet">

 R. Sekar and I.V. Ramakrishnan and A. Voronkov, Term Indexing, in A. Robinson and A. Voronkov, editors, <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../579/8402579.xml">
Handbook of Automated Reasoning</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, volume 2, 2001 (recent overview)</entry>
<entry level="1" type="bullet">

 W. W. McCune, Experiments with Discrimination-Tree Indexing and Path Indexing for Term Retrieval, Journal of Automated Reasoning, 9(2), 1992</entry>
<entry level="1" type="bullet">

 P. Graf, Substitution Tree Indexing, Proc. of RTA, Lecture Notes in Computer Science 914, 1995</entry>
<entry level="1" type="bullet">

 M. Stickel, The Path Indexing Method for Indexing Terms, Tech. Rep. 473, Artificial Intelligence Center, SRI International, 1989</entry>
<entry level="1" type="bullet">

 S. Schulz, Simple and Efficient Clause Subsumption with Feature Vector Indexing, Proc. of IJCAR-2004 workshop ESFOR, 2004</entry>
<entry level="1" type="bullet">

 A. Riazanov and A. Voronkov, Partially Adaptive Code Trees, Proc. JELIA, Lecture Notes in Artificial Intelligence 1919, 2000</entry>
<entry level="1" type="bullet">

 H. Ganzinger and R. Nieuwenhuis and P. Nivela, Fast Term Indexing with Coded Context Trees, Journal of Automated Reasoning, 32(2), 2004</entry>
<entry level="1" type="bullet">

 A. Riazanov and A. Voronkov, Efficient Instance Retrieval with Standard and Relational Path Indexing, Information and Computation, 199(1-2), 2005</entry>
</list>

</p>

</sec>
</bdy>
</article>
