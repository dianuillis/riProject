<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:36:40[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<protocol  confidence="0.9511911446218017" wordnetid="106665108">
<header>
<title>Transmission Control Protocol</title>
<id>30538</id>
<revision>
<id>244088905</id>
<timestamp>2008-10-09T08:33:10Z</timestamp>
<contributor>
<username>Kgfleischmann</username>
<id>2092791</id>
</contributor>
</revision>
<categories>
<category>Wikipedia articles needing clarification</category>
<category>Self-contradictory articles</category>
<category>Transport layer protocols</category>
<category>TCP/IP</category>
</categories>
</header>
<bdy>

The <b>Transmission Control Protocol (TCP)</b> is one of the core protocols of the <link xlink:type="simple" xlink:href="../476/15476.xml">
Internet Protocol Suite</link>. TCP is so central that the entire suite is often referred to as "TCP/IP." Whereas IP handles lower-level transmissions from computer to computer as a message makes its way across the Internet, TCP operates at a higher level, concerned only with the two <it>end systems</it>, for example a Web browser and a Web server. In particular, TCP provides reliable, ordered delivery of a stream of bytes from one program on one computer to another program on another computer. Besides the Web, other common applications of TCP include <link xlink:type="simple" xlink:href="../738/9738.xml">
e-mail</link> and <link xlink:type="simple" xlink:href="../709/7018709.xml">
file transfer</link>. Among its management tasks, TCP controls message size, the rate at which messages are exchanged, and network traffic congestion.
<p>

<table style="float:right; margin:0 0 1em 1em; width: 19em; font-size:95%;" class="navbox">
<row>
<header style="background:#adb">
 The <link xlink:type="simple" xlink:href="../476/15476.xml">
TCP/IP model</link>(RFC 1122)</header>
</row>
<row>
<header style="background:#cfc">
 <link xlink:type="simple" xlink:href="../179/172179.xml">
Application Layer</link></header>
</row>
<row>
<col><p>

<message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../893/38893.xml">
BGP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../622/8622.xml">
DHCP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../339/8339.xml">
DNS</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../289/53289.xml">
FTP</link>&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../794/12794.xml">
Gopher</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../049/2365049.xml">
GTP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../443/13443.xml">
HTTP</link></system_of_measurement>
</format>
</rule>
</direction>
</standard>
</protocol>
</information>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../837/14837.xml">
IMAP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <social_group wordnetid="107950920" confidence="0.8">
<gathering wordnetid="107975026" confidence="0.8">
<community wordnetid="108223802" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../730/14730.xml">
IRC</link></group>
</community>
</gathering>
</social_group>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/173004.xml">
NNTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../886/159886.xml">
NTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../062/23062.xml">
POP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../389/43389.xml">
RIP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../346/26346.xml">
RPC</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../661/1003661.xml">
RTCP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../163/26163.xml">
RTP</link></rule>
</direction>
</concept>
</idea>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../162/26162.xml">
RTSP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·    <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../702/28702.xml">
SDP</link></system_of_measurement>
</request>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../684/28684.xml">
SIP</link></rule>
</direction>
</concept>
</idea>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../675/27675.xml">
SMTP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../710/41710.xml">
SNMP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../215/29215.xml">
SOAP</link>&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../814/28814.xml">
SSH</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../813/187813.xml">
SSL</link> &nbsp;· <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../602/937602.xml">
STUN</link></rule>
</direction>
</concept>
</idea>
</protocol>
</message>
&nbsp;· <link xlink:type="simple" xlink:href="../062/31062.xml">
Telnet</link>&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../813/187813.xml">
TLS</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 &nbsp;· <link xlink:type="simple" xlink:href="../455/192455.xml">
XMPP</link> &nbsp;·    
Application layer protocols|(more)</p>
</col>
</row>
<row>
<header style="background:#cfc">
 <link xlink:type="simple" xlink:href="../145/146145.xml">
Transport Layer</link></header>
</row>
<row>
<col>
 <link xlink:type="simple" xlink:href="../538/30538.xml">
TCP</link>&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/31929.xml">
UDP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../423/1017423.xml">
DCCP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../896/404896.xml">
SCTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../171/618171.xml">
RSVP</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../470/309470.xml">
ECN</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  
Transport layer protocols|(more)</col>
</row>
<row>
<header style="background:#cfc">
 <link xlink:type="simple" xlink:href="../736/11207736.xml">
Internet Layer</link></header>
</row>
<row>
<col>
 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/15323.xml">
IP</link></rule>
</direction>
</protocol>
</message>
 (<message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../317/15317.xml">
IPv4</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/15318.xml">
IPv6</link></rule>
</direction>
</protocol>
</message>
)&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../107/15107.xml">
ICMP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../232/5223232.xml">
ICMPv6</link></rule>
</direction>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../654/236654.xml">
IGMP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../342/43342.xml">
IPsec</link></rule>
</direction>
</protocol>
</message>
&nbsp;· 
Internet Layer protocols|(more)</col>
</row>
<row>
<header style="background:#cfc">
 <link xlink:type="simple" xlink:href="../777/18419777.xml">
Link Layer</link></header>
</row>
<row>
<col>
 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../986/47986.xml">
ARP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../720/62720.xml">
RARP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../012/2099012.xml">
NDP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../388/43388.xml">
OSPF</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../738/1272738.xml">
Tunnels</link> &nbsp;·  <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../472/207472.xml">
Media Access Control</link></method>
</rule>
</direction>
</know-how>
</protocol>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../101/9101.xml">
Device Driver</link>s &nbsp;·  
Link protocols|(more)</col>
</row>


</table>

</p>
<sec>
<st>
Reason for TCP</st>

<p>

TCP provides a communication service at an intermediate level between an application program and the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/15323.xml">
Internet Protocol</link></rule>
</direction>
</protocol>
</message>
 (IP). That is, when an <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<furnishing wordnetid="103405265" confidence="0.8">
<table wordnetid="104379243" confidence="0.8">
<furniture wordnetid="103405725" confidence="0.8">
<console_table wordnetid="103092883" confidence="0.8">
<link xlink:type="simple" xlink:href="../746/454746.xml">
application program</link></console_table>
</furniture>
</table>
</furnishing>
</instrumentality>
</artifact>
 desires to send a large chunk of data across the Internet using IP, instead of breaking the data into IP-sized pieces and issuing a series of IP requests, the software can issue a single request to TCP and let TCP handle the IP details.</p>
<p>

IP works by exchanging pieces of information called <link xlink:type="simple" xlink:href="../734/43734.xml">
packets</link>. A packet is a sequence of <link xlink:type="simple" xlink:href="../365/3365.xml">
bytes</link> and consists of a <it>header</it> followed by a <it>body</it>. The header describes the packet's destination and which <link xlink:type="simple" xlink:href="../748/25748.xml">
routers</link> on the Internet to use to pass the packet along&mdash;generally in the right direction&mdash;until it arrives at its final destination.  The body contains the data which IP is transmitting. When IP is transmitting data on behalf of TCP, the contents of the IP packet body is TCP data.</p>
<p>

Due to network congestion, traffic load balancing, or other unpredictable network behavior, IP packets can be lost or delivered out of order. TCP detects these problems, requests retransmission of lost packets, rearranges out-of-order packets, and even helps minimize network congestion to reduce the occurrence of the other problems. Once TCP at the receiving end has finally reassembled a perfect copy of the large data chunk originally transmitted, it passes that single chunk up to the application program at the receiving end. Thus, TCP greatly simplifies the application programmer's network communication task.</p>

</sec>
<sec>
<st>
Applicability</st>

<p>

TCP is used extensively by many of the Internet's most popular application protocols and resulting applications, including the <invention wordnetid="105633385" confidence="0.8">
<link xlink:type="simple" xlink:href="../139/33139.xml">
World Wide Web</link></invention>
, <link xlink:type="simple" xlink:href="../738/9738.xml">
E-mail</link>, <link xlink:type="simple" xlink:href="../289/53289.xml">
File Transfer Protocol</link>, <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../814/28814.xml">
Secure Shell</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
, and some <link xlink:type="simple" xlink:href="../682/28682.xml">
streaming media</link> applications.</p>
<p>

However, because TCP is optimized for accurate delivery rather than timely delivery, TCP sometimes incurs relatively long delays (in the order of seconds) while waiting for out-of-order messages or retransmissions of lost messages, and it is not particularly suitable for real-time applications such as <link xlink:type="simple" xlink:href="../028/75028.xml">
Voice over IP</link>.   For such applications, protocols like the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../163/26163.xml">
Real-time Transport Protocol</link></rule>
</direction>
</concept>
</idea>
</protocol>
</message>
 (RTP) running over the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/31929.xml">
User Datagram Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 (UDP) are usually recommended instead.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

TCP is a reliable stream delivery service that guarantees delivery of a data stream sent from one host to another without duplication or losing data.  Since packet transfer is not reliable, a technique known as positive acknowledgment with retransmission is used to guarantee reliability of packet transfers.  This fundamental technique requires the receiver to respond with an acknowledgment message as it receives the data.  The sender keeps a record of each packet it sends, and waits for acknowledgment before sending the next packet.  The sender also keeps a timer from when the packet was sent, and retransmits a packet if the timer expires.  The timer is needed in case a packet becomes lost or corrupt.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

TCP (Transmission Control Protocol) consists of a set of rules: for the protocol, that are used with the Internet Protocol, and for the IP, to send data "in a form of message units" between computers over the Internet. At the same time that the IP takes care of handling the actual delivery of the data, the TCP takes care of keeping track of the individual units of data "packets" (or more accurately, "segments") that a message is divided into for efficient routing through the net. For example, when an HTML file is sent to you from a Web server, the TCP program layer of that server takes the file as a stream of bytes and divides it into segments, numbers the segments, and then forwards them individually to the IP program layer. The IP program layer then turns each TCP segment into an IP packet by adding a header which includes (among other things) the destination IP address. Even though every packet has the same destination IP address, they can get routed differently through the network. When the client program in your computer gets them, the TCP stack (implementation) reassembles the individual segments and ensures they are correctly ordered as it streams them to an application.</p>

</sec>
<sec>
<st>
TCP segment structure</st>
<p>

A TCP segment consists of two sections:
<list>
<entry level="1" type="bullet">

 header</entry>
<entry level="1" type="bullet">

 data</entry>
</list>
</p>
<p>

The TCP header<weblink xlink:type="simple" xlink:href="http://freebie.fatpipe.org/~mjb/Drawings/TCP_Header.png">
http://freebie.fatpipe.org/~mjb/Drawings/TCP_Header.png</weblink> consists of 11 fields, of which only 10 are required. The eleventh field is optional (pink background in table) and aptly named "options".</p>
<p>

<table style="text-align:center" class="wikitable">
<caption>
TCP Header</caption>
<row>
<header>
Bit offset</header>
<header colspan="4" width="11%">
Bits 0–3</header>
<header colspan="4" width="11%">
4–7</header>
<header colspan="8" width="22%">
8–15</header>
<header colspan="16" width="44%">
16–31</header>
</row>
<row>
<col>
<b>0</b></col>
<col colspan="16">
Source port</col>
<col colspan="16">
Destination port</col>
</row>
<row>
<col>
<b>32</b></col>
<col colspan="32">
Sequence number</col>
</row>
<row>
<col>
<b>64</b></col>
<col colspan="32">
Acknowledgment number</col>
</row>
<row>
<col>
<b>96</b></col>
<col colspan="4">
Data offset</col>
<col colspan="4">
Reserved</col>
<col colspan="1">
CWR</col>
<col colspan="1">
ECE</col>
<col colspan="1">
URG</col>
<col colspan="1">
ACK</col>
<col colspan="1">
PSH</col>
<col colspan="1">
RST</col>
<col colspan="1">
SYN</col>
<col colspan="1">
FIN</col>
<col colspan="16">
Window Size</col>
</row>
<row>
<col>
<b>128</b></col>
<col colspan="16">
Checksum</col>
<col colspan="16">
Urgent pointer</col>
</row>
<row>
<col>
<b>160</b></col>
<col colspan="32" bgcolor="#FFDDDD">
Options (optional)</col>
</row>
<row>
<col>
<b>160/192+</b></col>
<col colspan="32">
&nbsp;Data&nbsp;</col>
</row>
</table>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Source port (16 bits) &ndash; identifies the sending port</entry>
<entry level="1" type="bullet">

 Destination port (16 bits) &ndash; identifies the receiving port</entry>
<entry level="1" type="bullet">

 Sequence number (32 bits) &ndash; has a dual role</entry>
<entry level="2" type="bullet">

 If the SYN flag is present, then this is the initial sequence number and the sequence number of the first data byte is this sequence number plus 1</entry>
<entry level="2" type="bullet">

 If the SYN flag is not present, then this is the sequence number of the first data byte</entry>
<entry level="1" type="bullet">

 Acknowledgement number (32 bits) &ndash; if the ACK flag is set then the value of this field is the next expected byte that the receiver is expecting.</entry>
<entry level="1" type="bullet">

 Data offset (4 bits) &ndash; specifies the size of the TCP header in 32-bit words.  The minimum size header is 5 words and the maximum is 15 words thus giving the minimum size of 20 bytes and maximum of 60 bytes.  This field gets its name from the fact that it is also the offset from the start of the TCP packet to the data.</entry>
<entry level="1" type="bullet">

 Reserved (4 bits) &ndash; for future use and should be set to zero</entry>
<entry level="1" type="bullet">

 Flags (8 bits) (aka Control bits) &ndash; contains 8 1-bit flags</entry>
<entry level="2" type="bullet">

 CWR (1 bit) &ndash; Congestion Window Reduced (CWR) flag is set by the sending host to indicate that it received a TCP segment with the ECE flag set (added to header by RFC 3168).</entry>
<entry level="2" type="bullet">

 ECE (ECN-Echo) (1 bit) &ndash; indicate that the TCP peer is <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../470/309470.xml">
ECN</link></rule>
</direction>
</protocol>
</message>
 capable during 3-way handshake (added to header by RFC 3168).</entry>
<entry level="2" type="bullet">

 URG (1 bit) &ndash; indicates that the URGent pointer field is significant</entry>
<entry level="2" type="bullet">

 ACK (1 bit) &ndash; indicates that the ACKnowledgment field is significant</entry>
<entry level="2" type="bullet">

 PSH (1 bit) &ndash; Push function</entry>
<entry level="2" type="bullet">

 RST (1 bit) &ndash; Reset the connection</entry>
<entry level="2" type="bullet">

 SYN (1 bit) &ndash; Synchronize sequence numbers</entry>
<entry level="2" type="bullet">

 FIN (1 bit) &ndash; No more data from sender</entry>
<entry level="1" type="bullet">

 Window (16 bits) &ndash; the size of the <b>receive window</b>, which specifies the number of bytes (beyond the sequence number in the acknowledgment field) that the receiver is currently willing to receive (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Flow+control%22])">
Flow control</link></it>)</entry>
<entry level="1" type="bullet">

 Checksum (16 bits) &ndash; The 16-bit <link xlink:type="simple" xlink:href="../538/7538.xml">
checksum</link> field is used for error-checking of the header <it>and data''</it></entry>
<entry level="1" type="bullet">

 Urgent pointer (16 bits) &ndash; if the URG flag is set, then this 16-bit field is an offset from the sequence number indicating the last urgent data byte</entry>
<entry level="1" type="bullet">

 Options (Variable bits) &ndash; the total length of the option field must be a multiple of a 32-bit word and the data offset field adjusted appropriately</entry>
<entry level="2" type="bullet">

0 - End of options list</entry>
<entry level="2" type="bullet">

1 - No operation (NOP, Padding)</entry>
<entry level="2" type="bullet">

2 - Maximum segment size (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Maximum+segment+size%22])">
maximum segment size</link></it>)</entry>
<entry level="2" type="bullet">

3 - Window scale (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Window+scaling%22])">
window scaling</link> for details</it>)</entry>
<entry level="2" type="bullet">

4 - Selective Acknowledgement ok (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Selective+acknowledgments%22])">
selective acknowledgments</link> for details</it>)</entry>
<entry level="2" type="bullet">

5 - </entry>
<entry level="2" type="bullet">

6 - </entry>
<entry level="2" type="bullet">

7 - </entry>
<entry level="2" type="bullet">

8 - Timestamp (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22TCP+Timestamps%22])">
TCP Timestamps</link> for details</it>)</entry>
</list>
</p>
<p>

The last field is not a part of the header. The contents of this field are whatever the upper layer protocol wants but this protocol is not set in the header and is presumed based on the port selection.
<list>
<entry level="1" type="bullet">

 Data (Variable bits): As you might expect, this is the payload, or data portion of a TCP packet. The payload may be any number of application layer protocols. The most common are HTTP, Telnet, SSH, FTP, but other popular protocols also use TCP.</entry>
</list>
</p>

</sec>
<sec>
<st>
Protocol operation</st>

<p>

<image location="right" width="250px" src="Tcp_state_diagram.svg" type="thumbnail">
<caption>
<p>

<image width="38px" src="Ambox_contradict.svg">
<caption>

Accuracy dispute
</caption>
</image>
</p>
<p>

| class="mbox-text" style=""| This section appears to <b>contradict</b> itself&nbsp;about active/passive closes. Please help <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Transmission_Control_Protocol&amp;action=edit">
fix&nbsp;this&nbsp;problem</weblink>. </p>


<p>

|}

</p>

</caption>
</image>
</p>
<p>

Unlike TCP's traditional counterpart, <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/31929.xml">
User Datagram Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
, which can immediately start sending packets, TCP provides connections that need to be established before sending data. TCP connections have three phases:</p>
<p>

<list>
<entry level="1" type="number">

 connection establishment</entry>
<entry level="1" type="number">

 data transfer</entry>
<entry level="1" type="number">

 connection termination</entry>
</list>
</p>
<p>

Before describing these three phases, a note about the various <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/285512.xml">
states</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 of a connection end-point or <it><link xlink:type="simple" xlink:href="../218/4764218.xml">
Internet socket</link></it>:
<list>
<entry level="1" type="number">

 LISTEN</entry>
<entry level="1" type="number">

 SYN-SENT</entry>
<entry level="1" type="number">

 SYN-RECEIVED </entry>
<entry level="1" type="number">

 ESTABLISHED</entry>
<entry level="1" type="number">

 FIN-WAIT-1</entry>
<entry level="1" type="number">

 FIN-WAIT-2</entry>
<entry level="1" type="number">

 CLOSE-WAIT</entry>
<entry level="1" type="number">

 CLOSING</entry>
<entry level="1" type="number">

 LAST-ACK</entry>
<entry level="1" type="number">

 TIME-WAIT</entry>
<entry level="1" type="number">

 CLOSED</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 LISTEN : represents waiting for a connection request from any remote TCP and port. (usually set by TCP servers)</entry>
<entry level="1" type="definition">

 SYN-SENT : represents waiting for the remote TCP to send back a TCP packet with the SYN and ACK flags set. (usually set by TCP clients)</entry>
<entry level="1" type="definition">

 SYN-RECEIVED : represents waiting for the remote TCP to send back an acknowledgment after having sent back a connection acknowledgment to the remote TCP. (usually set by TCP servers)</entry>
<entry level="1" type="definition">

 ESTABLISHED : represents that the port is ready to receive/send data from/to the remote TCP. (set by TCP clients and servers)</entry>
<entry level="1" type="definition">

 TIME-WAIT : represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request. According to RFC 793 a connection can stay in TIME-WAIT for a maximum of four minutes.</entry>
</list>
</p>

<ss1>
<st>
Connection establishment</st>
<p>

To establish a connection, TCP uses a three-way <link xlink:type="simple" xlink:href="../229/41229.xml">
handshake</link>.</p>
<p>

Before a client attempts to connect with a server, the server must first bind to a port to open it up for connections: this is called a passive open.
Once the passive open is established, a client may initiate an active open.
To establish a connection, the three-way (or 3-step) handshake occurs: 
<list>
<entry level="1" type="number">

 The active open is performed by the client sending a SYN to the server.</entry>
<entry level="1" type="number">

 In response, the server replies with a SYN-ACK.</entry>
<entry level="1" type="number">

 Finally the client sends an ACK back to the server.</entry>
</list>
</p>
<p>

At this point, both the client and server have received an acknowledgment of the connection.</p>
<p>

Example:
<list>
<entry level="1" type="number">

 The initiating host (client) sends a synchronization packet (SYN flag set to 1) to initiate a connection. It sets the packet's sequence number to a random value <math>x</math>.</entry>
<entry level="1" type="number">

 The other host receives the packet, records the sequence number <math>x</math> from the client, and replies with an acknowledgment and synchronization (SYN-ACK). The Acknowledgment is a 32-bit field in TCP segment header. It contains the next sequence number that this host is expecting to receive <math>(x + 1)</math>. The host also initiates a return session. This includes a TCP segment with its own initial Sequence Number of value <math>y</math>.</entry>
<entry level="1" type="number">

 The initiating host responds with the next Sequence Number <math>(x + 1)</math> and a simple Acknowledgment Number value of <math>y + 1</math>, which is the Sequence Number value of the other host + 1.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Data transfer</st>
<p>

There are a few key features that set TCP apart from <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/31929.xml">
User Datagram Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
:
<list>
<entry level="1" type="bullet">

 Ordered data transfer - the destination host rearranges according to sequence number<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
<entry level="1" type="bullet">

 Retransmission of lost packets - any cumulative stream not acknowledged will be retransmitted<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
<entry level="1" type="bullet">

 Discarding duplicate packets</entry>
<entry level="1" type="bullet">

 Error-free data transfer</entry>
<entry level="1" type="bullet">

 Flow control - limits the rate a sender transfers data to guarantee reliable delivery.  When the receiving host's buffer fills, then next acknowledgement contains a 0 in the window size, to stop transfer and allow the data in the buffer to be processed.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
<entry level="1" type="bullet">

 Congestion control - sliding window<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
</list>
</p>

<ss2>
<st>
 Ordered data transfer, retransmission of lost packets and discarding duplicate packets  </st>

<p>

TCP uses a <it>sequence number</it> to identify each byte of data. The sequence number identifies the order of the bytes sent from each computer so that the data can be transferred reliably and in order, regardless of any fragmentation, disordering, or <link xlink:type="simple" xlink:href="../109/2928109.xml">
packet loss</link> that occurs during transmission.
For every byte transmitted the sequence number must be incremented. In the first two steps of the 3-way handshake, both computers exchange an initial sequence number (ISN). This number can be arbitrary, and should in fact be unpredictable, in order to avoid a <link xlink:type="simple" xlink:href="../632/4487632.xml">
TCP Sequence Prediction Attack</link>.</p>
<p>

TCP primarily uses a <it>cumulative acknowledgment</it> scheme, where the receiver sends an acknowledgment signifying that the receiver has received all data preceding the acknowledged sequence number. Essentially, the first data byte in a segment is assigned a sequence number, which is inserted in the sequence number field, and the receiver sends an acknowledgment specifying the sequence number of the next byte they expect to receive. For example, if computer A sends 4 bytes with a sequence number of 100 (conceptually, the four bytes would have a sequence number of 100, 101, 102, &amp; 103 assigned) then the receiver would send back an acknowledgment of 104 since that is the next byte it expects to receive in the next packet. By sending an acknowledgment of 104, the receiver is signaling that it received bytes 100, 101, 102, &amp; 103 correctly.  If, by some chance, the last two bytes were corrupted then an acknowledgment value of 102 would be sent since 100 &amp; 101 were received successfully.</p>
<p>

In addition to cumulative acknowledgments, TCP receivers can also send selective acknowledgments to provide further information (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Selective+acknowledgments%22])">
selective acknowledgments</link></it>).</p>
<p>

If the sender infers that data has been lost in the network, it <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../648/2667648.xml">
retransmits</link></rule>
</direction>
</protocol>
</message>
 the data.</p>

</ss2>
<ss2>
<st>
Error-free data transfer </st>
<p>

Sequence numbers and acknowledgments cover discarding duplicate packets, retransmission of lost packets, and ordered-data transfer.
To assure correctness a <link xlink:type="simple" xlink:href="../538/7538.xml">
checksum</link> field is included (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22TCP+segment+structure%22])">
TCP segment structure</link> for details on checksumming</it>).</p>
<p>

The TCP checksum is a quite weak check by modern standards.  Data Link Layers with high bit error rates may require additional link error correction/detection capabilities. If TCP were to be redesigned today, it would most probably have a 32-bit <link xlink:type="simple" xlink:href="../838/38838.xml">
cyclic redundancy check</link> specified as an error check instead of the current checksum.  The weak checksum is partially compensated for by the common use of a CRC or better integrity check at <link xlink:type="simple" xlink:href="../949/152949.xml">
layer 2</link>, below both TCP and IP, such as is used in <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../511/23511.xml">
PPP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 or the <link xlink:type="simple" xlink:href="../499/9499.xml">
Ethernet</link> frame. However, this does not mean that the 16-bit TCP checksum is redundant: remarkably, introduction of errors in packets between CRC-protected hops is common, but the <link xlink:type="simple" xlink:href="../042/238042.xml">
end-to-end</link> 16-bit TCP checksum catches most of these simple errors <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>.  This is the <link xlink:type="simple" xlink:href="../042/238042.xml">
end-to-end principle</link> at work.</p>

</ss2>
<ss2>
<st>
 Flow control </st>

<p>

TCP uses an end-to-end <link xlink:type="simple" xlink:href="../428/1619428.xml">
flow control</link> protocol to avoid having the sender send data too fast for the TCP receiver to reliably receive and process it. Having a mechanism for flow control is essential  in an environment where machines of diverse network speeds communicate. For example, when a fast PC sends data to a slow hand-held PDA, the PDA needs to regulate the influx of data, or protocol software would be overrun quickly.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Similarly, flow control is essential if the application that is receiving the data is reading it more slowly than the sending application is sending it.</p>
<p>

TCP uses a <link xlink:type="simple" xlink:href="../727/12824727.xml">
sliding window</link> flow control protocol. In each TCP segment, the receiver specifies in the <b>receive window</b> field the amount of additional received data (in bytes) that it is willing to buffer for the connection. The sending host can send only up to that amount of data before it must wait for an acknowledgment and window update from the receiving host.</p>
<p>

<image location="right" width="250px" src="Tcp.png" type="thumbnail">
<caption>

TCP sequence numbers and receive windows behave very much like a clock. The receive window shifts each time the receiver receives and acknowledges a new segment of data. Once it runs out of sequence numbers, the sequence number loops back to 0.
</caption>
</image>
 </p>
<p>

When a receiver advertises a window size of 0, the sender stops sending data and starts the <b>persist timer</b>. The persist timer is used to protect TCP from a <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link> situation that could arise if the window size update from the receiver is lost and the receiver has no more data to send while the sender is waiting for the new window size update. When the persist timer expires the TCP sender sends a small packet so that the receiver sends an acknowledgement with the new window size.</p>
<p>

If a receiver is processing incoming data in small increments, it may repeatedly advertise a small receive window. This is referred to as the <link xlink:type="simple" xlink:href="../596/2111596.xml">
silly window syndrome</link>, since it is inefficient to send only a few bytes of data in a TCP segment, given the relatively large overhead of the TCP header. TCP senders and receivers typically employ flow control logic to specifically avoid repeatedly sending small segments. The sender-side silly window syndrome avoidance logic is referred to as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../169/1753169.xml">
Nagle's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>

</ss2>
<ss2>
<st>
 Congestion control </st>
<p>

The final main aspect of TCP is <link xlink:type="simple" xlink:href="../196/6008196.xml">
congestion control</link>. TCP uses a number of mechanisms to achieve high performance and avoid '<link xlink:type="simple" xlink:href="../271/2668271.xml">
congestion collapse</link>', where network performance can fall by several orders of magnitude. These mechanisms control the rate of data entering the network, keeping the data flow below a rate that would trigger collapse.</p>
<p>

Acknowledgments for data sent, or lack of acknowledgments, are used by senders to infer network conditions between the TCP sender and receiver. Coupled with timers, TCP senders and receivers can alter the behavior of the flow of data. This is more generally referred to as congestion control and/or network congestion avoidance.</p>
<p>

Modern implementations of TCP contain four intertwined algorithms:  <link xlink:type="simple" xlink:href="../666/1977666.xml">
Slow-start</link>, <link xlink:type="simple" xlink:href="../471/1723471.xml">
congestion avoidance</link>, <link xlink:type="simple" xlink:href="../192/2425192.xml">
fast retransmit</link>, and <link xlink:type="simple" xlink:href="../666/1977666.xml#xpointer(//*[./st=%22Fast+Recovery%22])">
fast recovery</link> (<weblink xlink:type="simple" xlink:href="http://rfc.sunsite.dk/rfc/rfc2581.html">
RFC2581</weblink>).</p>
<p>

In addition, senders employ a <b>retransmission timer</b> that is based on the estimated <link xlink:type="simple" xlink:href="../672/41672.xml">
round-trip time</link> (or RTT) between the sender and receiver, as well as the variance in this round trip time. The behavior of this timer is specified in RFC 2988. There are subtleties in the estimation of RTT. For example, senders must be careful when calculating RTT samples for retransmitted packets; typically they use <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../781/14467781.xml">
Karn's Algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 or TCP timestamps (see RFC 1323).  These individual RTT samples are then averaged over time to create a Smoothed Round Trip Time (SRTT) using <link>
Jacobson's algorithm</link>.  This SRTT value is what is finally used as the round-trip time estimate.</p>
<p>

Enhancing TCP to reliably handle loss, minimize errors, manage congestion and go fast in very high-speed environments are ongoing areas of research and standards development. As a result, there are a number of <link xlink:type="simple" xlink:href="../471/1723471.xml">
TCP congestion avoidance algorithm</link> variations.</p>

</ss2>
</ss1>
<ss1>
<st>
 Maximum segment size </st>

<p>

The <link xlink:type="simple" xlink:href="../445/600445.xml">
Maximum segment size</link> (MSS) is the largest amount of data, specified in bytes, that TCP is willing to send in a single segment. For best performance, the MSS should be set small enough to avoid <link xlink:type="simple" xlink:href="../677/323677.xml">
IP fragmentation</link>, which can lead to excessive retransmissions if there is packet loss. To try to accomplish this, typically the MSS is negotiated using the MSS option when the TCP connection is established, in which case it is determined by the <link xlink:type="simple" xlink:href="../894/20894.xml">
maximum transmission unit</link> (MTU) size of the <link xlink:type="simple" xlink:href="../949/152949.xml">
data link layer</link> of the networks to which the sender and receiver are directly attached.  Furthermore, TCP senders can use <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../283/6018283.xml">
Path MTU discovery</link></rule>
</direction>
</protocol>
</message>
 to infer the minimum MTU along the network path between the sender and receiver, and use this to dynamically adjust the MSS in order to avoid IP fragmentation within the network.</p>

</ss1>
<ss1>
<st>
 Selective acknowledgments </st>

<p>

Relying purely on the cumulative acknowledgment scheme employed by the original TCP protocol can lead to inefficiencies when packets are lost. For example, suppose 10,000 bytes are sent in 10 different TCP packets, and the first packet is lost during transmission. In a pure cumulative acknowledgment protocol, the receiver cannot say that it received bytes 1,000 to 9,999 successfully, but failed to receive the first packet, containing bytes 0 to 999. Thus the sender would then have to resend all 10,000 bytes.</p>
<p>

In order to solve this problem TCP employs the <it>selective acknowledgment (SACK)</it> option, defined in RFC 2018, which allows the receiver to acknowledge discontiguous blocks of packets that were received correctly, in addition to the sequence number of the last contiguous byte received successively, as in the basic TCP acknowledgment. The acknowledgement can specify a number of <it>SACK blocks</it>, where each SACK block is conveyed by the starting and ending sequence numbers of a contiguous range that the receiver correctly received. In the example above, the receiver would send SACK with sequence numbers 1,000 and 10,000. The sender will thus retransmit only the first packet, bytes 0 to 999.</p>
<p>

The SACK option is not mandatory and it is used only if both parties support it. This is negotiated when connection is established. SACK uses the optional part of the TCP header (<it>see <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22TCP+segment+structure%22])">
TCP segment structure</link> for details</it>). The use of SACK is widespread - all popular TCP stacks support it. Selective acknowledgment is also used in <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../896/404896.xml">
SCTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
.</p>

</ss1>
<ss1>
<st>
 Window scaling </st>

<p>

<indent level="1">

<it>Main article: <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../525/5747525.xml">
TCP window scale option</link></rule>
</direction>
</protocol>
</message>
</it>
</indent>
For more efficient use of high bandwidth networks, a larger TCP window size may be used. The TCP window size field controls the flow of data and is limited to between 2 and 65,535 bytes.</p>
<p>

Since the size field cannot be expanded, a scaling factor is used. The <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../525/5747525.xml">
TCP window scale option</link></rule>
</direction>
</protocol>
</message>
, as defined in RFC 1323, is an option used to increase the maximum window size from 65,535 bytes to 1 Gigabyte.  Scaling up to larger window sizes is a part of what is necessary for <link xlink:type="simple" xlink:href="../128/2584128.xml">
TCP Tuning</link>.</p>
<p>

The window scale option is used only during the TCP 3-way handshake. The window scale value represents the number of bits to left-shift the 16-bit window size field. The window scale value can be set from 0 (no shift) to 14.</p>
<p>

Many routers and packet firewalls rewrite the window scaling factor during a transmission. This causes sending and receiving sides to assume different TCP window sizes. The result is non-stable traffic that is very slow. The problem is visible on some sending and receiving sites which are behind the path of broken routers.</p>
<p>

TCP window scaling can be a particular problem on <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 and <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../648/2289648.xml">
Windows Vista</link></version>
 systems.</p>

</ss1>
<ss1>
<st>
 TCP Timestamps </st>

<p>

TCP timestamps, defined in RFC 1323, help TCP compute the <link xlink:type="simple" xlink:href="../672/41672.xml">
round-trip time</link> between the sender and receiver. Timestamp options include a 4-byte timestamp value, where the sender inserts its current value of its timestamp clock, and a 4-byte echo reply timestamp value, where the receiver generally inserts the most recent timestamp value that it has received. The sender uses the echo reply timestamp in an acknowledgment to compute the total elapsed time since the acknowledged segment was sent.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

TCP timestamps are also used to help in the case where TCP sequence numbers encounter their 232 bound and "wrap around" the sequence number space. This scheme is known as <it>Protect Against Wrapped Sequence</it> numbers, or <it>PAWS</it> (see RFC 1323 for details).</p>

</ss1>
<ss1>
<st>
 Out of Band Data </st>
<p>

One is able to interrupt or abort the queued stream instead of waiting for the stream to finish.  This is done by specifying the data as <it>urgent</it>.  This will tell the receiving program to process it immediately, along with the rest of the urgent data.  When finished, TCP informs the application and resumes back to the stream queue.
An example is when TCP is used for a remote login session, the user can send a keyboard sequence that interrupts or aborts the program at the other end.  These signals are most often needed when a program on the remote machine fails to operate correctly.  The signals must be sent without waiting for the program to finish its current transfer. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

Unfortunately, TCP OOB data was not designed for the modern Internet. The <it>urgent</it> pointer only alters the processing on the remote host and doesn't expedite any processing on the network itself. When it gets to the remote host there are two slightly different interpretations of the protocol which means only single bytes of OOB data are reliable. This is assuming it's reliable at all as it's one of the least commonly used protocol elements and tends to be poorly implemented.</p>

</ss1>
<ss1>
<st>
Forcing Data Delivery</st>

<p>

Normally, TCP waits for the buffer to exceed the maximum segment size before sending any data.  This creates serious delays when the two sides of the connection are exchanging short messages and need to receive the response before continuing.  For example, the login sequence at the beginning of a session begins with the short message "Login," and the session cannot make any progress until these five characters have been transmitted and the response has been received.  This process can be seriously delayed by TCP's normal behavior.</p>
<p>

However, an application can force delivery of octets to the output stream using a <it>push</it> operation provided by TCP to the application layer.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>  This operation also causes TCP to set the PSH flag or control bit to ensure that data will be delivered immediately to the application layer by the receiving transport layer. </p>
<p>

In the most extreme cases, for example when a user expects each keystroke to be echoed by the receiving application, the <it>push</it> operation can be used each time a keystroke occurs.  More generally, application programs use this function to force output to be sent after writing a character or line of characters.  By forcing the data to be sent immediately, delays and wait time are reduced.</p>

</ss1>
<ss1>
<st>
 Connection termination </st>
<p>

The connection termination phase uses, at most, a four-way <link xlink:type="simple" xlink:href="../229/41229.xml">
handshake</link>, with each side of the connection terminating independently.  When an endpoint wishes to stop its half of the connection, it transmits a FIN packet, which the other end acknowledges with an ACK. Therefore, a typical tear-down requires a pair of FIN and ACK segments from each TCP endpoint.</p>
<p>

A connection can be <link xlink:type="simple" xlink:href="../720/5170720.xml">
"half-open"</link>, in which case one side has terminated its end, but the other has not. The side that has terminated can no longer send any data into or receive any data from the connection, but the other side can (but generally if it tries, this should result in no acknowledgment and therefore a timeout, or else result in a positive RST, and either way thereby the destruction of the half-open socket).</p>
<p>

It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN &amp; ACK (merely combines 2 steps into one) and host A replies with an ACK.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> This is perhaps the most common method.</p>
<p>

It is possible for both hosts to send FINs simultaneously then both just have to ACK.  This could possibly be considered a 2-way handshake since the FIN/ACK sequence is done in parallel for both directions.</p>
<p>

Some host TCP stacks may implement a "half-duplex" close sequence, as <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 or <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../704/36704.xml">
HP-UX</link></O>
 do. If such a host actively closes a connection but still has not read all the incoming data the stack already received from the link, this host will send a RST instead of a FIN (Section 4.2.2.13 in <weblink xlink:type="simple" xlink:href="http://tools.ietf.org/html/rfc1122">
RFC 1122</weblink>). This allows a TCP application to be sure that the remote application has read all the data the former sent - waiting the FIN from the remote side when it will actively close the connection. Unfortunately, the remote TCP stack cannot distinguish between a <it>Connection Aborting RST</it> and this <it>Data Loss RST</it> - both will make the remote stack to throw away all the data it received, but the application still didn't read.&#91;&#93;</p>
<p>

Some application protocols may violate the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<proposal wordnetid="107162194" confidence="0.8">
<recommendation wordnetid="106671637" confidence="0.8">
<advice wordnetid="106671484" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../747/22747.xml">
OSI model layers</link></system_of_measurement>
</advice>
</recommendation>
</proposal>
</rule>
</direction>
</standard>
</protocol>
</message>
, using the TCP open/close handshaking for the application protocol open/close handshaking - these may find the RST problem on active close. As an example:
s = connect(remote);
send(s, data);
close(s);
For a usual program flow like above, a TCP/IP stack like that described above does not guarantee that all the data will arrive to the other application <it>unless</it> the programmer is sure that the remote side will not send anything.</p>

</ss1>
<ss1>
<st>
 Vulnerabilities </st>

<ss2>
<st>
 Vulnerability to Denial of Service </st>
<p>

By using a spoofed IP address and repeatedly sending <link xlink:type="simple" xlink:href="../762/1256762.xml">
purposely assembled</link> SYN packets attackers can cause the server to consume large amounts of resources keeping track of the bogus connections.  This is known as a <operation wordnetid="100955060" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<attack wordnetid="100972621" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../095/236095.xml">
SYN flood</link></activity>
</psychological_feature>
</act>
</attack>
</event>
</operation>
 attack.  Proposed solutions to this problem include <link xlink:type="simple" xlink:href="../326/6507326.xml">
SYN cookies</link> and Cryptographic puzzles.</p>

</ss2>
<ss2>
<st>
 Connection hijacking </st>
<p>

An attacker who is able to eavesdrop a TCP session and redirect packets can hijack a TCP connection. To do so, the attacker learns the sequence number from the ongoing communication and forges a false packet that looks like the next packet in the stream. Such a simple hijack can result in one packet being erroneously accepted at one end. When the receiving host acknowledges the extra packet to the other side of the connection, synchronization is lost. Hijacking might be combined with ARP or routing attacks that allow taking control of the packet flow, so as to get permanent control of the hijacked TCP connection.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>
<p>

Impersonating a different IP address was possible prior to RFC 1948, when the initial <it>sequence number</it> was easily guessable. That allowed an attacker to blindly send a sequence of packets that the receiver would believe to come from a different IP address, without the need to deploy ARP or routing attacks: it is enough to ensure that the legitimate host of the impersonated IP address is down, or bring it to that condition using denial of service attacks.  This is why the initial sequence number is chosen at random.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
 TCP ports </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../331/4971331.xml">
TCP and UDP port</link></it>
</indent>

TCP uses the notion of <link xlink:type="simple" xlink:href="../331/4971331.xml">
port number</link>s to identify sending and receiving application end-points on a host, or <it><link xlink:type="simple" xlink:href="../218/4764218.xml">
Internet socket</link>s</it>.  Each side of a TCP connection has an associated 16-bit unsigned port number (0-65535) reserved by the sending or receiving application.  Arriving TCP data packets are identified as belonging to a specific TCP connection by its sockets, that is, the combination of source host address, source port, destination host address, and destination port. This means that a server computer can provide several clients with several services simultaneously, as long as a client takes care of initiating any simultaneous connections to one destination port from different source ports.</p>
<p>

Port numbers are categorized into three basic categories: well-known, registered, and dynamic/private.  The well-known ports are assigned by the <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/84022.xml">
Internet Assigned Numbers Authority</link></system_of_measurement>
</standard>
 (IANA) and are typically used by system-level or root processes.  Well-known applications running as servers and passively listening for connections typically use these ports.  Some examples include: <link xlink:type="simple" xlink:href="../289/53289.xml">
FTP</link> (21), <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../814/28814.xml">
ssh</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 (22), <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../062/31062.xml">
TELNET</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 (23), <link>
SMTP</link> (25) and <link xlink:type="simple" xlink:href="../104/2701104.xml">
HTTP</link> (80).  Registered ports are typically used by end user applications as ephemeral source ports when contacting servers, but they can also identify named services that have been registered by a third party.  Dynamic/private ports can also be used by end user applications, but are less commonly so. Dynamic/private ports do not contain any meaning outside of any particular TCP connection.</p>

</sec>
<sec>
<st>
 Development </st>

<p>

TCP is a complex and evolving protocol.  However, while significant enhancements have been made and proposed over the years, its most basic operation has not changed significantly since its first specification <weblink xlink:type="simple" xlink:href="http://www.ietf.org/rfc/rfc675.txt">
RFC 675</weblink> in 1974, and the v4 specification RFC 793, published in <link xlink:type="simple" xlink:href="../776/34776.xml">
September 1981</link>.<weblink xlink:type="simple" xlink:href="http://www.faqs.org/rfcs/rfc793.html">
http://www.faqs.org/rfcs/rfc793.html</weblink>  RFC 1122, Host Requirements for Internet Hosts, clarified a number of TCP protocol implementation requirements. RFC 2581, TCP Congestion Control, one of the most important TCP-related RFCs in recent years, describes updated algorithms to be used in order to avoid undue congestion. In 2001, RFC 3168 was written to describe <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../470/309470.xml">
explicit congestion notification</link></rule>
</direction>
</protocol>
</message>
 (<message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../470/309470.xml">
ECN</link></rule>
</direction>
</protocol>
</message>
), a congestion avoidance signalling mechanism.</p>
<p>

The original <link xlink:type="simple" xlink:href="../471/1723471.xml">
TCP congestion avoidance algorithm</link> was known as "TCP Tahoe", but many alternative algorithms have since been proposed (including <link>
TCP Reno</link>, <link xlink:type="simple" xlink:href="../265/2115265.xml">
TCP Vegas</link>, <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../066/746066.xml">
FAST TCP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
, <link>
TCP New Reno</link>, and <link>
TCP Hybla</link>).</p>
<p>

<link>
TCP Interactive</link> (iTCP) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> is a research effort into TCP extensions that allows applications to subscribe to TCP events and register handler components that can launch applications for various purposes, including application assisted congestion control.</p>

</sec>
<sec>
<st>
 TCP over wireless </st>
<p>

TCP has been optimized for wired networks. Any <link xlink:type="simple" xlink:href="../109/2928109.xml">
packet loss</link> is considered to be the result of congestion and the congestion window size is reduced dramatically as a precaution. However, wireless links are known to experience sporadic and usually temporary losses due to fading, shadowing, hand off, and other radio effects, that cannot be considered congestion. After the (erroneous) back-off of the congestion window size, due to wireless packet loss, there can be a congestion avoidance phase with a conservative decrease in window size. This causes the radio link to be underutilized.  Extensive research has been done on the subject of how to combat these harmful effects. Suggested solutions can be categorized as end-to-end solutions (which require modifications at the client and/or server), link layer solutions (such as <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../607/2368607.xml">
RLP</link></rule>
</direction>
</protocol>
</message>
 in <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../213/481213.xml">
CDMA2000</link></system_of_measurement>
</standard>
), or proxy based solutions (which require some changes in the network without modifying end nodes).</p>

</sec>
<sec>
<st>
 Hardware implementations </st>

<p>

One way to overcome the processing power requirements of TCP is to build hardware implementations of it, widely known as <link xlink:type="simple" xlink:href="../531/849531.xml">
TCP Offload Engine</link>s (TOE). The main problem of TOEs is that they are hard to integrate into computing systems, requiring extensive changes in the operating system of the computer or device. The first company to develop such a device was <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../505/2231505.xml">
Alacritech</link></institution>
</company>
.</p>

</sec>
<sec>
<st>
 Debugging </st>
<p>

A <link xlink:type="simple" xlink:href="../114/59114.xml">
packet sniffer</link>, which intercepts TCP traffic on a network link, can be useful in debugging networks, network stacks and applications which use TCP by showing the user what packets are passing through a link.  Some networking stacks support the SO_DEBUG socket option, which can be enabled on the socket using setsockopt. That option dumps all the packets, TCP states and events on that socket which will be helpful in debugging.  <link xlink:type="simple" xlink:href="../563/914563.xml">
netstat</link> is another utility that can be used for debugging.</p>

</sec>
<sec>
<st>
 Alternatives </st>
<p>

For many applications TCP is not appropriate. One big problem (at least with normal implementations) is that the application cannot get at the packets coming after a lost packet until the retransmitted copy of the lost packet is received. This causes problems for real-time applications such as streaming multimedia  (such as <link xlink:type="simple" xlink:href="../301/52301.xml">
Internet radio</link>), real-time multiplayer games and <link xlink:type="simple" xlink:href="../028/75028.xml">
voice over IP</link> (VoIP) where it is sometimes more useful to get most of the data in a timely fashion than it is to get all of the data in order. </p>
<p>

For both historical and performance reasons, most <link xlink:type="simple" xlink:href="../593/266593.xml">
storage area network</link>s (SANs) prefer to use <link xlink:type="simple" xlink:href="../327/143327.xml">
Fibre Channel</link> protocol (FCP) instead of TCP/IP.</p>
<p>

Also for <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded systems</link>, <link xlink:type="simple" xlink:href="../258/8002258.xml">
network booting</link> and servers that serve simple requests from huge numbers of clients (e.g. <link xlink:type="simple" xlink:href="../339/8339.xml">
DNS</link> servers) the complexity of TCP can be a problem. Finally some tricks such as transmitting data between two hosts that are both behind <link xlink:type="simple" xlink:href="../036/53036.xml">
NAT</link> (using <link xlink:type="simple" xlink:href="../602/937602.xml">
STUN</link> or similar systems) are far simpler without a relatively complex protocol like TCP in the way. </p>
<p>

Generally where TCP is unsuitable the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/31929.xml">
User Datagram Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 (UDP) is used. This provides the application <link xlink:type="simple" xlink:href="../389/41389.xml">
multiplexing</link> and checksums that TCP does, but does not handle  building streams or retransmission giving the application developer the ability to code those in a way suitable for the situation and/or to replace them with other methods like <link xlink:type="simple" xlink:href="../167/41167.xml">
forward error correction</link> or <link xlink:type="simple" xlink:href="../883/8481883.xml">
interpolation</link>.</p>
<p>

<message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../896/404896.xml">
SCTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 is another IP protocol that provides reliable stream oriented services not so dissimilar from TCP.  It is newer and considerably more complex than TCP so has not yet seen widespread deployment. However, it is especially designed to be used in situations where reliability and near-real-time considerations are important.</p>
<p>

<message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../484/9137484.xml">
Venturi Transport Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 (VTP) is a patented proprietary protocol that is designed to replace TCP transparently in order to overcome perceived inefficiencies related to wireless data transport.</p>
<p>

TCP also has some issues in high bandwidth utilization environments.  The <link xlink:type="simple" xlink:href="../471/1723471.xml">
TCP congestion avoidance algorithm</link> works very well for ad-hoc environments where it is not known who will be sending data, but if the environment is predictable, a timing based protocol such as <link xlink:type="simple" xlink:href="../ury/25th_century.xml">
ATM</link> can avoid the overhead of the retransmits that TCP needs.</p>

</sec>
<sec>
<st>
Fields used to compute the checksum</st>

<ss1>
<st>
TCP checksum using IPv4</st>
<p>

When TCP runs over <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../317/15317.xml">
IPv4</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
, the method used to compute the checksum is defined in RFC 793:
<indent level="1">

<it>The checksum field is the 16 bit one's complement of the one's complement sum of all 16-bit words in the header and text.  If a segment contains an odd number of header and text octets to be checksummed, the last octet is padded on the right with zeros to form a 16-bit word for checksum purposes.  The pad is not transmitted as part of the segment.  While computing the checksum, the checksum field itself is replaced with zeros.</it>
</indent>

In other words, after appropriate padding, all 16-bit words are added using <link xlink:type="simple" xlink:href="../694/586694.xml#xpointer(//*[./st=%22Ones'+complement%22])">
one's complement arithmetic</link>. The sum is then bitwise complemented and inserted as the checksum field. A pseudo-header that mimics the IPv4 header, used in the checksum computation, is shown in the table below.</p>
<p>

<table style="text-align:center" class="wikitable">
<caption>
TCP pseudo-header (IPv4)</caption>
<row>
<header>
Bit offset</header>
<header colspan="4" width="11%">
Bits 0–3</header>
<header colspan="4" width="11%">
4–7</header>
<header colspan="8" width="22%">
8–15</header>
<header colspan="16" width="44%">
16–31</header>
</row>
<row>
<header>
0</header>
<col colspan="32" bgcolor="#FFDDDD">
Source address</col>
</row>
<row>
<header>
32</header>
<col colspan="32" bgcolor="#FFDDDD">
Destination address</col>
</row>
<row>
<header>
64</header>
<col colspan="8" bgcolor="#FFDDDD">
Zeros</col>
<col colspan="8" bgcolor="#FFDDDD">
Protocol</col>
<col colspan="16" bgcolor="#FFDDDD">
TCP length</col>
</row>
<row>
<header>
96</header>
<col colspan="16">
Source port</col>
<col colspan="16">
Destination port</col>
</row>
<row>
<header>
128</header>
<col colspan="32">
Sequence number</col>
</row>
<row>
<header>
160</header>
<col colspan="32">
Acknowledgement number</col>
</row>
<row>
<header>
192</header>
<col colspan="4">
Data offset</col>
<col colspan="4">
Reserved</col>
<col colspan="8">
Flags</col>
<col colspan="16">
Window</col>
</row>
<row>
<header>
224</header>
<col colspan="16" bgcolor="#FFDDDD">
Checksum</col>
<col colspan="16">
Urgent pointer</col>
</row>
<row>
<header>
256</header>
<col colspan="32">
Options (optional)</col>
</row>
<row>
<header>
256/288+</header>
<col colspan="32">
&nbsp;Data&nbsp;</col>
</row>
</table>
</p>
<p>

The source and destination addresses are those of the IPv4 header. The protocol value is 6 for TCP (cf. <link xlink:type="simple" xlink:href="../563/1171563.xml">
List of IP protocol numbers</link>). The TCP length field is the length of the TCP header and data.</p>

</ss1>
<ss1>
<st>
TCP checksum using IPv6 </st>
<p>

When TCP runs over <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/15318.xml">
IPv6</link></rule>
</direction>
</protocol>
</message>
, the method used to compute the checksum is changed, as per RFC 2460:
<indent level="1">

<it>Any transport or other upper-layer protocol that includes the addresses from the IP header in its checksum computation must be modified for use over IPv6, to include the 128-bit IPv6 addresses instead of 32-bit IPv4 addresses.</it>
</indent>

An IPv6 pseudo-header for computation of the checksum is shown below.</p>
<p>

<table style="text-align: center;" class="wikitable">
<caption>
TCP pseudo-header (IPv6)</caption>
<row>
<header>
Bit offset</header>
<header colspan="8" width="22%">
Bits 0 - 7</header>
<header colspan="8" width="22%">
8–15</header>
<header colspan="8" width="22%">
16–23</header>
<header colspan="8" width="22%">
24–31</header>
</row>
<row>
<header>
0</header>
<col colspan="32" rowspan="4" bgcolor="#FFDDDD">
Source address</col>
</row>
<row>
<header>
32</header>
</row>
<row>
<header>
64</header>
</row>
<row>
<header>
96</header>
</row>
<row>
<header>
128</header>
<col colspan="32" rowspan="4" bgcolor="#FFDDDD">
Destination address</col>
</row>
<row>
<header>
160</header>
</row>
<row>
<header>
192</header>
</row>
<row>
<header>
224</header>
</row>
<row>
<header>
256</header>
<col colspan="32" bgcolor="#FFDDDD">
TCP length</col>
</row>
<row>
<header>
288</header>
<col colspan="24" bgcolor="#FFDDDD">
Zeros</col>
<col colspan="8" bgcolor="#FFDDDD">
Next header</col>
</row>
<row>
<header>
320</header>
<col colspan="16">
Source port</col>
<col colspan="16">
Destination port</col>
</row>
<row>
<header>
352</header>
<col colspan="32">
Sequence number</col>
</row>
<row>
<header>
384</header>
<col colspan="32">
Acknowledgement number</col>
</row>
<row>
<header>
416</header>
<col colspan="4">
Data offset</col>
<col colspan="4">
Reserved</col>
<col colspan="8">
Flags</col>
<col colspan="16">
Window</col>
</row>
<row>
<header>
448</header>
<col colspan="16" bgcolor="#FFDDDD">
Checksum</col>
<col colspan="16">
Urgent pointer</col>
</row>
<row>
<header>
480</header>
<col colspan="32">
Options (optional)</col>
</row>
<row>
<header>
480/512+</header>
<col colspan="32">
&nbsp;Data&nbsp;</col>
</row>
</table>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Source address &ndash; the one in the IPv6 header</entry>
<entry level="1" type="bullet">

 Destination address &ndash; the final destination; if the IPv6 packet doesn't contain a Routing header, that will be the destination address in the IPv6 header, otherwise, at the originating node, it will be the address in the last element of the Routing header, and, at the receiving node, it will be the destination address in the IPv6 header. </entry>
<entry level="1" type="bullet">

 TCP length &ndash; the length of the TCP header and data;</entry>
<entry level="1" type="bullet">

 Next Header &ndash; the protocol value for TCP</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../754/1696754.xml">
Connection-oriented protocol</link></rule>
</direction>
</protocol>
</message>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/4139219.xml">
T/TCP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 variant of TCP</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../331/4971331.xml">
TCP and UDP port</link> </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../136/347136.xml">
TCP and UDP port numbers</link> for a long list of ports/services</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../471/1723471.xml">
TCP congestion avoidance algorithms</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../169/1753169.xml">
Nagle's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../781/14467781.xml">
Karn's Algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../894/20894.xml">
Maximum transmission unit</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../677/323677.xml">
IP fragmentation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../445/600445.xml">
Maximum segment size</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../596/2111596.xml">
Silly window syndrome</link></entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/11216867.xml">
TCP segment</link></rule>
</direction>
</protocol>
</message>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../632/4487632.xml">
TCP Sequence Prediction Attack</link></entry>
<entry level="1" type="bullet">

 <operation wordnetid="100955060" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<attack wordnetid="100972621" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../095/236095.xml">
SYN flood</link></activity>
</psychological_feature>
</act>
</attack>
</event>
</operation>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../326/6507326.xml">
SYN cookies</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../128/2584128.xml">
TCP Tuning</link> for high performance networks</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../283/6018283.xml">
Path MTU discovery</link></rule>
</direction>
</protocol>
</message>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../745/6231745.xml">
tcphdr</link> - the Unix TCP header structure in the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../896/404896.xml">
SCTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/146145.xml#xpointer(//*[./st=%22Transport+protocol+comparison+table%22])">
Transport protocol comparison table</link></rule>
</direction>
</protocol>
</message>
</entry>
</list>
</p>


</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<teacher wordnetid="110694258" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../323/10925323.xml">
Comer, Douglas E.</link></scholar>
</research_worker>
</teacher>
</writer>
</causal_agent>
</alumnus>
</communicator>
</educator>
</professional>
</scientist>
</adult>
</intellectual>
</person>
</physical_entity>
&#32;(2006). Internetworking with TCP/IP:Principles, Protocols, and Architecture, 5th&#32;<b>1</b>,&#32;Prentice Hall. ISBN 0130905526.</cite>&nbsp;</entry>
<entry id="2">
 <cite id="CITEREFStonePartridge2000" style="font-style:normal">Stone&#32;&amp;&#32;Partridge&#32;(2000),&#32;"<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/stone00when.html">
When The CRC and TCP Checksum Disagree</weblink>",&#32;<it>SIGCOMM</it>, </cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Tanenbaum, Andrew S.</link></professor>
</person>
&#32;(2003-03-17). Computer Networks, Fourth Edition,&#32;Prentice Hall. ISBN 0-13-066102-3.</cite>&nbsp;</entry>
<entry id="4">
Laurent Joncheray, <it>Simple Active Attack Against TCP</it>, 1995 <weblink xlink:type="simple" xlink:href="http://www.usenix.org/publications/library/proceedings/security95/joncheray.html">
http://www.usenix.org/publications/library/proceedings/security95/joncheray.html</weblink></entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://www.medianet.kent.edu/projects_files/projectITCP.html">
TCP Interactive (iTCP)</weblink></entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading </st>
<p>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../988/525988.xml">
W. Richard Stevens</link></writer>
</causal_agent>
</person>
</communicator>
</physical_entity>
. TCP/IP Illustrated, Volume 1: The Protocols. ISBN 0-201-63346-9</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../988/525988.xml">
W. Richard Stevens</link></writer>
</causal_agent>
</person>
</communicator>
</physical_entity>
 and <link>
Gary R. Wright</link>. TCP/IP Illustrated, Volume 2: The Implementation. ISBN 0-201-63354-X</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../988/525988.xml">
W. Richard Stevens</link></writer>
</causal_agent>
</person>
</communicator>
</physical_entity>
. TCP/IP Illustrated, Volume 3: <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/4139219.xml">
TCP for Transactions</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
, <link xlink:type="simple" xlink:href="../104/2701104.xml">
HTTP</link>, <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/173004.xml">
NNTP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
, and the <link xlink:type="simple" xlink:href="../697/4769697.xml">
UNIX Domain</link> Protocols. ISBN 0-201-63495-3</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>
 
<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.3wayhandshake.com">
TCP 3-Way Handshake Example</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://edocs.tu-berlin.de/diss/2004/savoric_michael.htm">
Dissertation about TCP improvements in wired and wireless networks</weblink> (Dissertation)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.iana.org/assignments/port-numbers">
IANA Port Assignments</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://condor.depaul.edu/~jkristof/technotes/tcp.html">
John Kristoff's Overview of TCP (Fundamental concepts behind TCP and how it is used to transport data between two endpoints)</weblink></entry>
<entry level="1" type="bullet">

 RFC 675 - Specification of Internet Transmission Control Program, December 1974 Version</entry>
<entry level="1" type="bullet">

 RFC 793 - TCP v4</entry>
<entry level="1" type="bullet">

 RFC 1122 - some error-corrections</entry>
<entry level="1" type="bullet">

 RFC 1323 - TCP-Extensions</entry>
<entry level="1" type="bullet">

 RFC 1379 - Extending TCP for Transactions -- Concepts</entry>
<entry level="1" type="bullet">

 RFC 1948 - Defending Against Sequence Number Attacks</entry>
<entry level="1" type="bullet">

 RFC 2018 - TCP Selective Acknowledgment Options</entry>
<entry level="1" type="bullet">

 RFC 2581 - TCP Congestion Control</entry>
<entry level="1" type="bullet">

 RFC 2988 - Computing TCP's Retransmission Timer</entry>
<entry level="1" type="bullet">

 RFC 4614 - A Roadmap for TCP Specification Documents</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.networksorcery.com/enp/protocol/tcp.htm">
TCP, Transmission Control Protocol</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.medianet.kent.edu/technicalreports.html#TR2005-07-22">
 TCP EFSM diagram - A detailed description of TCP states.</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://tcp.mywebcities.com/">
The basics of Transmission Control Protocol</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">
The Law of Leaky Abstractions</weblink> by Joel Spolsky</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mathforum.org/library/drmath/view/54379.html">
Checksum example</weblink></entry>
</list>
</p>



</sec>
</bdy>
</protocol>
</article>
