<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:07:01[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Machine epsilon</title>
<id>3076863</id>
<revision>
<id>242644862</id>
<timestamp>2008-10-03T01:42:37Z</timestamp>
<contributor>
<username>Beland</username>
<id>57939</id>
</contributor>
</revision>
<categories>
<category>Computer arithmetic</category>
<category>Articles with example C code</category>
<category>Articles with example Fortran code</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../376/11376.xml">
floating point arithmetic</link>, the <b>machine epsilon</b> (also called <b>macheps</b>, <b>machine precision</b> or <b>unit roundoff</b>) is, for a particular <link xlink:type="simple" xlink:href="../see/Linden=2C_T$ennessee.xml">
floating point unit</link>, the difference between 1 and the smallest exactly representable number greater than one. It gives an upper bound on the <link xlink:type="simple" xlink:href="../422/640422.xml">
relative error</link> due to rounding of floating point numbers<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.
<sec>
<st>
Example</st>

<p>

An <link xlink:type="simple" xlink:href="../039/405039.xml">
IEEE 754</link> <link xlink:type="simple" xlink:href="../250/143250.xml">
single precision</link> floating point number has 24 bits of <link xlink:type="simple" xlink:href="../250/419250.xml">
mantissa</link>, including the leading unit digit. The number 1 is represented with an <link xlink:type="simple" xlink:href="../091/1069091.xml">
unbiased</link> exponent of 0 and a mantissa of 1.000000000000000000000002 in binary. The next largest representable number has an exponent of 0 and a mantissa of 1.000000000000000000000012. The difference between these numbers is 0.000000000000000000000012, or 2−23. This is the machine epsilon of a floating point unit which uses IEEE single-precision floating point arithmetic. In general, for a floating point type with a <link xlink:type="simple" xlink:href="../052/437052.xml">
base</link> <it>b</it> and a mantissa of <it>p</it> digits, the epsilon is εmach = <it>b</it>1-<it>p</it>.</p>

</sec>
<sec>
<st>
Other definitions</st>

<p>

The machine epsilon is sometimes defined as the smallest positive number which, when added to 1, yields a result other than one. Unlike the definition above, this value depends on the <link xlink:type="simple" xlink:href="../945/169945.xml">
rounding mode</link>. For IEEE single precision in the most common rounding mode (round to even), this value is 2−24 + 2−47, or slightly more than half the value by the definition above. For rounding toward +∞ the value is the smallest representable positive number (2−149, a <link>
denormal</link>), while for rounding toward -∞ or toward zero it coincides with the earlier definition.</p>
<p>

Some documents mistakenly use this definition when the other is intended. For example, both the <link xlink:type="simple" xlink:href="../364/324364.xml">
GNU libc</link> manual<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> and <link xlink:type="simple" xlink:href="../204/166204.xml">
Microsoft Visual C++</link> documentation<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> define the constant FLT_EPSILON in this way, in conflict with the ISO C standard<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>, which mandates the definition at the head of this article, and with their own implementations, which follow the standard.</p>

</sec>
<sec>
<st>
How to determine the macheps</st>
<p>

Note that results depend on the particular floating-point format used, such as <b>float</b>, <b>double</b>, <b>long double</b>, or similar as supported by the programming language, the compiler, and the runtime library for the actual platform.</p>
<p>

Some formats supported by the processor might be not supported by the chosen compiler and operating system. Other formats might be emulated by the runtime library, including <link xlink:type="simple" xlink:href="../892/600892.xml">
arbitrary-precision arithmetic</link> available in some languages and libraries.</p>
<p>

In a strict sense the term <it>machine epsilon</it> means the <b>1+eps</b> accuracy directly supported by the processor (or coprocessor), not some <b>1+eps</b> accuracy supported by a specific compiler for a specific operating system, unless it's known to use the best format.</p>
<p>

A trivial example is the machine epsilon for integer arithmetic on processors without floating point formats; it is <b>1</b>, because 1+1=2 is the smallest integer greater than 1.</p>
<p>

The following C program does not actually determine the machine epsilon; rather, it determines a number within a factor of two (one <link xlink:type="simple" xlink:href="../657/22657.xml">
order of magnitude</link>) of the true machine epsilon, using a <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link>.</p>


<p>

<list>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

int main( int argc, char **argv )
{
float machEps = 1.0f;</p>
<p>

printf( "current Epsilon, 1 + current Epsilon\n" );
do {
printf( "%G\t%.20f\n", machEps, (1.0f + machEps) );
machEps /= 2.0f;
// If next epsilon yields 1, then break, because current
// epsilon is the machine epsilon.
}
while ((float)(1.0 + (machEps/2.0)) != 1.0);</p>
<p>

printf( "\nCalculated Machine epsilon: %G\n", machEps );
return 0;
}</p>
<p>

Abridged Output</p>
<p>

$ gcc machine_epsilon.c; ./a.out
current Epsilon, 1 + current Epsilon
1       2.00000000000000000000
0.5     1.50000000000000000000
...
0.000244141     1.00024414062500000000
0.00012207      1.00012207031250000000
6.10352E-05     1.00006103515625000000
3.05176E-05     1.00003051757812500000
1.52588E-05     1.00001525878906250000
7.62939E-06     1.00000762939453125000
3.8147E-06      1.00000381469726562500
1.90735E-06     1.00000190734863281250
9.53674E-07     1.00000095367431640625
4.76837E-07     1.00000047683715820312
2.38419E-07     1.00000023841857910156</p>
<p>

Calculated Machine epsilon: 1.19209E-07</p>
<p>

A similar, Java method:</p>

<p>

private void calculateMachineEpsilonFloat() {
float machEps = 1.0f;</p>
<p>

do {
machEps /= 2.0f;
}
while ((float)(1.0 + (machEps/2.0)) != 1.0);</p>
<p>

System.out.println( "Calculated Machine epsilon: " + machEps );
}</p>


</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal">David Goldberg&#32;(March 1991).&#32;"<weblink xlink:type="simple" xlink:href="http://www.validlab.com/goldberg/paper.pdf">
What Every Computer Scientist Should Know About Floating-Point Arithmetic</weblink>". <it>ACM Computing Surveys (CSUR)</it>&#32;<b>23</b>&#32;(1): 5–48. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F103162.103163">
10.1145/103162.103163</weblink>. Retrieved on <link>
2008-04-28</link>.</cite>&nbsp;</entry>
</list>
</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.gnu.org/software/libc/manual/html_node/Floating-Point-Parameters.html">
GNU libc manual, section A.5.3.2</weblink>, dated August 5, 2007, retrieved September 28, 2007.</entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/k15zsh48(VS.80).aspx">
Run-Time Library Reference: Data Type Constants</weblink>, retrieved September 28, 2007.</entry>
<entry id="4">
WG14 N1124, section 5.2.4.2.2, paragraph 11.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../376/11376.xml">
Floating point</link></kind>
</type>
</category>
</concept>
</idea>
 - general discussion of accuracy issues in floating point arithmetic</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://orion.math.iastate.edu/burkardt/c_src/machar/machar.html">
MACHAR</weblink>, a routine (in C and Fortran) to "dynamically compute machine constants" (ACM algorithm 722)</entry>
</list>
</p>


</sec>
</bdy>
</article>
