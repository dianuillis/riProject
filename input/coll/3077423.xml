<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:09:13[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<change_of_state  confidence="0.8" wordnetid="100199130">
<event  confidence="0.8" wordnetid="100029378">
<change  confidence="0.8" wordnetid="100191142">
<improvement  confidence="0.8" wordnetid="100248977">
<action  confidence="0.8" wordnetid="100037396">
<optimization  confidence="0.8" wordnetid="100260051">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<header>
<title>Peephole optimization</title>
<id>3077423</id>
<revision>
<id>225356472</id>
<timestamp>2008-07-13T07:13:46Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>compiler optimizations</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../208/1695208.xml">
compiler theory</link>, <b>peephole optimization</b> is a kind of <link xlink:type="simple" xlink:href="../779/225779.xml">
optimization</link> performed over a very small set of instructions in a segment of generated code. The set is called a "peephole" or a "window". It works by recognising sets of instructions that don't actually do anything, or that can be replaced by a leaner set of instructions.
<sec>
<st>
Replacement Rules<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></st>

<p>

<list>
<entry level="1" type="bullet">

 Constant Folding: Evaluate constant subexpressions in advance.</entry>
<entry level="1" type="bullet">

 Strength Reduction: Replace slow operations with faster equivalents.</entry>
<entry level="1" type="bullet">

 Null Sequences: Delete useless operations</entry>
<entry level="1" type="bullet">

 Combine Operations: Replace several operations with one equivalent.</entry>
<entry level="1" type="bullet">

 Algebraic Laws: Use algebraic laws to simplify or reorder instructions.</entry>
<entry level="1" type="bullet">

 Special Case Instructions: Use instructions designed for special operand cases.</entry>
<entry level="1" type="bullet">

 Address Mode Operations: Use address modes to simplify code.</entry>
</list>
</p>
<p>

Of course there can be other types of peephole optimizations involving simplifying the target machine instructions, assuming that the target machine is known in advance. Advantages of a given architecture and instruction sets can be exploited in this case.</p>

</sec>
<sec>
<st>
Example</st>
<p>

The following <link xlink:type="simple" xlink:href="../389/16389.xml">
Java assembler code</link></p>
<p>

...
aload 1
aload 1
mul
...</p>
<p>

can be replaced by</p>
<p>

...
aload 1
dup
mul
...</p>
<p>

This kind of optimization, like most peephole optimizations, makes certain assumptions about the efficiency of instructions. For instance, in this case, it is assumed that the dup operation (which duplicates and pushes the top of the <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link>) is more efficient than the aload X operation (which loads a local <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link> identified as X and pushes it on the stack).</p>
<p>

Another example is to eliminate redundant load stores. 
a = b + c; 
d = a + e;
is straightforwardly implemented as

MOV b, R0  # Copy b to the register
ADD c, R0  # Add  c to the register, the register is now b+c
MOV R0, a  # Copy the register to a
MOV a, R0  # Copy a to the register
ADD e, R0  # Add  e to the register, the register is now a+e [(b+c)+e]
MOV R0, d  # Copy the register to d 

but can be optimised to

MOV b, R0 # Copy b to the register 
ADD c, R0 # Add c to the register, which is now b+c (a)
MOV R0, a # Copy the register to a
ADD e, R0 # Add e to the register, which is now b+c+e [(a)+e]
MOV R0, d # Copy the register to d

Furthermore, if the compiler knew that the variable a was not used again, the middle operation could be omitted.</p>

</sec>
<sec>
<st>
Implementation</st>
<p>

Modern architectures typically allow for many hundreds of different kinds of peephole optimizations, and it is therefore often appropriate for <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> <link xlink:type="simple" xlink:href="../311/5311.xml">
programmers</link> to implement them using a <link xlink:type="simple" xlink:href="../688/279688.xml">
pattern matching</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>. </p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Crafting a Compiler with C++, Fischer/LeBlanc</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="ftp://ftp.cs.princeton.edu/pub/lcc/contrib/copt.shar">
The copt general-purpose peephole optimizer by Christopher W. Fraser</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://oarizo.com/downloads/misc/copt2.zip">
Source code for Vaughn Cato's peephole optimizer</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=365000">
The original paper</weblink></entry>
</list>

&lsaquo; The  below () is being considered for deletion. See  to help reach a consensus. &rsaquo;
<list>
<entry level="1" type="bullet">

 <image width="16px" src="Wiktionary-logo-en.svg">

</image>
 The <web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../658/156658.xml">
Wiktionary</link></web_site>
 definition of </entry>
</list>
</p>

</sec>
</bdy>
</psychological_feature>
</act>
</optimization>
</action>
</improvement>
</change>
</event>
</change_of_state>
</article>
