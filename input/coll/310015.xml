<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:45:55[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Parsing</title>
<id>310015</id>
<revision>
<id>241721134</id>
<timestamp>2008-09-29T07:32:03Z</timestamp>
<contributor>
<username>Derek farn</username>
<id>752956</id>
</contributor>
</revision>
<categories>
<category>Compiler theory</category>
<category>Parsing</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

For help with Wikipedia's parser functions, see .
"Parser" redirects here. For the computer programming language, see <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../210/13923210.xml">
Parser (CGI language)</link></programming_language>
.
<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link> and <link xlink:type="simple" xlink:href="../526/17526.xml">
linguistics</link>, <b>parsing</b>, or, more formally, <b>syntactic analysis</b>, is the process of analyzing a sequence of <link xlink:type="simple" xlink:href="../251/81251.xml">
tokens</link> to determine their grammatical structure with respect to a given (more or less) <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>.</p>
<p>

Parsing is also an earlier term for the diagramming of sentences of natural languages, and is still used for the diagramming of <link xlink:type="simple" xlink:href="../224/71224.xml">
inflected</link> languages, such as the <class wordnetid="107997703" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../401/25401.xml">
Romance languages</link></class>
 or <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../730/17730.xml">
Latin</link></language>
.  The term parsing comes from Latin <it>pars</it> (<it>ōrātiōnis</it>), meaning <link xlink:type="simple" xlink:href="../059/45059.xml">
part (of speech)</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

<sec>
<st>
 Parser </st>
<p>

A <b>parser</b> is one of the components in an <link xlink:type="simple" xlink:href="../394/15394.xml">
interpreter</link> or <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>, which checks for correct syntax and builds a <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link> (often some kind of <link xlink:type="simple" xlink:href="../404/118404.xml">
parse tree</link>, <link xlink:type="simple" xlink:href="../629/75629.xml">
abstract syntax tree</link> or other hierarchical structure) implicit in the input tokens. The parser often uses a separate <link xlink:type="simple" xlink:href="../251/81251.xml">
lexical analyser</link> to create tokens from the sequence of input characters. Parsers may be programmed by hand or may be semi-automatically generated (in some programming language) by a tool (such as <link xlink:type="simple" xlink:href="../358/34358.xml">
Yacc</link>) from a grammar written in <link xlink:type="simple" xlink:href="../247/62247.xml">
Backus-Naur form</link>.</p>

</sec>
<sec>
<st>
 Human languages </st>

<p>

<indent level="1">

<it>See also: 
Natural language parsing|Category:Natural language parsing</it>
</indent>

In some <link xlink:type="simple" xlink:href="../980/19980.xml">
machine translation</link> and <link xlink:type="simple" xlink:href="../652/21652.xml">
natural language processing</link> systems, human languages are parsed by computer programs. Human sentences are not easily parsed by programs, as there is substantial <link xlink:type="simple" xlink:href="../040/154040.xml">
ambiguity</link> in the structure of human language. In order to parse natural language data, researchers must first agree on the <link xlink:type="simple" xlink:href="../569/12569.xml">
grammar</link> to be used. The choice of syntax is affected by both <link xlink:type="simple" xlink:href="../059/18059.xml">
linguistic</link>  and computational concerns; for instance some parsing systems use <link xlink:type="simple" xlink:href="../408/254408.xml">
lexical functional grammar</link>, but in general, parsing for grammars of this type is known to be <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
. <model wordnetid="105890249" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<hypothesis wordnetid="105888929" confidence="0.8">
<link xlink:type="simple" xlink:href="../952/255952.xml">
Head-driven phrase structure grammar</link></hypothesis>
</concept>
</idea>
</model>
 is another linguistic formalism which has been popular in the parsing community, but other research efforts have focused on less complex formalisms such as the one used in the Penn <link xlink:type="simple" xlink:href="../417/3732417.xml">
Treebank</link>. <link xlink:type="simple" xlink:href="../551/1614551.xml">
Shallow parsing</link> aims to find only the boundaries of major constituents such as noun phrases. Another popular strategy for avoiding linguistic controversy is <link xlink:type="simple" xlink:href="../031/1060031.xml">
dependency grammar</link> parsing.</p>
<p>

Most modern parsers are at least partly <link xlink:type="simple" xlink:href="../685/26685.xml">
statistical</link>; that is, they rely on a corpus of training data which has already been annotated (parsed by hand). This approach allows the system to gather information about the frequency with which various constructions occur in specific contexts. <it>(See <link xlink:type="simple" xlink:href="../488/233488.xml">
machine learning</link>.)</it> Approaches which have been used include straightforward <link xlink:type="simple" xlink:href="../329/299329.xml">
PCFG</link>s (probabilistic context free grammars), <link xlink:type="simple" xlink:href="../718/201718.xml">
maximum entropy</link>, and <link xlink:type="simple" xlink:href="../542/1729542.xml">
neural net</link>s. Most of the more successful systems use <it>lexical</it> statistics (that is, they consider the identities of the words involved, as well as their <link xlink:type="simple" xlink:href="../059/45059.xml">
part of speech</link>). However such systems are vulnerable to <link xlink:type="simple" xlink:href="../332/173332.xml">
overfitting</link> and require some kind of smoothing to be effective.</p>
<p>

Parsing algorithms for natural language cannot rely on the grammar having 'nice' properties as with manually-designed grammars for programming languages. As mentioned earlier some grammar formalisms are very computationally difficult to parse; in general, even if the desired structure is not <link xlink:type="simple" xlink:href="../867/6867.xml">
context-free</link>, some kind of context-free approximation to the grammar is used to perform a first pass. Algorithms which use context-free grammars often rely on some variant of the <link xlink:type="simple" xlink:href="../929/53929.xml">
CKY algorithm</link>, usually with some <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic</link> to prune away unlikely analyses to save time. <it>(See <link xlink:type="simple" xlink:href="../490/106490.xml">
chart parsing</link>.)</it> However some systems trade speed for accuracy using, eg, linear-time versions of the <link>
shift-reduce</link> algorithm. A somewhat recent development has been <link>
parse reranking</link> in which the parser proposes some large number of analyses, and a more complex system selects the best option.</p>

</sec>
<sec>
<st>
 Programming languages </st>

<p>

The most common use of a parser is as a component of a <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> or <link xlink:type="simple" xlink:href="../394/15394.xml">
interpreter</link>.  This parses the <link xlink:type="simple" xlink:href="../661/27661.xml">
source code</link> of a <link xlink:type="simple" xlink:href="../015/23015.xml">
computer programming language</link> to create some form of internal representation. Programming languages tend to be specified in terms of a <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link> because fast and efficient parsers can be written for them. Parsers are written by hand or generated by <link xlink:type="simple" xlink:href="../097/70097.xml">
parser generator</link>s.</p>
<p>

Context-free grammars  are limited in the extent to which they can express all of the requirements of a language. Informally, the reason is that the memory of such a language is limited. The grammar cannot remember the presence of a construct over an arbitrarily long input; this is necessary for a language in which, for example, a name must be declared before it may be referenced. More powerful grammars that can express this constraint, however, cannot be parsed efficiently. Thus, it is a common strategy to create a relaxed parser for a context-free grammar which accepts a superset of the desired language constructs (that is, it accepts some invalid constructs); later, the unwanted constructs can be filtered out.</p>

<ss1>
<st>
Overview of process</st>
<p>

<image location="right" width="150px" src="Parser_Flow.gif">
<caption>

Flow of data in a typical parser
</caption>
</image>

The following example demonstrates the common case of parsing a computer language with two levels of grammar: lexical and syntactic. </p>
<p>

The first stage is the token generation, or <link xlink:type="simple" xlink:href="../251/81251.xml">
lexical analysis</link>, by which the input character stream is split into meaningful symbols defined by a grammar of <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link>s. For example, a calculator program would look at an input such as "12*(3+4)^2" and split it into the tokens 12, *, (, 3, +, 4, ), ^, and 2, each of which is a meaningful symbol in the context of an arithmetic expression. The parser would contain rules to tell it that the characters *, +, ^, ( and ) mark the start of a new token, so meaningless tokens like "12*" or "(3" will not be generated.</p>
<p>

The next stage is parsing or syntactic analysis, which is checking that the tokens form an allowable expression. This is usually done with reference to a <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link> which recursively defines components that can make up an expression and the order in which they must appear. However, not all rules defining programming languages can be expressed by context-free grammars alone, for example type validity and proper declaration of identifiers. These rules can be formally expressed with <link xlink:type="simple" xlink:href="../975/479975.xml">
attribute grammar</link>s.</p>
<p>

The final phase is <link>
semantic parsing</link> or analysis, which is working out the implications of the expression just validated and taking the appropriate action. In the case of a calculator or interpreter, the action is to evaluate the expression or program; a compiler, on the other hand, would generate some kind of code. Attribute grammars can also be used to define these actions.</p>

</ss1>
</sec>
<sec>
<st>
Types of parsers</st>
<p>

The task of the parser is essentially to determine if and how the input can be derived from the start symbol of the grammar. This can be done in essentially two ways:
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../102/339102.xml">
Top-down parsing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 - Top-down parsing can be viewed as an attempt to find left-most derivations of an input-stream by searching for <link xlink:type="simple" xlink:href="../404/118404.xml">
parse tree</link>s using a top-down expansion of the given <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link> rules. Tokens are consumed from left to right. Inclusive choice is used to accommodate <link xlink:type="simple" xlink:href="../677/677.xml">
ambiguity</link> by expanding all alternative right-hand-sides of grammar rules <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/58045.xml">
LL parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s and <link xlink:type="simple" xlink:href="../089/70089.xml">
recursive-descent parser</link>  are examples of top-down parsers, which cannot accommodate <link xlink:type="simple" xlink:href="../498/1418498.xml">
 left recursive</link> productions. Although it has been believed that simple implementations of top-down parsing cannot accommodate direct and indirect left-recursion and may require exponential time and space complexity while parsing ambiguous <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link>s,  more sophisticated algorithm for top-down parsing have been created by Frost, Hafiz, and Callaghan <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> which accommodates <link xlink:type="simple" xlink:href="../677/677.xml">
ambiguity</link> and <link xlink:type="simple" xlink:href="../498/1418498.xml">
left recursion</link> in polynomial time and which generates polynomial-size representations of the potentially-exponential number of parse trees. Their algorithm is able to produce both left-most and right-most derivations of an input with regard to a given CFG.</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../521/679521.xml">
Bottom-up parsing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 - A parser can start with the input and attempt to rewrite it to the start symbol. Intuitively, the parser attempts to locate the most basic elements, then the elements containing these, and so on. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s are examples of bottom-up parsers. Another term used for this type of parser is Shift-Reduce parsing.</entry>
</list>
</p>
<p>

Another important distinction is whether the parser generates a <it>leftmost derivation</it> or a <it>rightmost derivation</it> (see <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link>). LL parsers will generate a leftmost <link xlink:type="simple" xlink:href="../443/294443.xml">
derivation</link> and LR parsers will generate a rightmost derivation (although usually in reverse) .</p>

</sec>
<sec>
<st>
 Examples of parsers </st>

<ss1>
<st>
 Top-down parsers </st>
<p>

Some of the parsers that use <link xlink:type="simple" xlink:href="../102/339102.xml">
top-down parsing</link> include:
<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../089/70089.xml">
Recursive descent parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/58045.xml">
LL parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (<b>L</b>eft-to-right, <b>L</b>eftmost derivation)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.uwindsor.ca/~hafiz/proHome.html">
X-SAIGA</weblink> - eXecutable SpecificAtIons of GrAmmars. Contains publications related to top-down parsing algorithm that supports left-recursion and ambiguity in polynomial time and space.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Bottom-up parsers </st>
<p>

Some of the parsers that use <link xlink:type="simple" xlink:href="../521/679521.xml">
bottom-up parsing</link> include:
<list>
<entry level="1" type="bullet">

 Precedence parser</entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../946/1301946.xml">
Operator-precedence parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../125/2012125.xml">
Simple precedence parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 BC (bounded context) parsing</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (<b>L</b>eft-to-right, <b>R</b>ightmost derivation)</entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../104/70104.xml">
Simple LR (SLR) parser</link></entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/18004.xml">
LALR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../056/73056.xml">
Canonical LR (LR(1)) parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../191/3372191.xml">
GLR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/53929.xml">
CYK parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Parser development software</st>
<p>

Some of the well known parser development tools include the following.  Also see <link xlink:type="simple" xlink:href="../734/3959734.xml">
comparison of parser generators</link>.</p>
<p>

<list>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../588/765588.xml">
ANTLR</link></software>
</entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../189/53189.xml">
Bison</link></equipment>
</implement>
</generator>
</apparatus>
</tool>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../658/862658.xml">
Coco/R</link></equipment>
</generator>
</apparatus>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/8544400.xml">
GOLD</link></software>
</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../257/402257.xml">
JavaCC</link></software>
</entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/105985.xml">
Lex</link></equipment>
</implement>
</generator>
</apparatus>
</tool>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../388/8052388.xml">
Ragel</link></software>
</entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../088/1826088.xml">
Spirit Parser Framework</link></equipment>
</generator>
</apparatus>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../928/13062928.xml">
SYNTAX</link></entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/34358.xml">
Yacc</link></equipment>
</implement>
</generator>
</apparatus>
</tool>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../437/38437.xml">
Lemon</link></entry>
</list>
</p>


</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../050/16637050.xml">
Generating strings</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

<ss1>
<st>
Parsing concepts</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../490/106490.xml">
Chart parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../097/70097.xml">
Compiler-compiler</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../165/4569165.xml">
Deterministic parsing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../251/81251.xml">
Lexing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../551/1614551.xml">
Shallow parsing</link></entry>
</list>
</p>


</ss1>
</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
http://www.bartleby.com/61/33/P0083300.html</entry>
<entry id="2">
http://dictionary.reference.com/search?q=parse&amp;x=0&amp;y=0</entry>
<entry id="3">
 Aho, A.V., Sethi, R. and Ullman ,J.D.  (1986) " Compilers: principles, techniques, and tools." <it> Addison-Wesley Longman Publishing Co., Inc. Boston, MA, USA. </it> </entry>
<entry id="4">
 Frost, R., Hafiz, R. and Callaghan, P. (2007) " Modular and Efficient Top-Down Parsing for Ambiguous Left-Recursive Grammars ." <it>10th International Workshop on Parsing Technologies (IWPT), ACL-SIGPARSE </it>, Pages: 109 - 120, June 2007, Prague.</entry>
<entry id="5">
 Frost, R., Hafiz, R. and Callaghan, P. (2008) " Parser Combinators for Ambiguous Left-Recursive Grammars." <it> 10th International Symposium on Practical Aspects of Declarative Languages (PADL), ACM-SIGPLAN </it>, Volume 4902/2008, Pages: 167-181, January 2008, San Francisco.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.vu.nl/~dick/PTAPG.html">
Parsing Techniques - A Practical Guide</weblink> web page of book includes downloadable pdf.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
