<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:46:54[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Paging</title>
<id>311193</id>
<revision>
<id>244253059</id>
<timestamp>2008-10-09T23:42:12Z</timestamp>
<contributor>
<username>Saga City</username>
<id>138511</id>
</contributor>
</revision>
<categories>
<category>All pages needing cleanup</category>
<category>All articles that may contain original research</category>
<category>Virtual memory</category>
<category>Articles with invalid date parameter in template</category>
<category>Memory management</category>
<category>Articles with obsolete information</category>
<category>Articles that may contain original research since April 2008</category>
</categories>
</header>
<bdy>

This article is about computer virtual memory.  For the wireless communication devices, see <link xlink:type="simple" xlink:href="../045/229045.xml">
pager</link> and <link xlink:type="simple" xlink:href="../045/229045.xml">
radio paging</link>. <link xlink:type="simple" xlink:href="../396/354396.xml">
Bank switching</link> is also sometimes referred to as paging. <link xlink:type="simple" xlink:href="../349/346349.xml">
page flipping</link> is also sometimes referred to as paging.<p>

In <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s that have their <link>
main memory</link> divided into <link xlink:type="simple" xlink:href="../911/11254911.xml">
pages</link>, <b>paging</b> (sometimes called <b>swapping</b>) is a transfer of pages between main memory and an auxiliary store, such as <link xlink:type="simple" xlink:href="../777/13777.xml">
hard disk drive</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Paging is an important part of <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> implementation in most contemporary general-purpose operating systems, allowing them to use disk storage for data that does not fit into physical RAM. Paging is usually implemented as <link xlink:type="simple" xlink:href="../509/6509.xml">
architecture-specific</link> code built into the <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link> of the operating system. </p>

<sec>
<st>
Overview</st>

<p>

The main functions of paging are performed when a program tries to access pages that are not currently mapped to physical memory (<link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link>). This situation is known as a <link xlink:type="simple" xlink:href="../143/1157143.xml">
page fault</link>. The operating system must then take control and handle the page fault, in a manner invisible to the program. Therefore, the operating system must:
<list>
<entry level="1" type="number">

 Determine the location of the data in auxiliary storage.</entry>
<entry level="1" type="number">

 Obtain an empty page frame in RAM to use as a container for the data.</entry>
<entry level="1" type="number">

 Load the requested data into the available page frame.</entry>
<entry level="1" type="number">

 Update the Page Table to show the new data.</entry>
<entry level="1" type="number">

 Return control to the program, transparently retrying the <link xlink:type="simple" xlink:href="../801/3149801.xml">
instruction</link> that caused the page fault.</entry>
</list>
</p>
<p>

The need to reference memory at a particular address arises from two main sources:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../218/5218.xml">
Processor</link> trying to load and execute a program's instructions itself.</entry>
<entry level="1" type="bullet">

 Data being accessed by a program's instruction.</entry>
</list>
</p>
<p>

In step 2, when a page has to be loaded and all existing pages in <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link> are currently in use, one of the existing pages must be swapped with the requested new page. The paging system must determine the page to swap by choosing one that is least likely to be needed within a short time. There are various <link xlink:type="simple" xlink:href="../476/727476.xml">
page replacement algorithm</link>s that try to answer such issue. </p>
<p>

Most operating systems use the <link xlink:type="simple" xlink:href="../281/954281.xml">
least recently used</link> (LRU) page replacement algorithm. The theory behind LRU is that the least recently used page is the most likely one not to be needed shortly; when a new page is needed, the least recently used page is discarded.  This algorithm is most often correct but not always: e.g. a sequential process moves forward through memory and never again accesses the most recently used page.</p>
<p>

If a page chosen to be swapped has been modified since loading (if the page is <it>dirty</it>), it has to be written to auxiliary storage, otherwise it is simply discarded.</p>
<p>

In addition to swapping in pages because they are necessary, in reaction to a page fault, there are several strategies for guessing what pages might be needed, and speculatively pre-loading them.</p>

<ss1>
<st>
 Demand paging </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../997/1310997.xml">
Demand paging</link></it>
</indent>

Demand paging refuses to guess.
With demand paging, no pages are brought into RAM until necessary. 
In particular, with demand paging, a program usually begins execution with none of its pages pre-loaded in RAM. 
Pages are copied from the executable file into RAM the first time the executing code references them, usually in response to a <link xlink:type="simple" xlink:href="../143/1157143.xml">
page fault</link>.
During a particular run of a program, pages of the executable file that implement functionality not used on that particular run are never loaded.</p>

</ss1>
<ss1>
<st>
 Loader paging </st>

<p>

Loader paging&#91;&#93; guesses that the entire program will be used.
Many operating systems (including those with a relocating <link xlink:type="simple" xlink:href="../773/483773.xml">
loader</link>) load every page of a program into RAM before beginning to execute the program.</p>

</ss1>
<ss1>
<st>
 Anticipatory paging </st>
<p>

This technique preloads a process's non-resident pages that are likely to be referenced in the near future (taking advantage of <link xlink:type="simple" xlink:href="../028/64028.xml">
locality of reference</link>). Such strategies attempt to reduce the number of page faults a process experiences.</p>

</ss1>
<ss1>
<st>
 Swap prefetch </st>

<p>

A few operating systems use anticipatory paging, also called swap prefetch.
These operating systems periodically attempt to guess which pages will soon be needed, and start loading them into RAM.
There are various heuristics in use, such as <it>"if a program references one virtual address which causes a page fault, perhaps the next few pages' worth of virtual address space will soon be used"</it> and <it>"if one big program just finished execution, leaving lots of free RAM, perhaps the user will return to using some of the programs that were recently paged out"</it>.</p>

</ss1>
<ss1>
<st>
 Pre-cleaning </st>

<p>

Unix operating systems periodically use <link xlink:type="simple" xlink:href="../775/5210775.xml">
sync</link> to pre-clean all dirty pages, that is, to save all modified pages to hard disk.
This makes starting a large new program run much faster, because it can be loaded into page frames that held clean pages that were dropped, rather than being loaded into page frames that were dirty and needed to be written back to disk before they were dropped.</p>

</ss1>
</sec>
<sec>
<st>
Thrashing</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../891/665891.xml">
Thrash (computer science)</link></it>
</indent>
Most programs reach a steady state in their demand for memory <link xlink:type="simple" xlink:href="../028/64028.xml">
locality</link> both in terms of instructions fetched and data being accessed.  This steady state is usually much less than the total memory required by the program.  This steady state is sometimes referred to as the <link xlink:type="simple" xlink:href="../794/3007794.xml">
working set</link>: the set of memory pages that are most frequently accessed.</p>
<p>

Virtual memory systems work most efficiently when the ratio of the working set to the total number of pages that can be stored in RAM is low enough to minimize the number of page faults.
A program that works with huge data structures will sometimes require a working set that is too large to be efficiently managed by the page system resulting in constant page faults that drastically slow down the system.  This condition is referred to as <link xlink:type="simple" xlink:href="../891/665891.xml">
thrashing</link>: pages are swapped out and then accessed causing frequent faults.</p>
<p>

An interesting characteristic of thrashing is that as the working set grows, there is very little increase in the number of faults until the critical point (when faults go up dramatically and majority of system's processing power is spent on handling them).</p>
<p>

An extreme example of this sort of situation occurred on the <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/7522024.xml">
IBM System/360 Model 67</link></machine>
</device>
</horizontal_surface>
</instrumentality>
</surface>
</artifact>
</platform>
 and <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../785/59785.xml">
IBM System/370</link></horizontal_surface>
</surface>
</artifact>
</platform>
 series mainframe computers, in which a particular instruction could consist of an execute instruction, which crosses a page boundary, that the instruction points to a move instruction, that itself also crosses a page boundary, targeting a move of data from a source that crosses a page boundary, to a target of data that also crosses a page boundary. The total amount of pages thus being used by this particular instruction is eight, and all eight pages must be present in memory at the same time. If the operating system will allocate less than eight pages of actual memory in this example, when it attempts to swap out some part of the instruction or data to bring in the remainder, the instruction will again page fault, and it will thrash on every attempt to restart the failing instruction.</p>
<p>

To decrease excessive paging, and thus possibly resolve thrashing problem, a user can do any of the following:
<list>
<entry level="1" type="bullet">

 Increase the amount of RAM in the computer (generally the best long-term solution).</entry>
<entry level="1" type="bullet">

 Decrease the number of programs being concurrently run on the computer.</entry>
</list>
</p>
<p>

The term <it>thrashing</it> is also used in contexts other than virtual memory systems, for example to describe <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link> issues in computing or <link xlink:type="simple" xlink:href="../596/2111596.xml">
silly window syndrome</link> in networking.</p>

</sec>
<sec>
<st>
Terminology</st>
<p>

Historically, <it>paging</it> sometimes also referred simply to <link xlink:type="simple" xlink:href="../117/547117.xml">
memory allocation</link> scheme using fixed-length pages as opposed to variable-length <link xlink:type="simple" xlink:href="../131/1323131.xml">
segments</link>, and without implicit suggestion that virtual memory technique is employed at all or that those pages are transferred to disk.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Such usage is rare today.</p>
<p>

Some modern systems use the term <it>swapping</it> along with <it>paging</it>. Historically, <it>swapping</it> referred to moving from/to secondary storage a whole program at a time, in a scheme known as <link>
roll-in/roll-out</link>.
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> 
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> 
In the 1960s, after the concept of virtual memory was introduced&mdash;in two variants, either using segments or pages&mdash;the term <it>swapping</it> was applied to moving, respectively, either segments or pages, between disk and memory. Today with the virtual memory mostly based on pages, not segments, <it>swapping</it> became a fairly close synonym of <it>paging</it>, although with one difference. </p>
<p>

In many popular systems, there is a concept known as <link xlink:type="simple" xlink:href="../313/8641313.xml">
page cache</link>, of using the same single mechanism for <it>both</it> virtual memory and <link xlink:type="simple" xlink:href="../829/6829.xml">
disk caching</link>. A page may be then transferred to or from <it>any</it> ordinary disk file, not necessarily a dedicated space. In some of such systems, notably <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../815/31815.xml">
Unix-like</link></family>
 including <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
, <it>swapping</it> only refers to virtual memory scope and <it>paging</it> to both. <it>Page in</it> is transferring a page from the disk to RAM.  <it>Page out</it> is transferring a page from RAM to the disk. But <it>swap in</it> and <it>out</it> only refer to transferring pages between RAM and dedicated <it>swap space</it> or <it>swap file</it>, and not any other place on disk.</p>
<p>

On the other hand, <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../001/19001.xml">
Microsoft</link></company>
 systems from <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/33438.xml">
Windows NT</link></family>
 line very rarely use the term <it>swapping</it> to differentiate from general paging, and call the dedicated secondary store just a <it>page file</it>.</p>

</sec>
<sec>
<st>
Implementations</st>

<ss1>
<st>
Windows 3.x and Windows 9x</st>
<p>

Virtual memory has been a feature of <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> since <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/168400.xml">
Windows 3.0</link></version>
 in 1990. Microsoft introduced virtual memory in response to the failures of <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../387/67387.xml">
Windows 1.0</link></version>
 and <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../153/188153.xml">
Windows 2.0</link></version>
, attempting to slash resource requirements for the operating system. </p>
<p>

Confusion abounds about Microsoft's decision to refer to the swap file as "virtual memory". Novices unfamiliar with the concept accept this definition without question, and speak of adjusting Windows' virtual memory size. In fact <it>every</it> process has a fixed, unchangeable virtual memory size, usually 2 <link xlink:type="simple" xlink:href="../000/147000.xml">
GiB</link>. The user has only an option to change disk capacity dedicated to paging.</p>
<p>

Windows 3.x creates a <link xlink:type="simple" xlink:href="../202/5842202.xml">
hidden file</link> named 386SPART.PAR or WIN386.SWP for use as a swap file. It is generally found in the <link xlink:type="simple" xlink:href="../871/158871.xml">
root directory</link>, but it may appear elsewhere (typically in the WINDOWS directory). Its size depends on how much swap space the system has (a setting selected by the user under <link xlink:type="simple" xlink:href="../714/1615714.xml">
Control Panel</link> → Enhanced under "Virtual Memory".) If the user moves or deletes this file, a <screen wordnetid="104152829" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/18909256.xml">
blue screen</link></surface>
</artifact>
</screen>
 will appear the next time Windows is started, with the <link xlink:type="simple" xlink:href="../502/3388502.xml">
error message</link> "The permanent swap file is corrupt". The user will be prompted to choose whether or not to delete the file (whether or not it exists).</p>
<p>

<version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../064/34064.xml">
Windows 95</link></version>
, <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../433/75433.xml">
Windows 98</link></version>
 and <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../458/75458.xml">
Windows Me</link></version>
 use a similar file, and the settings for it are located under Control Panel → System → Performance tab → Virtual Memory. Windows automatically sets the size of the page file to start at 1.5&amp;times; the size of physical memory, and expand up to 3&amp;times; physical memory if necessary. If a user runs memory-intensive applications on a system with low physical memory, it is preferable to manually set these sizes to a value higher than default.</p>

</ss1>
<ss1>
<st>
Windows NT</st>
<p>

In NT-based versions of Windows (such as <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/33879.xml">
Windows XP</link></version>
 and <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../648/2289648.xml">
Windows Vista</link></version>
), the file used for paging is named pagefile.sys.  The default location of the page file is in the root directory of the partition where Windows is installed. Windows can be configured to use free space on any available drives for pagefiles.  It is required, however, for the boot partition (i.e. the drive containing the Windows directory) to have a pagefile on it if the system is configured to write either kernel or full memory dumps after a <screen wordnetid="104152829" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/18909256.xml">
crash</link></surface>
</artifact>
</screen>
. Windows uses the paging file as temporary storage for the memory dump. When the system is rebooted, Windows copies the memory dump from the pagefile to a separate file and frees the space that was used in the pagefile.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>

<ss2>
<st>
Fragmentation</st>
<p>

In Windows's default configuration the pagefile is allowed to expand beyond its initial allocation when necessary. If this happens gradually, it can become heavily <link xlink:type="simple" xlink:href="../119/8429119.xml">
fragmented</link> which can potentially cause performance problems. The common advice given to avoid this is to set a single "locked" pagefile size so that Windows will not expand it.  However, the pagefile only expands when it has been filled, which, in its default configuration, is 150% the total amount of physical memory.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>  Thus the total demand for pagefile-backed virtual memory must exceed 250% of the computer's physical memory before the pagefile will expand.</p>
<p>

The fragmentation of the pagefile that occurs when it expands is temporary. As soon as the expanded regions are no longer in use (at the next reboot, if not sooner) the additional disk space allocations are freed and the pagefile is back to its original state. </p>
<p>

Locking a page file's size can be problematic in the case that a Windows application requests more memory than the total size of physical memory and the pagefile. In this case, requests to allocate memory fail, which may cause applications and system processes to fail.  Supporters of this view will note that the pagefile is rarely read or written in sequential order, so the performance advantage of having a completely sequential pagefile is minimal. However, it is generally agreed that a large pagefile will allow use of memory-heavy applications, and there is no penalty except that more disk space is used.</p>
<p>

<link xlink:type="simple" xlink:href="../339/360339.xml">
Defragment</link>ing the page file is also occasionally recommended to improve performance when a Windows system is chronically using much more memory than its total physical memory. This view ignores the fact that, aside from the temporary results of expansion, the pagefile does not become fragmented over time. In general, performance concerns related to pagefile access are much more effectively dealt with by adding more physical memory.</p>

</ss2>
</ss1>
<ss1>
<st>
Linux</st>
<p>

<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 and other <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../815/31815.xml">
Unix-like</link></family>
 operating systems use the term "swap" to describe both the act of moving memory pages between RAM and disk, and the region of a disk the pages are stored on.  It is common to use a whole partition of a hard disk for swapping.  However, with the 2.6 Linux kernel, swap files are just as fast<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> as swap partitions, although <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../386/26386.xml">
Red Hat</link></company>
 recommends using a swap partition.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> The administrative flexibility of swap files outweighs that of partitions; since modern high capacity hard drives can remap physical sectors, no partition is guaranteed to be contiguous.</p>
<p>

Linux supports using a virtually unlimited number of swapping devices, each of which can be assigned a priority. When the operating system needs to swap pages out of physical memory, it uses the highest-priority device with free space. If multiple devices are assigned the same priority, they are used in a fashion similar to level 0 <link xlink:type="simple" xlink:href="../695/54695.xml">
RAID</link> arrangements. This provides improved performance as long as the devices can be accessed efficiently in parallel. Therefore, care should be taken assigning the priorities. For example, swaps located on the same physical disk should not be used in parallel, but in order ranging from the fastest to the slowest (i.e.: the fastest having the highest priority).</p>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="45px" src="Ambox_outdated_content.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>The  of this article or section may be compromised due to out-of-date information.</b> 
You can <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Paging&amp;action=edit">
improve the article</weblink> by updating it. There may be information on the . <it>(September 2008)</it></col>
</row>
</table>

 
Recently, some experimental improvement to the 2.6 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/18510.xml">
Linux kernel</link></software>
 have been made by <person wordnetid="100007846" confidence="0.9508927676800064">
<doctor wordnetid="110020890" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../573/12470573.xml">
Con Kolivas</link></doctor>
</person>
, published in his popular <link>
-ck patchset</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref>. The improvement, called "swap prefetch", employs a mechanism of prefetching previously swapped pages back to physical memory even before they are actually needed, as long as the system is relatively idle (so as not to impair performance) and there is available physical memory to use. This applies to a situation when a "heavy" application has been temporarily used, causing other processes to swap out. After it is closed, both freeing large areas of memory and reducing disk load, prefetch of other processes starts, reducing their initial user response time. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></p>

</ss1>
<ss1>
<st>
Mac OS X</st>
<p>

<link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>, like Linux, supports both swap partitions and the use of swap files, but the default and recommended configuration is to use multiple swap files.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></p>

</ss1>
<ss1>
<st>
Sun Solaris</st>
<p>

Solaris allows swapping to raw disk slices as well as files.  The traditional method is to use slice 1 (ie. the second slice) on the OS disk to house swap. 
Swap setup is managed by the system boot process if there are entries in the "vfstab" file, but can also be managed manually through the use of the "swap" command. While it is possible to remove,  at runtime, all swap from a lightly loaded system, Sun does not recommend it. 
Recent additions to the <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../693/1205693.xml">
ZFS</link></instrumentality>
</artifact>
</system>
 file system allow creation of ZFS Devices that can be used as swap partitions. Swapping to normal files on ZFS file systems is not supported.</p>

</ss1>
</sec>
<sec>
<st>
Performance</st>
<p>

The backing store for a virtual memory operating system is typically many orders of <link xlink:type="simple" xlink:href="../301/577301.xml">
magnitude</link> slower than <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link>.  Therefore it is desirable to reduce or eliminate swapping, where practical.  Some operating systems offer settings to influence the kernel's decisions.</p>
<p>

<list>
<entry level="1" type="number">

 Linux offers the /proc/sys/vm/swappiness parameter, which changes the balance between swapping out runtime memory, as opposed to dropping pages from the system <link xlink:type="simple" xlink:href="../313/8641313.xml">
page cache</link>.</entry>
<entry level="1" type="number">

 Windows 2000, XP, and Vista offer the DisablePagingExecutive registry setting, which controls whether kernel-mode code and data can be eligible for paging out.</entry>
<entry level="1" type="number">

 Mainframe computers frequently used head-per-track disk drives or drums for swap storage to eliminate the latency implicit in seeking a moveable head.</entry>
<entry level="1" type="number">

 Flash memory devices have an inherent life limitation which makes them inappropriate for general-purpose swapspace. However schemes such as <link xlink:type="simple" xlink:href="../290/5233290.xml">
ReadyBoost</link> may be used to preload binaries or other read-only data into the virtual memory space.</entry>
</list>
</p>
<p>

Many <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../815/31815.xml">
Unix-like</link></family>
 operating systems (for example <link xlink:type="simple" xlink:href="../ury/22nd_century.xml">
AIX</link>, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 and <link xlink:type="simple" xlink:href="../145/46145.xml">
Sun Solaris</link>) allow using multiple storage devices for swap space in parallel, to increase performance.</p>

</sec>
<sec>
<st>
 Tuning swap space size </st>
<p>

In some older virtual memory operating systems, space in swap backing store is reserved when programs allocate memory for runtime data.  OS vendors typically issue guidelines about how much swap space should be allocated. Between 1.5 or 2 times the installed RAM is a typical number <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref>.  With a large amount of RAM, the disk space needed for the backing store can be very large.  Newer versions of these operating systems attempt to solve this problem: for example, some <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../704/36704.xml">
HP-UX</link></O>
 kernels offer a tunable swapmem_on that controls whether RAM can be used for memory reservations.  In systems with sufficient RAM, this significantly reduces the needed space allocation for the backing store.</p>

</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <link>
Physical memory</link>, a subject of paging</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../354/32354.xml">
Virtual memory</link>, an abstraction that paging may create</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../997/1310997.xml">
Demand paging</link>, a "lazy" paging scheme</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../313/8641313.xml">
Page cache</link>, a disk cache that utilizes virtual memory mechanism</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/727476.xml">
Page replacement algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../131/1323131.xml">
Segmentation (memory)</link></entry>
<entry level="1" type="bullet">

 <link>
Page size</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../962/674962.xml">
Page table</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../117/547117.xml">
Memory allocation</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite id="CITEREFBelzerHolzmanKent1981" style="font-style:normal">Belzer, Jack; Holzman, Albert G.&#32;&amp; Kent, Allen, eds.&#32;(1981),&#32;<weblink xlink:type="simple" xlink:href="http://books.google.com/books?id=KUgNGCJB4agC&amp;printsec=frontcover">
"Virtual memory systems"</weblink>,&#32;<it>Encyclopedia of computer science and technology</it>, <b>14</b>, CRC Press, pp. 32, ISBN 0824722140, </cite>&nbsp;
</entry>
<entry id="2">
 <cite id="CITEREFDeitel1983" style="font-style:normal">Deitel, Harvey M.&#32;(1983),&#32;<it>An Introduction to Operating Systems</it>, Addison-Wesley, pp. 181, 187, ISBN 0201144735</cite>&nbsp;</entry>
<entry id="3">
 <cite id="CITEREFBelzerHolzmanKent1981" style="font-style:normal">Belzer, Jack; Holzman, Albert G.&#32;&amp; Kent, Allen, eds.&#32;(1981),&#32;<weblink xlink:type="simple" xlink:href="http://books.google.com/books?id=uTFirmDlSL8C&amp;printsec=frontcover">
"Operating systems"</weblink>,&#32;<it>Encyclopedia of computer science and technology</it>, <b>11</b>, CRC Press, pp. 433, ISBN 0824722612, </cite>&nbsp; </entry>
<entry id="4">
 <cite id="CITEREFBelzerHolzmanKent1981" style="font-style:normal">Belzer, Jack; Holzman, Albert G.&#32;&amp; Kent, Allen, eds.&#32;(1981),&#32;<weblink xlink:type="simple" xlink:href="http://books.google.com/books?id=uTFirmDlSL8C&amp;printsec=frontcover">
"Operating systems"</weblink>,&#32;<it>Encyclopedia of computer science and technology</it>, <b>11</b>, CRC Press, pp. 442, ISBN 0824722612, </cite>&nbsp; </entry>
<entry id="5">
 <cite id="CITEREFCragon1996" style="font-style:normal">Cragon, Harvey G.&#32;(1996),&#32;<it><weblink xlink:type="simple" xlink:href="http://books.google.com/books?id=q2w3JSFD7l4C">
Memory Systems and Pipelined Processors</weblink></it>, Jones and Bartlett Publishers, pp. 109, ISBN 0867204745, </cite>&nbsp;</entry>
<entry id="6">
Tsigkogiannis, Ilias&#32;(<link xlink:type="simple" xlink:href="../396/8396.xml">
December 11</link> <link xlink:type="simple" xlink:href="../164/36164.xml">
2006</link>).&#32;"<weblink xlink:type="simple" xlink:href="http://blogs.msdn.com/iliast/archive/2006/12/11/crash-dump-analysis.aspx">
Crash Dump Analysis</weblink>".&#32;<it>Ilias Tsigkogiannis' Introduction to Windows Device Drivers</it>.&#32;  MSDN Blogs.&#32;Retrieved on <link>
2008-07-22</link>.</entry>
<entry id="7">
"<weblink xlink:type="simple" xlink:href="http://support.microsoft.com/kb/889654">
How to determine the appropriate page file size for 64-bit versions of Windows Server 2003 or Windows XP (MSKB889654_</weblink>".&#32;<it>Knowledge Base</it>.&#32;  Microsoft&#32;(<link xlink:type="simple" xlink:href="../667/21667.xml">
November 7</link> <link xlink:type="simple" xlink:href="../165/36165.xml">
2007</link>).&#32;Retrieved on <link>
2007-12-26</link>.</entry>
<entry id="8">
<weblink xlink:type="simple" xlink:href="http://lkml.org/lkml/2006/5/29/3">
LKML: "Jesper Juhl": Re: How to send a break? - dump from frozen 64bit linux</weblink></entry>
<entry id="9">
<weblink xlink:type="simple" xlink:href="http://lkml.org/lkml/2005/7/7/326">
LKML: Andrew Morton: Re: Swap partition vs swap file</weblink></entry>
<entry id="10">
http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/sysadmin-guide/ch-swapspace.html</entry>
<entry id="11">
http://kernel.kolivas.org Con Kolivas' 2.6 Linux Kernel patchset</entry>
<entry id="12">
http://ck.wikia.com/wiki/SwapPrefetch SwapPrefetch description on ck kernel wiki. Retrieved 18-09-2007.</entry>
<entry id="13">
John Siracusa&#32;(<link xlink:type="simple" xlink:href="../555/22555.xml">
October 15</link> <link xlink:type="simple" xlink:href="../551/34551.xml">
2001</link>).&#32;"<weblink xlink:type="simple" xlink:href="http://arstechnica.com/reviews/os/macosx-10-1.ars/7">
Mac OS X 10.1</weblink>".&#32;  <web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../941/1765941.xml">
Ars Technica</link></web_site>
.&#32;Retrieved on <link>
2008-07-23</link>.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://computer.howstuffworks.com/virtual-memory.htm">
How Virtual Memory Works</weblink> from HowStuffWorks.com (in fact explains only swapping concept, and not virtual memory concept)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.rojakpot.com/showarticle.aspx?artno=143&amp;pgno=1">
Swap File vs. Paging File</weblink> (Hint: From Windows 95 onwards, all Windows OS versions use only paging files.) DEAD LINK (no info relevant to this "paging" subject)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.faqs.org/docs/linux_admin/x1762.html">
Linux swap space management</weblink> (outdated, as the author admits)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.techarp.com/showarticle.aspx?artno=143">
Guide On Optimizing Virtual Memory Speed</weblink> (outdated, and contradicts section 1.4 of this wiki page, and (at least) references 8, 9, and 11.)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.pcnineoneone.com/howto/swpfile1.html">
Windows swap file management</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://people.msoe.edu/~mccrawt/resume/papers/CS384/mccrawt_cs384_virtual.pdf">
Virtual Memory Page Replacement Algorithms</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://support.microsoft.com/kb/308417/">
Windows XP. How to manually change the size of the virtual memory paging file</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://support.microsoft.com/?id=312362">
Windows XP. Factors that may deplete the supply of paged pool memory</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.acc.umu.se/~bosse/">
SwapFs</weblink> driver that can be used to save the paging file of Windows on a swap partition of Linux.</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../194/22194.xml">
Operating system</link></header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
General</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../395/55395.xml">
History</link>&nbsp;·  <record wordnetid="106647206" confidence="0.8">
<chronology wordnetid="106503224" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<timeline wordnetid="106504965" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../968/247968.xml">
Timeline</link></written_record>
</timeline>
</evidence>
</indication>
</chronology>
</record>
&nbsp;·  <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/229119.xml">
Developement</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
&nbsp;·  <link xlink:type="simple" xlink:href="../531/981531.xml">
List</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../394/50394.xml">
Kernel</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<table style="width:100%;;;;" class="nowraplinks  navbox-subgroup" cellspacing="0">
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
General</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../023/20023.xml">
Microkernel</link>&nbsp;·  <link xlink:type="simple" xlink:href="../023/20023.xml#xpointer(//*[./st=%22Nanokernel%22])">
Nanokernel</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Types</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../825/20825.xml">
monolithic</link>&nbsp;·  <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/4345041.xml">
hybrid</link></kernel>
</natural_object>
</plant_part>
&nbsp;·  <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../757/95757.xml">
exokernel</link></kernel>
</natural_object>
</plant_part>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";padding-left:0em;padding-right:0em;;" class="navbox-group">
Components</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../467/93467.xml">
Kernel space</link>&nbsp;·  <link xlink:type="simple" xlink:href="../658/371658.xml">
Loadable kernel module</link>&nbsp;·  <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>&nbsp;·  <link xlink:type="simple" xlink:href="../467/93467.xml">
User space</link>&nbsp;·  <link xlink:type="simple" xlink:href="../109/555109.xml">
Userland</link></col>
</row>
</table>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../806/15395806.xml">
Process management</link></col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../178/45178.xml">
Process</link>&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Multiprogramming</link>&nbsp;·  <link xlink:type="simple" xlink:href="../289/15289.xml">
Interrupt</link>&nbsp;·  Modes: (<link xlink:type="simple" xlink:href="../596/167596.xml">
Protected mode</link>&nbsp;·  <link>
Supervisor mode</link>)&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Computer multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../920/231920.xml">
Scheduling</link>&nbsp;·  <link xlink:type="simple" xlink:href="../904/6904.xml">
Context switch</link>&nbsp;·  <link xlink:type="simple" xlink:href="../857/6857.xml">
Cooperative multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../566/2204566.xml">
Preemptive multitasking</link>&nbsp;·  <link xlink:type="simple" xlink:href="../954/3991954.xml">
CPU modes</link>&nbsp;·  <link xlink:type="simple" xlink:href="../303/45303.xml">
Thread (computer science)</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Memory management</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../373/515373.xml">
Memory protection</link>&nbsp;·  <link xlink:type="simple" xlink:href="../131/1323131.xml">
Segmentation</link>&nbsp;·  <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link>&nbsp;·  <link xlink:type="simple" xlink:href="../112/177112.xml">
Memory management unit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../803/28803.xml">
Segmentation fault</link>&nbsp;·  <link xlink:type="simple" xlink:href="../943/573943.xml">
General protection fault</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Examples</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../304/18933304.xml">
AmigaOS</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../801/4801.xml">
BeOS</link>&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../409/22409.xml">
IBM OS/2</link></O>
&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../027/20027.xml">
MS-DOS</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../890/18890.xml">
Windows</link>&nbsp;·  <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
&nbsp;·  <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link>&nbsp;·  <link xlink:type="simple" xlink:href="../658/1178658.xml">
OpenSolaris</link>&nbsp;·  <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>&nbsp;·   <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../889/360889.xml">
ReactOS</link></O>
&nbsp;·  <it><link xlink:type="simple" xlink:href="../916/71916.xml">
more…</link>''</it></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Miscellaneous concepts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../679/6885679.xml">
Boot loader</link>&nbsp;·  <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../253/432253.xml">
PXE</link></system_of_measurement>
</standard>
&nbsp;·  <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link>&nbsp;·  <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/351131.xml">
Virtual file system</link></instrumentality>
</artifact>
</system>
&nbsp;·  <link xlink:type="simple" xlink:href="../071/2550071.xml">
Virtual tape library</link>&nbsp;·  <link xlink:type="simple" xlink:href="../592/4122592.xml">
Computer network</link>&nbsp;·  <link xlink:type="simple" xlink:href="../293/12293.xml">
GUI</link>&nbsp;·  <link xlink:type="simple" xlink:href="../511/425511.xml">
HAL</link></col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</article>
