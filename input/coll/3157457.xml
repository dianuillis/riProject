<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:08:14[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<header>
<title>Production system</title>
<id>3157457</id>
<revision>
<id>239248102</id>
<timestamp>2008-09-18T11:17:07Z</timestamp>
<contributor>
<username>Yakiv Gluck</username>
<id>6633482</id>
</contributor>
</revision>
<categories>
<category>expert systems</category>
<category>Logic programming</category>
</categories>
</header>
<bdy>

A <b>production system </b> (or <b>production rule system</b>) is a computer program typically used to provide some form of <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link>, which consists primarily of a set of rules about behavior. These rules, termed <b>productions</b>, are a basic <link xlink:type="simple" xlink:href="../920/16920.xml">
representation</link> found useful in <link xlink:type="simple" xlink:href="../641/1505641.xml">
AI planning</link>, <link xlink:type="simple" xlink:href="../136/10136.xml">
expert systems</link> and <link xlink:type="simple" xlink:href="../373/5033373.xml">
action selection</link>. A production system provides the mechanism necessary to execute productions in order to achieve some goal for the system.<p>

Productions consist of two parts: a sensory precondition (or "IF" statement) and an action (or "THEN"). If a production's precondition matches the current <link xlink:type="simple" xlink:href="../512/285512.xml">
state</link> of the world, then the production is said to be <it>triggered</it>. If a production's action is <link xlink:type="simple" xlink:href="../206/418206.xml">
executed</link>, it is said to have <it>fired</it>.  A production system also contains a database, sometimes called <link xlink:type="simple" xlink:href="../912/33912.xml">
working memory</link>, which maintains data about current state or knowledge, and a rule interpreter.  The rule interpreter must provide a mechanism for prioritizing productions when more than one is triggered.</p>

<sec>
<st>
 Basic operation </st>

<p>

Rule interpreters generally execute a <link xlink:type="simple" xlink:href="../962/568962.xml">
forward chaining</link> algorithm for selecting productions to execute to meet current goals, which can include updating the system's data or <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../235/1974235.xml">
beliefs</link></instrumentality>
</artifact>
</system>
.  The condition portion of each rule (<it>left-hand side</it> or LHS) is tested against the current state of the working memory.  </p>
<p>

In idealized or data-oriented production systems, there is an assumption that any triggered conditions should be executed: the consequent actions (<it>right-hand side</it> or RHS) will update the agent's knowledge, removing or adding data to the working memory.  The system stops processing either when the user interrupts the forward chaining loop; when a given number of cycles has been performed; when a "halt" RHS is executed, or when no rules have true LHSs.</p>
<p>

Real-time and expert systems, in contrast, often have to choose between mutually exclusive productions --- since actions take time, only one action can be taken, or (in the case of an expert system) recommended.  In such systems, the rule interpreter, or <link xlink:type="simple" xlink:href="../609/418609.xml">
inference engine</link>, cycles through two steps: matching production rules against the database, followed by selecting which of the matched rules to apply and executing the selected actions.</p>

</sec>
<sec>
<st>
Matching production rules against working memory</st>
<p>

Production systems may vary on the expressive power of conditions in production rules.  Accordingly, the <link xlink:type="simple" xlink:href="../688/279688.xml">
pattern matching</link> algorithm which collects production rules with matched conditions may range from the naive -- trying all rules in sequence, stopping at the first match -- to the optimized, in which rules are "compiled" into a network of inter-related conditions.</p>
<p>

The latter is illustrated by the <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../566/172566.xml">
RETE</link></instrumentality>
</artifact>
</system>
 algorithm, designed by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/476022.xml">
Charles L. Forgy</link></scholar>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 in 1983, which is used in a series of production systems, called OPS and originally developed at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../093/48093.xml">
Carnegie Mellon University</link></university>
 culminating in <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/475829.xml">
OPS5</link></language>
</instrumentality>
</artifact>
</system>
 in the early eighties.  OPS5 may be viewed as a full-fledged programming language for production system programming.</p>

</sec>
<sec>
<st>
 Choosing which rules to evaluate </st>
<p>

Production systems may also differ in the final selection of production rules to execute, or <it>fire </it>.  The collection of rules resulting from the previous matching algorithm is called the <it>conflict set </it>, and the selection process is also called a <it><link xlink:type="simple" xlink:href="../193/5421193.xml">
conflict resolution strategy</link> </it>.</p>
<p>

Here again, such strategies may vary from the simple -- use the order in which production rules were written; assign weights or priorities to production rules and sort the conflict set accordingly -- to the complex -- sort the conflict set according to the times at which production rules were previously fired; or according to the extent of the modifications induced by their RHSs.  Whichever conflict resolution strategy is implemented, the method is indeed crucial to the efficiency and correctness of the production system.</p>

</sec>
<sec>
<st>
 Using production systems </st>
<p>

The use of production systems varies from simple string <link xlink:type="simple" xlink:href="../847/415847.xml">
rewriting</link> rules to the modeling of human cognitive processes, from term rewriting and reduction systems to <link xlink:type="simple" xlink:href="../136/10136.xml">
expert system</link>s.</p>

<ss1>
<st>
 A simple string rewriting production system example </st>
<p>

This example shows a set of production rules for reversing a string from an alphabet that does not contain the symbols "$" and "*" (which are used as marker symbols).</p>
<p>

P1: $$ -&amp;gt; *
P2: *$ -&amp;gt; *
P3: *x -&amp;gt; x*
P4: * -&amp;gt; null &amp; halt
P5: $xy -&amp;gt; y$x
P6: null -&amp;gt; $</p>
<p>

In this example, production rules are chosen for testing according to their order in this production list.  For each rule, the input string is examined from left to right with a moving window to find a match with the LHS of the production rule.  When a match is found, the matched substring in the input string is replaced with the RHS of the production rule. In this production system, x and y are <it>variables </it> matching any character of the input string alphabet.  Matching resumes with P1 once the replacement has been made.</p>
<p>

The string "ABC", for instance, undergoes the following sequence of transformations under these production rules:</p>
<p>

$ABC (P6)
B$AC (P5)
BC$A (P5)
$BC$A (P6)
C$B$A (P5)
$C$B$A (P6)
$$C$B$A (P6)
<list>
<entry level="1" type="bullet">

C$B$A (P1)</entry>
</list>

C*$B$A (P3)
C*B$A (P2)
CB*$A (P3)
CB*A (P2)
CBA* (P3)
CBA (P4)</p>
<p>

In such a simple system, the ordering of the production rules is crucial.  Often, the lack of control structure makes production systems difficult to design.  It is, of course, possible to add control structure to the production systems model, namely in the inference engine, or in the working memory.</p>

</ss1>
<ss1>
<st>
 An OPS5 production rule example </st>
<p>

In a toy simulation world where a monkey in a room can grab different objects and climb on others, an example production rule to grab an object suspended from the ceiling would look like:</p>
<p>

(p Holds::Object-Ceiling
{(goal ^status active ^type holds ^objid &amp;lt;O1&amp;gt;) &amp;lt;goal&amp;gt;}
{(physical-object
^id &amp;lt;O1&amp;gt;
^weight light
^at &amp;lt;p&amp;gt;
^on ceiling) &amp;lt;object-1&amp;gt;}
{(physical-object ^id ladder ^at &amp;lt;p&amp;gt; ^on floor) &amp;lt;object-2&amp;gt;}
{(monkey ^on ladder ^holds NIL) &amp;lt;monkey&amp;gt;}
-(physical-object ^on &amp;lt;O1&amp;gt;)
--&amp;gt;
(write (crlf) Grab &amp;lt;O1&amp;gt; (crlf))
(modify &amp;lt;object1&amp;gt; ^on NIL)
(modify &amp;lt;monkey&amp;gt; ^holds &amp;lt;O1&amp;gt;)
(modify &amp;lt;goal&amp;gt; ^status satisfied)
)</p>
<p>

In this example, data in working memory is structured and variables appear between angle brackets.  The name of the data structure, such as "goal" and "physical-object", is the first literal in conditions; the fields of a structure are prefixed with "^".  The "-" indicates a negative condition.  </p>
<p>

Production rules in OPS5 apply to all instances of data structures that match conditions and conform to variable bindings.  In this example, should several objects be suspended from the ceiling, each with a different ladder nearby supporting an empty-handed monkey, the conflict set would contain as many production rule instances derived from the same production "Holds::Object-Ceiling".  The conflict resolution step would later select which production instances to fire.</p>
<p>

Note that the binding of variables resulting from the pattern matching in the LHS is used in the RHS to refer to the data to be modified.  Note also that the working memory contains explicit control structure data in the form of "goal" data structure instances.  In the example, once a monkey holds the suspended object, the status of the goal is set to "satisfied" and the same production rule can no longer apply as its first condition fails.</p>

</ss1>
</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 Brownston, L., Farrell R., Kant E. (1985). <it>Programming Expert Systems in OPS5</it> Reading, Massachusetts: Addison-Wesley. ISBN 0-201-10647-7</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Waterman, D.A., Hayes-Roth, F. (1978). <it>Pattern-Directed Inference Systems</it> New York: Academic Press. ISBN 0127375503  </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Klahr, D., Langley, P. and Neches, R. (1987). <it>Production System Models of Learning and Development</it>. Cambridge, Mass.: The MIT Press.</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../373/5033373.xml">
Action selection mechanism</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../136/10136.xml">
Expert system</link></entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../609/418609.xml">
Inference engine</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/475829.xml">
OPS5</link></language>
</instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../566/172566.xml">
Rete algorithm</link></instrumentality>
</artifact>
</system>
</entry>
</list>
</p>


</sec>
</bdy>
</instrumentality>
</artifact>
</system>
</article>
