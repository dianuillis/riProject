<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:47:32[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Quine–McCluskey algorithm</title>
<id>317263</id>
<revision>
<id>231579169</id>
<timestamp>2008-08-13T01:25:39Z</timestamp>
<contributor>
<username>Bobblewik</username>
<id>51235</id>
</contributor>
</revision>
<categories>
<category>Boolean algebra</category>
</categories>
</header>
<bdy>

The <b>Quine–McCluskey algorithm</b> (or <b>the method of prime implicants</b>) is a method used for minimization of <link xlink:type="simple" xlink:href="../349/753349.xml">
boolean function</link>s which was developed by <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../833/33833.xml">
W.V. Quine</link></philosopher>
</person>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../563/10597563.xml">
Edward J. McCluskey</link></associate>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
.  It is functionally identical to <link xlink:type="simple" xlink:href="../684/10854684.xml">
Karnaugh map</link>ping, but the tabular form makes it more efficient for use in computer algorithms, and it also gives a deterministic way to check that the minimal form of a Boolean function has been reached.  It is sometimes referred to as the tabulation method.<p>

The method involves two steps:
<list>
<entry level="1" type="number">

 Finding all <link xlink:type="simple" xlink:href="../776/1156776.xml">
prime implicants</link> of the function.</entry>
<entry level="1" type="number">

 Use those prime implicants in a <it>prime implicant chart</it> to find the essential prime implicants of the function, as well as other prime implicants that are necessary to cover the function.</entry>
</list>
</p>

<sec>
<st>
Complexity</st>
<p>

Although more practical than Karnaugh mapping when dealing with more than four variables, the Quine-McCluskey algorithm also has a limited range of use since the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 it solves is <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
: the <link xlink:type="simple" xlink:href="../263/192263.xml">
runtime</link> of the Quine-McCluskey algorithm grows <link xlink:type="simple" xlink:href="../933/191933.xml">
exponentially</link> with the input size. It can be shown that for a function of <it>n</it> variables the upper bound on the number of prime implicants is 3<it>n</it>/<it>n</it>. If <it>n</it> = 32 there may be over 6.5 * 1015, prime implicants. Functions with a large number of variables have to be minimized with potentially non-optimal <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic</link> methods, of which the <link xlink:type="simple" xlink:href="../395/12152395.xml">
Espresso heuristic logic minimizer</link> is the de-facto world standard.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
Example</st>

<ss1>
<st>
Step 1: finding prime implicants</st>
<p>

Minimizing an arbitrary function:</p>
<p>

<indent level="1">

<math>f(A,B,C,D) =\sum m(4,8,10,11,12,15) + d(9,14)  \,</math>
</indent>

A B C D   f 
m0  0 0 0 0   0
m1  0 0 0 1   0
m2  0 0 1 0   0
m3  0 0 1 1   0
m4  0 1 0 0   1
m5  0 1 0 1   0
m6  0 1 1 0   0 
m7  0 1 1 1   0
m8  1 0 0 0   1
m9  1 0 0 1   x
m10  1 0 1 0   1
m11  1 0 1 1   1 
m12  1 1 0 0   1
m13  1 1 0 1   0
m14  1 1 1 0   x
m15  1 1 1 1   1</p>
<p>

One can easily form the canonical <link xlink:type="simple" xlink:href="../841/794841.xml">
sum of products</link> expression from this table, simply by summing the <link xlink:type="simple" xlink:href="../841/794841.xml">
minterm</link>s (leaving out <link xlink:type="simple" xlink:href="../599/7444599.xml">
don't-care terms</link>) where the function evaluates to one:</p>
<p>

<indent level="1">

<math>f_{A,B,C,D} = A'BC'D' + AB'C'D' + AB'CD' + AB'CD + ABC'D' + ABCD</math>
</indent>

Of course, that's certainly not minimal. So to optimize, all minterms that evaluate to one are first placed in a minterm table. Don't-care terms are also added into this table, so they can be combined with minterms:</p>
<p>

Number of 1s  Minterm  Binary Representation
--------------------------------------------
1             m4       0100
m8       1000
--------------------------------------------
2             m9       1001
m10      1010
m12      1100
--------------------------------------------
3             m11      1011
m14      1110
--------------------------------------------
4             m15      1111</p>
<p>

At this point, one can start combining minterms with other minterms. If two terms vary by only a single digit changing, that digit can be replaced with a dash indicating that the digit doesn't matter. Terms that can't be combined any more are marked with a "*". When going from Size 2 to Size 4, treat '-' as a third bit value. Ex: -110 and -100 or -11- can be combined, but not -110 and 011-. (Trick: Match up the '-' first.)</p>
<p>

Number of 1s  Minterm  0-Cube | Size 2 Implicants | Size 4 Implicants
------------------------------|-------------------|----------------------
1             m4       0100   | m(4,12)  -100*    | m(8,9,10,11)   10--*
m8       1000   | m(8,9)   100-     | m(8,10,12,14)  1--0*
------------------------------| m(8,10)  10-0     |----------------------
2             m9       1001   | m(8,12)  1-00     | m(10,11,14,15) 1-1-*
m10      1010   |-------------------|
m12      1100   | m(9,11)  10-1     |
------------------------------| m(10,11) 101-     |
3             m11      1011   | m(10,14) 1-10     |
m14      1110   | m(12,14) 11-0     |
------------------------------|-------------------|
4             m15      1111   | m(11,15) 1-11     |
| m(14,15) 111-     |</p>

</ss1>
<ss1>
<st>
Step 2: prime implicant chart</st>

<p>

None of the terms can be combined any further than this, so at this point we construct an essential prime implicant table. Along the side goes the prime implicants that have just been generated, and along the top go the minterms specified earlier. The don't care terms are not placed on top - they are omitted from this section because they are not necessary inputs. </p>
<p>

<table class="wikitable">
<row>

<col>
4</col>
<col>
8</col>
<col>
10</col>
<col>
11</col>
<col>
12</col>
<col>
15</col>

</row>
<row>
<col>
m(4,12)*</col>
<col>
X</col>



<col>
X</col>

<col>
-100</col>
</row>
<row>
<col>
m(8,9,10,11)</col>

<col>
X</col>
<col>
X</col>
<col>
X</col>


<col>
10--</col>
</row>
<row>
<col>
m(8,10,12,14)</col>

<col>
X</col>
<col>
X</col>

<col>
X</col>

<col>
1--0</col>
</row>
<row>
<col>
m(10,11,14,15)*</col>


<col>
X</col>
<col>
X</col>

<col>
X</col>
<col>
1-1-</col>
</row>
</table>
 </p>
<p>

Here, each of the <it>essential</it> prime implicants has been starred - the second prime implicant can be 'covered' by the third and fourth, and the third prime implicant can be 'covered' by the second and first, and is thus neither an essential. If a prime implicant is essential then, as would be expected, it is necessary to include it in the minimized boolean equation. In some cases, the essential prime implicants do not cover all minterms, in which case additional procedures for chart reduction can be employed. The simplest "additional procedure" is trial and error, but a more systematic way is <link xlink:type="simple" xlink:href="../648/4147648.xml">
Petrick's Method</link>. In the current example, the essential prime implicants do not handle all of the minterms, so, in this case, one can combine the essential implicants with one of the two non-essential ones to yield one of these two equations:</p>
<p>

<indent level="1">

<math>f_{A,B,C,D} = BC'D' + AB' + AC \ </math>
</indent>
:<math>f_{A,B,C,D} = BC'D' + AD' + AC \ </math></p>
<p>

Both of those final equations are functionally equivalent to this original (very area-expensive) equation:
<indent level="1">

<math>f_{A,B,C,D} = A'BC'D' + AB'C'D' + AB'C'D + AB'CD' + AB'CD + ABC'D' + ABCD' + ABCD \ </math>
</indent>

</p>
</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../239/2701239.xml">
Boolean algebra (logic)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../085/12769085.xml">
Circuit minimization</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../684/10854684.xml">
Karnaugh map</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../395/12152395.xml">
Espresso</link> heuristic minimization program</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../648/4147648.xml">
Petrick's Method</link></entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../833/33833.xml">
Willard Van Orman Quine</link></philosopher>
</person>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
V.P. Nelson e.a., <it>Digital Circuit Analysis and Design</it>, Prentice Hall, 1995, pag. 234</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.omnistream.co.uk/qm/">
Web-Based Quine-McCluskey Algorithm</weblink>, an open source implementation written in PHP. (<weblink xlink:type="simple" xlink:href="http://www.phpclasses.org/quine_mccluskey">
PHP Class</weblink>)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://user.cs.tu-berlin.de/~lordmaik/projects/quinemccluskey/quinemccluskey/quineapplet.htm">
Java-Applet</weblink> Applet to minimize a boolean function based on QuineMcCluskey Algorithm. (German page)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.inf.ufrgs.br/lagarto/">
Karma (Karnaugh Map Viewer)</weblink> – A CAD tool for Karnaugh map manipulation with didactic features in logic circuit synthesis. Uses Quine-McCluskey algorithm to generate a minimal sum of products.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://134.193.15.25/vu/course/cs281/lectures/simplification/quine-McCluskey.html">
Lecture on the Quine–McCluskey algorithm</weblink></entry>
<entry level="1" type="bullet">

 A. Costa <weblink xlink:type="simple" xlink:href="http://www.dei.isep.ipp.pt/~acc/bfunc/">
BFunc</weblink>, QMC based boolean logic simplifiers supporting up to 64 inputs / 64 outputs (independently) or 32 outputs (simultaneously)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www25.brinkster.com/denshade/QuineMcCluskey.html">
Java applet</weblink> to display all the generated primes.</entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 <weblink xlink:type="simple" xlink:href="http://cheeseshop.python.org/pypi/qm/0.2">
Implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/quinessence/">
Quinessence</weblink>, an open source implementation written in Free Pascal.</entry>
<entry level="1" type="bullet">

 <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../136/18136.xml">
A literate program</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 written in Java <weblink xlink:type="simple" xlink:href="http://en.literateprograms.org/Quine-McCluskey_algorithm_%28Java%29">
implementing the Quine-McCluskey algorithm</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://automatics.hit.bg/#minBool">
minBool</weblink> a <link xlink:type="simple" xlink:href="../412/20412.xml">
Matlab</link> implementation.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://cran.r-project.org/src/contrib/Descriptions/QCA.html">
QCA</weblink> an open source, R based implementation used in the social sciences, by <link>
Adrian Duşa</link></entry>
<entry level="1" type="bullet">

 A series of two articles describing the algorithm(s) implemented in R: <weblink xlink:type="simple" xlink:href="http://www.compasss.org/Dusa2007.pdf">
first article</weblink> and <weblink xlink:type="simple" xlink:href="http://www.compasss.org/Dusa2007a.pdf">
second article</weblink>.</entry>
</list>

The R implementation is exhaustive and it offers complete and exact solutions. It processes up to 20 input variables.
<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://geocities.com/abeautifulmind1998">
http://geocities.com/abeautifulmind1998</weblink> , a Java program to display the boolean expression ..... by Manoranjan Sahu</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-ihs.theoinf.tu-ilmenau.de/~sane/projekte/qmc/embed_qmc.html">
http://www-ihs.theoinf.tu-ilmenau.de/~sane/projekte/qmc/embed_qmc.html</weblink>, an applet for a step by step analyze of the QMC- algorithm by Christian Roth</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/qmcs">
http://sourceforge.net/projects/qmcs</weblink> SourceForge.net C++ program implementing the algorithm.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/~kulp/Algorithm-QuineMcCluskey-0.01/lib/Algorithm/QuineMcCluskey.pm">
Perl Module</weblink></entry>
</list>
</p>



</sec>
</bdy>
</article>
