<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:36:17[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Virtual memory</title>
<id>32354</id>
<revision>
<id>244208666</id>
<timestamp>2008-10-09T20:06:00Z</timestamp>
<contributor>
<username>SF007</username>
<id>6059244</id>
</contributor>
</revision>
<categories>
<category>Virtual memory</category>
</categories>
</header>
<bdy>

This article is about the computational technique.&#32;&#32;For the TBN game show, see <change_of_state wordnetid="100199130" confidence="0.8">
<beginning wordnetid="100235435" confidence="0.8">
<diversion wordnetid="100426928" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<change wordnetid="100191142" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<show wordnetid="100520257" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<introduction wordnetid="100238022" confidence="0.8">
<entertainment wordnetid="100429048" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../669/9852669.xml">
Virtual Memory (game show)</link></activity>
</entertainment>
</introduction>
</psychological_feature>
</act>
</show>
</action>
</change>
</event>
</diversion>
</beginning>
</change_of_state>
.&#32;&#32;
<image width="250px" src="VirtualMem01.png" type="thumb">
<caption>

The program thinks it has a large range of contiguous addresses; but in reality the parts it is currently using are scattered around <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link>, and the inactive parts are saved in a disk file.
</caption>
</image>
<p>

<link xlink:type="simple" xlink:href="../354/32354.xml">
Virtual memory</link> is a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> system technique which gives an application program the impression that it has contiguous working memory, while in fact it may be physically fragmented and may even overflow on to disk storage. Systems that use this technique make programming of large applications easier and use real physical memory (e.g. <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link>) more efficiently than those without virtual memory.</p>
<p>

Note that "virtual memory" is not just "using disk space to extend physical memory size". Extending memory is a normal consequence of using virtual memory techniques, but can be done by other means such as <link xlink:type="simple" xlink:href="../764/5360764.xml">
overlay</link>s or swapping programs and their data completely out to disk while they are inactive. The definition of "virtual memory"  is based on tricking programs into thinking they are using large blocks of <it>contiguous</it> addresses.</p>
<p>

All modern general-purpose computer <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s use virtual memory techniques for ordinary applications, such as word processors, spreadsheets, multimedia players, accounting, etc. Few older operating systems, such as <link xlink:type="simple" xlink:href="../146/8146.xml">
DOS</link> of the 1980s, or those for the <link xlink:type="simple" xlink:href="../266/20266.xml">
mainframes</link> of the 1960s, had virtual memory functionality - notable exceptions being the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../548/19278548.xml">
Atlas</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 and <link xlink:type="simple" xlink:href="../693/332693.xml">
B5000</link>.</p>
<p>

<link xlink:type="simple" xlink:href="../630/46630.xml">
Embedded system</link>s and other special-purpose computer systems which require very fast, very consistent response time do not generally use virtual memory.</p>

<sec>
<st>
Implementation techniques</st>


<ss1>
<st>
Paged virtual memory</st>
<p>

Almost all implementations of virtual memory divide the <link xlink:type="simple" xlink:href="../423/934423.xml">
virtual address space</link> of an application program into <link xlink:type="simple" xlink:href="../911/11254911.xml">
page</link>s; a page is a block of contiguous virtual memory addresses.  Pages are usually at least 4K <link xlink:type="simple" xlink:href="../365/3365.xml">
byte</link>s in size, and systems with large virtual address ranges or large amounts of real memory (e.g. <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link>) generally use larger page sizes.</p>

<ss2>
<st>
Page tables</st>
<p>
 
Almost all implementations use <link xlink:type="simple" xlink:href="../962/674962.xml">
page table</link>s to translate the virtual addresses seen by the application program into <link xlink:type="simple" xlink:href="../118/5286118.xml">
physical address</link>es (also referred to as "real addresses") used by the hardware to process instructions. Each entry in a page table contains the starting virtual address of the page--either the real memory address at which the page is actually stored, or an indicator that the page is currently held in a disk file (if the system uses disk files to let applications use amounts of virtual memory which exceed real memory).</p>
<p>

Systems can have one page table for the whole system or a separate page table for each application. If there is only one, different applications which are <link xlink:type="simple" xlink:href="../857/6857.xml">
running at the same time</link> share a single virtual address space, i.e. they use different parts of a single range of virtual addresses. Systems which use multiple page tables provide multiple virtual address spaces - concurrent applications think they are using the same range of virtual addresses, but their separate page tables redirect to different real addresses.</p>

</ss2>
<ss2>
<st>
Paging</st>
<p>

<link>
Paging</link> is the process of saving inactive virtual memory pages to disk and restoring them to real memory when required.</p>
<p>

Most virtual memory systems enable programs to use virtual address ranges which in total exceed the amount of real memory (e.g. <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link>). To do this they use disk files to save virtual memory pages which are not currently active, and restore them to real memory when they are needed. Pages are not necessarily restored to the same real addresses from which they were saved - applications are aware only of virtual addresses. Usually when a page is going to be restored to real memory, the real memory already contains another virtual memory page which will be saved to disk before the restore takes place.</p>

</ss2>
<ss2>
<st>
Dynamic address translation</st>
<p>

When a <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> fetches an instruction located at a particular virtual address or, while executing an instruction, fetches data from a particular virtual address or stores data to a particular virtual address, the virtual address must be translated to the corresponding physical address.  This is done by a hardware component, sometimes called a <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link>, which looks up the real address (from the page table) corresponding to a virtual address and passes the real address to the parts of the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> which execute instructions. If the page tables indicate that the virtual memory page is not currently in real memory, the hardware raises a <link xlink:type="simple" xlink:href="../143/1157143.xml">
page fault</link>  <link xlink:type="simple" xlink:href="../101/396101.xml">
exception</link> (special internal signal) which invokes the paging supervisor component of the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> (see below).</p>

</ss2>
<ss2>
<st>
Paging supervisor</st>
<p>

This part of the operating system creates and manages the page tables. If the dynamic address translation hardware raises a page fault exception, the paging supervisor searches the page file(s) (on disk) for the page containing the required virtual address, reads it into real physical memory, updates the page tables to reflect the new location of the virtual address and finally tells the dynamic address translation mechanism to start the search again. Usually all of the real physical memory is already in use and the paging supervisor must first save an area of real physical memory to disk and update the page table to say that the associated virtual addresses are no longer in real physical memory but saved on disk. Paging supervisors generally save and overwrite areas of real physical memory which have been <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/727476.xml#xpointer(//*[./st=%22Least_recently_used%22])">
least recently used</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, because these are probably the areas which are used least often. So every time the dynamic address translation hardware matches a virtual address with a real physical memory address, it must put a time-stamp in the page table entry for that virtual address.</p>

</ss2>
<ss2>
<st>
Permanently resident pages</st>
<p>

All virtual memory systems have memory areas that are "pinned down", i.e. cannot be swapped out to secondary storage, for example:
<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../289/15289.xml">
Interrupt</link> mechanisms generally rely on an array of pointers to the handlers for various types of interrupt (<link xlink:type="simple" xlink:href="../558/14558.xml">
I/O</link> completion, <link xlink:type="simple" xlink:href="../016/530016.xml">
timer</link> event, program error, <link xlink:type="simple" xlink:href="../143/1157143.xml">
page fault</link>, etc.). If the pages containing these pointers or the code that they invoke were pageable, interrupt-handling would become even more complex and time-consuming; and it would be especially difficult in the case of page fault interrupts.</entry>
<entry level="1" type="bullet">

The page tables are usually not pageable.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../183/2406183.xml">
Data buffer</link>s that are accessed outside of the CPU, for example by peripheral devices that use <link xlink:type="simple" xlink:href="../717/57717.xml">
direct memory access</link> (DMA) or by <link xlink:type="simple" xlink:href="../370/2470370.xml">
I/O channel</link>s. Usually such devices and the <link>
 buses</link> (connection paths)  to which they are attached  use physical memory addresses rather than virtual memory addresses.  Even on buses with an <link xlink:type="simple" xlink:href="../181/5313181.xml">
IOMMU</link>, which is a special <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link> that can translate virtual addresses used on an I/O bus to physical addresses, the transfer cannot be stopped if a page fault occurs and then restarted when the page fault has been processed. So pages containing locations to which or from which a peripheral device is transferring data are either permanently pinned down or pinned down while the transfer is in progress.</entry>
<entry level="1" type="bullet">

Timing-dependent kernel/application areas cannot tolerate the varying response time caused by paging.</entry>
</list>
</p>

<ss3>
<st>
Virtual=real operatio</st>
<p>
=
In <link xlink:type="simple" xlink:href="../649/19649.xml">
MVS</link>, <link xlink:type="simple" xlink:href="../122/39122.xml">
z/OS</link>, and similar OSes, some parts of the systems memory are managed in virtual=real mode, where every virtual address corresponds to a real address. Those are: 
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link> mechanisms</entry>
<entry level="1" type="bullet">

 paging supervisor and page tables</entry>
<entry level="1" type="bullet">

 all <link xlink:type="simple" xlink:href="../183/2406183.xml">
data buffer</link>s accessed by <link xlink:type="simple" xlink:href="../370/2470370.xml">
I/O channel</link>s</entry>
<entry level="1" type="bullet">

 application programs which use non-standard methods of managing I/O and therefore provide their own buffers and communicate directly with peripherals (programs that create their own <link>
channel command word</link>s).</entry>
</list>
</p>
<p>

In IBM's early virtual memory operating systems virtual=real mode was the only way to "pin down" pages. z/OS has 3 modes, V=V (virtual=virtual; fully pageable), V=R and V=F (virtual = fixed, i.e. "pinned down" but with DAT operating).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</ss3>
</ss2>
</ss1>
<ss1>
<st>
Segmented virtual memory</st>
<p>

Some systems, such as the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../693/332693.xml">
Burroughs large systems</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
, do not use paging to implement virtual memory.  Instead, they use <link xlink:type="simple" xlink:href="../131/1323131.xml">
segmentation</link>, so that an application's virtual address space is divided into variable-length segments.  A virtual address consists of a segment number and an offset within the segment.</p>
<p>

Memory is still physically addressed with a single number (called <it>absolute</it> or <it>linear</it> address). To obtain it, the processor looks up the segment number in a segment table to find a segment descriptor.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>  The segment descriptor contains a flag indicating whether the segment is present in main memory and, if it is, the address in main memory of the beginning of the segment (segment's <it><link xlink:type="simple" xlink:href="../501/1698501.xml">
base</link></it> address) and the length of the segment.  It checks whether the offset within the segment is less than the length of the segment and, if it isn't, an interrupt is generated.  If a segment is not present in main memory, a hardware interrupt is raised to the operating system, which may try to read the segment into main memory, or to <it>swap in</it>.  The operating system might have to remove other segments (<it>swap out</it>) from main memory in order to make room in main memory for the segment to be read in.</p>
<p>

Notably, the <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../054/15054.xml">
Intel 80286</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 supported a similar segmentation scheme as an option, but it was unused by most operating systems.</p>
<p>

It is possible to combine segmentation and paging, usually dividing each segment into pages.  In systems that combine them, such as <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../847/18847.xml">
Multics</link></O>
 and the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<digital_computer wordnetid="103196324" confidence="0.8">
<minicomputer wordnetid="103770224" confidence="0.8">
<link xlink:type="simple" xlink:href="../646/294646.xml">
IBM System/38</link></minicomputer>
</digital_computer>
</machine>
</device>
</instrumentality>
</artifact>
</computer>
 and <link xlink:type="simple" xlink:href="../769/39769.xml">
IBM System i</link> machines, virtual memory is usually implemented with paging, with segmentation used to provide memory protection.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>  With the <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/15070.xml">
Intel 80386</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 and later <link xlink:type="simple" xlink:href="../046/15046.xml">
IA-32</link> processors, the segments reside in a <link xlink:type="simple" xlink:href="../733/80733.xml">
32-bit</link> linear paged address space, so segments can be moved into and out of that linear address space, and pages in that linear address space can be moved in and out of main memory, providing two levels of virtual memory; however, few if any operating systems do so.  Instead, they only use paging.</p>
<p>

The difference between virtual memory implementations using pages and using segments is not only about the memory division with fixed and variable sizes, respectively. In some systems, e.g. <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../847/18847.xml">
Multics</link></O>
, or later <link xlink:type="simple" xlink:href="../646/294646.xml">
System/38</link> and <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../542/905542.xml">
Prime</link></institution>
</company>
 machines, the segmentation was actually visible to the user processes, as part of the semantics of a memory model. In other words, instead of a process just having a memory which looked like a single large vector of bytes or words, it was more structured. This is different from using pages, which doesn't change the model visible to the process. This had important consequences. </p>
<p>

A segment wasn't just a "page with a variable length", or a simple way to lengthen the address space (as in <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../054/15054.xml">
Intel 80286</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
). In Multics, the segmentation was a very powerful mechanism that was used to provide a single-level virtual memory model, in which there was no differentiation between "process memory" and "file system" - a process' active address space consisted only a list of segments (files) which were mapped into its potential address space, both code and data. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
It is not the same as the later <link xlink:type="simple" xlink:href="../709/608709.xml">
mmap</link> function in Unix, because inter-file pointers don't work when mapping files into semi-arbitrary places. Multics had such addressing mode built into most instructions. In other words it could perform relocated inter-segment references, thus eliminating the need for a <link xlink:type="simple" xlink:href="../566/18566.xml">
linker</link> completely. This also worked when different processes mapped the same file into different places in their private address spaces.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</ss1>
</sec>
<sec>
<st>
Avoiding thrashing</st>
<p>

All implementations need to avoid a problem called "<link>
thrashing</link>", where the computer spends too much time shuffling blocks of virtual memory between real memory and disks, and therefore appears to work slower. Better design of application programs can help, but ultimately the only cure is to install more real memory. For more information see <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link>.</p>

</sec>
<sec>
<st>
History</st>
<p>

In the 1940s and 1950s, before the development of a virtual memory, all larger programs had to contain logic for managing two-level storage (primary and secondary, today's analogies being RAM and hard disk), such as <link xlink:type="simple" xlink:href="../764/5360764.xml">
overlaying</link> techniques. Programs were responsible for moving overlays back and forth from secondary storage to primary.</p>
<p>

The main reason for introducing virtual memory was therefore not simply to extend primary memory, but to make such an extension as easy to use for programmers as possible.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>
<p>

Many systems already had the ability to divide the memory between multiple programs (required for <link xlink:type="simple" xlink:href="../857/6857.xml">
multiprogramming</link> and <link xlink:type="simple" xlink:href="../857/6857.xml">
multiprocessing</link>), provided for example by "base and bounds registers" on early models of the <link xlink:type="simple" xlink:href="../628/23628.xml">
PDP-10</link>, without providing virtual memory.  That gave each application a private address space starting at an address of 0, with an address in the private address space being checked against a bounds register to make sure it's within the section of memory allocated to the application and, if it is, having the contents of the corresponding base register being added to it to give an address in main memory.  This is a simple form of <link xlink:type="simple" xlink:href="../131/1323131.xml">
segmentation</link> without virtual memory.</p>
<p>

Virtual memory was developed in approximately 1959–1962, at the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../266/83266.xml">
University of Manchester</link></university>
 for the <link xlink:type="simple" xlink:href="../548/19278548.xml">
Atlas Computer</link>, completed in 1962.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> However, <link>
 Fritz-Rudolf Güntsch</link>, one of Germany's pioneering computer scientists and later the developer of the <name wordnetid="106333653" confidence="0.8">
<company wordnetid="108058098" confidence="0.8">
<trade_name wordnetid="106845599" confidence="0.8">
<part wordnetid="113809207" confidence="0.8">
<electronics_company wordnetid="108003035" confidence="0.8">
<language_unit wordnetid="106284225" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../812/653812.xml">
Telefunken</link></institution>
</language_unit>
</electronics_company>
</part>
</trade_name>
</company>
</name>
 TR 440 mainframe, claims to have invented the concept in 1957 in his doctoral dissertation <it>Logischer Entwurf eines digitalen Rechengerätes mit mehreren asynchron laufenden Trommeln und automatischem Schnellspeicherbetrieb</it> (<it>Logic Concept of a Digital Computing Device with Multiple Asynchronous Drum Storage and Automatic Fast Memory Mode</it>).</p>
<p>

In 1961, <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../524/4524.xml">
Burroughs</link></institution>
</company>
 released the <link xlink:type="simple" xlink:href="../693/332693.xml">
B5000</link>, the first commercial computer with virtual memory.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> It used <link xlink:type="simple" xlink:href="../131/1323131.xml">
segmentation</link> rather than <link xlink:type="simple" xlink:href="../193/311193.xml">
paging</link>.</p>
<p>

Like many technologies in the history of computing, virtual memory was not accepted without challenge. Before it could be implemented in mainstream operating systems, many models, experiments, and theories had to be developed to overcome the numerous problems. Dynamic address translation required a specialized, expensive, and hard to build hardware, moreover initially it slightly slowed down the access to memory.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> There were also worries that new system-wide algorithms of utilizing secondary storage would be far less effective than previously used application-specific ones.</p>
<p>

By <link xlink:type="simple" xlink:href="../610/34610.xml">
1969</link> the debate over virtual memory for commercial computers was over.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> An <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 research team led by David Sayre showed that the virtual memory overlay system consistently worked better than the best manually controlled systems. </p>
<p>

Possibly the first <link xlink:type="simple" xlink:href="../272/20272.xml">
minicomputer</link> to introduce virtual memory was the Norwegian <link xlink:type="simple" xlink:href="../563/2706563.xml">
NORD-1</link>. During the 1970s, other minicomputers implemented virtual memory, notably <link xlink:type="simple" xlink:href="../517/32517.xml">
VAX</link> models running <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../736/32736.xml">
VMS</link></O>
.  </p>
<p>

Virtual memory was introduced to the x86 architecture with the <link xlink:type="simple" xlink:href="../596/167596.xml">
protected mode</link> of the <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../054/15054.xml">
Intel 80286</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 processor. At first it was done with <link>
segment swapping</link>, which became inefficient with larger segments. The <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/15070.xml">
Intel 80386</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 introduced support for paging underneath the existing <link xlink:type="simple" xlink:href="../131/1323131.xml">
segmentation</link> layer. The page fault exception could be chained with other exceptions without causing a <link xlink:type="simple" xlink:href="../233/1501233.xml">
double fault</link>.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Physical memory</link> and its <link xlink:type="simple" xlink:href="../118/5286118.xml">
physical address</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../018/568018.xml">
Memory address</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../144/507144.xml">
Address space</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../423/934423.xml">
Virtual address space</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../597/7597.xml">
CPU design</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../911/11254911.xml">
Page (computing)</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../962/674962.xml">
Page table</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../794/3007794.xml">
Working set</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../112/177112.xml">
Memory management unit</link></entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../281/954281.xml">
Cache algorithms</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="2" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/727476.xml">
Page replacement algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../131/1323131.xml">
Segmentation (memory)</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../646/294646.xml">
System/38</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../924/66924.xml">
Memory management</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../117/547117.xml">
Memory allocation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../596/167596.xml">
Protected mode</link>, a <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>'s name of virtual memory addressing</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
"<weblink xlink:type="simple" xlink:href="http://publib.boulder.ibm.com/infocenter/zoslnctr/v1r7/topic/com.ibm.zconcepts.doc/zconcepts.pdf">
z/OS Basic Skills Information Center: z/OS Concepts</weblink>".</entry>
<entry id="2">
 <cite style="font-style:normal" class="book"> <weblink xlink:type="simple" xlink:href="http://computer-refuge.org/bitsavers/pdf/burroughs/B5000_5500_5700/5000-21005_B5000_operChar.pdf">
The Operational Characteristics of the Processors for the Burroughs B5000</weblink>. Retrieved on <link>
2007-11-13</link>.</cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal" class="book">&#32;(<link xlink:type="simple" xlink:href="../655/34655.xml">
January 1968</link>) <weblink xlink:type="simple" xlink:href="http://computer-refuge.org/bitsavers/pdf/ge/GE-645/GE-645_SystemMan_Jan68.pdf">
GE-645 System Manual</weblink>,&#32;pp21-30. Retrieved on <link>
2007-11-13</link>.</cite>&nbsp;</entry>
<entry id="4">
<link>
F. J. Corbató</link>, <link xlink:type="simple" xlink:href="../955/974955.xml">
V. A. Vyssotsky</link>.&#32;"<weblink xlink:type="simple" xlink:href="http://www.multicians.org/fjcc1.html">
Introduction and Overview of the Multics System</weblink>".&#32;Retrieved on <link>
2007-11-13</link>.</entry>
<entry id="5">
E. L. Glaser, J. F. Couleur, G. A. Oliver.&#32;"<weblink xlink:type="simple" xlink:href="http://www.multicians.org/fjcc2.html">
System Design of a Computer for Time Sharing Applications</weblink>".</entry>
<entry id="6">
 <cite id="CITEREFBensoussanClingen1972" style="font-style:normal">Bensoussan, A.&#32;&amp;&#32;Clingen, C. T.&#32;(May 1972),&#32;"<weblink xlink:type="simple" xlink:href="http://www.multicians.org/multics-vm.html">
The Multics Virtual Memory: Concepts and Design</weblink>",&#32;<it>Communications of the ACM</it>&#32;<b>15</b>(5):  308–318, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F355602.361306">
10.1145/355602.361306</weblink>, </cite>&nbsp;</entry>
<entry id="7">
 <cite id="CITEREFOrganick1972" style="font-style:normal">Organick, E.I.&#32;(1972),&#32;<it>The Multics System: An Examination of Its Structure</it>, MIT Press</cite>&nbsp;</entry>
<entry id="8">
 <cite style="font-style:normal"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../772/974772.xml">
Denning, Peter</link></scientist>
&#32;(1997).&#32;"<weblink xlink:type="simple" xlink:href="http://cs.gmu.edu/cne/pjd/PUBS/bvm.pdf">
Before Memory Was Virtual</weblink>". <it>In the Beginning: Recollections of Software Pioneers</it>.</cite>&nbsp;</entry>
<entry id="9">
http://www.computer50.org/kgill/atlas/atlas.html Atlas design includes virtual memory</entry>
<entry id="10">
http://web.mac.com/joynerian/iWeb/Ian%20Joyner/Burroughs.html Ian Joyner on Burroughs B5000
</entry>
<entry id="11">
 <cite id="CITEREFCragon1996" style="font-style:normal">Cragon, Harvey G.&#32;(1996),&#32;<it><weblink xlink:type="simple" xlink:href="http://books.google.com/books?id=q2w3JSFD7l4C">
Memory Systems and Pipelined Processors</weblink></it>, Jones and Bartlett Publishers, pp. 113, ISBN 0867204745, </cite>&nbsp;</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 John L. Hennessy, David A. Patterson, <it>Computer Architecture, A Quantitative Approach</it> (ISBN 1-55860-724-2)</entry>
<entry level="1" type="bullet">

 Virtual Memory Secrets by Murali</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://linux-mm.org/">
Linux Memory Management</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://gnulinuxclub.org/index.php?option=com_content&amp;task=view&amp;id=161&amp;Itemid=32">
Linux Kernel Mailing List Discussion</weblink></entry>
<entry level="1" type="bullet">

Pointers to <weblink xlink:type="simple" xlink:href="http://web-cat.cs.vt.edu/AlgovizWiki/VirtualMemory">
virtual memory visualizations</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/ms810616.aspx">
The Virtual-Memory Manager in Windows NT</weblink></entry>
</list>

<it>This article was originally based on material from the <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<wordbook wordnetid="106418693" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<dictionary wordnetid="106418901" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/11324.xml">
Free On-line Dictionary of Computing</link></publication>
</reference_book>
</dictionary>
</book>
</wordbook>
</artifact>
</creation>
</product>
</work>
, which is  under the <link xlink:type="simple" xlink:href="../782/18938782.xml">
GFDL</link>.</it></p>


</sec>
</bdy>
</article>
