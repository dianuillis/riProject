<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:48:52[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Snapshot algorithm</title>
<id>331547</id>
<revision>
<id>194238863</id>
<timestamp>2008-02-26T20:06:58Z</timestamp>
<contributor>
<username>Andreas Kaufmann</username>
<id>72502</id>
</contributor>
</revision>
<categories>
<category>Distributed systems</category>
<category>Distributed algorithms</category>
</categories>
</header>
<bdy>

The <b>snapshot algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> used in <link xlink:type="simple" xlink:href="../501/8501.xml">
distributed systems</link> for recording a consistent global state of an <link xlink:type="simple" xlink:href="../ury/26th_century.xml">
asynchronous</link> system. It is also known as <b>Chandy-Lamport Algorithm for the determination of consistent global states</b>, after <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../671/195671.xml">
Leslie Lamport</link></scientist>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../678/9385678.xml">
K. Mani Chandy</link></employee>
</scientist>
</causal_agent>
</worker>
</person>
</physical_entity>
. 
<sec>
<st>
History</st>
<p>

According to <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/lamport/pubs/pubs.html#chandy">
Leslie Lamport's website</weblink>, “The distributed snapshot algorithm described here came about when I visited Chandy, who was then at the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../031/32031.xml">
University of Texas in Austin</link></university>
.  He posed the problem to me over dinner, but we had both had too much <link xlink:type="simple" xlink:href="../961/32961.xml">
wine</link> to think about it right then.  The next morning, in the shower, I came up with the solution.  When I arrived at Chandy's office, he was waiting for me with the same solution.”</p>
<p>

It was defined in a paper titled “<weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/lamport/pubs/chandy.pdf">
Distributed Snapshots: Determining Global States of a Distributed System</weblink>.”</p>

</sec>
<sec>
<st>
Definition</st>
<p>

The assumptions of the algorithm are as follows:
<list>
<entry level="1" type="bullet">

 There are no failures and all messages arrive intact and only once</entry>
<entry level="1" type="bullet">

 The communication channels are unidirectional and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/11347.xml">
FIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 ordered</entry>
<entry level="1" type="bullet">

 There is a communication path between any two processes in the system</entry>
<entry level="1" type="bullet">

 Any process may initiate the snapshot algorithm</entry>
<entry level="1" type="bullet">

 The snapshot algorithm does not interfere with the normal execution of the processes</entry>
<entry level="1" type="bullet">

 Each process in the system records its local state and the state of its incoming channels</entry>
</list>
</p>
<p>

The algorithm works using marker messages. Each process that wants to initiate a snapshot records its local state and sends a marker on each of its outgoing channels. All the other processes, upon receiving a marker, record their local state, the state of the channel from which the marker just came as empty, and send marker messages on all of their outgoing channels. If a process receives a marker after having recorded its local state, it records the state of the incoming channel from which the marker came as carrying all the messages received since it first recorded its local state.</p>
<p>

Some of the assumptions of the algorithm can be facilitated using a more reliable communication protocol such as <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/15476.xml">
TCP/IP</link></rule>
</direction>
</protocol>
</message>
. The algorithm can be adapted so that there could be multiple snapshots occurring simultaneously.</p>

</sec>
<sec>
<st>
Working</st>
<p>

The snapshot algorithm works like so:
<list>
<entry level="1" type="number">

 The observer process (the process taking a snapshot):</entry>
<entry level="2" type="number">

 Saves its own local state</entry>
<entry level="2" type="number">

 Sends a snapshot request message bearing a snapshot token to all other processes</entry>
<entry level="1" type="number">

 A process receiving the snapshot token <it>for the first time</it> on <it>any</it> message:</entry>
<entry level="2" type="number">

 Sends the observer process its own saved state</entry>
<entry level="2" type="number">

 Attaches the snapshot token to all subsequent messages (to help propagate the snapshot token)</entry>
<entry level="1" type="number">

 Should a process that has already received the snapshot token receive a message that does not bear the snapshot token, this process will forward that message to the observer process.  This message was obviously sent before the snapshot “cut off” (as it does not bear a snapshot token and thus must have come from before the snapshot token was sent out) and needs to be included in the snapshot.</entry>
</list>
</p>
<p>

From this, the observer builds up a complete snapshot: a saved state for each process and all messages “in the ether” are saved.</p>

</sec>
<sec>
<st>
References</st>

<p>

<weblink xlink:type="simple" xlink:href="http://www.lamport.org/">
Leslie Lamport's Website</weblink></p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</article>
