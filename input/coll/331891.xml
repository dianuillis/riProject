<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:48:55[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Peterson&apos;s algorithm</title>
<id>331891</id>
<revision>
<id>241837533</id>
<timestamp>2008-09-29T19:25:51Z</timestamp>
<contributor>
<username>Reelrt</username>
<id>2967211</id>
</contributor>
</revision>
<categories>
<category>Distributed systems</category>
<category>Concurrency control</category>
<category>Concurrent algorithms</category>
<category>Articles with example C code</category>
</categories>
</header>
<bdy>

<b>Peterson's algorithm</b> is a <link xlink:type="simple" xlink:href="../605/2581605.xml">
concurrent programming</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> that allows two processes to share a single-use resource without conflict, using only shared memory for communication. It was formulated by <link>
Gary Peterson</link> in <link xlink:type="simple" xlink:href="../776/34776.xml">
1981</link> at the <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../918/31918.xml">
University of Rochester</link></university>
. While Peterson's original formulation worked with only two processes, the algorithm can be generalised for more than two, as discussed in "Operating Systems Review, January 1990 ('Proof of a Mutual Exclusion Algorithm', M Hofri)".<sec>
<st>
 The algorithm </st>

<p>

flag[0]   = 0
flag[1]   = 0
turn      = 0</p>
<p>

P0: flag[0] = 1                        P1: flag[1] = 1
turn = 1                               turn = 0
<b>while</b>( flag[1] <b>&amp;&amp;</b> turn == 1 );         <b>while</b>( flag[0] <b>&amp;&amp;</b> turn == 0 );
// do nothing                          // do nothing
// critical section                    // critical section 
...                                    ...
// end of critical section             // end of critical section
flag[0] = 0                            flag[1] = 0</p>
<p>

The algorithm uses two variables, <it>flag</it> and <it>turn</it>. A flag value of 1 indicates that the 
process wants to enter the <link xlink:type="simple" xlink:href="../312/638312.xml">
critical section</link>. The variable turn holds the ID of the process 
whose turn it is. Entrance to the critical section is granted for process P0 if P1 does not 
want to enter its critical section or if P1 has given priority to P0 by setting turn to 0.</p>
<p>

The algorithm satisfies the three essential criteria of <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link>:
</p>
<ss1>
<st>
 Mutual exclusion </st>
<p>

P0 and P1 can never be in the critical section at the same time: If P0 is in its 
critical section, then flag[0] is 1 and either flag[1] is false or turn is 0. In both cases, P1 
cannot be in its critical section.</p>

</ss1>
<ss1>
<st>
 Progress requirement </st>
<p>

If process P0 does not want to enter its critical section, P1 can enter it without waiting. There is 
not strict alternating between P0 and P1.</p>

</ss1>
<ss1>
<st>
 Bounded waiting </st>
<p>

A process will not wait longer than one turn for entrance to the critical section: After giving 
priority to the other process, this process will run to completion and set its flag to 0, thereby 
allowing the other process to enter the critical section.</p>

</ss1>
</sec>
<sec>
<st>
 C implementation example using two POSIX threads </st>


<p>

/* Example code that simulates two sequences of bank transactions in parallel.
The critical section is the money transfer from one account to the other
(there may be no money disappearing or suddenly appearing).
<list>
<entry level="1" type="bullet">

/</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

volatile int flag[2];
volatile int turn;</p>
<p>

volatile int rich_guy = 30000;
volatile int poor_guy = 0;</p>
<p>

void prologue(int self)
{
flag[self] = 1;
turn = !self;
while (flag[!self] &amp;&amp; turn == !self);
}</p>
<p>

void epilogue(int self)
{
flag[self] = 0; 
}</p>
<p>

bool transfer_money()
{
int money;
money = rand() % (1000);
if (money &amp;gt; rich_guy) money = rich_guy;
printf("($%d)\n", money);
poor_guy += money; 
rich_guy -= money; 
return (rich_guy = 0);
}</p>
<p>

void *bank_transaction(void *x)
{
int id = (int)x;
bool done;
do {
prologue(id);
printf("Transaction %d will transfer money... ", id);
done = transfer_money();
epilogue(id);
} while (!done);</p>
<p>

return NULL;
}</p>
<p>

int main(void)
{
pthread_t transaction[2];
printf("Rich guy has $%d\n"
"Poor guy has $%d\n"
"Starting two parallel bank transfers...\n", rich_guy, poor_guy);
pthread_create(&amp;transaction[0], NULL, bank_transaction, (void *)0);
pthread_create(&amp;transaction[1], NULL, bank_transaction, (void *)1);</p>
<p>

puts("Waiting for transactions...");
pthread_join(transaction[0], NULL);
pthread_join(transaction[1], NULL);</p>
<p>

printf("Done.\n"
"Rich guy has $%d\n"
"Poor guy has $%d\n", rich_guy, poor_guy);</p>
<p>

return 0;
}</p>

</sec>
<sec>
<st>
Note</st>
<p>

When working at the hardware level, Peterson's algorithm is typically not needed to achieve atomic access. 
Some processors have special instructions, like <link xlink:type="simple" xlink:href="../099/394099.xml">
test-and-set</link> or <link xlink:type="simple" xlink:href="../224/632224.xml">
compare-and-swap</link> that, by locking the memory bus, can be used to provide mutual exclusion in <link xlink:type="simple" xlink:href="../318/50318.xml">
SMP</link> systems.</p>
<p>

Many modern CPUs reorder instruction execution and memory accesses to improve execution efficiency.  Such processors invariably give some way to force ordering in a stream of memory accesses, typically through a <link xlink:type="simple" xlink:href="../216/728216.xml">
memory barrier</link> instruction.  Implementation of Peterson's and related algorithms on an <link xlink:type="simple" xlink:href="../307/1002307.xml">
out-of-order</link> processor generally require use of such operations to work correctly to keep sequential operations from happening in an incorrect order.</p>
<p>

Most such CPU's also have some sort of guaranteed <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic operation</link>, such as XCHG on <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> processors and <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/2882985.xml">
Load-Link/Store-Conditional</link></concept>
</idea>
 on <link xlink:type="simple" xlink:href="../971/8971.xml">
Alpha</link>, <link xlink:type="simple" xlink:href="../170/20170.xml">
MIPS</link>, <link xlink:type="simple" xlink:href="../281/24281.xml">
PowerPC</link>, and other architectures.  These instructions are intended to provide a way to build synchronization primitives more efficiently than can be done with pure shared memory approaches.</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://paul.luminos.nl/documents/show_document.php?d=339">
Java implementation of Peterson's algorithm</weblink>, including documentation and source code</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../826/36826.xml">
Dekker's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../076/2176076.xml">
Lamport's bakery algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</article>
