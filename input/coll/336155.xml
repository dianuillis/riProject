<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:50:47[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Skip list</title>
<id>336155</id>
<revision>
<id>241587242</id>
<timestamp>2008-09-28T18:56:09Z</timestamp>
<contributor>
<username>Wojciech mula</username>
<id>7361352</id>
</contributor>
</revision>
<categories>
<category>Linked lists</category>
<category>Data structures</category>
</categories>
</header>
<bdy>

Invented in 1990 by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../645/1910645.xml">
William Pugh</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
, a <b>skip list</b> is a probabilistic <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link>, based on multiple parallel, sorted <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link>s, with <link xlink:type="simple" xlink:href="../128/145128.xml">
efficiency</link> comparable to a <link xlink:type="simple" xlink:href="../320/4320.xml">
binary search tree</link> (order log <it>n</it> average time for most operations).<p>

Underlying the skip list is an augmentation of an ordered <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link> with additional forward links, added in a <link xlink:type="simple" xlink:href="../462/65462.xml">
randomized</link> way with a geometric/negative <link xlink:type="simple" xlink:href="../876/3876.xml">
binomial distribution</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, so that a search in the list may quickly skip parts of the list (hence the name). Insert, search and delete operations are performed in logarithmic randomized time.</p>

<sec>
<st>
 Description </st>

<p>

A skip list is built in layers.  The bottom layer is an ordinary ordered <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link>.  Each higher layer acts as an "<link xlink:type="simple" xlink:href="../991/6150991.xml">
express lane</link>" for the lists below, where an element in layer <it>i</it> appears in layer <it>i</it>+1 with some fixed probability <it>p</it> (two commonly-used values for <it>p</it> are 1/2 or 1/4).  On average, each element appears in 1/(1-<it>p</it>) lists, and the tallest element (usually a special head element at the front of the skip list) in <math>\log_{1/p} n\,</math> lists.</p>
<p>

<image location="center" width="150px" src="Skip_list.svg" type="frame">
</image>
</p>
<p>

A search for a target element is started with the head element in the top list, and proceeds horizontally until the current element is greater than or equal to the target. If the current element is equal to the target, it has been found. If the current element is greater than the target, go back to the previous element and drop down vertically to the next lower list and repeat the procedure.  The expected number of steps in each linked list is easily seen to be 1/<it>p</it>, by tracing the search path backwards from the target until reaching an element that appears in the next higher list.  So the total <it>expected</it> cost of a search is <math>(\log_{1/p} n)/p,\,</math> which is <math>\mathcal{O}(\log n)\,</math> when <it>p</it> is a constant.  By choosing different values of <it>p</it>, it is possible to trade search costs against storage costs.</p>

<ss1>
<st>
 Implementation Details </st>

<p>

Although the above diagram is drawn as several, separate linked lists with some repeated node values--implying a total of 1+3+5+10 = 19 total nodes, in practice one would not implement a skip list this way because of the "drop down vertically" step. In fact there are only 10 total nodes in the diagram, but several of them contain more than one pointer.</p>
<p>

Insertions and deletions are implemented much like the corresponding linked-list operations, except that "tall" elements must be inserted into or deleted from more than one linked list.</p>
<p>

Θ(n) operations, which force us to visit every node in ascending order (such as printing the entire list) provide the opportunity to perform a behind-the-scenes derandomization of the level structure of the skip-list in an optimal way, bringing the skip list to <math>\mathcal{O}(\log n)</math> search time (Choose the level of the i'th finite node to be 1 plus the number of times we can repeatedly divide i by 2 before it becomes odd.  Also, i=0 for the negative infinity header as we have the usual special case of choosing the highest possible level for negative and/or positive infinite nodes.). However this also allows someone to know where all of the higher-than-level 1 nodes are and delete them. </p>
<p>

Alternatively, we could make the level structure quasi-random in the following way: </p>
<p>

make all nodes level 1
j = 1
while the number of nodes at level j &amp;gt; 1
for each i'th node at level j
if i is odd 
if i is not the last node at level j
randomly choose whether to promote it to level j+1
else
do not promote
end if
else if i is even and node i-1 was not promoted
promote it to level j+1
end if
end for
j = j + 1
end while</p>
<p>

Like the derandomized version, quasi-randomization is only done when there is some other reason to be running a Θ(n) operation (which visits every node). </p>
<p>

The advantage of this quasi-randomness is that it doesn't give away nearly as much level-structure related information to an <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../634/8198634.xml">
adversarial user</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 as the de-randomized one.  This is desirable because an adversarial user who is able to tell which nodes are not at the lowest level can pessimize performance by simply deleting higher-level nodes. The search performance is still guaranteed to be logarithmic.</p>
<p>

It would be tempting to make the following "optimization":  In the part which says "Next, for each i'th...", forget about doing a coin-flip for each even-odd pair.  Just flip a coin once to decide whether to promote only the even ones or only the odd ones.  Instead of Θ(n lg n) coin flips, there would only be Θ(lg n) of them.  Unfortunately, this gives the adversarial user a 50/50 chance of being correct upon guessing that all of the even numbered nodes (among the ones at level 1 or higher) are higher than level one.  This is despite the property that he has a very low probability of guessing that a particular node is at level N for some integer N.</p>

<p>

The following proves these two claims concerning the advantages of quasi-randomness over the totally derandomized version.  First, to prove that the search time is guaranteed to be logarithmic.  Suppose a node n is searched for, where n is the position of the found node among the nodes of level 1 or higher.  If n is even, then there is a 50/50 chance that it is higher than level 1.  However, if it is not higher than level 1 then node n-1 is guaranteed to be higher than level 1.  If n is odd, then there is a 50/50 chance that it is higher than level 1.  Suppose that it is not; there is a 50/50 chance that node n-1 is higher than level 1.  Suppose that this is not either; we are guaranteed that node n-2 is higher than level 1.  The analysis can then be repeated for nodes of level 2 or higher, level 3 or higher, etc. always keeping in mind that n is the position of the node among the ones of level k or higher for integer k.  So the search time is constant in the best case (if the found node is the highest possible level) and 2 times the worst case for the search time for the totally derandomized skip-list (because we have to keep moving left twice rather than keep moving left once).</p>
<p>

Next, an examination of the probability of an adversarial user's guess of a node being level k or higher being correct.  First, the adversarial user has a 50/50 chance of correctly guessing that a particular node is level 2 or higher.  This event is independent of whether or not the user correctly guesses at some other node being level 2 or higher.  If the user knows the positions of two consecutive nodes of level 2 or higher, and knows that the one on the left is in an odd numbered position among the nodes of level 2 or higher, the user has a 50/50 chance of correctly guessing which one is of level 3 or higher.  So, the user's probability of being correct, when guessing that a node is level 3 or higher, is 1/4.  Inductively continuing this analysis, we see that the user's probability of guessing that a particular node is level k or higher is 1/(2^(k-1)).</p>
<p>

The above analyses only work when the number of nodes is a power of two.  However, because of the third rule which says, "Finally, if i is odd and also the last node at level 1 then do not promote." (where we substitute the appropriate level number for 1) it becomes a sequence of exact-power-of-two-sized skiplists, concatenated onto each other, for which the analysis does work.  In fact, the exact powers of two correspond to the binary representation for the number of nodes in the whole list.</p>
<p>

A skip list, upon which we have not recently performed either of the above mentioned Θ(n) operations, does not provide the same absolute worst-case performance guarantees as more traditional <link xlink:type="simple" xlink:href="../310/378310.xml">
balanced tree</link> data structures, because it is always possible (though with very low probability) that the coin-flips used to build the skip list will produce a badly balanced structure.  However, they work well in practice, and the randomized balancing scheme has been argued to be easier to implement than the deterministic balancing schemes used in balanced binary search trees.  Skip lists are also useful in <link xlink:type="simple" xlink:href="../162/145162.xml">
parallel computing</link>, where insertions can be done in different parts of the skip list in parallel without any global rebalancing of the data structure. Such parallelism can be especially advantageous for resource discovery in an ad-hoc <link xlink:type="simple" xlink:href="../172/33172.xml">
Wireless network</link> because a randomized skip list can be made robust to the loss of any single node<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>..</p>
<p>

There has been some evidence that skip lists have worse real-world performance and space requirements than <link xlink:type="simple" xlink:href="../674/4674.xml">
B tree</link>s due to <link>
memory locality</link> and other issues <weblink xlink:type="simple" xlink:href="http://resnet.uoregon.edu/~gurney_j/jmpc/skiplist.html">
http://resnet.uoregon.edu/~gurney_j/jmpc/skiplist.html</weblink>.</p>

</ss1>
</sec>
<sec>
<st>
History</st>

<p>

Skip lists were invented by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../645/1910645.xml">
William Pugh</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
. He details how they work in <it>Skip lists: a probabilistic alternative to balanced trees</it> in <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/291161.xml">
Communications of the ACM</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
, June 1990, 33(6) 668-676.
See also <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/pugh90skip.html">
citations</weblink> and <weblink xlink:type="simple" xlink:href="ftp://ftp.cs.umd.edu/pub/skipLists/">
downloadable documents</weblink>.</p>
<p>

To quote the inventor:</p>
<p>

<indent level="1">

<it>Skip lists are a probabilistic data structure that seem likely to supplant balanced trees as the implementation method of choice for many applications. Skip list algorithms have the same asymptotic expected time bounds as balanced trees and are simpler, faster and use less space.</it>
</indent>

</p>
</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Pugh, William&#32;(June 1990).&#32;"Skip lists: a probabilistic alternative to balanced trees". <it>Communications of the ACM</it>&#32;<b>33</b>&#32;(6): 668–676. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F78973.78977">
10.1145/78973.78977</weblink>.</cite>&nbsp;</entry>
<entry id="2">
Shah, Gauri Ph.D.;&#32;James Aspnes&#32;(December 2003).&#32;"<it><weblink xlink:type="simple" xlink:href="http://www.cs.yale.edu/homes/shah/pubs/thesis.pdf">
Distributed Data Structures for Peer-to-Peer Systems</weblink></it>"&#32;(PDF). &#32;Retrieved on <link>
2008-09-23</link>.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link>
Deterministic skip list</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://people.ksp.sk/~kuko/bak/index.html">
Skip List Applet</weblink> by Kubo Kovac</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.sccnet.com.br/jackson/SkipList/index.php?link=implementacao">
Skip List Applet - Portuguese</weblink> by Jackson Porciúncula (very good)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://nist.gov/dads/HTML/skiplist.html">
Skip list description</weblink> from the <link xlink:type="simple" xlink:href="../551/1661551.xml">
Dictionary of Algorithms and Data Structures</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.codeproject.com/csharp/SkipList1.asp">
A Skip List in C#</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://dekorte.com/projects/opensource/SkipDB/">
SkipDB, a BerkeleyDB-style database implemented using skip lists.</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf">
William Pugh's original paper</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://iamwww.unibe.ch/~wenger/DA/SkipList/">
Thomas Wenger's demo applet on skiplists</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.mu.oz.au/aia/SkipList.html">
A Java Applet that emphasizes more on visualizing the steps of the algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://ocw.mit.edu/ans7870/6/6.046j/f05/lecturenotes/ocw-6.046-26oct2005.mp3">
Prof. Erik Demaine's lecture on skip lists</weblink> from MIT's OpenCourseWare program. (Audio)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ConcurrentSkipListSet.html">
Java 6 ConcurrentSkipListSet</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://infohost.nmt.edu/tcc/help/lang/python/examples/pyskip/">
John Shipman's didactic zero-defect implementation in Python</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/en-us/library/ms379573.aspx">
An Extensive Examination of Data Structures Using C# 2.0: Building a Better Binary Search Tree</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.codersource.net/csharp_skip_list.aspx">
C# Skip List: A Simpler Alternative to Binary Trees?</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
