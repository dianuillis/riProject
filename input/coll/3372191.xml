<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:22:44[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>GLR parser</title>
<id>3372191</id>
<revision>
<id>244119368</id>
<timestamp>2008-10-09T12:54:01Z</timestamp>
<contributor>
<username>Simon123</username>
<id>535923</id>
</contributor>
</revision>
<categories>
<category>Parsing algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>GLR parser</b> ("Generalized Left-to-right Rightmost derivation parser") is an extension of an <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 algorithm to handle <link xlink:type="simple" xlink:href="../198/452198.xml">
nondeterministic</link> and <link xlink:type="simple" xlink:href="../729/647729.xml">
ambiguous grammars</link>.  First described in a 1986 paper by <link xlink:type="simple" xlink:href="../334/6763334.xml">
Masaru Tomita</link>, it has also been referred to as a "parallel parser".<p>

Though the algorithm has evolved since its original form, the principles have remained intact: Tomita's goal was to parse <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link> text thoroughly and efficiently.  Standard <link xlink:type="simple" xlink:href="../030/18030.xml">
LR parsers</link> cannot accommodate the <link xlink:type="simple" xlink:href="../198/452198.xml">
nondeterministic</link> and ambiguous nature of <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link>, and the GLR algorithm can.</p>

<sec>
<st>
 Algorithm </st>

<p>

Briefly, the GLR algorithm works in a manner similar to the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 algorithm, except that, given a particular grammar, a GLR parser will process all possible interpretations of a given input in a <link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link>. On the front-end, a GLR <link xlink:type="simple" xlink:href="../097/70097.xml">
parser generator</link> converts an input grammar into parser tables, in a manner similar to an LR generator.  However, where LR parse tables allow for only one <link xlink:type="simple" xlink:href="../857/548857.xml">
state transition</link> (given a state and an input token), GLR parse tables allow for multiple transitions. In effect, GLR allows for shift/reduce and reduce/reduce conflicts.</p>
<p>

When a conflicting transition is encountered, the parse stack is forked into two or more parallel parse stacks, where the state corresponding to each possible transition is at the top.  Then, the next input token is read and used to determine the next transition(s) for each of the "top" states -- and further forking can occur.  If any given top state and input token do not result in at least one transition, then that "path" through the parse tables is invalid and can be discarded.</p>
<p>

A crucial optimization allows sharing of common prefixes and suffixes of these stacks, which constrains the overall <link xlink:type="simple" xlink:href="../707/389707.xml">
search space</link> and memory usage required to parse input text.  The complex structures that arise from this improvement make the stack more like a lattice of nodes.</p>

</sec>
<sec>
<st>
 Advantages </st>

<p>

When implemented carefully, the GLR algorithm has the same time complexity as the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/53929.xml">
CYK algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and <link xlink:type="simple" xlink:href="../685/9685.xml">
Earley algorithm</link> -- <it>O</it>(<it>n</it>3).  However, GLR carries two additional advantages:</p>
<p>

<list>
<entry level="1" type="bullet">

 The time required to run the algorithm is proportional to the degree of nondeterminism in the grammar -- on deterministic grammars the GLR algorithm runs in <it>O</it>(<it>n</it>) time (this is not true of the Earley and CYK algorithms)</entry>
<entry level="1" type="bullet">

 The GLR algorithm is "on-line" -- that is, it consumes the input tokens in a specific order and performs as much work as possible after consuming each token.</entry>
</list>
</p>
<p>

In practice, most programming languages are deterministic or "nearly deterministic," meaning that any nondeterminism is usually resolved within a small (though possibly unbounded) number of tokens.  Compared to other algorithms capable of handling the full class of context-free grammars (such as Earley or CYK), the GLR algorithm gives better performance on these "nearly deterministic" grammars, because only a single stack will be active during the majority of the parsing process.</p>

</sec>
<sec>
<st>
 Implementations </st>

<p>

The freely available <weblink xlink:type="simple" xlink:href="http://dparser.sourceforge.net/">
dparser</weblink>, the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../880/14190880.xml">
Scannerless Boolean Parser</link></software>
, the <link xlink:type="simple" xlink:href="../154/12235154.xml">
ASF+SDF</link> framework, and <link xlink:type="simple" xlink:href="../189/53189.xml">
GNU Bison</link> support GLR parser generation.</p>




</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
