<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:20:08[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Automata-based programming</title>
<id>3377755</id>
<revision>
<id>239440946</id>
<timestamp>2008-09-19T02:15:54Z</timestamp>
<contributor>
<username>McSly</username>
<id>2576398</id>
</contributor>
</revision>
<categories>
<category> programming paradigms</category>
</categories>
</header>
<bdy>

For other uses, see <link xlink:type="simple" xlink:href="../023/16352023.xml">
Automata-based programming (Shalyto's approach)</link>.<p>

<b>Automata-based programming</b> is a <link xlink:type="simple" xlink:href="../897/189897.xml">
programming paradigm</link> in which the program or its part is thought of as a model of a <link xlink:type="simple" xlink:href="../931/10931.xml">
finite state machine</link> or any other (often more complicated) formal automata (see <link xlink:type="simple" xlink:href="../356/103356.xml">
automata theory</link>). Sometimes a potentially-infinite set of possible states is introduced, and such a set can have a complicated structure, not just an enumeration.</p>
<p>

<b>FSM-based programming</b> is generally the same, but, formally speaking, doesn't cover all possible variants as FSM stands for <link xlink:type="simple" xlink:href="../931/10931.xml">
finite state machine</link> and <b>automata-based programming</b> doesn't necessarily employ FSMs in the strict sense.</p>
<p>

The following properties are key indicators for automata-based programming:
<list>
<entry level="1" type="number">

 The time period of the program's execution is clearly separated down to the <it>steps of the automaton</it>. Each of the <it>steps</it> is effectively an execution of a code section (same for all the steps), which has a single entry point. Such a section can be a function or other routine, or just a cycle body. The step section might be divided down to subsection to be executed depending on different states, although this is not necessary.</entry>
<entry level="1" type="number">

 Any communication between the steps is only possible via the explicitly noted set of variables named <it>the state</it>. Between any two steps, the program (or its part created using the automata-based technique) can <b>not</b> have implicit components of its state, such as local (stack) variables' values, return addresses, the current instruction pointer etc. That is, the state of the whole program, taken at any two moments of entering the step of the automaton, can only differ in the values of the variables being considered as the state of the automaton. </entry>
</list>
</p>
<p>

The whole execution of the automata-based code is a (possibly explicit) cycle of the automaton's steps.</p>
<p>

Another reason to use the notion of <b>automata-based programming</b> is that the programmer's style of thinking about the program in this technique is very similar to the style of thinking used to solve maths-related tasks using <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
, <link xlink:type="simple" xlink:href="../156/198156.xml">
Markov algorithm</link> etc.</p>

<sec>
<st>
 Example </st>

<p>

Consider we need a program in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 that reads a text from <it>standard input stream</it>, line by line, and prints the first word of each line. It is clear we need first to read and skip the leading spaces, if any, then read characters of the first word and print them until the word ends, and then read and skip all the remaining characters until the end-of-line character is encountered. Upon the end of line character (regardless of the stage) we restart the algorithm from the beginning, and in case the <it>end of file</it> condition (regardless of the stage) we terminate the program.</p>

<ss1>
<st>
 Traditional (imperative) program </st>

<p>

The program which solves the example task in traditional (imperative) style can look something like this:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

int main()
{
int c;
do {
c = getchar();
while(c == ' ')
c = getchar();
while(c != EOF &amp;&amp; c != ' ' &amp;&amp; c != '\n') {
putchar(c);
c = getchar();
}
putchar('\n');
while(c != EOF &amp;&amp; c != '\n')
c = getchar();
} while(c != EOF);
return 0;
}</p>


</ss1>
<ss1>
<st>
 Automata-based style program </st>

<p>

The same task can be solved thinking in terms of finite state machines. Please note that line parsing has three stages: skipping the leading spaces, printing the word and skipping the trailing characters. Let's call them <b>states</b> before, inside and after. The program may now look like this:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

int main()
{
enum states {
before, inside, after
} state;
int c;
state = before;
while((c = getchar()) != EOF) {
switch(state) {
case before:
if(c == '\n') {
putchar('\n');
} else
if(c != ' ') {
putchar(c);
state = inside;
}
break;
case inside:
switch(c) {
case ' ':  state = after; break;
case '\n':
putchar('\n');
state = before;
break;
default:   putchar(c);
}
break;
case after:
if(c == '\n') {
putchar('\n');
state = before;
}
}
}
return 0;
}</p>
<p>

Although the code now looks longer, it has at least one significant advantage: there's only one <it>reading</it> (that is, call to the getchar() function) instruction in the program. Besides that, there's only one while loop instead of the four the previous version had.</p>
<p>

In this program, the body of the while loop is the <b>automaton step</b>, and the loop itself is the <it>cycle of the automaton's work</it>.</p>
<p>

<image location="right" width="150px" src="Automata_that_prints_the_first_word_of_each_line.png">
<caption>

Automaton's diagram
</caption>
</image>

The program implements (models) the work of a <it>finite state machine</it> shown on the picture. The <b>N</b> denotes the end of line character, the <b>S</b> denotes spaces, and the <b>A</b> stands for all the other characters. The automaton follows exactly one <it>arrow</it> on each step depending on the current state and the encountered character. Some state switches are accompanied with printing the character; such arrows are marked with asterisks.</p>
<p>

It is not absolutely necessary to divide the code down to separate handlers for each unique state. Furthermore, in some cases the very notion of the <it>state</it> can be composed of several variables' values, so that it could be impossible to handle each possible state explicitly. In the discussed program it is possible to reduce the code length noticing that the actions taken in response to the end of line character are the same for all the possible states. The following program is equal to the previous one but is a bit shorter:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

int main()
{
enum states {
before, inside, after
} state;
int c;
state = before;
while((c = getchar()) != EOF) {
if(c == '\n') {
putchar('\n');
state = before;
} else
switch(state) {
case before:
if(c != ' ') {
putchar(c);
state = inside;
}
break;
case inside:
if(c == ' ') {
state = after;
} else {
putchar(c);
}
break;
case after:
break;
}
}
return 0;
}</p>


</ss1>
<ss1>
<st>
 A separate function for the automaton step </st>

<p>

The most important property of the previous program is that the automaton step code section is clearly localized. It is possible to demonstrate this property even better if we provide a separate function for it:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

enum states { before, inside, after };
void step(enum states *state, int c)
{
if(c == '\n') {
putchar('\n');
<list>
<entry level="1" type="bullet">

state = before;</entry>
</list>

} else
switch(*state) {
case before:
if(c != ' ') {
putchar(c);
<list>
<entry level="1" type="bullet">

state = inside;</entry>
</list>

}
break;
case inside:
if(c == ' ') {
<list>
<entry level="1" type="bullet">

state = after;</entry>
</list>

} else {
putchar(c);
}
break;
case after:
break;
}
} 
int main()
{
int c;
enum states state = before;
while((c = getchar()) != EOF) {
step(&amp;state, c);
}
return 0;
}</p>
<p>

This example clearly demonstrates the basic properties of automata-based code:
<list>
<entry level="1" type="number">

 time periods of automaton step executions may not overlap</entry>
<entry level="1" type="number">

 the only information passed from the previous step to the next is the explicitly specified <it>automaton state''</it></entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Explicit <link xlink:type="simple" xlink:href="../857/548857.xml">
state transition table</link> </st>

<p>

A finite automaton can be defined by an explicit <link xlink:type="simple" xlink:href="../857/548857.xml">
state transition table</link>. Generally speaking, an automata-based program code can naturally reflect this approach. In the program below there's an array named the_table, which defines the table. The rows of the table stand for three <it>states</it>, while columns reflect the input characters (first for spaces, second for the end of line character, and the last is for all the other characters).</p>
<p>

For every possible combination, the table contains the new state number and the flag, which determines whether the automaton must print the symbol. In a real life task, this could be more complicated; e.g., the table could contain pointers to functions to be called on every possible combination of conditions.</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

enum states { before = 0, inside = 1, after = 2 };
struct branch {
enum states new_state:2;
int should_putchar:1;
};
struct branch the_table[3][3] = {
/* ' '         '\n'        others */
/* before */ { {before,0}, {before,1}, {inside,1} },
/* inside */ { {after, 0}, {before,1}, {inside,1} },
/* after  */ { {after, 0}, {before,1}, {after, 0} }
};
void step(enum states *state, int c)
{
int idx2 = (c == ' ') ? 0 : (c == '\n') ? 1 : 2;
struct branch *b = &amp; the_table[*state][idx2];
<list>
<entry level="1" type="bullet">

state = b-&amp;gt;new_state;</entry>
</list>

if(b-&amp;gt;should_putchar) putchar(c);
}
int main()
{
int c;
enum states state = before;
while((c = getchar()) != EOF)
step(&amp;state, c);
return 0;
}</p>


</ss1>
<ss1>
<st>
 Using <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented</link> capabilities </st>

<p>

If the implementation language supports <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented programming</link>, it is reasonable to <link xlink:type="simple" xlink:href="../301/10301.xml">
encapsulate</link> the automaton into an object, thus hiding implementation details from the outer program. for example, the same program in C++ can look like this:</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
</list>

class StateMachine {
enum states { before = 0, inside = 1, after = 2 } state;
struct branch {
enum states new_state:2;
int should_putchar:1;
};
static struct branch the_table[3][3];
public:
StateMachine() : state(before) {}
void FeedChar(int c) {
int idx2 = (c == ' ') ? 0 : (c == '\n') ? 1 : 2;
struct branch *b = &amp; the_table[state][idx2];
state = b-&amp;gt;new_state;
if(b-&amp;gt;should_putchar) putchar(c);
}
};
struct StateMachine::branch StateMachine::the_table[3][3] = {
/* ' '         '\n'        others */
/* before */ { {before,0}, {before,1}, {inside,1} },
/* inside */ { {after, 0}, {before,1}, {inside,1} },
/* after  */ { {after, 0}, {before,1}, {after, 0} }
};
int main()
{
int c;
StateMachine machine;
while((c = getchar()) != EOF)
machine.FeedChar(c);
return 0;
}</p>
<p>

Please note we have intentionally used the input/output functions from the standard library of <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 to minimize changes not directly related to the subject of the article.</p>

</ss1>
</sec>
<sec>
<st>
 Applications </st>

<p>

Automata-based programming is widely used in <link xlink:type="simple" xlink:href="../251/81251.xml">
lexical</link> and <link xlink:type="simple" xlink:href="../015/310015.xml">
syntactic analyses</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

Besides that, thinking in terms of automata (that is, breaking the execution process down to <it>automaton steps</it> and passing information from step to step through the explicit <it>state</it>) is necessary for <link xlink:type="simple" xlink:href="../599/62599.xml">
event-driven programming</link> as the only alternative to using parallel processes or threads.</p>
<p>

The notions of states and state machines are often used in the field of <link xlink:type="simple" xlink:href="../707/2567707.xml">
formal specification</link>. For instance, <link xlink:type="simple" xlink:href="../169/32169.xml">
UML</link>-based software architecture development uses <link xlink:type="simple" xlink:href="../337/187337.xml#xpointer(//*[./st=%22UML+state+diagram%22])">
state diagrams</link> to specify the behaviour of the program. Also various <link xlink:type="simple" xlink:href="../235/83235.xml">
communication protocols</link> are often specified using the explicit notion of <it>state</it> (see, e.g., RFC 793<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>).</p>
<p>

Thinking in terms of automata (steps and states) can also be used to describe semantics of some <link xlink:type="simple" xlink:href="../015/23015.xml">
programming languages</link>. For example, the execution of a programm written in the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../151/14926151.xml">
Refal</link></programming_language>
 language is described as a sequence of <it>steps</it> of a so-called abstract Refal machine; the state of the machine is a <it>view</it> (an arbitrary Refal expression without variables).</p>
<p>

<link xlink:type="simple" xlink:href="../189/505189.xml">
Continuations</link> in the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
 language require thinking in terms of steps and states, although Scheme itself is in no way automata-related (it is recursive). To make it possible the <link xlink:type="simple" xlink:href="../182/1064182.xml">
call/cc</link> feature to work, implementation needs to be able to catch a whole state of the executing program, which is only possible when there's no implicit part in the state. Such a <it>caught state</it> is the very thing called <it>continuation</it>, and it can be considered as the <it>state</it> of a (relatively complicated) automaton. The step of the automaton is deducing the next continuation from the previous one, and the execution process is the cycle of such steps.</p>
<p>

Alexander Ollongren in his book<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> explains the so-called <it>Vienna method</it> of programming languages semantics description which is fully based on formal automata.</p>
<p>

The STAT system <weblink xlink:type="simple" xlink:href="http://www.cs.ucsb.edu/~seclab/projects/stat/index.html">
http://www.cs.ucsb.edu/~seclab/projects/stat/index.html</weblink> is a good example of using the automata-based approach; this system, besides other features, includes an embedded language called <it>STATL</it> which is purely automata-oriented.</p>

</sec>
<sec>
<st>
 History </st>

<p>

Automata-based techniques were used widely in the domains where there are algorithms based on automata theory, such as formal language analyses.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

One of the early papers on this is by Johnson et al, 1968.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>
<p>

One of the earliest mentions of automata-based programming as a general technique is found in the paper by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/58731.xml">
Peter Naur</link></scientist>
</person>
, 1963.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> The author calls the technique <it>Turing machine approach</it>, however no real <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 is given in the paper; instead, the technique based on states and steps is described.</p>

</sec>
<sec>
<st>
 Compared against imperative and procedural programming </st>

<p>

The notion of <link xlink:type="simple" xlink:href="../512/285512.xml">
state</link> is not exclusive property of automata-based programming. Generally speaking, <it>state</it> (or <link xlink:type="simple" xlink:href="../720/2760720.xml">
program state</link>) appears during execution of any <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>, as a combination of all information that can change during the execution. For instance, a <it>state</it> of a traditional <link xlink:type="simple" xlink:href="../847/197847.xml">
imperative</link> program consists of
<list>
<entry level="1" type="number">

 values of all variables and the information stored within dynamic memory</entry>
<entry level="1" type="number">

 values stored in registers</entry>
<entry level="1" type="number">

 stack contents (including local variables' values and return addresses)</entry>
<entry level="1" type="number">

 current value of the instruction pointer</entry>
</list>
</p>
<p>

These can be divided to the <b>explicit</b> part (such as values stored in variables) and the <b>implicit</b> part (return addresses and the instruction pointer).</p>
<p>

Having said this, an automata-based program can be considered as a special case of an imperative program, in which implicit part of the state is minimized. The state of the whole program taken at the two distinct moments of entering the <it>step</it> code section can differ in the automaton state only. This simplifies the analysis of the program.</p>

</sec>
<sec>
<st>
 Object-oriented programming relationship </st>

<p>

In the theory of <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented programming</link> an <b>object</b> is said to have an internal <it>state</it> and is capable of <it>receiving messages</it>, <it>responding</it> to them, <it>sending</it> messages to other objects and changing the internal state during message handling. In more practical terminology, <it>to call an object's method</it> is considered the same as <it>to send a message to the object</it>.</p>
<p>

Thus, from one hand, objects from object-oriented programming can be considered as automata (or models of automata) whose <it>state</it> is the combination of internal fields, and one or more methods are considered to be the <it>step</it>. Such methods must not call each other nor theirselves, neither directly nor indirectly, otherwise the object can not be considered to be implemented on the automata-based manner.</p>
<p>

From the other hand, it is obvious that <it>object</it> is good for implementing a model of an automaton. When the automata-based approach is used within an object-oriented language, an automaton model is usually implemented by a class, the <it>state</it> is represented with internal (private) fields of the class, and the <it>step</it> is implemented as a method; such a method is usually the only non-constant public method of the class (besides constructors and destructors). Other public methods could query the state but don't change it. All the secondary methods (such as particular state handlers) are usually hidden within the private part of the class.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite id="Reference-Aho-1973" style="font-style:normal" class="book">Aho, Alfred V.;&#32;Ullman, Jeffrey D.&#32;(1973). The theory of parsing, translation and compiling&#32;<b>1</b>.&#32;Englewood Cliffs, N. J.:&#32;Prentice-Hall.</cite>&nbsp;
</entry>
<entry id="2">
RFC 793</entry>
<entry id="3">
 <cite id="Reference-Ollongren-1974" style="font-style:normal" class="book">Ollongren, Alexander&#32;(1974). Definition of programming languages by interpreting automata.&#32;London:&#32;Academic Press.</cite>&nbsp;</entry>
<entry id="4">
 <cite id="CITEREFJohnsonPorterAckleyRoss1968" style="font-style:normal">Johnson, W. L.; Porter, J. H.; Ackley, S. I.&#32;&amp;&#32;Ross, D. T.&#32;(1968),&#32;"Automatic generation of efficient lexical processors using finite state techniques",&#32;<it>Comm ACM</it>&#32;<b>11</b>(12):  805-813</cite>&nbsp;
</entry>
<entry id="5">
 <cite style="font-style:normal">Naur, Peter&#32;(September 1963).&#32;"The design of the GIER ALGOL compiler Part II"&#32;(in English). <it>BIT Numerical Mathematics</it>&#32;<b>3</b>: 145–166. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FBF01939983">
10.1007/BF01939983</weblink>. <symbol wordnetid="106806469" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<signal wordnetid="106791372" confidence="0.8">
<identifier wordnetid="107270601" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../930/234930.xml">
ISSN</link></system_of_measurement>
</identifier>
</signal>
</standard>
</symbol>
 <weblink xlink:type="simple" xlink:href="http://worldcat.org/issn/0006-3835">
0006-3835</weblink>.</cite>&nbsp;
</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 See also </st>


<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://erlang.org/doc/design_principles/fsm.html">
Erlang: Gen_Fsm Behaviour</weblink> FSM support in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../646/9646.xml">
Erlang</link></programming_language>
</entry>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../078/1285078.xml">
Esterel</link></language>
, an automata-based language</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://dec.bournemouth.ac.uk/forth/jfar/vol7/paper1/paper.html">
J. V. Noble. «Finite State Machines in Forth»</weblink> — automata-based programming in <link xlink:type="simple" xlink:href="../012/11012.xml">
Forth</link></entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Harell, David&#32;(1987).&#32;"<weblink xlink:type="simple" xlink:href="http://www.wisdom.weizmann.ac.il/~dharel/SCANNED.PAPERS/Statecharts.pdf">
Statecharts: A Visual Formalism for Complex Systems</weblink>". <it>Sci. Comput. Programming</it>&#32;(8): 231–274. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0167-6423%2887%2990035-9">
10.1016/0167-6423(87)90035-9</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Harell, David; Drusinsky, D.&#32;(1989).&#32;"Using Statecharts for Hardware Description and Synthesis". <it>IEEE Trans. Computer Aided Design of Integrated Circuits and Systems</it>&#32;(8): 798–807.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://legacy.imatix.com/html/libero/index.htm">
Libero home page</weblink> Libero — automata-based code generator (exists since 1982)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gnu.org/software/autogen/autofsm.html">
GNU AutoFSM</weblink> FSM-bsed code generator</entry>
</list>
</p>

</sec>
</bdy>
</article>
