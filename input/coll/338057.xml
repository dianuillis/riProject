<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:51:01[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Shifting nth-root algorithm</title>
<id>338057</id>
<revision>
<id>219924270</id>
<timestamp>2008-06-17T14:00:26Z</timestamp>
<contributor>
<username>Tardis</username>
<id>250465</id>
</contributor>
</revision>
<categories>
<category>Root-finding algorithms</category>
</categories>
</header>
<bdy>

The <b>shifting nth-root algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for extracting the <link>
<it>n</it>th root</link> of a positive <link xlink:type="simple" xlink:href="../491/19725491.xml">
real number</link> which proceeds iteratively by shifting in <it>n</it> <link xlink:type="simple" xlink:href="../582/280582.xml">
digits</link> of the radicand, starting with the most significant, and produces one digit of the root on each iteration, in a manner similar to <link xlink:type="simple" xlink:href="../384/313384.xml">
long division</link>.
<sec>
<st>
Algorithm</st>


<ss1>
<st>
Notation</st>

<p>

Let <it>B</it> be the <link xlink:type="simple" xlink:href="../207/701207.xml">
base</link> of the number system you are using, and <it>n</it> be the degree of the root to be extracted.  Let <it>x</it> be the radicand processed thus far, <it>y</it> be the root extracted thus far, and <it>r</it> be the remainder.  Let &amp;alpha; be the next <it>n</it> digits of the radicand, and &amp;beta; be the next digit of the root.  Let <it>x</it>' be the new value of <it>x</it> for the next iteration, <it>y</it>' be the new value of <it>y</it> for the next iteration, and <it>r</it>' be the new value of <it>r</it> for the next iteration.  These are all <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>s.</p>

</ss1>
<ss1>
<st>
Invariants</st>

<p>

At each iteration, the <link xlink:type="simple" xlink:href="../638/1126638.xml">
invariant</link> <math>y^n + r = x</math> will hold.  The invariant <math>(y+1)^n&amp;gt;x</math> will hold.  Thus <it>y</it> is the largest integer less than the <it>n</it>th root of x, and <it>r</it> is the <link xlink:type="simple" xlink:href="../897/502897.xml">
remainder</link>.</p>

</ss1>
<ss1>
<st>
Initialization</st>

<p>

The initial values of <it>x</it>, <it>y</it>, and <it>r</it> should be 0.  The value of &amp;alpha; for the first iteration should be the most significant aligned block of <it>n</it> digits of the radicand.  An aligned block of <it>n</it> digits means a block of digits aligned so that the decimal point falls between blocks.  For example, in 123.4 the most significant aligned block of 2 digits is 01, the next most significant is 23, and the third most significant is 40.</p>

</ss1>
<ss1>
<st>
Main loop</st>

<p>

On each iteration we shift in <it>n</it> digits of the radicand, so we have <math>x' = B^n x + \alpha</math> and we produce 1 digit of the root, so we have <math>y' = B y + \beta </math>.  We want to choose &amp;beta; and <it>r</it>' so that the invariants described above hold.  It turns out that there is always exactly one such choice, as will be proved below.</p>
<p>

The first invariant says that:</p>
<p>

<indent level="1">

<math>x' = y'^n + r'</math>
</indent>

or</p>
<p>

<indent level="1">

<math>B^n x + \alpha = (B y + \beta)^n + r'</math>
</indent>

So, pick the largest integer &amp;beta; such that</p>
<p>

<indent level="1">

<math>(B y + \beta)^n \le B^n x + \alpha</math>
</indent>

and let</p>
<p>

<indent level="1">

<math>r' = B^n x + \alpha - (B y + \beta)^n</math>
</indent>

Such a &amp;beta; always exists, since if <math>\beta = 0</math> then the condition is <math>B^n y^n \le B^n x + \alpha</math>, but <math>y^n \le x</math>, so this is always true.  Also, &amp;beta; must be less than <it>B</it>, since if <math>\beta = B</math> then we would have</p>
<p>

<indent level="1">

<math>(B(y+1))^n \le B^n x + \alpha</math>
</indent>

but the second invariant implies that</p>
<p>

<indent level="1">

<math>B^n x &amp;lt; B^n (y+1)^n</math>
</indent>

and since <math>B^n x</math> and <math>B^n (y+1)^n</math> are both multiples of <math>B^n</math> the difference between them must be at least <math>B^n</math>, and then we have</p>
<p>

<indent level="1">

<math>B^n x + B^n \le B^n (y+1)^n</math>
</indent>
:<math>B^n x + B^n \le B^n x + \alpha</math>
<indent level="1">

<math>B^n \le \alpha</math>
</indent>

but <math>0 \le \alpha &amp;lt; B^n</math> by definition of &amp;alpha;, so this can't be true, and <math>(B y + \beta)^n</math> is a monotonically increasing function of &amp;beta;, so it can't be true for larger &amp;beta; either, so we conclude that there exists an integer &amp;gamma; with <math>\gamma&amp;lt;B</math> such that an integer <it>r</it>' with <math>r' \ge 0</math> exists such that the first invariant holds if and only if <math>0 \le \beta \le \gamma</math>.</p>
<p>

Now consider the second invariant.  It says:</p>
<p>

<indent level="1">

<math>(y'+1)^n&amp;gt;x'</math>
</indent>

or</p>
<p>

<indent level="1">

<math>(B y + \beta + 1)^n&amp;gt;B^n x + \alpha</math>
</indent>

Now, if &amp;beta; is not the largest admissible &amp;beta; for the first invariant as described above, then <math>\beta + 1</math> is also admissible, and we have</p>
<p>

<indent level="1">

<math>(B y + \beta + 1)^n \le B^n x + \alpha</math>
</indent>

This violates the second invariant, so to satisfy both invariants we must pick the largest &amp;beta; allowed by the first invariant.  Thus we have proven the existence and uniqueness of &amp;beta; and <it>r</it>'.</p>
<p>

To summarize, on each iteration:
<list>
<entry level="1" type="number">

 Let &amp;alpha; be the next aligned block of digits from the radicand</entry>
<entry level="1" type="number">

 Let <math>x' = B^n x + \alpha</math></entry>
<entry level="1" type="number">

 Let &amp;beta; be the largest &amp;beta; such that <math>(B y + \beta)^n \le B^n x + \alpha</math></entry>
<entry level="1" type="number">

 Let <math>y' = B y + \beta</math></entry>
<entry level="1" type="number">

 Let <math>r' = x' - y'^n</math></entry>
</list>
</p>
<p>

Now, note that <math>x = y^n + r</math>, so the condition</p>
<p>

<indent level="1">

<math>(B y + \beta)^n \le B^n x + \alpha</math>
</indent>

is equivalent to</p>
<p>

<indent level="1">

<math>(B y + \beta)^n - B^n y^n \le B^n r + \alpha</math>
</indent>

and</p>
<p>

<indent level="1">

<math>r' = x' - y'^n = B^n x + \alpha - (B y + \beta)^n</math>
</indent>

is equivalent to</p>
<p>

<indent level="1">

<math>r' = B^n r + \alpha - ((B y + \beta)^n - B^n y ^n)</math>
</indent>

Thus, we don't actually need <math>x</math>, and since <math>r = x - y^n</math> and <math>x&amp;lt;(y+1)^n</math>, <math>r&amp;lt;(y+1)^n-y^n</math> or <math>r&amp;lt;n y^{n-1}+O(y^{n-2})</math>, or <math>r&amp;lt;n x^{{n-1}\over n} + O(x^{{n-2}\over n})</math>, so by using <math>r</math> instead of <math>x</math> we save time and space by a factor of 1/<it>n</it>.  Also, the <math>B^n y^n</math> we subtract in the new test cancels the one in <math>(B y + \beta)^n</math>, so now the highest power of <it>y</it> we have to evaluate is <math>y^{n-1}</math> rather than <math>y^n</math>.</p>
<p>

The final algorithm is:
<list>
<entry level="1" type="number">

 Initialize <it>r</it> and <it>y</it> to 0</entry>
<entry level="1" type="number">

 Repeat until desired <link xlink:type="simple" xlink:href="../110/552110.xml">
precision</link> is obtained:</entry>
<entry level="2" type="number">

 Let &amp;alpha; be the next aligned block of digits from the radicand</entry>
<entry level="2" type="number">

 Let &amp;beta; be the largest &amp;beta; such that <math>(B y + \beta)^n - B^n y^n \le B^n r + \alpha</math></entry>
<entry level="2" type="number">

 Let <math>y' = B y + \beta</math></entry>
<entry level="2" type="number">

 Let <math>r' = B^n r + \alpha - ((B y + \beta)^n - B^n y^n)</math></entry>
<entry level="2" type="number">

 Assign <math>y \leftarrow y'</math> and <math>r \leftarrow r'</math></entry>
<entry level="1" type="number">

 <math>y</math> is the largest integer such that <math>y^n&amp;lt;x B^k</math>, and <math>y^n+r=x B^k</math>, where <math>k</math> is the number of digits of the radicand after the decimal point that have been consumed (a negative number if the algorithm hasn't reached the decimal point yet).</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Paper and pencil nth roots</st>

<p>

As noted above, this algorithm is similar to long division, and it lends itself to the same notation:</p>
<p>

1.  4   4   2   2   4
----------------------
3/ 3.000 000 000 000 000
/\/  1 = 300*(0^2)*1+30*0*(1^2)+1^3
-
2 000
1 744 = 300*(1^2)*4+30*1*(4^2)+4^3
-----
256 000
241 984 = 300*(14^2)*4+30*14*(4^2)+4^3
-------
14 016 000
12 458 888 = 300*(144^2)*2+30*144*(2^2)+2^3
----------
1 557 112 000
1 247 791 448 = 300*(1442^2)*2+30*1442*(2^2)+2^3
-------------
309 320 552 000
249 599 823 424 = 300*(14422^2)*4+30*14422*(4^2)+4^3
---------------
59 720 728 576</p>
<p>

Note that after the first iteration or two the leading term dominates the
<math>(B y + \beta)^n - B^n y^n</math>, so we can get an often correct first guess at &amp;beta; by dividing <math>B r + \alpha</math> by <math>n B^{n-1} y^{n-1}</math>.</p>

</ss1>
<ss1>
<st>
Performance</st>

<p>

On each iteration, the most time-consuming task is to select &amp;beta;.  We know that there are <it>B</it> possible values, so we can find &amp;beta; using <math>O(\log(B))</math> comparisons.  Each comparison will require evaluating <math>(B y +\beta)^n - B^n y^n</math>.  In the <it>k</it>th iteration, y has <it>k</it> digits, and the polynomial can be evaluated with <math>2 n - 4</math> multiplications of up to <math>k(n-1)</math> digits and <math>n - 2</math> additions of up to <math>k(n-1)</math> digits, once we know the powers of <it>y</it> and &amp;beta; up through <math>n-1</math> for <it>y</it> and <it>n</it> for &amp;beta;.  &amp;beta; has a restricted range, so we can get the powers of &amp;beta; in constant time.  We can get the powers of <it>y</it> with <math>n-2</math> multiplications of up to <math>k(n-1)</math> digits.  Assuming <it>n</it>-digit multiplication takes time <math>O(n^2)</math> and addition takes time <math>O(n)</math>, we take time
<math>O(k^2 n^2)</math> for each comparison, or time <math>O(k^2 n^2 \log(B))</math> to pick &amp;beta;.  The remainder of the algorithm is addition and subtraction that takes time <math>O(k)</math>, so each iteration takes <math>O(k^2 n^2 \log(B))</math>.  For all <it>k</it> digits, we need time <math>O(k^3 n^2 \log(B))</math>.</p>
<p>

The only internal storage needed is <it>r</it>, which is <math>O(k)</math> digits on the <it>k</it>th iteration.  That this algorithm doesn't have bounded memory usage puts an upper bound on the number of digits which can be computed mentally, unlike the more elementary algorithms of arithmetic.  Unfortunately, any bounded memory state machine with periodic inputs can only produce periodic outputs, so there are no such algorithms which can compute irrational numbers from rational ones, and thus no bounded memory root extraction algorithms.</p>
<p>

Note that increasing the base increases the time needed to pick &amp;beta; by a factor of <math>O(log(B))</math>, but decreases the number of digits needed to achieve a given precision by the same factor, and since the algorithm is cubic time in the number of digits, increasing the base gives an overall speedup of <math>O(\log^2(B))</math>.  When the base is larger than the radicand, the algorithm degenerates to <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link>, so it follows that this algorithm is not useful for computing roots with a computer, as it is always outperformed by much simpler binary search, and has the same memory complexity.</p>

</ss1>
</sec>
<sec>
<st>
Examples</st>


<ss1>
<st>
<link xlink:type="simple" xlink:href="../208/29208.xml">
Square root</link> of 2 in binary</st>

<p>

1. 0  1  1  0  1
------------------
/ 10.00 00 00 00 00     1
/\/   1                  + 1
-----               ----
1 00                100
0               +  0
--------            -----
1 00 00             1001
10 01            +   1
-----------         ------
1 11 00          10101
1 01 01         +    1
----------      -------
1 11 00       101100
0      +     0
----------   --------
1 11 00 00    1011001
1 01 10 01          1
----------
1 01 11 remainder</p>

</ss1>
<ss1>
<st>
Square root of 3</st>

<p>

1. 7  3  2  0  5
----------------------
/ 3.00 00 00 00 00
/\/  1 = 20*0*1+1^2
-
2 00
1 89 = 20*1*7+7^2
----
11 00
10 29 = 20*17*3+3^2
-----
71 00
69 24 = 20*173*2+2^2
-----
1 76 00
0 = 20*1732*0+0^2
-------
1 76 00 00
1 73 20 25 = 20*17320*5+5^2
----------
2 79 75</p>

</ss1>
<ss1>
<st>
<link xlink:type="simple" xlink:href="../506/292506.xml">
Cube root</link> of 5</st>

<p>

1.  7   0   9   9   7
----------------------
3/ 5.000 000 000 000 000
/\/  1 = 300*(0^2)*1+30*0*(1^2)+1^3
-
4 000
3 913 = 300*(1^2)*7+30*1*(7^2)+7^3
-----
87 000
0 = 300*(17^2)*0+30*17*(0^2)+0^3
-------
87 000 000
78 443 829 = 300*(170^2)*9+30*170*(9^2)+9^3
----------
8 556 171 000
7 889 992 299 = 300*(1709^2)*9+30*1709*(9^2)+9^3
-------------
666 178 701 000
614 014 317 973 = 300*(17099^2)*7+30*17099*(7^2)+7^3
---------------
52 164 383 027</p>

</ss1>
<ss1>
<st>
Fourth root of 7</st>

<p>

1.   6    2    6    5    7
---------------------------
_ 4/ 7.0000 0000 0000 0000 0000
\/  1 = 4000*(0^3)*1+400*(0^2)*(1^2)+40*0*(1^3)+1^4
-
6 0000
5 5536 = 4000*(1^3)*6+600*(1^2)*(6^2)+40*1*(6^3)+6^4
------
4464 0000
3338 7536 = 4000*(16^3)*2+600*(16^2)*(2^2)+40*16*(2^3)+2^4
---------
1125 2464 0000
1026 0494 3376 = 4000*(162^3)*6+600*(162^2)*(6^2)+40*162*(6^3)+6^4
--------------
99 1969 6624 0000
86 0185 1379 0625 = 4000*(1626^3)*5+600*(1626^2)*(5^2)+
-----------------   40*1626*(5^3)+5^4
13 1784 5244 9375 0000
12 0489 2414 6927 3201 = 4000*(16265^3)*7+600*(16265^2)*(7^2)+
----------------------   40*16265*(7^3)+7^4
1 1295 2830 2447 6799</p>


</ss1>
</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
