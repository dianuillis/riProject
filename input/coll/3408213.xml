<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:19:18[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Memory bound function</title>
<id>3408213</id>
<revision>
<id>220784629</id>
<timestamp>2008-06-21T15:47:18Z</timestamp>
<contributor>
<username>Leszek Jańczuk</username>
<id>6848259</id>
</contributor>
</revision>
<categories>
<category>Anti-spam</category>
<category>Computer memory</category>
<category>Analysis of algorithms</category>
</categories>
</header>
<bdy>

<b>Memory bound</b> refers to a situation in which the time to complete a given <link xlink:type="simple" xlink:href="../672/4594672.xml">
computational problem</link> is decided primarily by the amount of available <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> to hold <link xlink:type="simple" xlink:href="../040/18985040.xml">
data</link>. In other words, the limiting factor of solving a given problem is the <link>
memory access speed</link>. The application of memory bound <link xlink:type="simple" xlink:href="../988/40988.xml">
functions</link> could prove to be valuable in preventing <link xlink:type="simple" xlink:href="../368/28368.xml">
spam</link>, which has become a problem of epidemic proportions on the <link xlink:type="simple" xlink:href="../539/14539.xml">
Internet</link>.
<sec>
<st>
Memory bound functions and memory functions</st>
<p>

Memory bound functions and memory functions are related in that both involve extensive memory access, but a distinction should be made between them</p>
<p>

Memory functions use a <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> technique called <link xlink:type="simple" xlink:href="../483/723483.xml">
memoization</link> in order to relieve the inefficiency of <link xlink:type="simple" xlink:href="../407/25407.xml">
recursion</link> that might occur. It is based on the simple idea of calculating and storing solutions to subproblems so that the solutions can be reused later without recalculating the <link xlink:type="simple" xlink:href="../102/243102.xml">
subproblems</link> again. The best known example that takes advantage of memorization is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that computes the <link xlink:type="simple" xlink:href="../918/10918.xml">
Fibonacci number</link>s. The following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudo-code</link> illustrates an algorithm that uses memoization, which runs in <link xlink:type="simple" xlink:href="../591/91591.xml">
linear</link> CPU time:</p>
<p>

<b>for i = 0 to n-1</b>
result[i] = -1  // -1 means undefined
Fibonacci (results, n)
{
<b>if</b> (results[n] != -1) //check if it has already been solved before
<b>return</b> results[n]
<b>if</b> (n == 0)
val = 0
<b>else if</b> (n == 1)
val = 1
<b>else</b>
val = Fibonacci_results(results, n -2 ) + Fibonacci_results(results, n -1)
results[n] = val
<b>return val
}</b></p>
<p>

Compare the above to an algorithm that uses recursion, which runs in <link xlink:type="simple" xlink:href="../581/44581.xml">
exponential</link> CPU time:</p>
<p>

Recursive_Fibonacci (n)
{	
<b>if</b> (n == 0)
<b>return</b> 0
<b>else if</b> ( n == 1)
<b>return</b> 1
<b>else</b>
<b>return</b> Recursive_Fibonacci (n -1) + Recursive_Fibonacci (n -2)
}</p>
<p>

While the recursive algorithm is simpler and more elegant than the algorithm that uses memoization, the latter has a significantly lower <link xlink:type="simple" xlink:href="../543/7543.xml">
time complexity</link> than the former. 
The term “memory bound function” has surfaced only recently and is used principally to describe a function that uses XOR and consists of a series of computations in which each computation depends on the previous computation. Whereas memory functions have long been an important actor in improving time complexity, memory bound functions have seen far fewer applications. Recently, however, scientists have proposed a method using memory bound functions as a means to discourage spammers from abusing resources, which could be a major breakthrough in that area.</p>

</sec>
<sec>
<st>
Using memory bound functions to prevent spam</st>
<p>

In 1992, IBM research scientists Cynthia Dwork and Moni Naor published a paper titled <it><weblink xlink:type="simple" xlink:href="http://dsns.csie.nctu.edu.tw/research/crypto/HTML/PDF/C92/139.PDF">
Pricing via Processing or Combating Junk Mail</weblink></it>, suggesting a possibility of using <link xlink:type="simple" xlink:href="../697/648697.xml">
CPU bound</link> functions to deter abusers from sending spam. The scheme was based on the idea that computer users are much more likely to abuse a resource if the cost of abusing the resource is negligible: the underlying reason spam has become so rampant is that sending an <link xlink:type="simple" xlink:href="../738/9738.xml">
e-mail</link> has minuscule cost for spammers.</p>
<p>

Dwork and Naor proposed that spamming might be reduced by injecting an additional cost in the form of an expensive <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> computation: CPU bound functions would consume CPU resources at the sender's machine for each message, thus preventing huge amounts of spam from being sent in a short period. 
The basic scheme that protects against abuses is as follows: </p>
<p>

Let S be sender, R be recipient, and M be an e-mail. If R has agreed beforehand to receive e-mail from S, then M is transmitted in the usual way. Otherwise, S computes some function G(M) and sends (M, G(M)) to R. R checks if what it receives from S is of the form (M, G(M)). If yes, R accepts M. Otherwise, R rejects M. The figure on the right depicts cases in which there were no prior agreements:</p>

<p>

The function G() is selected such that the verification by R is relatively fast (taking a millisecond) and such that the computation by S is somewhat slow (involving at least several seconds). Therefore, S will be discouraged from sending M to multiple recipients with no prior agreements: the cost in terms of both time and computing resources of computing G() repeatedly will become very prohibitive for a spammer who intends to send many millions of e-mails.</p>
<p>

The major problem of using the above scheme is that fast CPUs compute much faster than slow CPUs. Further, higher-end computer systems also have sophisticated pipelines and other advantageous features that facilitate computations. As a result, a spammer with a state-of-the-art system will hardly be affected by such deterrence while a typical user with a mediocre system will be adversely affected. If a computation takes a few seconds on a new <link xlink:type="simple" xlink:href="../137/18457137.xml">
PC</link>, it may take a minute on an old PC, and several minutes on a <link xlink:type="simple" xlink:href="../304/23304.xml">
PDA</link>, which might be a nuisance for users of old PCs, but probably unacceptable for users of PDAs. The disparity in client CPU speed constitutes one of the prominent roadblocks to widespread adoption of any scheme based on a CPU bound function. Therefore, researchers are concerned with finding functions that most computer systems will evaluate at about the same speed, so that high-end systems might evaluate these functions somewhat faster than low-end systems (2-10 times faster, but not 10-100 faster) as CPU disparities might imply. These ratios are “<link xlink:type="simple" xlink:href="../113/10113.xml">
egalitarian</link>” enough for the intended applications: the functions are effective in discouraging abuses and do not add a prohibitive delay on legitimate interactions, across a wide range of systems.	</p>
<p>

The new egalitarian approach is to rely on memory bound functions. As stated before, a memory bound function is a function whose computation time is dominated by the time spent accessing memory. A memory bound function accesses locations in a large region of memory in an unpredictable way, in such a way that using caches are not effective. In recent years, the speed of CPU has grown drastically, but there has been comparatively small progress in developing faster main memory. Since the <link xlink:type="simple" xlink:href="../837/87837.xml">
ratio</link>s of memory <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/17933.xml">
latencies</link></concept>
</idea>
 of machines built in the last five years is typically no greater than two, and almost always less than four, the memory bound function will be egalitarian to most systems for the foreseeable future.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../697/648697.xml">
CPU bound</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../513/648513.xml">
I/O bound</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../844/18844.xml">
Memory</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../297/125297.xml">
Dynamic programming</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../483/723483.xml">
Memoization</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../368/28368.xml">
Spam</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../407/25407.xml">
Recursion</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../102/243102.xml">
Optimal substructure</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

Abadi, M., Burrows, M., Manasse, M., &amp; Wobber, T. (2005, May).  <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/research/sv/sv-pubs/memory-longer-acm.pdf">
Moderately Hard, Memory-bound Functions.</weblink> <it>ACM Transactions on Internet Technology''</it></entry>
<entry level="1" type="bullet">

Dwork, C., Goldberg, A., &amp; Naor, M. (2003). <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/research/sv/PennyBlack/demo/lbdgn.pdf">
On Memory-Bound Functions for Fighting Spam.</weblink> <it>Advances in Cryptology''</it></entry>
<entry level="1" type="bullet">

Dwork, C., &amp; Naor, M. (1992). <weblink xlink:type="simple" xlink:href="http://dsns.csie.nctu.edu.tw/research/crypto/HTML/PDF/C92/139.PDF">
Pricing via Processing or Combating Junk Mail</weblink> <it>Advances in Cryptology''</it></entry>
<entry level="1" type="bullet">

Hellman, M. E. (1980). <weblink xlink:type="simple" xlink:href="http://www-ee.stanford.edu/~hellman/publications/36.pdf">
A Cryptanalytic Time-Memory Trade Off.</weblink> <it>IEEE Transactionson Information Theory''</it></entry>
</list>
</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://pennypost.sourceforge.net/MBound">
Implementation of a Memory Bound function</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.iastate.edu/~prabhu/Tutorial/title.html">
Computer Architecture</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://computer.howstuffworks.com/computer-memory.htm">
How Computer Memory Works</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://mat.gsia.cmu.edu/classes/dynamic/dynamic.html">
Dynamic Programming</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://allendowney.com/cs357spring1998/ass5/node6.html">
CPU Bound vs. I/O Bound</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ftc.gov/spam/">
FTC-SPAM</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
