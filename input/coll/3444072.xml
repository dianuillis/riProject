<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:25:37[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Push-relabel maximum flow algorithm</title>
<id>3444072</id>
<revision>
<id>243724614</id>
<timestamp>2008-10-07T19:58:46Z</timestamp>
<contributor>
<username>Iridescent</username>
<id>937705</id>
</contributor>
</revision>
<categories>
<category>Network flow</category>
</categories>
</header>
<bdy>

The <b>push-relabel algorithm</b> is one of the most efficient algorithms to compute a <link xlink:type="simple" xlink:href="../165/403165.xml">
maximum flow</link>. The general algorithm has <math>O(V^2 E)</math> time complexity, while the implementation with FIFO vertex selection rule has <math>O(V^3)</math> running time, the highest active vertex selection rule provides <math>O(V^2\sqrt{E})</math> complexity, and the implementation with <link>
Sleator</link>'s and <link xlink:type="simple" xlink:href="../127/46127.xml">
Tarjan</link>'s dynamic tree data structure runs in <math>O(V E \log(V^2/E))</math> time. In most cases it is more efficient than the <link xlink:type="simple" xlink:href="../230/239230.xml">
Edmonds-Karp algorithm</link>, which runs in <math>O(VE^2)</math> time. 
<sec>
<st>
Algorithm</st>

<p>

Given a flow network <math>G(V,E)</math> with capacity from node <it>u</it> to node <it>v</it> given as <math>c(u,v)</math>, and source <it>s</it> and sink <it>t</it>, we want to find the maximum amount of flow you can send from <it>s</it> to <it>t</it> through the network. Two types of operations are performed on nodes, <it>push</it> and <it>relabel</it>. Throughout we maintain:
<list>
<entry level="1" type="bullet">

 <math>f(u,v)</math>. Flow from <it>u</it> to <it>v</it>. Available capacity is <math>c(u,v) - f(u,v)</math>.</entry>
<entry level="1" type="bullet">

 <math>height(u)</math>. We only <it>push</it> from <it>u</it> to <it>v</it> if <math>height(u) &amp;gt; height(v)</math>. For all <it>u</it>, <math>height(u)</math> is a non-negative integer.</entry>
<entry level="1" type="bullet">

 <math>excess(u)</math>. Sum of flow to and from <it>u</it>.</entry>
</list>
</p>
<p>

After each step of the algorithm, the flow is a <b>preflow</b>, satisfying:</p>
<p>

<list>
<entry level="1" type="bullet">

 <math>\ f(u,v) \leq c(u,v)</math>. The flow between <math>u</math> and <math>v</math>, does not exceed the capacity.</entry>
<entry level="1" type="bullet">

 <math>\ f(u,v) = - f(v,u)</math>. We maintain the net flow.</entry>
<entry level="1" type="bullet">

 <math>\ \sum_v f(u,v) = excess(u) \geq 0</math> for all nodes <math>u \neq s</math>. Only the source may produce flow.</entry>
</list>
</p>
<p>

Notice that the last condition for a preflow is relaxed from the corresponding condition for a <link xlink:type="simple" xlink:href="../676/645676.xml#xpointer(//*[./st=%22Definition%22])">
legal flow</link> in a regular flow network.</p>
<p>

We observe that the longest possible path from <it>s</it> to <it>t</it> is <math>|V|</math> nodes long. Therefore it must be possible to assign <it>height</it> to the nodes such that for any legal flow, <math>height(s) = |V|</math> and <math>height(t) = 0</math>, and if there is a positive flow from <it>u</it> to <it>v</it>, <math>height(u) &amp;gt; height(v)</math>. As we adjust the height of the nodes, the flow goes through the network as water through a landscape. Differing from algorithms such as <link xlink:type="simple" xlink:href="../777/53777.xml">
Ford-Fulkerson</link>, the flow through the network is not necessarily a legal flow throughout the execution of the algorithm.</p>
<p>

In short words, the heights of nodes (except <it>s</it> and <it>t</it>) is adjusted, and flow is sent between nodes, until all possible flow has reached <it>t</it>. Then we continue increasing the height of internal nodes until all the flow that went into the network, but did not reach <it>t</it>, has flowed back into <it>s</it>. A node can reach the height <math>2|V|-1</math> before this is complete, as the longest possible path back to <it>s</it> excluding <it>t</it> is <math>|V|-1</math> long, and <math>height(s) = |V|</math>. The height of <it>t</it> is kept at 0.</p>

<ss1>
<st>
Push</st>
<p>

A <it>push</it> from <it>u</it> to <it>v</it> means sending a part of the excess flow into <it>u</it> on to <it>v</it>. Three conditions must be met for a <it>push</it> to take place:
<list>
<entry level="1" type="bullet">

 <math>excess(u) &amp;gt; 0</math>. More flow into the node than out of it so far.</entry>
<entry level="1" type="bullet">

 <math>c(u,v) - f(u,v) &amp;gt; 0</math>. Available capacity from <it>u</it> to <it>v</it>.</entry>
<entry level="1" type="bullet">

 <math>height(u) = height(v)+1</math>. Can only send to lower node.</entry>
</list>

We send an amount of flow equal to <math>\min(excess(u), c(u,v)-f(u,v))</math>.</p>

</ss1>
<ss1>
<st>
Relabel</st>
<p>

Doing a <it>relabel</it> on a node <it>u</it> is increasing its height until it is higher than at least one of the nodes it has available capacity to. Conditions for a <it>relabel</it>:
<list>
<entry level="1" type="bullet">

 <math>excess(u) &amp;gt; 0</math>. There must be a point in relabelling.</entry>
<entry level="1" type="bullet">

 <math>height(u) \leq height(v)</math> for all <it>v</it> such that <math>c(u,v)-f(u,v) &amp;gt; 0</math>. The only nodes we have available capacity to are higher.</entry>
</list>

When relabelling <it>u</it>, we set <math>height(u)</math> to be the lowest value such that <math>height(u) &amp;gt; height(v)</math> for some <it>v</it> where <math>c(u,v)-f(u,v) &amp;gt; 0</math>.</p>

</ss1>
<ss1>
<st>
Push-relabel algorithm</st>
<p>

<it>Push-relabel algorithms</it> in general have the following layout:
<list>
<entry level="1" type="number">

 As long as there is legal <it>push</it> or <it>relabel</it> operation</entry>
<entry level="2" type="number">

 Perform a legal push, or</entry>
<entry level="2" type="number">

 a legal relabel.</entry>
</list>
</p>
<p>

The running time for these algorithms are in general <math>O(V^2 E)</math> (argument omitted).</p>

</ss1>
<ss1>
<st>
Discharge</st>
<p>

In <it>relabel-to-front</it>, a <it>discharge</it> on a node <it>u</it> is the following:
<list>
<entry level="1" type="number">

 As long as <math>excess(u) &amp;gt; 0</math>:</entry>
<entry level="2" type="number">

 If not all neighbours have been tried since last <it>relabel</it>:</entry>
<entry level="3" type="number">

 Try to <it>push</it> flow to an untried neighbour.</entry>
<entry level="2" type="number">

 Else:</entry>
<entry level="3" type="number">

 <it>Relabel</it> <it>u''</it></entry>
</list>
</p>
<p>

This requires that for each node, it is known which nodes have been tried since last <it>relabel</it>.</p>

</ss1>
<ss1>
<st>
Relabel-to-front algorithm, ie. using FIFO heuristic </st>
<p>

In the <it>relabel-to-front algorithm</it>, the order of the <it>push</it> and <it>relabel</it> operations is given:</p>
<p>

<list>
<entry level="1" type="number">

 Send as much flow from <it>s</it> as possible.</entry>
<entry level="1" type="number">

 Build a list of all nodes except <it>s</it> and <it>t</it>.</entry>
<entry level="1" type="number">

 As long as we have not traversed the entire list:</entry>
<entry level="2" type="number">

 <it>Discharge</it> the current node.</entry>
<entry level="2" type="number">

 If the height of the current node changed: </entry>
<entry level="3" type="number">

 Move the current node to the front of the list</entry>
<entry level="3" type="number">

 Restart the traversal from the start of the list.</entry>
</list>
</p>
<p>

The running time for <it>relabel-to-front</it> is <math>O(V^3)</math> (proof omitted).</p>

</ss1>
</sec>
<sec>
<st>
Sample implementation</st>

<p>

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 implementation:</p>
<p>

<b>def</b> relabel_to_front(C, source, sink):
n = len(C) <it># C is the capacity matrix</it>
F = [[0] * n <b>for</b> _ <b>in</b> xrange(n)]
<it># residual capacity from u to v is C[u][v] - F[u][v]</it></p>
<p>

height = [0] * n <it># height of node</it>
excess = [0] * n <it># flow into node minus flow from node</it>
seen   = [0] * n <it># neighbours seen since last relabel</it>
<it># node "queue"</it>
list   = [i '''for''' i '''in''' xrange(n) '''if''' i != source '''and''' i != sink]</p>
<p>

<b>def</b> push(u, v):
send = min(excess[u], C[u][v] - F[u][v])
F[u][v] += send
F[v][u] -= send
excess[u] -= send
excess[v] += send</p>
<p>

<b>def</b> relabel(u):
<it># find smallest new height making a push possible,</it>
<it># if such a push is possible at all</it>
min_height = height[u]
<b>for</b> v <b>in</b> xrange(n):
<b>if</b> C[u][v] - F[u][v] &amp;gt; 0:
min_height = min(min_height, height[v])
height[u] = min_height + 1</p>
<p>

<b>def</b> discharge(u):
<b>while</b> excess[u] &amp;gt; 0:
<b>if</b> seen[u]  n: <it># check next neighbour</it>
v = seen[u]
<b>if</b> C[u][v] - F[u][v] &amp;gt; 0 <b>and</b> height[u] &amp;gt; height[v]:
push(u, v)
<b>else</b>:
seen[u] += 1
<b>else</b>: <it># we have checked all neighbours. must relabel</it>
relabel(u)
seen[u] = 0</p>
<p>

height[source] = n   <it># longest path from source to sink is less than n long</it>
excess[source] = Inf <it># send as much flow as possible to neighbours of source</it>
<b>for</b> v <b>in</b> xrange(n):
push(source, v)</p>
<p>

p = 0
<b>while</b> p  len(list):
u = list[p]
old_height = height[u]
discharge(u)
<b>if</b> height[u] &amp;gt; old_height:
list.insert(0, list.pop(p)) <it># move to front of list</it>
p = 0 <it># start from front of list</it>
p += 1</p>
<p>

<b>return</b> sum([F[source][i] <b>for</b> i <b>in</b> xrange(n)])</p>
<p>

Note that the above implementation is not very efficient. It is slower than <link xlink:type="simple" xlink:href="../230/239230.xml">
Edmonds-Karp algorithm</link> even for very dense graphs. To speed it up, you can do at least two things:</p>
<p>

<list>
<entry level="1" type="number">

 Make neighbour lists for each node, and let the index seen[u] be an iterator over this, instead of the range <math>0..n-1</math>.</entry>
<entry level="1" type="number">

 Use a <b>gap heuristic</b>. If there is a <math>k</math> such that for no node, <math>height(u)=k</math>, you can set <math>height(u)=\max(height(u), height(s) + 1)</math> for all nodes except <math>s</math> for which <math>height(u)&amp;gt;k</math>. This is because any such <math>k</math> represents a <link xlink:type="simple" xlink:href="../130/78130.xml">
minimal cut</link> in the graph, and no more flow will go from the nodes <math>S = \{u|height(u)&amp;gt;k\}</math> to the nodes <math>T = \{v|height(v)&amp;lt;k\}</math>. If <math>(S,T)</math> was not a minimal cut, there would be an edge <math>(u,v)</math> such that <math>u \in S</math>, <math>v \in T</math> and <math>c(u,v)-f(u,v) &amp;gt; 0</math>. But then <math>height(u)</math> would never be set higher than <math>height(v)+1</math>, contradicting that <math>height(u) &amp;gt; k</math> and <math>height(v) &amp;lt; k</math>.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 26.4: Push-relabel algorithms, and section 26.5: The relabel-to-front-algorithm.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Andrew V. Goldberg</link>, <link xlink:type="simple" xlink:href="../127/46127.xml">
Robert E. Tarjan</link>. <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/12130.12144">
A new approach to the maximum flow problem</weblink>. Annual ACM Symposium on Theory of Computing, Proceedings of the eighteenth annual ACM symposium on Theory of computing, 136&ndash;146. ISBN:0-89791-193-8 1986 </entry>
</list>
</p>


</sec>
</bdy>
</article>
