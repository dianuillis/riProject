<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:53:24[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Triple buffering</title>
<id>346597</id>
<revision>
<id>242543229</id>
<timestamp>2008-10-02T17:50:11Z</timestamp>
<contributor>
<username>Redirect fixer</username>
<id>7523687</id>
</contributor>
</revision>
<categories>
<category>Computer graphics algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, <b>triple buffering</b> is a variant on <link xlink:type="simple" xlink:href="../349/346349.xml">
double buffering</link>, a technique for drawing graphics that shows no (or less) flicker, shearing, and tearing artifacts.<p>

Triple buffering attempts to provide a speed improvement over double buffering.  In real life applications, this often involves trying to abstract the graphics drawing operations from being synchronized with the <link xlink:type="simple" xlink:href="../677/7677.xml">
monitor's</link> refresh rate.  Typically this involves frames being drawn at a rate lower than or higher than the monitor's frame rate (a variable frame rate) without the usual effects this would cause (namely flickering, shearing and tearing).</p>
<p>

Due to the software <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> not having to poll the graphics hardware for monitor refresh events, the algorithm is free to run as fast as possible.  This is not the only method of triple buffering available, but is the most prevalent on the <link xlink:type="simple" xlink:href="../137/18457137.xml">
PC</link> architecture where the speed of the target machine is highly variable.</p>
<p>

Another method of triple buffering involves synchronizing with the monitor frame rate, and simply using the third buffer as a method of providing breathing room for changing demands in the amount of graphics drawn.  This is the use of a buffer in the true sense whereby the buffer acts as a .  Such a method requires a higher minimum specification of the target hardware but provides a consistent (vs. variable) frame rate. This is the case when using triple buffering in <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../506/8506.xml">
DirectX</link></software>
, where a chain of 3 buffer are rendered and always displayed.</p>
<p>

Triple buffering implies three buffers, but the method can be extended to as many buffers as is practical for the <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<furnishing wordnetid="103405265" confidence="0.8">
<table wordnetid="104379243" confidence="0.8">
<furniture wordnetid="103405725" confidence="0.8">
<console_table wordnetid="103092883" confidence="0.8">
<link xlink:type="simple" xlink:href="../746/454746.xml">
application</link></console_table>
</furniture>
</table>
</furnishing>
</instrumentality>
</artifact>
. Usually, there is no advantage to using more than three buffers.</p>

<sec>
<st>
 Limitations of double buffering </st>
<p>

If the system has two color buffers A and B, it can display buffer B while drawing a new picture (rendering) into buffer A. When it is done rendering into buffer A, the system needs to wait until buffer B is in the monitor's vertical blank period before swapping buffers. This waiting period could be several <link xlink:type="simple" xlink:href="../153/36153.xml">
milliseconds</link> during which neither buffer can be touched. At 60 frames per second, there are only 16.67 milliseconds in which to draw the frame, so this delay could waste valuable frame time. When the monitor is in vertical blank it can either swap buffers A and B and then start rendering into buffer B (page flipping) or copy buffer A into buffer B and render into buffer A.</p>

</sec>
<sec>
<st>
 Advantage of triple buffering </st>
<p>

If the system has three color buffers A, B and C, it does not have to wait to swap buffers. It can display buffer B while rendering into buffer A. When done rendering into buffer A, it can start rendering into buffer C immediately. When the monitor is in vertical blank, it can display buffer A and make buffer B available for reuse.</p>
<p>

Also, on systems like <link xlink:type="simple" xlink:href="../980/1980.xml">
Amiga</link>s, you could paint using the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> in parallel with the <link xlink:type="simple" xlink:href="../474/145474.xml">
blitter</link> doing a cleanup of a previous buffer, meaning that you could show buffer A, while cleaning buffer B and paint graphics on buffer C. If you only used two buffers, you would have to make sure the cleaning was completely done before starting the drawing on the unused buffer, which would waste some time.</p>

</sec>
<sec>
<st>
 Limitations of triple buffering </st>
<p>

If the system always renders buffers in less time than it takes to display a buffer once on the monitor, the computer will wait for the monitor regardless of how many buffers there are. In this particular case triple buffering has no advantage over double buffering. The third buffer also uses additional <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link>, which could be used for other data (like textures).</p>
<p>

Thirdly, if the system is <link xlink:type="simple" xlink:href="../528/644528.xml">
interactive</link> (for example, a simulator or a video game), and using triple buffering as a fixed order reservoir, triple buffering increases the average delay between the input controls being read and visual feedback being presented to the user. In the other case where frames can be dropped without being displayed, triple buffering can actually lower response time by including input data which wasn't available when the previous dropped frames were rendered.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../762/504762.xml">
Vertical synchronization</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://www.gamecritics.com/triple-buffering-improve-your-pc-gaming-performance-for-free">
Triple buffering: improve your PC gaming performance for free</weblink></it> by Mike Doolittle (2007-05-24)</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
