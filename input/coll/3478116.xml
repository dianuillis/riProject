<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:30:23[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Cohen-Sutherland</title>
<id>3478116</id>
<revision>
<id>226988231</id>
<timestamp>2008-07-21T13:17:05Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Clipping (computer graphics)</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, the <b>Cohen-Sutherland</b> algorithm is a <link xlink:type="simple" xlink:href="../474/1982474.xml">
line clipping</link> algorithm. The algorithm divides a 2D space into 9 parts, of which only the middle part (viewport) is visible. 
<sec>
<st>
The algorithm</st>

<p>

The algorithm includes, excludes or partially includes the line based on where the two endpoints are:</p>
<p>

<list>
<entry level="1" type="bullet">

 Both endpoints are in the viewport (bitwise OR of endpoints == 0): trivial accept.</entry>
<entry level="1" type="bullet">

 Both endpoints are on the same side of the rectangle, which is not visible (bitwise AND of endpoints != 0): trivial reject.</entry>
<entry level="1" type="bullet">

 Both endpoints are in different parts: In case of this non trivial situation the algorithm finds one of the two points that are outside the viewport (there is at least one point outside). The intersection of the outpoint and extended viewport border is then calculated (i.e. with the parametric equation for the line) and this new point replaces the outpoint. The algorithm repeats until a trivial accept or reject occurs.</entry>
</list>
</p>
<p>

The numbers in the figure below are called <link>
outcodes</link>. An outcode is computed for each of the two points in the line. The first bit is set to 1 if the point is above the viewport. The bits in the outcode represent: Top, Bottom, Right, Left. For example the outcode 1010 represents a point that is top-right of the viewport.  Note that the outcodes for endpoints <b>must</b> be recalculated on each iteration after the clipping occurs.</p>
<p>

<table border="1">
<row>
<col>
1001</col>
<col>
1000</col>
<col>
1010</col>
</row>
<row>
<col>
0001</col>
<col>
0000</col>
<col>
0010</col>
</row>
<row>
<col>
0101</col>
<col>
0100</col>
<col>
0110</col>
</row>
</table>
</p>
<p>

Here is the algorithm for Cohen-Sutherland</p>
<p>

procedure CohenSutherlandLineClipAndDraw(
x0,y0,x1,y1,xmin,xmax,ymin,ymax : real ; value: integer);
{ Cohen-Sutherland clipping algorithm for line P0=(x0,y0) to P1=(x1,y1)
and clip rectangle with diagonal from (xmin,ymin) to (xmax,ymax).}
type
edge = (LEFT,RIGHT,BOTTOM,TOP);
outcode = set of edge;
var
accept,done : boolean;
outcode0,outcode1,outcodeOut : outcode;
{Outcodes for P0,P1, and whichever point lies outside the clip rectangle}
x,y : real;
procedure CompOutCode(x,y: real; var code:outcode);
{Compute outcode for the point (x,y) }
begin
code := ;
if      y &amp;gt; ymax then code := [TOP]
else if y  ymin then code := [BOTTOM];</p>
<p>

if      x &amp;gt; xmax then code := code + [RIGHT]
else if x  xmin then code := code + [LEFT]
end;</p>
<p>

begin
accept := false;  done := false;
CompOutCode (x0,y0,outcode0); CompOutCode (x1,y1,outcode1);
repeat
if(outcode0=) and (outcode1=) then {Trivial accept and exit}
begin accept := true; done:=true end
else if (outcode0*outcode1) &amp;gt;  then
done := true {Logical intersection is true,
so trivial reject and exit.}
else
{Failed both tests, so calculate the line segment to clip;
from an outside point to an intersection with clip edge.}
begin
{At least one endpoint is outside the clip rectangle; pick it.}
if outcode0 &amp;gt;  then
outcodeOut := outcode0 else outcodeOut := outcode1;
{Now find intersection point;
use formulas y=y0+slope*(x-x0),x=x0+(1/slope)*(y-y0).}</p>
<p>

if TOP in outcodeOut then
begin     {Divide line at top of clip rectangle}
x := x0 + (x1 - x0) * (ymax - y0) / (y1 - y0);
y := ymax
end
else if BOTTOM in outcodeOut then
begin     {Divide line at bottom of clip rectangle}
x := x0 + (x1 - x0) * (ymin - y0) / (y1 - y0);
y := ymin
end</p>
<p>

if RIGHT in outcodeOut then
begin     {Divide line at right edge of clip rectangle}
y := y0 + (y1 - y0) * (xmax - x0) / (x1 - x0);
x := xmax
end
else if LEFT in outcodeOut then
begin     {Divide line at left edge of clip rectangle}
y := y0 + (y1 - y0) * (xmin - x0) / (x1 - x0);
x := xmin
end;</p>
<p>

{Now we move outside point to intersection point to clip,
and get ready for next pass.}
if (outcodeOut = outcode0) then
begin
x0 := x; y0 := y; CompOutCode(x0,y0,outcode0)
end
else
begin
x1 := x; y1 := y; CompOutCode(x1,y1,outcode1);
end
end   {subdivide}
until done;
if accept then MidpointLineReal(x0,y0,x1,y1,value) {Version for
real coordinates}
end; {CohenSutherlandLineClipAndDraw}</p>


</sec>
<sec>
<st>
See also</st>

<p>

Algorithms used for the same purpose:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../925/1943925.xml">
Liang-Barsky</link></entry>
<entry level="1" type="bullet">

 <link>
Cyrus-Beck</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../118/3478118.xml">
Nicholl-Lee-Nicholl</link></entry>
<entry level="1" type="bullet">

 <link>
Fast-Clipping</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
