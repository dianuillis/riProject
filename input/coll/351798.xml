<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:52:53[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Neighbor-joining</title>
<id>351798</id>
<revision>
<id>244642519</id>
<timestamp>2008-10-11T21:00:31Z</timestamp>
<contributor>
<username>Thorwald</username>
<id>74279</id>
</contributor>
</revision>
<categories>
<category>Computational_phylogenetics</category>
<category>Phylogenetics</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../214/4214.xml">
bioinformatics</link>, <b>neighbor-joining</b> is a bottom-up clustering method used for the construction of <link xlink:type="simple" xlink:href="../962/23962.xml">
phylogenetic</link> <link xlink:type="simple" xlink:href="../806/30806.xml">
tree</link>s. Usually used for trees based on <link xlink:type="simple" xlink:href="../955/7955.xml">
DNA</link> or <link xlink:type="simple" xlink:href="../634/23634.xml">
protein</link> <link xlink:type="simple" xlink:href="../511/24511.xml">
sequence</link> data, the algorithm requires knowledge of the distance between each pair of taxa (e.g. species or sequences) in the tree.  
<sec>
<st>
 The algorithm </st>

<p>

Neighbor-joining is an iterative algorithm. Each iteration consists of the following steps:</p>
<p>

<list>
<entry level="1" type="number">

 Based on the current <link xlink:type="simple" xlink:href="../350/831350.xml">
distance matrix</link> calculate the matrix Q (explained below). </entry>
<entry level="1" type="number">

 Find the pair of taxa in Q with the lowest value. Create a node on the tree that joins these two taxa (i.e. join the closest neighbors, as the algorithm name implies).</entry>
<entry level="1" type="number">

 Calculate the distance of each of the taxa in the pair to this new node.</entry>
<entry level="1" type="number">

 Calculate the distance of all taxa outside of this pair to the new node.</entry>
<entry level="1" type="number">

 Start the algorithm again, considering the pair of joined neighbors as a single taxon and using the distances calculated in the previous step.</entry>
</list>
</p>

<ss1>
<st>
 The Q-matrix </st>

<p>

Based on a distance matrix relating <it>r</it> taxa, calculate Q as follows: </p>
<p>

<indent level="1">

 <math>Q(i,j)=(r-2)d(i,j)-\sum_{k=1}^r d(i,k) - \sum_{k=1}^r d(j,k)</math>
</indent>

<it>d</it>(<it>i</it>,<it>j</it>) is the distance between taxa <it>i</it> and <it>j</it>.</p>
<p>

For example, if we have four taxa (A, B, C, D) and the following distance matrix: </p>
<p>

<table class="wikitable">
<row>

<header>
A</header>
<header>
B</header>
<header>
C</header>
<header>
D</header>
</row>
<row>
<header>
A</header>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
B</header>
<col>
7</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
C</header>
<col>
11</col>
<col>
6</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
D</header>
<col>
14</col>
<col>
9</col>
<col>
7</col>
<col>
&mdash;</col>
</row>
</table>
</p>
<p>

We obtain the following values for the Q matrix:</p>
<p>

<table class="wikitable">
<row>

<header>
A</header>
<header>
B</header>
<header>
C</header>
<header>
D</header>
</row>
<row>
<header>
A</header>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
B</header>
<col>
&amp;minus;40</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
C</header>
<col>
&amp;minus;34</col>
<col>
&amp;minus;34</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
D</header>
<col>
&amp;minus;34</col>
<col>
&amp;minus;34</col>
<col>
&amp;minus;40</col>
<col>
&mdash;</col>
</row>
</table>
</p>
<p>

In the example above, two pairs of taxa have the lowest value, namely &amp;minus;40. We can select either of them for the second step of the algorithm. We follow the example assuming that we joined taxa A and B together.</p>

</ss1>
<ss1>
<st>
 Distance of the pair members to the new node </st>

<p>

For each neighbor in the pair just joined, use the following formula to calculate to the new node (<it>f</it> and <it>g</it> are the paired taxa and <it>u</it> is the newly generated node):</p>
<p>

<indent level="1">

 <math>d(f,u)=\frac{1}{2}d(f,g)+\frac{1}{2(r-2)} \left [ \sum_{k=1}^r d(f,k) - \sum_{k=1}^r d(g,k) \right ] \quad </math>
</indent>

In the example above, this formula would give a distance of 6 between A and the new node. It would also give and a distance of 1 between B and the new node.</p>

</ss1>
<ss1>
<st>
 Distance of the other taxa to the new node </st>

<p>

For each taxon not considered in the previous step, we calculate the distance to the new node as follows:</p>
<p>

<indent level="1">

 <math>d(u,k)=\frac{1}{2} [d(f,k)-d(f,u)] + \frac{1}{2} [d(g,k)-d(g,u)]</math>
</indent>

where <it>u</it> is the new node, <it>k</it> is the node for which we want to calculate the distance and <it>f</it> and <it>g</it> are the members of the pair just joined. </p>
<p>

Following the example, the distance between C and the new node is 5. Also, the distance between the new node and D is 8.</p>

</ss1>
<ss1>
<st>
 The next recursion step </st>

<p>

From the steps above, the following matrix will result (AB acting as a new taxon):</p>
<p>

<table class="wikitable">
<row>

<header>
AB</header>
<header>
C</header>
<header>
D</header>
</row>
<row>
<header>
AB</header>
<col>
&mdash;</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
C</header>
<col>
5</col>
<col>
&mdash;</col>
<col>
&mdash;</col>
</row>
<row>
<header>
D</header>
<col>
8</col>
<col>
7</col>
<col>
&mdash;</col>
</row>
</table>
</p>
<p>

We can start the procedure anew taking this matrix as the original distance matrix. In our example, it suffices to do one more step of the recursion to obtain the complete tree.</p>

</ss1>
</sec>
<sec>
<st>
 Pros and cons of the NJ method </st>

<p>

Neighbor-joining is based on the minimum-evolution criterion for <link xlink:type="simple" xlink:href="../326/149326.xml">
phylogenetic tree</link>s, i.e. the topology that gives the least total branch length is preferred at each step of the algorithm.  However, neighbor-joining may not find the true tree topology with least total branch length because it is a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link> that constructs the tree in a step-wise fashion.  Even though it is sub-optimal in this sense, it has been extensively tested and usually finds a tree that is quite close to the optimal tree.  Nevertheless, it has been largely superseded in phylogenetics by methods that do not rely on distance measures and offer superior accuracy under most conditions.  </p>
<p>

The main virtue of neighbor-joining relative to these other methods is its computational efficiency.  That is, neighbor-joining is a polynomial-time algorithm. It can be used on very large data sets for which other means of phylogenetic analysis (e.g. <link xlink:type="simple" xlink:href="../020/1130020.xml">
minimum evolution</link>, <link xlink:type="simple" xlink:href="../020/1130020.xml">
maximum parsimony</link>, <link xlink:type="simple" xlink:href="../806/140806.xml">
maximum likelihood</link>) are <link xlink:type="simple" xlink:href="../926/5926.xml">
computation</link>ally prohibitive. Unlike the <link xlink:type="simple" xlink:href="../968/355968.xml">
UPGMA</link> algorithm for phylogenetic tree reconstruction, neighbor-joining does not assume that all lineages evolve at the same rate (<link xlink:type="simple" xlink:href="../001/250001.xml">
molecular clock hypothesis</link>) and produces an unrooted tree. Rooted trees can be created by using an <link xlink:type="simple" xlink:href="../183/948183.xml">
outgroup</link> and the root can then effectively be placed on the point in the tree where the edge from the outgroup connects. </p>
<p>

Furthermore, neighbor-joining is <link>
statistically consistent</link> under many models of evolution. Hence, given data of sufficient length, neighbor-joining will reconstruct the true tree with high probability.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../968/355968.xml">
UPGMA</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 Atteson K (1997). "The performance of neighbor-joining algorithms of phylogeny reconstruction", pp. 101&ndash;110. <it>In</it> Jiang, T., and Lee, D., eds., <it>Lecture Notes in Computer Science, 1276</it>, Springer-Verlag, Berlin. COCOON '97.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Gascuel O, Steel M&#32;(2006).&#32;"Neighbor-joining revealed". <it>Mol Biol Evol</it>&#32;<b>23</b>&#32;(11): 1997-2000. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1093%2Fmolbev%2Fmsl072">
10.1093/molbev/msl072</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 Mihaescu R, Levy D, Pachter L (2006). "<weblink xlink:type="simple" xlink:href="http://arxiv.org/abs/cs.DS/0602041">
Why neighbor-joining works</weblink>".</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Saitou N, Nei M&#32;(1987).&#32;"<weblink xlink:type="simple" xlink:href="http://mbe.oxfordjournals.org/cgi/reprint/4/4/406">
The neighbor-joining method: a new method for reconstructing phylogenetic trees</weblink>". <it>Mol Biol Evol</it>&#32;<b>4</b>&#32;(4): 406-425. PMID 3447015.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Studier JA, Keppler KJ&#32;(1988).&#32;"<weblink xlink:type="simple" xlink:href="http://mbe.oxfordjournals.org/cgi/reprint/5/6/729.pdf">
A note on the Neighbor-Joining algorithm of Saitou and Nei</weblink>". <it>Mol Biol Evol</it>&#32;<b>5</b>&#32;(6): 729-731. PMID 3221794.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.icp.be/~opperd/private/neighbor.html">
The Neighbor-Joining Method</weblink> &mdash; a tutorial</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
Topics in <link xlink:type="simple" xlink:href="../962/23962.xml">
phylogenetics</link></header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
Relevant fields</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../130/3986130.xml">
Computational phylogenetics</link>&nbsp;·  <link xlink:type="simple" xlink:href="../544/149544.xml">
Molecular phylogeny</link>&nbsp;·  <link xlink:type="simple" xlink:href="../376/5376.xml">
Cladistics</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Basic concepts</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../006/1006006.xml">
Synapomorphy</link>&nbsp;·  <link xlink:type="simple" xlink:href="../326/149326.xml">
Phylogenetic tree</link>&nbsp;·  <link xlink:type="simple" xlink:href="../198/3657198.xml">
Phylogenetic network</link>&nbsp;·  <link xlink:type="simple" xlink:href="../260/2388260.xml">
Long branch attraction</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Inference methods</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../020/1130020.xml">
Maximum parsimony</link>&nbsp;·   <link xlink:type="simple" xlink:href="../806/140806.xml">
Maximum likelihood</link>&nbsp;·  <link xlink:type="simple" xlink:href="../798/351798.xml">
Neighbor-joining</link>&nbsp;·  <link xlink:type="simple" xlink:href="../968/355968.xml">
UPGMA</link>&nbsp;·  <link xlink:type="simple" xlink:href="../979/7022979.xml">
Bayesian inference</link>&nbsp;·  <link xlink:type="simple" xlink:href="../498/9950498.xml">
Least squares</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Current topics</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../324/436324.xml">
PhyloCode</link>&nbsp;·  <link xlink:type="simple" xlink:href="../851/2613851.xml">
DNA barcoding</link></col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
<link xlink:type="simple" xlink:href="../016/635016.xml">
List of evolutionary biology topics</link></col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</entity>
</article>
