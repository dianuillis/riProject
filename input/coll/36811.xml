<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:39:43[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<condition  confidence="0.8" wordnetid="113920835">
<state  confidence="0.8" wordnetid="100024720">
<problem  confidence="0.8" wordnetid="114410605">
<difficulty  confidence="0.8" wordnetid="114408086">
<header>
<title>Subset sum problem</title>
<id>36811</id>
<revision>
<id>240504690</id>
<timestamp>2008-09-23T19:11:18Z</timestamp>
<contributor>
<username>Eukesh</username>
<id>133061</id>
</contributor>
</revision>
<categories>
<category>Dynamic programming</category>
<category>NP-complete problems</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>subset sum problem</b> is an important problem in <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity theory</link> and <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>.  The problem is this: given a set of integers, does the sum of some non-empty subset equal exactly zero?  For example, given the set { &amp;minus;7, &amp;minus;3, &amp;minus;2, 5, 8}, the answer is YES because the subset { &amp;minus;3, &amp;minus;2, 5} sums to zero.  The problem is <link xlink:type="simple" xlink:href="../466/39466.xml">
NP-Complete</link>.<p>

An equivalent problem is this: given a set of integers and an integer <it>s</it>, does any non-empty subset sum to <it>s</it>?  Subset sum can also be thought of as a special case of the <link xlink:type="simple" xlink:href="../974/16974.xml">
knapsack problem</link>.  One interesting special case of subset sum is the <link xlink:type="simple" xlink:href="../567/3269567.xml">
partition problem</link>, in which <it>s</it> is half of the sum of all elements in the set.</p>

<sec>
<st>
 General discussion </st>

<p>

The subset sum problem is a good introduction to the NP-complete class of problems. There are two reasons for this</p>
<p>

<list>
<entry level="1" type="bullet">

 It is a <link xlink:type="simple" xlink:href="../336/8336.xml">
decision</link> and not an <link xlink:type="simple" xlink:href="../536/1126536.xml">
optimization problem</link></entry>
<entry level="1" type="bullet">

 It has a very simple formal definition and problem statement.</entry>
</list>
</p>
<p>

A solution that has a ± 1% precision is good enough for many physical problems. Being asked to solve a subset sum problem for 100-digit numbers with a precision of ±10&amp;minus;100 might seem silly and irrelevant. There are reasons why this is not the case.</p>
<p>

First, the number of place values in the problem is essentially equivalent to the number of simultaneous constraints that need to be solved. A numerical precision of 1% means solving the problem to just the first 7 base two place values (any numerical error after that is less than 1/128 of the first digit). However, if there are 100 base 2 place values in the problem, solving just 7 of them amounts to solving only 7% of the constraints. Moreover, given that the volume of the solution space in this case would be 2100, and you have only covered a volume of 27, then there is still a solution space of 293 left uncovered. In this way a solution with a 1% numerical precision has covered essentially none of the real problem. The only way that a solution to the Subset Sum Problem can be used as a solution to other NP problems is to solve all of the problem (and all of the constraints) exactly.</p>
<p>

Second, in at least one context, it is actually important to solve real subset sum problems exactly. In cryptography, Subset Sum problem comes up when a codebreaker attempts, given a message and <link xlink:type="simple" xlink:href="../294/10294.xml">
ciphertext</link>, to deduce the secret <link xlink:type="simple" xlink:href="../039/53039.xml">
key</link>. A key that is not equal to but within ± 1% of the real key is essentially useless for the codebreaker.</p>
<p>

Lastly, from a purely theoretical point of view it the exact problem and its solution are of interest.</p>
<p>

Although the subset sum problem is a decision problem, the cases when an approximate solution is sufficient have also been studied, in the field of <link xlink:type="simple" xlink:href="../105/563105.xml">
approximations algorithms</link>. One algorithm for the approximate version of the subset sum problem is given below.</p>

</sec>
<sec>
<st>
 The complexity of subset sum </st>

<p>

The complexity (difficulty of solution) of subset sum can be viewed as depending on two parameters, <it>N</it>, the number of decision variables, and <it>P</it>, the precision of the problem (stated as the number of binary place values that it takes to state the problem). (Note: here the letters <it>N</it> and <it>P</it> mean something different than what they mean in the <it>NP</it> class of problems.)</p>
<p>

The complexity of the best known algorithms is exponential in the smaller of the two parameters <it>N</it> and <it>P</it>. Thus, the problem is most difficult if <it>N</it> and <it>P</it> are of the same order. It only becomes easy if either <it>N</it> or <it>P</it> becomes very small. </p>
<p>

If <it>N</it> (the number of variables) is small, then an exhaustive search for the solution is practical. If <it>P</it> (the number of place values) is a small fixed number, then there are dynamic programming algorithms that can solve it exactly.</p>
<p>

What is happening is that the problem becomes seemingly non-exponential when it is practical to count the entire solution space. There are two ways to count the solution space in the subset sum problem. One is to count the number of ways the variables can be combined. There are 2N possible ways to combine the variables. However, with N = 10, there are only 1024 possible combinations to check. These can be counted easily with a branching search. The other way is to count all possible numerical values that the combinations can take. There are 2P possible numerical sums. However, with P = 5 there are only 32 possible numerical values that the combinations can take. These can be counted easily with a dynamic programming algorithm. When N = P and both are large, then there is no aspect of the solution space that can be counted easily.</p>
<p>

Efficient algorithms for both small <it>N</it> and small <it>P</it> cases are given below.</p>

</sec>
<sec>
<st>
 Exponential time algorithm </st>

<p>

There are several ways to solve subset sum in time exponential in N. The most naïve algorithm would be to cycle through all subsets of N numbers and, for every one of them, check if the subset sums to the right number. The running time is of order <it>O(2NN)</it>, since there are <it>2N</it> subsets and, to check each subset, we need to sum at most <it>N</it> elements.</p>
<p>

A better exponential time algorithm is known, which runs in time <it>O(2N/2N)</it>. The algorithm splits the <it>N</it> elements into two sets of <it>N/2</it> each. For each of these two sets, it calculates sums of all <it>2N/2</it> possible subsets of its elements and stores them in an array of length <it>2N/2</it>. It then sorts each of these two arrays, which can be done in time <it>O(2N/2N)</it>. When arrays are sorted, the algorithm can check if an element of the first array and an element of the second array sum up to <it>s</it> in time <it>O(2N/2)</it>. To do that, the algorithm passes through the first array in decreasing order (starting at the largest element) and the second array in increasing order (starting at the smallest element). Whenever the sum of the current element in the first array and the current element in the second array is more than <it>s</it>, the algorithm moves to the next element in the first array. If it is less than <it>s</it>, the algorithm moves to the next element in the second array. If two elements with sum <it>s</it> are found, it stops.</p>
<p>

No better algorithm has been found since Horowitz and Sahni first published this algorithm in 1974, suggesting that this improved algorithm may have the best running-time possible of all algorithms which solve the subset sum problem. If true, this would imply that <math>P \ne NP</math>, which is one of the most famous long standing unsolved problems (see <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../115/6115.xml">
P = NP problem</link></group>
</collection>
</difficulty>
</problem>
</class>
</state>
</condition>
).</p>

</sec>
<sec>
<st>
 Pseudo-polynomial time dynamic programming solution </st>

<p>

The problem can be solved as follows using <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>. Suppose the sequence is</p>
<p>

<indent level="1">

<it>x1</it>, ..., <it>xn</it>
</indent>

and we wish to find a nonempty subset which sums to zero.</p>
<p>

Let <it>N</it> be the sum of the negative values and <it>P</it> the sum of the positive values.  Define the function <it>Q(i,s) to be </it>'0<b> if there is no subset of <it>x1</it></b><b>, ..., <it>xi</it></b><b> which sums to <it>s</it></b><b>; </b>1<b> if there is a nonempty such subset; or </b>2<b> if only empty subset sums to <it>s</it></b><b> (i.e. when <it>s</it></b><b> is zero).</b></p>
<p>

(Thus, the question we really want to know is whether <it>Q</it>(n,0) equals <b>1</b>.)</p>
<p>

Clearly:
<it>Q(i,s) = </it>'0<b> for <it>sN</it></b><b> or <it>s</it></b><b>&amp;gt;<it>P</it></b><b>. </b></p>
<p>

Create an array to hold the values <it>Q(i,s)</it> for 1&amp;le;<it>i</it>&amp;le;<it>n</it> and <it>N</it>&amp;le;<it>s</it>&amp;le;<it>P</it>.  The array can now be filled in using a simple recursion.  </p>
<p>

Initialize all <it>Q(1,s)</it> to <b>0</b>. Let <it>Q(1,0)</it> be <b>2</b>. Let <it>Q(1, x1)</it> be <b>1</b>. For <it>i</it>&amp;gt;1, if <it>Q(i-1,s-xi)</it> is nonzero, let <it>Q(i,s)</it> be <b>1</b> otherwise let it be value of <it>Q(i-1,s)</it>.</p>
<p>

(Note that <it>Q(i,s)</it> can be made a boolean valued function if we are interested in subset which sums to something other than zero.)</p>
<p>

The total number of arithmetic operations is </p>
<p>

<indent level="1">

<it>O</it>(<it>n</it>(<it>P</it> &amp;minus; <it>N</it>)).  
</indent>

For example, if all the values are </p>
<p>

<indent level="1">

<it>O</it>(<it>nk</it>)
</indent>

for some <it>k</it>, then the time required is </p>
<p>

<indent level="1">

<it>O</it>(<it>nk+1</it>).
</indent>

This solution does not count as polynomial time in complexity theory because <it>P-N</it> is not polynomial in the <it>size</it> of the problem, which is the number of bits used to represent it.  This algorithm is polynomial in the value of N and P, which are exponential in their numbers of bits.</p>

</sec>
<sec>
<st>
 Polynomial time approximate algorithm </st>

<p>

An <link xlink:type="simple" xlink:href="../105/563105.xml">
approximate</link> version of the subset sum would be: given a set of <it>N</it> numbers <it>x1</it>, <it>x2</it>, ..., <it>xN</it> and a number <it>s</it>, output
<list>
<entry level="1" type="bullet">

 yes, if there is a subset that sums up to <it>s</it>;</entry>
<entry level="1" type="bullet">

 no, if there is no subset summing up to a number between <it>(1-c)s</it> and <it>s</it> for some small <it>c&amp;gt;0</it>;</entry>
<entry level="1" type="bullet">

 any answer, if there is a subset summing up to a number between <it>(1-c)s</it> and <it>s</it> but no subset summing up to <it>s</it>.</entry>
</list>

If all numbers are non-negative, the approximate subset sum is solvable in time polynomial in <it>N</it> and <it>1/c</it>. </p>
<p>

The solution for subset sum also provides the solution for the original subset sum problem in the case where the numbers are small (again, for nonnegative numbers). If any sum of the numbers can be specified with at most <it>P</it> bits, then solving the problem approximately with <it>c=2-P</it> is equivalent to solving it exactly. Then, the polynomial time algorithm for approximate subset sum becomes an exact algorithm with running time polynomial in <it>N</it> and <it>2P</it> (i.e., exponential in <it>P</it>). </p>
<p>

The algorithm for the approximate subset sum problem is as follows:
initialize a list <it>S</it> to contain one element 0.
for each <it>i</it> from 1 to <it>N</it> do
let <it>T</it> be a list consisting of <it>xi+y</it>, for all <it>y</it> in <it>S</it>
let <it>U</it> be the union of <it>T</it> and <it>S</it>
sort <it>U</it>
make <it>S</it> empty 
let <it>y</it> be the smallest element of <it>U</it> 
add <it>y</it> to <it>S</it> 
for each element <it>z</it> of <it>U</it> in increasing order do //trim the list by eliminating numbers close one to another
if <it>y(1-c/N)z</it>, set <it>y=z</it> and add <it>z</it> to <it>S</it> 
if <it>S</it> contains a number between <it>(1-c)s</it> and <it>s</it>, output <it>yes</it>, otherwise <it>no</it>
The algorithm is polynomial time because the lists <it>S</it>, <it>T</it> and <it>U</it> always remain of size polynomial in <it>N</it> and <it>1/c</it> and, as long as they are of polynomial size, all operations on them can be done in polynomial time. The size of lists is kept polynomial by the trimming step, in which we only include a number <it>z</it> into <it>S</it> if the previous <it>y</it> is at most </p>
<p>

<indent level="1">

(1 &amp;minus; <it>c</it>/<it>N</it>)<it>z</it>. 
</indent>

This step ensures that each element in <it>S</it> is smaller than the next one by at least a factor of (1 &amp;minus; <it>c</it>/<it>N</it>) and any list with that property is of at most polynomial size.</p>
<p>

The algorithm is correct because each step introduces a multiplicative error of at most (1 &amp;minus;<it>c</it>/<it>N</it>) and <it>N</it> steps together introduce the error of at most  </p>
<p>

<indent level="1">

(1 &amp;minus; <it>c</it>/<it>N</it>)<it>N</it>  1 &amp;minus; <it>c</it>.
</indent>

</p>
</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Cormen-2001" style="font-style:normal" class="book"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Cormen, Thomas H.</link></scientist>
;&#32;<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Leiserson, Charles E.</link></scientist>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../057/68057.xml">
Rivest, Ronald L.</link></scientist>
</person>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Stein, Clifford</link></scientist>
&#32;[1990]&#32;(2001).&#32;"35.5: The subset-sum problem", <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, 2nd edition,&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../601/719601.xml">
MIT Press</link></company>
 and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../269/651269.xml">
McGraw-Hill</link></company>
. ISBN 0-262-03293-7.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><link xlink:type="simple" xlink:href="../372/1709372.xml">
Michael R. Garey</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../983/577983.xml">
David S. Johnson</link></associate>
</scholar>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</peer>
</physical_entity>
&#32;(1979). Computers and Intractability: A Guide to the Theory of NP-Completeness.&#32;W.H. Freeman. ISBN 0-7167-1045-5.</cite>&nbsp; A3.2: SP13, pg.223.</entry>
</list>
</p>



</sec>
<sec>
<st>
 External links </st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.geocities.com/SiliconValley/Garage/3323/aat/a_diop.html#diophant">
An algorithm (exponential time) for solving the subset sum problem</weblink></entry>
</list>


</p>

</sec>
</bdy>
</difficulty>
</problem>
</state>
</condition>
</article>
