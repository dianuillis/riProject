<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:39:25[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Dekker&apos;s algorithm</title>
<id>36826</id>
<revision>
<id>239446609</id>
<timestamp>2008-09-19T02:40:24Z</timestamp>
<contributor>
<username>Michael Slone</username>
<id>279360</id>
</contributor>
</revision>
<categories>
<category>Distributed systems</category>
<category>Concurrency control</category>
<category>Concurrent algorithms</category>
</categories>
</header>
<bdy>

<b>Dekker's algorithm</b> is a <link xlink:type="simple" xlink:href="../605/2581605.xml">
concurrent programming</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> derived by the <link xlink:type="simple" xlink:href="../551/1656551.xml">
Dutch</link> <link xlink:type="simple" xlink:href="../902/18902.xml">
mathematician</link> <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../442/6036442.xml">
T. J. Dekker</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 in 1964 that allows two threads to share a single-use resource without conflict, using only <link xlink:type="simple" xlink:href="../653/825653.xml">
shared memory</link> for communication. <p>

It avoids the strict alternation of a naive turn-taking algorithm, and was one of the first mutual exclusion algorithms to be invented.</p>

<sec>
<st>
Introduction</st>

<p>

If two processes attempt to enter a <link xlink:type="simple" xlink:href="../312/638312.xml">
critical section</link> at the same time, the algorithm will allow only one process in, based on whose turn it is. If one process is already in the critical section, the other process will <link xlink:type="simple" xlink:href="../489/671489.xml">
Busy wait</link> for the first process to exit.  This is done by the use of two flags f0 and f1 which indicate an intention to enter the critical section and a turn variable which indicates who has priority between the two processes.</p>

</sec>
<sec>
<st>
Pseudocode</st>

<p>

f0 := false
f1 := false
turn := 0   // or 1</p>
<p>

p0:                                 p1:
f0 := true                          f1 := true
<b>while</b> f1 {                          <b>while</b> f0 {
<b>if</b> turn ≠ 0 {                       <b>if</b> turn ≠ 1 {
f0 := false                         f1 := false
<b>while</b> turn ≠ 0 {                    <b>while</b> turn ≠ 1 {
}                                   }
f0 := true                          f1 := true
}                                  }
}                                    }</p>
<p>

// critical section                   // critical section 
...                                   ...
// remainder section                  // remainder section
turn := 1                             turn := 0
f0 := false                           f1 := false</p>
<p>

Processes indicate an intention to enter the critical section which is tested by the outer while loop.  If the other process has not flagged intent, the critical section can be entered safely irrespective of the current turn.  Mutual exclusion will still be guaranteed as neither process can become critical before setting their flag (implying at least one process will enter the while loop).  This also guarantees progress as waiting will not occur on a process which has withdrawn intent to become critical.  Alternatively, if the other process's variable was set the while loop is entered and the turn variable will establish who is permitted to become critical.  Processes without priority will withdraw their intention to enter the critical section until they are given priority again (the inner while loop).  Processes with priority will break from the while loop and enter their critical section. </p>
<p>

Dekker's algorithm guarantees mutual exclusion, freedom from deadlock, and freedom from starvation. Let us see why the last property holds. Suppose p0 is stuck inside the "while f1" loop forever. There is freedom from deadlock, so eventually p1 will proceed to its critical section and set turn = 0 (and the value of turn will remain unchanged as long as p0 doesn't progress). Eventually p0 will break out of the inner "while turn ≠ 0" loop (if it was ever stuck on it). After that it will set f0 := true and settle down to waiting for f1 to become false (since turn = 0, it will never do the actions in the while loop). The next time p1 tries to enter its critical section, it will be forced to execute the actions in its "while f0" loop. In particular, it will eventually set f1 = false and get stuck in the "while turn ≠ 1" loop (since turn remains 0). The next time control passes to p0, it will exit the "while f1" loop and enter its critical section.  </p>
<p>

If the algorithm were modified by performing the actions in the "while f1" loop without checking if turn = 0, then there is a possibility of starvation. Thus all the steps in the algorithm are necessary.</p>

</sec>
<sec>
<st>
Note</st>

<p>

One advantage of this algorithm is that it doesn't require special <link xlink:type="simple" xlink:href="../099/394099.xml">
Test-and-set</link> (atomic read/modify/write) instructions and is therefore highly portable between languages and machine architectures.  One disadvantage is that it is limited to two processes and makes use of <link xlink:type="simple" xlink:href="../489/671489.xml">
Busy waiting</link> instead of process suspension.  (The use of busy waiting suggests that processes should spend a minimum of time inside the critical section.)</p>
<p>

Modern operating systems provide mutual exclusion primitives that are more general and flexible than Dekker's algorithm.  However, it should be noted that in the absence of actual contention between the two processes, the entry and exit from critical section is extremely efficient when Dekker's algorithm is used.</p>
<p>

Many modern <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link>s execute their instructions in an out-of-order fashion. This algorithm won't work on <link xlink:type="simple" xlink:href="../318/50318.xml">
SMP</link> machines equipped with these CPUs without the use of <link xlink:type="simple" xlink:href="../216/728216.xml">
memory barrier</link>s. </p>
<p>

Additionally, many optimizing compilers can perform transformations that will cause this algorithm to fail regardless of the platform.  In many languages, it is legal for a compiler to detect that the flag variables <it>f0</it> and <it>f1</it> are never accessed in the loop.  It can then remove the writes to those variables from the loop, using a process called <change_of_state wordnetid="100199130" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<change wordnetid="100191142" confidence="0.8">
<improvement wordnetid="100248977" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<optimization wordnetid="100260051" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../357/807357.xml">
Loop-invariant code motion</link></psychological_feature>
</act>
</optimization>
</action>
</improvement>
</change>
</event>
</change_of_state>
.  It would also be possible for many compilers to detect that the <it>turn</it> variable is never modified by the inner loop, and perform a similar transformation, resulting in a potential <link xlink:type="simple" xlink:href="../273/45273.xml">
infinite loop</link>.  If either of these transformations is performed, the algorithm will fail, regardless of architecture.</p>
<p>

To alleviate this problem, <link xlink:type="simple" xlink:href="../846/944846.xml">
volatile</link> variables should be marked as modifiable outside the scope of the currently executing context. For example, in Java, one would annotate these variables as 'volatile'.  Note however that the C/C++ "volatile" attribute only guarantees that the compiler generates code with the proper ordering; it does not include the necessary <link>
memory barriers</link> to guarantee in-order <it>execution</it> of that code.</p>

</sec>
<sec>
<st>
See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../891/331891.xml">
Peterson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../076/2176076.xml">
Lamport's bakery algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>




</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</instrumentality>
</artifact>
</system>
</article>
