<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:45:40[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Turing&apos;s proof</title>
<id>3739933</id>
<revision>
<id>227508504</id>
<timestamp>2008-07-23T22:31:48Z</timestamp>
<contributor>
<username>Giftlite</username>
<id>37986</id>
</contributor>
</revision>
<categories>
<category>Proofs</category>
<category>theory of computation</category>
<category>Articles containing proofs</category>
<category>mathematical logic</category>
</categories>
</header>
<bdy>

First published in January <link xlink:type="simple" xlink:href="../684/34684.xml">
1937</link> with the title On <it>Computable Numbers, With an Application to the <link xlink:type="simple" xlink:href="../672/9672.xml">
Entscheidungsproblem</link></it>, <b>Turing's proof</b> was the second proof of the assertion (Alonzo Church proof was first) that some questions are "undecidable": they have neither YES nor NO answers within an axiom framework. In his own words:
"...what I shall prove is quite different from the well-known results of Gödel ... I shall now show that there is no general method which tells whether a given formula <b>U</b> is provable in <b>K</b> [Principia Mathematica]..." (Undecidable p. 145).<p>

Turing preceded this proof with two others. The second and third both rely on the first. All rely on his development of type-writer-like "computing machines" that obey a simple set of rules and his subsequent development of a "universal computing machine".</p>

<sec>
<st>
 The first description of a mechanical process-as-algorithm </st>
<p>

See <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
, <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link>, and <link xlink:type="simple" xlink:href="../668/13668.xml">
Halting problem</link> for more details.</p>
<p>

Until Turing's paper, <link xlink:type="simple" xlink:href="../407/25407.xml">
recursion</link> -- the successive applications of a kind of <link xlink:type="simple" xlink:href="../881/18881.xml">
induction</link>-like repetitive process -- were the methods <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../731/49731.xml">
Alonzo Church</link></scientist>
 et al. used to investigate whether or not all mathematical formulas could be reduced to a single "method". One of the more interesting examples of "recursion" is the following (it generates, by "finite differences", the curve 1&nbsp;−&nbsp;exp(−<it>kx</it>), where <it>x</it> = 0, 1, 2, 3, 4,....):</p>
<p>

<indent level="1">

 (1) Start with V = 0, let K be a constant -- positive but less than 1
</indent>
: (2) Let Vnew = Vold + k* (1 - Vold) [the arrow = indicates "replace"]
<indent level="1">

 (3) Do (2) until hell freezes over.
</indent>

If we choose k = 0.5, we get the following sequence:
<indent level="1">

 { 0, 0.5, 0.75, 0.875, ...., just a hair less than 1 }.
</indent>

The lasting legacy of Turing's work was his description of a "method" that was entirely, utterly, completely mechanical-- we just "program it", plug it in and (given we've programmed it well) it cranks out its number. Thus Turing defined a "tool" so precise it has become lingua franca among mathematicians and logicians. But he didn't stop there: he showed how to make write a single "universal" program that can interpret any "program" it finds on its tape (its memory). Some programs put there would be "well formed" -- that is, they will "run". Other programs put there won't be "well formed" -- and they won't "run". But in either case, Turing presented us with an absolute, <it>constructive</it> description of a mathematical process -- we can "construct" it, truly. </p>
<p>

[Quote from Alonzo Church here, re Turing's demonstration]</p>
<p>

Over the years his proofs have been superseded by easier proofs. [More here -- e.g. [[halting problem]], and Encyclopedia Britannia entry Meta-mathematics]</p>

</sec>
<sec>
<st>
 Richard's paradox </st>

<p>

In 1905 Jules Richard presented this profound paradox. <b>Alan Turing's first proof</b> constructs this paradox with his so-called computing machine and proves that this machine cannot answer a simple question: will this machine be able to determine if <it>any</it> computing machine (including itself) will become trapped in an unproductive "infinite loop" (i.e. it fails to continue its computation of the diagonal number).</p>
<p>

A succinct definition of <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<contradiction wordnetid="107206887" confidence="0.8">
<paradox wordnetid="106724559" confidence="0.8">
<falsehood wordnetid="106756407" confidence="0.8">
<link xlink:type="simple" xlink:href="../812/97812.xml">
Richard's paradox</link></falsehood>
</paradox>
</contradiction>
</message>
</statement>
 is found in Whitehead and Russell's <it>Principia Mathematica</it>:</p>
<p>

"Richard's paradox... is as follows. Consider all decimals that can be defined by means of a finite number of words [boldface added for emphasis, "words" are symbols]; let E be the class of such decimals. Then E has [aleph-sub-zero-- an infinity of] terms; hence its members can be ordered as the 1st, 2nd, 3rd, ... Let N be a number defined as follows [Whitehead &amp; Russell now employ the Cantor diagonal method]; If the nth figure in the nth decimal is p, let the nth figure in N be p+1 (or 0, if p = 9). Then N is different from all the members of E, since, whatever finite value n may have, the nth figure in N is different from the nth figure in the nth of the decimals composing E, and therefore N is different from the nth decimal. Nevertheless we have defined N in a finite number of words [i.e. this very word-definition just above!] and therefore N ought to be a member of E. Thus N both is and is not a member of E" (Principia Mathematica, 2nd edition 1927, p. 61).</p>

</sec>
<sec>
<st>
 Complications </st>
<p>

Turing's proof is complicated by a large number of definitions, and confounded with what <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 called "petty technical details" and "...technical details [that] are incorrect as given" (Davis's commentary in Undecidable, p. 115) . Turing himself published "A correction" in 1937: "The author is indebted to P. <link xlink:type="simple" xlink:href="../224/2282224.xml">
Bernays</link> for pointing out these errors" (Undecidable, p. 152).</p>
<p>

Specifically, in its original form the third proof is badly marred by technical errors. And even after Bernays' suggestions and Turing's corrections, errors remained in the description of the <link xlink:type="simple" xlink:href="../403/30403.xml">
universal machine</link>. And confusingly, since Turing was unable to correct his original paper, some text within the body harks to Turing's flawed first effort.</p>
<p>

Bernays' corrections may be found in <it>The Undecidable</it>, pp. 152-154; the original is to be found as:
<indent level="1">

 <it>On computable Numbers, with An Application to the Entscheidungsproblem. A Correction</it>., Proceedings of the London Mathematical Society (2), 43 (1937), 544-546.</indent>

The on-line version of Turing's paper has these corrections in an addendum; however, corrections to the Universal Machine must be found in an analysis provided by <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link>.</p>
<p>

At first, the only mathematician to pay close attention to the details of the proof was Post (cf Hodges p. 125) -- mainly because he had arrived simultaneously at a similar reduction of "algorithm" to primitive machine-like actions, so he took a personal interest in the proof . Strangely (perhaps World War II intervened) it took Post some ten years to dissect it in the <it>Appendix</it> to his paper <it>Recursive Unsolvability of a Problem of Thue</it>, 1947, (reprinted in Undecidable p. 293).</p>
<p>

<it>Before readers tackle "Proof #3" we strongly advise that they place those corrections on their copy of the proof.</it> </p>
<p>

Other problems present themselves: In his <it>Appendix</it> Post commented indirectly on the paper's difficulty and directly on its "outline nature" (Post in Undecidable p. 299) and "intuitive form" of the proofs (ibid). Post had to infer various points:</p>
<p>

<indent level="1">

 "If our critique is correct, a machine is said to be circle-free if it is a Turing computing ... machine which prints an infinite number of 0's and 1's. And the two theorems of Turing's in question are really the following. There is no Turing ... machine which, when supplied with an arbitrary positive integer n, will determine whether n is the D.N of a Turing computing ... machine that is circle-free. [Secondly], There is no Turing convention-machine which, when supplied with an arbitrary positive integer n, will determine whether n is the D.N of a Turing computing ... machine that ever prints a given symbol (0 say)" (Post in Undecidable p. 300)
</indent>

Anyone who has ever tried to read the paper will understand Hodges' complaint:</p>
<p>

<indent level="1">

 "The paper started attractively, but soon plunged (in typical Turing manner) into a thicket of obscure German Gothic type in order to develop his instruction table for the universal machine. The last people to give it a glance would be the applied mathematians who had to resort to practical computation..." (Hodges p. 124)
</indent>

Proof #1 is wonderful -- although by <link xlink:type="simple" xlink:href="../418/25418.xml">
reductio ad absurdum</link> form of proof --it is constructive and does not require much mathematics. </p>
<p>

Proof #2, on the other hand, uses <link xlink:type="simple" xlink:href="../418/25418.xml">
reductio ad absurdum</link> in a way -- via use of the negated "for all" operation ( i.e. "Not true that 'for all X: Y'") -- that might raise in the reader's mind questions around <law wordnetid="108441203" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/17637.xml">
Law of excluded middle</link></group>
</collection>
</law>
 and "an infinity of possibles". A bit of discussion of the <link xlink:type="simple" xlink:href="../806/228806.xml">
logical quantifier</link>s 'there exists at least one X' and 'for all X' attempts to provide a bit of help.  </p>
<p>

If readers brave Proof #3, they should come equipped with a solid background in (i) logic (ii) the paper of <link>
Kurt Gödel</link> <it>On Formally Undecidable Propositions of Principia Mathematica and Related Systems</it>, (reprinted in Undecidable p. 5). For assistance with Gödel's paper they should consult <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<philosopher wordnetid="110423589" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../778/1216778.xml">
Ernest Nagel</link></associate>
</scholar>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</philosopher>
</peer>
</physical_entity>
 and <link xlink:type="simple" xlink:href="../921/623921.xml">
James Newman</link>, <it>Godel’s Proof</it>, New York University Press, 1958.</p>

</sec>
<sec>
<st>
 Summary of the proofs </st>
<p>

In his proof that the "Entsheidungsproblem" can have no solution, Turing proceeded from two proofs that were to lead to his final proof. His first theorem is most relevant to the <link xlink:type="simple" xlink:href="../668/13668.xml">
Halting Problem</link>, the second is more relevant to <link xlink:type="simple" xlink:href="../852/25852.xml">
Rice's Theorem</link>. </p>
<p>

First proof: that no "computing machine" exists that can decide whether or not a "computing machine" is "circle-free" (i.e. goes on printing its number in binary ad infinitum): "...we have no general process for doing this in a finite number of steps" (p. 132, ibid). Turing's proof, although it seems to use the "diagonal process", in fact shows that his machine (called H) cannot calculate its own number, let alone the entire diagonal number (<link xlink:type="simple" xlink:href="../426/51426.xml">
Cantor's diagonal argument</link>): "The fallacy in the argument lies in the assumption that B [the diagonal number] is computable" (U p. 132).</p>
<p>

Second proof: This one is perhaps more familiar to readers: "We can show further that <it>there can be no machine E which, when supplied with the S.D ["program"] of an arbitrary machine M, will determine whether M ever prints a given symbol (0 say)</it>" (his italics, U p. 134).</p>
<p>

Third proof: "Corresponding to each computing machine M we construct a formula Un(M) and we show that, if there is a general method for determining whether Un(M) is provable, then there is a general method for determining whether M ever prints 0" (p. 145) </p>
<p>

This proof requires the use of formal logic to prove a first lemma, (difficult but mercifully short), followed by a brief word-proof of the second:
<indent level="1">

 "Lemma 1: If S1 [symbol "0"] appears on the tape in some complete configuration of M, then Un(M) is provable" (p. 147)
</indent>

<indent level="1">

 "Lemma 2: [The converse] If Un(M) is provable then S1 [symbol "0"] appears on the tape in some complete configuration of M" (p. 148)
</indent>

Finally, in only 64 words and symbols Turing proves by <it>reductio ad absurdum</it> that "the Hilbert <it>Entscheidungsproblem</it> can have no solution" (U p. 145).</p>

</sec>
<sec>
<st>
 Summary of the first proof </st>
<p>

Some key clarifications:
<indent level="1">

 Turing's machine H is attempting to print a diagonal number
</indent>
:: This diagonal number is created when H actually "simulates" each "successful" machine under evaluation and prints the R-th "figure" (1 or 0, binary) of the R-th "successful" machine/
<list>
<entry level="1" type="bullet">

 Turing spent much of his paper actually "constructing" his machines to convince us of their truth. This was required by his use of the <it>reductio ad absurdum</it> form of proof.</entry>
<entry level="1" type="bullet">

 We must emphasize the "constructive" nature of this proof. Turing describes what could be real machine, really buildable. The only questionable element is the existence of machine D, which this proof will eventually show to be impossible.</entry>
</list>
</p>
<p>

Turing begins the proof with the assertion of the existence of a “decision/determination” machine D. When fed any S.D (string of symbols A, C, D. L, R, N, semicolon “;”)  it will determine if this S.D (symbol string) represents a "computing machine" that is either "circular"-- and therefore "un-satisfactory u" --  or "circle-free"-- and therefore "satisfactory s".</p>
<p>

<indent level="1">

 Turing has previously demonstrated that all "computing machines<it>-- machines that compute a number as 1's and 0's forever-- can be written as an S.D on the tape of the “universal machine” U. Most of his work leading up to his first proof is spent demonstrating that the universal machine truly exists, i.e. 
</it></indent>
:: There truly exists a universal machine U
<indent level="2">

 For each number N, there truly exists a unique S.D, 
</indent>
:: Every Turing machine has an S.D
<indent level="2">

 Every S.D on U’s tape can be “run” by U and will produce the same “output” (figures 1, 0) as the original machine.
</indent>

Turing makes no comment about how machine D goes about its work. For sake of argument, we suppose that D would first look to see if the string of symbols is "well-formed" (i.e. in the form of an algorithm and not just a scramble of symbols), and if not then discard it. Then it would go “circle-hunting”. To do this perhaps it would use “heuristics” (tricks: taught or learned). For purposes of the proof, these details are not important. </p>
<p>

Turing then describes (rather loosely) the algorithm (method) to be followed by a machine he calls H. Machine H contains within it the decision-machine D (thus D is a “subroutine” of H). Machine H’s algorithm is expressed in H’s table of instructions, or perhaps in H’s Standard Description on tape and united with the universal machine U; Turing does not specify this.</p>
<p>

<indent level="1">

 In the course of describing universal machine U, Turing has demonstrated that a machine’s S.D (string of letters similar to a “program”) can be converted to an integer (base 8) and visa versa. Any number N (in base 8) can be converted to an S.D with the following replacements: 1 by A, 2 by C, 3 by D, 4 by L, 5 by R, 6 by N, 7 by semicolon ";".
</indent>

<indent level="2">

 As it turns out, machine H's unique number (D.N) is the number "K". We can infer that K is some hugely long number, maybe tens-of-thousands of digits long. But this is not important to what follows. 
</indent>

Machine H is responsible for converting <it>any</it> number N into an equivalent S.D symbol string for sub-machine D to test.  (In programming parlance: H passes an arbitrary "S.D” to D, and D returns “satisfactory” or “unsatisfactory”.) Machine H is also responsible for keeping a tally R (“Record”?) of successful numbers (we suppose that the number of "successful S.D's i.e. R is much less than the number of S.D's tested, i.e. N). Finally, H prints on a section of its tape a diagonal number “beta-primed” B’. H creates this B’ by “simulating” (in the computer-sense) the “motions” of each “satisfactory” machine/number; eventually this machine/number under test will arrive at its Rth “figure” (1 or 0), and H will print it. H then is responsible for “cleaning up the mess” left by the simulation, incrementing N and proceeding onward with its tests, <it>ad infinitum</it>.</p>
<p>

<indent level="1">

 Note: All these machines that H is hunting for are what Turing called "computing machines". These compute binary-decimal-numbers in an endless stream of what Turing called "figures": only the symbols 1 and 0.
</indent>

An example: Suppose machine H has tested 13472 numbers and produced 5 satisfactory numbers, i.e. H has converted the numbers 1 through 13472 into S.D’s (symbol strings) and passed them to D for test. As a consequence H has tallied 15 satisfactory numbers and run the first one to its 1st “figure”, the second to its  2nd figure, the third to its 3rd figure, the fourth to its 4th figure, and the fifth to its 5th figure. The count now stands at N = 13472, R = 5, and B’ = “.10011” (for example). H cleans up the mess on its tape, and proceeds:</p>
<p>

<it>H</it> increments <it>N</it> = 13453 and converts "13453" to symbol string ADRLD. If sub-machine D deems ADLRD unsatisfactory, then H leaves the tally-record R at 5. H will increment the number N to 13454 and proceed onward.  On the other hand, if D deems  ADRLD satisfactory then H will increment R to 6. H will convert N (again) into ADLRD [this is just an example, ADLRD is probably useless] and “run” it using the universal machine U until this machine-under-test (U "running" ADRLD) prints its 6th “figure” i.e. 1 or 0. H will print this 6th number (e.g. “0”) in the “output” region of its tape (e.g. B’ = “.100110”). </p>
<p>

H cleans up the mess, and then  increments the number <it>N</it> to 13454.</p>
<p>

The whole process unravels when H arrives at its own number K. We will proceed with our example. Suppose the successful-tally/record R stands at 12. H finally arrives at its own number minus 1, i.e. N = K-1 = 4335...321<b>4</b>, and this number is unsuccessful. Then H increments N to produce K = 4355...321<b>5</b>, i.e. its own number. H converts this to “LDDR...DCAR” and passes it to decision-machine D. Decision-machine D must return “satisfactory” (that is: H must <it>by definition</it> go on and on testing, <it>ad infinitum</it>, because it is "circle-free"). So ... H now increments tally R from 12 to 13 and then re-converts the number-under-test K into its S.D and uses U to simulate it. But this means that H will be simulating its own motions. (What's so wrong with thinking about your own thinking? Marvin Minsky makes the same point...) What is the first thing the simulation will do? This simulation K-aka-H either creates a new N or “resets” the “old” N to 1. This "K-aka-H" either creates a new R or “resets” the “old” R to 0. Old-H “runs” new "K-aka-H" until it arrives at its 12th figure.</p>
<p>

But it never makes it to the 13th figure; K-aka-H eventually arrives at 4355...321<b>5</b>, again, and <it>K-aka-H</it> must repeat the test. <it>K-aka-H</it> will ever reach the 13th figure. The H-machine probably just prints copies of itself <it>ad infinitum</it> across blank tape. But this contradicts the premise that H is a satisfactory, non-circular computing machine that goes on printing the diagonal numbers's 1’s and 0’s forever. (We also will see the same thing if N is reset to 1 and R is reset to 0).</p>
<p>

If the reader does not believe this, they can write a "stub" for decision-machine D (stub "D" will return "satisfactory") and then see for themselves what happens at the instant machine H encounters its own number.</p>

</sec>
<sec>
<st>
 Summary of the second proof </st>
<p>

Less than one page long, the passage from premises to conclusion is obscure.</p>
<p>

Turing proceeds by <it>reductio ad absurdum</it>. He asserts the existence of a machine E, which when given the S.D (standard description, i.e. "program") of an arbitrary machine M, will determine whether M ever prints a given symbol (0 say). He does not assert that this M is a "computing machine". </p>
<p>

Given the existence of machine E, Turing proceeds as follows:
<list>
<entry level="1" type="number">

 If machine E exists then a machine G exists that determines if M prints 0 infinitely often, AND</entry>
<entry level="1" type="number">

 If E exists then another process exits [we can call the process/machine G' for reference] that determines if M prints 1 infinitely often, THEREFORE</entry>
<entry level="1" type="number">

 When we combine G with G' we have a process that determines if M prints an infinity of figures, AND</entry>
<entry level="1" type="number">

 IF the process "G with G'" determines M prints an infinity of figures, THEN "G with G'" has determined that M is circle-free, BUT</entry>
<entry level="1" type="number">

 This process "G with G'" that determine if M is circle-free, by proof 1, cannot exist, THEREFORE</entry>
<entry level="1" type="number">

 Machine E does not exist.</entry>
</list>
</p>

<ss1>
<st>
 Details of second proof </st>
<p>

The difficulty in the proof is step 1. The reader will helped by realizing that Turing is not explaining his subtle handiwork. (In a nut shell: he is using certain equivalencies between the “existential-“ and “universal-operators” together with their equivalent expressions written with logical operators). (For more see <b>Footnote|Second Proof</b>)</p>
<p>

Here’s an example: Suppose we see before us a parking lot full of hundreds of cars. We decide to go around the entire lot looking for: “Cars with flat (bad) tires”.  After an hour or so we have found two “cars with bad tires.” We can now say with certainty that “Some cars have bad tires”. Or we could say: “It’s not true that ‘All the cars have good tires’”. Or: “It is true that: ‘not all the cars have good tires”. Let’s go to another lot. Here we discover that “All the cars have good tires.” We might say, “There’s not a single instance of a car having a bad tire.”  Thus we see that, if we can say something about each car separately then we can say something about ALL of them collectively.</p>
<p>

This is what Turing does:
From <it>M</it> he creates a collection of machines { <it>M</it>1, <it>M</it>2, <it>M</it>3, <it>M</it>4, … , <it>Mn</it> } and about each he writes a sentence: “<it>X</it> prints at least one 0” and allows only two “truth values”, True = blank or False = :0:. One by one he determines the truth value of the sentence for each machine and makes a string of blanks or :0:, or some combination of these. We might get something like this: “<it>M</it>1 prints a 0” = True AND “<it>M</it>2 prints a 0” = True AND “<it>M</it>3 prints a 0” = True AND “<it>M</it>4 prints a 0” = False, ... AND “<it>Mn</it> prints a 0” = False. He gets the string
<indent level="1">

 BBB:0::0::0: ... :0: ... ad infinitum 
</indent>
if there are an infinite number of machines <it>Mn</it>. If on the other hand if every machine had produced a "True" then the expression on the tape would be 
<indent level="1">

 BBBBB....BBBB ... ad infinitum
</indent>

Thus Turing has converted statements about each machine considered separately into a single "statement" (string) about all of them. Given the machine (he calls it G) that created this expression he can test it with his machine E, and determine if it ever produces a 0. In our first example above we see that indeed it does, so we know that not all the M's in our sequence print 0's. But the second example shows that, since the string is blanks then every Mn in our sequence has produced a 0.</p>
<p>

All that remains for Turing to do is create a process to create the sequence of Mn's from a single M.  </p>
<p>

Suppose <it>M</it> prints this pattern:</p>
<p>

<indent level="1">

 <it>M</it> =&amp;gt; ...AB01AB0010AB…
</indent>

Turing creates another machine F that takes M and crunches out a sequence of Mn’s that successively convert the first n 0’s to “0-bar” (<b>0</b>): 
<indent level="1">

 M1 = ...AB<b>0</b>1AB0010AB...
</indent>
: M2 = ...AB<b>0</b>1AB<b>0</b>010AB...
<indent level="1">

 M3 = ...AB<b>0</b>1AB<b>00</b>10AB...
</indent>
: M4 = ...AB<b>0</b>1AB<b>00</b>1<b>0</b>AB...
He claims, without showing details, that this machine F is truly build-able. We can see that one of a couple things could happen. F may run out of machines that have 0’s, or it may have to go on <it>ad infinitum</it> creating machines to “cancel the zeros”.</p>
<p>

Turing now combines machines E and F into a composite machine G. G starts with the original M, then uses F to create all the successor-machines M1, M2,. . ., Mn. Then G uses E to test each machine starting with M. If E detects that a machine never prints a zero, G prints :0: for that machine. If E detects that a machine does print a 0 (we assume, Turing doesn’t say) then G prints :: or just skips this entry, leaving the squares blank. We can see that a couple things can happen. 
<indent level="1">

 G will print no 0’s, ever, if all the Mn’s print 0’s, OR,
</indent>
: G will print ad infinitum 0’s if all the M’s print no 0’s, OR, 
<indent level="1">

 G will print 0’s for a while and then stop.
</indent>

Now, what happens when we apply E to G itself? 
<indent level="1">

  If E(G) determines that G never prints a 0 then we know that all the Mn’s have printed 0’s. And this means that, because all the Mn came from M, that M itself prints 0’s <it>ad infinitum</it>, OR
</indent>
: If E(G) determines that G does print a 0 then we know that not all the Mn’s print 0’s; therefore M does not print 0’s <it>ad infinitum</it>.</p>
<p>

As we can apply the same process for determining if M prints 1 infinitely often. When we combine these processes, we can determine that M does, or does not, go on printing 1’s and 0’s <it>ad infinitum</it>. Thus we have a method for determining if M is circle-free. By Proof 1 this is impossible. So the first assertion that E exists, is wrong: E does not exist.</p>

</ss1>
</sec>
<sec>
<st>
 Summary of proof #3 </st>
<p>

Here Turing proves  “that the <link xlink:type="simple" xlink:href="../302/8302.xml">
Hilbert</link> <link xlink:type="simple" xlink:href="../672/9672.xml">
Entscheidungsproblem</link> can have no solution “(Undecidable p. 145). Here he 
<indent level="1">

 “…show(s) that there can be no general process for determining whether a given formula U of the functional calculus K is provable.” (ibid).
</indent>

<list>
<entry level="1" type="bullet">

 Both Lemmas #1 and #2 are required to form the necessary "IF AND ONLY IF" (i.e. logical equivalence) required by the proof:</entry>
</list>
</p>
<p>

<indent level="1">

 "A set E is computably decidable if and only if both E and its complement are computably enumerable" (Frankél, p. 67)
</indent>

<b>Summary of the proof</b>:</p>
<p>

Turing demonstrates the existence of a formula <b>Un</b>(M) which says, in effect, that "in some complete configuration of M, <b>0</b> appears on the tape" (p. 146). This formula is TRUE, that is, it is "constructible", and he shows how to go about this.  </p>
<p>

Then Turing proves two Lemmas, the first requiring all the hard work. (The second is the converse of the first). Then he uses <it>reductio ad absurdum</it> to prove his final result:</p>
<p>

1 There exists a formula <b>Un</b>(M). This formula is TRUE, AND</p>
<p>

2 If the <it>Entsheidungsproblem</it> can be solved THEN a mechanical process exists for determining whether <b>Un</b>(M) is <it>provable</it> (derivable), AND </p>
<p>

4 BY Lemmas 1 and 2: <b>Un</b>(M) is <it>provable</it> IF AND ONLY IF <b>0</b> appears in some "complete configuration" of M, AND</p>
<p>

5 IF <b>0</b> appears in some "complete configuration" of M THEN a mechanical process exists that will determine whether arbitrary M ever prints <b>0</b>, AND</p>
<p>

6 By Proof 2 no mechanical process exists that will determine whether arbitrary M ever prints <b>0</b>, THEREFORE</p>
<p>

7 <b>Un</b>(M) is not <b>provable</b> (it is TRUE, but not <it>provable</it>) which means that the <it>Entscheidungsproblem</it> is unsolvable.</p>
<p>

<b>Discussion of Proof #3:</b></p>
<p>

<it>If readers intend to study the proof in detail they should correct their copies of the pages of the third proof with the corrections that Turing supplied</it>.  </p>
<p>

To (even attempt to) follow the technical details, the reader will need to understand the definition of "provable" and be aware of important "clues".</p>
<p>

"Provable" means, in the sense of Gödel [support this! '''Footnote|Provable'''], that (i) the axiom system itself is powerful enough to produce (express) the sentence "This sentence is provable", and (ii) that in any arbitrary "well-formed" proof the symbols lead by axioms, definitions, and substitution to the symbols of the conclusion. </p>
<p>

First clue: "Let us put the description of M into the first standard form of |6". Section 6 describes the very specific "encoding" of machine M on the tape of a "universal machine" U. This requires the reader to know some idiosyncrasies of Turing's universal machine U and the encoding scheme.</p>
<p>

(i) The universal machine is a set of "universal" instructions that reside in an "instruction table". Separate from this, on U's tape, a "computing machine" M will reside as "M-code". The universal table of instructions can print on the tape the symbols <b>A, C, D, 0, 1, u, v, w, x, y, z, :</b> . The various machines M can print these symbols only indirectly by commanding U to print them.</p>
<p>

(ii) The "machine code" of M consists of only a few letters and the semicolon, i.e. <b>D, C, A, R, L, N, ;</b> . Nowhere within the "code" of M will the numerical "figures" (symbols) <b>1</b> and <b>0</b> ever appear. If M wants U to print a symbol from the collection <b>blank, 0,  1</b> then it uses one of the following codes to tell U to print them. To make things more confusing, Turing calls these symbols S0, S1, and S2, i.e. 
<indent level="1">

 <b>blank</b> = S0 = <b>D</b>
</indent>
: <b>0</b> = S1 = <b>DC</b>
<indent level="1">

 <b>1</b> = S2 = <b>DCC</b>
</indent>

(iii) A "computing machine", whether it is built directly into a table (as his first examples show), or as machine-code M on universal-machine U's tape, prints its number on blank tape (to the right of M-code, if there is one) as <b>1</b>'s and <b>0</b>'s forever proceeding to the right.</p>
<p>

(iv) If a "computing machine" is U+"M-code", then "M-code" appears first on the tape; the tape has a left end and the "M-code" starts there and proceeds to the right on alternate squares. When the M-code comes to an end (and it must, because of the assumption that these M-codes are finite algorithms), the "figures" will begin as <b>1</b>'s and <b>0</b>'s on alternate squares, proceeding to the right forever. Turing uses the (blank) alternate squares (called "E"- "eraseable"- squares) to help U+"M-code" keep track of where the calculations are, both in the M-code and in the "figures" that the machine is printing.</p>
<p>

(v) A "complete configuration" is a printing of all symbols on the tape, including M-code [?] and "figures" up to that point, together with the figure currently being scanned (with a pointer-character printed to the left of the scanned symbol ?). If we have interpreted Turing's meaning correctly, this will be a hugely-long set of symbols. But whether the entire M-code must be repeated is unclear; only a printing of the current M-code instruction is necessary plus the printing of all figures with a figure-marker). </p>
<p>

(vi) Turing reduced the vast possible number of instructions in "M-code" (again: the code of M to appear on the tape) to a small canonical set, one of three similar to this: { qi Sj Sk R ql } e.g. <it>If machine is executing instruction #qi and symbol Sj is on the square being scanned, then Print symbol Sk and go Right and then go to instruction ql</it>: The other instructions are similar, encoding for "Left" L and "No motion" N. It is this set that is encoded by the string of symbols qi = DA...A, Sj = DC...C, Sk = DC...C, R, ql = DA....A. Each instruction is separated from another one by the semicolon. For example { q5, S1 S0 L q3 } means: Instruction #5: If scanned symbol is <b>0</b> then print <b>blank</b>, go Left, then go to instruction #3. It is encoded as follows
<indent level="1">

 ; D A A A A A D C D L D A A A    
</indent>

Second clue: Turing is using ideas introduced in Gödel's paper, that is, the "Gödelization" of (at least part of) the formula for <b>Un</b>(M). This clue appears only as a footnote on page 138 (Undecidable): "A sequence of r primes is denoted by ^(r)"(ibid). [Here, r inside parentheses is "raised"]. This "sequence of primes" appears in a formula called F^(n).</p>
<p>

Third clue: This reinforces the second clue. Turing's original attempt at the proof uses the expression 
<indent level="1">

 (Eu)N(u) &amp; (x)( ... etc. ...) (Undecidable, p. 146)
</indent>
Earlier in the paper Turing had previously used this expression (p. 138) and defined N(u) to mean "u is a non-negative integer"(ibid) (i.e. a Gödel number). But, with the Bernays corrections, Turing abandoned this approach (i.e. the use of N(u)) and the only place where "the Gödel number" appears explicitly is where he uses F^(n).     </p>
<p>

What does this mean for the proof? The first clue means that a simple examination of the M-code on the tape will not reveal if a symbol <b>0</b> is ever printed by U+"M-code". A testing-machine might look for the appearance of <b>DC</b> in one of the strings of symbols that represent an instruction. But will this instruction ever be "executed?" Something has to "run the code" to find out. This something can be a machine, or it can be lines in a formal proof, i.e. Lemma #1.</p>
<p>

The second and third clues mean that, as its foundation is Gödel's paper,  the proof is difficult.</p>

</sec>
<sec>
<st>
 Details of proof #3 </st>
<p>

- a work in progress: technical details may not correct -</p>
<p>

<list>
<entry level="1" type="bullet">

 In the example below we will actually construct a simple "theorem" --  a little <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link> program "run it". We will see just how mechanical a properly-designed theorem can be. A proof, we will see, is just that, a "test" of the theorem that we do by inserting a "proof example" into the beginning and see what pops out at the end.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Both Lemmas #1 and #2 are required to form the necessary "IF AND ONLY IF" (i.e. logical equivalence) required by the proof:</entry>
</list>
</p>
<p>

<indent level="1">

 "A set E is computably decidable if and only if both E and its complement are computably enumerable" (Frankél, p. 67)
</indent>

<list>
<entry level="1" type="bullet">

 To quote Frankel:</entry>
<entry level="1" type="indent">

 "A sentence A is said to be decidable in a <link xlink:type="simple" xlink:href="../102/396102.xml">
formal system</link> S if either A or its negation is provable in S" (Frankél, p. 65)</entry>
</list>
</p>
<p>

Frankel has defined "provable" earlier in his book:
<indent level="1">

 "A formal system is a system of <it>axioms</it> (expressed in some formally defined language) and <it>rules of reasoning</it> (also called inference rules), ued to derive the <it>theorems</it> of the system. A <it>theorem</it> is any statement in the language of the system obtainable by a series of applications of the rules of reasoning, starting from the axioms. A <it>proof</it> is a finite sequence of such applications, leading to a theorem as its conclusion" (Ibid p. 17).
</indent>

Thus a "sentence" is a string of symbols, and a theorem is a string of strings of symbols.</p>
<p>

Turing is confronted with the following tasks:
<list>
<entry level="1" type="bullet">

 to convert a Universal Turing machine "program", and the numerical symbols on the tape (Turing's "figures", symbols "1" and "0"), into a "theorem" -- that is, a (monstrously-long) <it>string of sentences</it> that define the successive actions of the machine, (all) the figures of the tape, and the location of the "tape head". </entry>
</list>
</p>
<p>

Thus the "string of sentences" will be strings of strings of symbols. The only allowed individual symbols will come from Godel's symbols defined in his paper.(In the following example we use the "" and "&amp;gt;" around a "figure" to indicate that the "figure" is the symbol being scanned by the machine).</p>

<ss1>
<st>
 An example of what "complete configuration" means </st>
<p>

In the following we have to remind ourselves that every one of Turing’s “computing machines” is a binary-number generator/creator that begins work on “blank tape”. Properly constructed, it always cranks away ad infinitum, but its instructions are always finite. In Turing’s proofs Turing’s tape had a “left end” but extended right ad infinitum. For sake of example below we will assume that the “machine” is not a Universal machine, but rather the simpler “dedicated machine” with the instructions in the Table. </p>
<p>

Our example is based on a <it>modified</it> <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link> model of a Turing Machine. This model prints only the symbols 0 and 1. The blank tape is considered to be all b’s. Our modified model requires us to add two more instructions to the 7 Post-Turing instructions. The abbreviations that we will use are:
<indent level="1">

 R, RIGHT: look to the right and move tape to left, or move tape head right 
</indent>
: L, LEFT : look to the left and to move tape right, or move tape head left
<indent level="1">

 E, ERASE scanned square (e.g. make square blank)
</indent>
: P0,: PRINT 0 in scanned square
<indent level="1">

 P,1: PRINT 1 in scanned square 
</indent>
: Jb_n, JUMP-IF-blank-to-instruction_#n,
<indent level="1">

 J0_n, JUMP-IF-0-to-instruction_#n, 
</indent>
: J1_n, JUMP-IF-1-to-instrucntion_#n, 
<indent level="1">

 HALT. 
</indent>
In the cases of R, L, E, P0, and P1 after doing its task the machine continues on to the next instruction in numerical sequence; ditto for the jumps if their tests fail.</p>
<p>

But, for brevity, our examples will only use three squares. And these will always start as there blanks with the scanned square on the left: i.e. bbb. With two symbols 1, 0 and blank we can have 27 distinct configurations:</p>
<p>

<indent level="1">

 bbb, bb0, bb1, b0b, b00, b01, b1b, b10, b11, 0bb, 0b0, 0b1, 00b, 000, 001, 01b, 010, 011, 1bb, 1b0, 1b1, 10b, 100, 101, 11b, 110, 111
</indent>

We must be careful here, because it is quite possible that an algorithm will (temporarily) leave blanks in between figures, then come back and fill something in. More likely, an algorithm may do this intentionally. In fact, Turing’s machine does this—it prints on alternate squares, leaving blanks between figures so it can print locator symbols. </p>
<p>

Turing always left alternate squares blank so his machine could place a symbol to the left of a figure (or a letter if the machine is the universal machine and the scanned square is actually in the “program”). In our little example we will forego this and just put symbols ( ) around the scanned symbol, as follows:</p>
<p>

<indent level="1">

 b(b)0 this means, “Tape is blanks-to-the-left of left blank but left blank is “in play”, the scanned-square-is-blank, “0”, blanks-to-right” 
</indent>
: 1(0)1 this means, “Tape is blanks-to-the-left, then 1, scanned square is “0”</p>
<p>

Let’s write a simple program:
<indent level="1">

 start: P1, R, P1, R, P1, H
</indent>

Remember that we always start with blank tape. The complete configuration prints the symbols on the tape followed by the next instruction:
<indent level="1">

 start config: (b) P1,
</indent>
: config #1: (1) R,  
<indent level="1">

 config #2: 1(b) P1,
</indent>
: config #3: 1(1) R,
<indent level="1">

 config #4: 11(b) P1,
</indent>
: config #5: 11(1) H</p>
<p>

Let’s add “jump” into the formula. When we do this we discover why the complete configuration must include the tape symbols. (Actually, we see this better, below). This little program prints three “1”s to the right, reverses direction and moves left printing 0’s until it hits a blank. We will print all the symbols that our machine uses:
<indent level="1">

 start: P1, R, P1, R, P1, P0, L, J1_7, H
</indent>
: (b)bb P1,  
<indent level="1">

 (1)bb R, 
</indent>
: 1(b)b P1, 
<indent level="1">

 1(1)b R, 
</indent>
: 11(b) P1, 
<indent level="1">

 11(1) P0, 
</indent>
: 11(0) L,
<indent level="1">

 1(1)0 J1_7
</indent>
: 1(1)0 L
<indent level="1">

 (1)10 J0_7
</indent>
: (1)10 L
<indent level="1">

 (b)110 J0_7
</indent>
: (b)110 H
Here at the end we find that a blank on the left has “come into play” so we leave it as part of the total configuration. </p>
<p>

Given that we’ve done our job correctly, we add the starting conditions and see “where the theorem goes”. The resulting configuration-- the number 110-- is the PROOF.</p>
<p>

<list>
<entry level="1" type="bullet">

 Turing's first task had to write a generalized expression using logic symbols to express exactly what his Un(M) would do.  </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Turing’s second task is to "Godelize" this hugely long string-of-string-of-symbols using Godel's technique of assigning primes to the symbols and raising the primes to prime-powers, per Godel’s method.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

   <cite id="CITEREFTuring2009" style="font-style:normal">Turing, A.M.&#32;(1936),&#32;"On Computable Numbers, with an Application to the Entscheidungsproblem",&#32;<it>Proceedings of the London Mathematical Society</it>, 2&#32;<b>42</b>:  230-65, 1937</cite>&nbsp; (and  <cite id="CITEREFTuring1937" style="font-style:normal">Turing, A.M.&#32;(1937),&#32;"On Computable Numbers, with an Application to the Entscheidungsproblem: A correction",&#32;<it>Proceedings of the London Mathematical Society</it>, 2&#32;<b>43</b>:  544-6</cite>&nbsp;). <weblink xlink:type="simple" xlink:href="http://www.turingarchive.org/browse.php/B/12">
online version</weblink> This is the epochal paper where Turing defines <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s, shows that the <link xlink:type="simple" xlink:href="../672/9672.xml">
Entscheidungsproblem</link>) is unsolvable.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
, <it>The Undecidable, Basic Papers on Undecidable Propositions, Unsolvable Problems And Computable Functions</it>, Raven Press, New York, 1965. The two papers of Post referenced above are included in this volume. Other papers include those by Godel, Church, Rosser, and Kleene.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../990/18550990.xml">
Andrew Hodges</link></person>
, <it>Alan Turing: The Enigma</it>, Simon and Schuster, New York. Cf Chapter "The Spirit of Truth" for a history leading to, and a discussion of, his proof.</entry>
<entry level="1" type="bullet">

 <philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../863/1546863.xml">
Hans Reichenbach</link></philosopher>
, <it>Elements of Symbolic Logic</it>, Dover Publications, Inc., New York, 1947.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Footnotes </st>
<p>

(<b>Footnote|Godel</b>):
-- this is a stub ---</p>
<p>

(<b>Footnote|Second Proof</b>):</p>
<p>

For more about  the “quantification operators” i.e. the “For all” operator and “There exists an instance of” operator see Reichenbach p. 87. The following equivalence is of particular interest here:</p>
<p>

<indent level="1">

 1:  ~( (A x) ~f(x) ) = (E x) f(x)
</indent>

In words, for an example using three x’s with the sentences f(x) = "x is red", and ~f(x) = “x is not red”:</p>
<p>

<indent level="1">

 1: “It is not true that: “For all x ‘x is not red’ ”  = “There is at least one instance of x with the property “x is red”
</indent>

Suppose object x1 is blue, x2 is red, and x3 is green. Then the statements “x1 is not red” is true, and “x2 is not red” is false, and “x3 is not red” is true.  So the statement “For all x: ‘x is not red’” is not true, because we have the instance “x2 is red”.</p>
<p>

The two quantifiers' equivalences in terms of the logical operators OR (V), AND (&amp;) and NOT (~) can be found in Reichenbach p. 91ff:
<indent level="1">

 2:  (E x) f(x) = ( f(x1) V f(x2) V ... f(xn) )
</indent>
: 3: ( (A x) ~f(x) ) =  ( ~f(x1) &amp; ~f(x2) &amp; ... &amp; ~f(xn) )</p>
<p>

In words:
<indent level="1">

 2: “There is at least one instance x with the property ‘x is red’”  =  “( ‘x1 is red’ OR ‘x2 is red’ OR ‘x3 is red’ )”.
</indent>
: 3:  “For all x: ‘x is not red’ ” = “( ‘x1 is not red’ AND ‘x2 is not red’ AND ‘x3 is not red’ )”. </p>
<p>

(<b>Footnote|First Proof</b>):</p>
<p>

1 <b>computable number</b> — a number whose decimal is computable by a machine, i.e. by finite means (e.g. an algorithm) [Turing Thesis]</p>
<p>

2 <b>M</b> — a machine with a finite instruction table and a scanning/printing head. M moves an infinite tape divided into squares each “capable of bearing a symbol”. The machine-instructions are only the following: move one square left, move one square right, on the scanned square print symbol p, erase the scanned square, if the symbol is p then do instruction aaa, if the scanned symbol is not p then do instruction aaa, if the scanned symbol is none then do instruction aaa, if the scanned symbol is any do instruction aaa [where “aaa” is an instruction-identifier]</p>
<p>

3 <b>computing machine</b> — an M that prints two kinds of symbols, symbols of the first type are called “figures” and are only binary symbols 1 and 0; symbols of the second type are any other symbols.</p>
<p>

4 <b>figures</b> — symbols <b>1</b> and <b>0</b>, a.k.a. “symbols of the first kind”</p>
<p>

5 <b>m-configuration</b> -- the instruction-identifier, either a symbol in the instruction table, or a string of symbols representing the instruction- number on the tape of the universal machine (e.g. "DAAAAA = #5")</p>
<p>

6 <b>symbols of the second kind</b> — any symbols other than <b>1</b> and <b>0</b></p>
<p>

7 <b>circular</b> — an unsuccessful computating machine.  It fails to print, ad infinitum, the figures <b>0</b> or <b>1</b> that represent in binary the number it computes</p>
<p>

8 <b>circle-free</b> — a successful computating machine. It prints, ad infinitum, the figures <b>0</b> or <b>1</b> that represent in binary the number it computes</p>
<p>

9 <b>sequence</b> — as in “sequence computed by the machine”: symbols of the first kind a.k.a. figures a.k.a symbols 0 and 1.</p>
<p>

10  <b>computable sequence</b> — can be computed by a circle-free machine</p>
<p>

11 <b>S.D</b> – Standard Description: a sequence of symbols A, C, D, L, R, N, “;” on a Turing machine tape</p>
<p>

12 <b>D.N</b> — Description Number: an S.D converted to a number: 1=A, 2=C, 3 =D, 4=L, 5=R, 6=N, 7=;</p>
<p>

13 <b>M(n)</b> — a machine whose D.N is number “n”</p>
<p>

14 <b>statisfactory</b> — a S.D or D.N that represents a circle-free machine</p>
<p>

15 <b>U</b> — a machine equipped with a “universal” table of instructions. If U is “supplied with a tape on the beginning of which is written the S.D of some computing machine M, U will compute the same sequence as M.”</p>
<p>

16 <b>B’</b>—“beta-primed”: A so-called “diagonal number” made up of the n-th figure (i.e. 0 or 1) of the n-th computable sequence [also: the computable number of H, see below]</p>
<p>

17 <b>u</b> – an unsatisfactory, i.e. circular, S.D</p>
<p>

18 <b>s</b> – satisfactory, i.e. circle-free S.D</p>
<p>

19 <b>D</b> – a machine contained in H (see below). When supplied with the S.D of any computing machine M, D will test M’s S.D and if circular mark it with “u” and if circle-free mark it with “s”</p>
<p>

20 <b>H</b> – a computing machine. H computes B’, maintains R and N. H contains D and U and an unspecified machine (or process)that maintains N and R and provides D with the equivalent S.D of N. E also computes the figures of B’ and assembles the figures of B’.</p>
<p>

21 <b>R</b> – a record, or tally, of the quantity of successful (circle-free) S.D tested by D</p>
<p>

22 <b>N</b> – a number, starting with 1, to be converted into an S.D by machine E. E maintains N.</p>
<p>

23 <b>K</b> – a number. The D.N of H.</p>
<p>

Required for Proof #3:</p>
<p>

5 <b>m-configuration</b> -- the instruction-identifier, either a symbol in the instruction table, or a string of symbols representing the instruction's number on the tape of the universal machine (e.g. "DAAAAA = instruction #5"). In Turing's S.D the m-configuration appears twice in each instruction, the left-most string is the "current instruction"; the right-most string is the next instruction.</p>
<p>

24 <b>complete configuration</b> -- the number (figure <b>1</b> or <b>0</b>) of the scanned square, the complete sequence of all symbols on the tape, and the m-confguration (the instruction-identifier, either a symbol or a string of symbols representing a number, e.g. "instruction DAAAA = #5")</p>
<p>

25 <b>RSi(x, y)</b> - "in the complete configuration x of M the symbol on square y is Si. "complete configuration" is definition #5,</p>
<p>

26 <b>I(x, y)</b> - "in the complete configuration x of M the square y is scanned"</p>
<p>

27 <b>Kqm(x)</b> - "in the complete configuration x of M the machine-configuration (instruction number) is qm"</p>
<p>

28 <b>F(x,y)</b> - "y is the <it>immediate</it> successor of x" (follows Gödel's use of "f" as the successor-function).</p>
<p>

29 <b>G(x,y)</b> - "x precedes y", not necessarily immediately</p>
<p>

30 <b>Inst{ qi, Sj Sk L ql}</b> is an abbreviation, as are Inst{ qi, Sj Sk R ql }, and Inst{qi, Sj Sk N ql}. See below.</p>
<p>

Turing reduces his instruction set to three “canonical forms” – one for Left, Right, and No-movement. Si and Sk are symbols on the tape. 
<indent level="1">

 		tape				Final
</indent>
:m-config	Symbol	Operations	m-config
<indent level="1">

  qi		Si		PSk, L		qm
</indent>
:  qi		Si		PSk, R		qm
<indent level="1">

  qi		Si		PSk, N		qm
</indent>
For example, the operations in the first line are PSk = PRINT symbol Sk from the collection <b>A, C, D, 0, 1, u, v, w, x, y, z, :</b> , then move tape LEFT.</p>
<p>

These he further abbreviated as:
(N1)	qi Sj Sk L qm
(N2)	qi Sj Sk R qm
(N3)	qi Sj Sk N qm</p>
<p>

In Proof #3 he calls the first of these “Inst{ qi Sj Sk L ql }”, and he shows how to write the entire machine S.D  as the  logical conjunction (logical OR): this string is called “Des(M)”, as in “Description-of-M”.
i.e. if the machine prints 0 then 1’s and 0’s on alternate squares to the right ad infinitum it might have the table (similar example appears on page 119:
<indent level="1">

 q1, blank, P0, R, q2
</indent>
: q2, blank, P-blank, R, q3
<indent level="1">

 q3, blank, P1, R, q4
</indent>
: q4, blank, P-blank, R, q1
(This has been reduced to canonical form with the “p-blank” instructions so it differs a bit from Turing’s example).
If put them into the “ Inst( ) form” the instructions will be the following (remembering: S0 is blank, S1 = 0, S2 = 1):
<indent level="1">

 Inst { q1 S0 S1 R q2 }
</indent>
: Inst { q2 S0 S0 R q3 }
<indent level="1">

 Inst { q3 S0 S2 R q4 }
</indent>
: Inst { q4 S0 S0 R q1 }
The reduction to the Standard Description SD will be:
<indent level="1">

 ;D A D D C R D A A; D A A D D R D A A A ; D A A A D D C C R D A A A A ; D A A A A D D R D A ;
</indent>
This agrees with his example in the book (there will be a blank between each letter and number). Universal machine U uses the alternate blank squares as places to put "pointers".</p>

</sec>
</bdy>
</article>
