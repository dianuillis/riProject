<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:56:45[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Tomasulo algorithm</title>
<id>390562</id>
<revision>
<id>243125648</id>
<timestamp>2008-10-05T07:36:56Z</timestamp>
<contributor>
<username>Eryueniaobp</username>
<id>7336785</id>
</contributor>
</revision>
<categories>
<category>Algorithms</category>
<category>Instruction processing</category>
</categories>
</header>
<bdy>

The <b>Tomasulo algorithm</b> is a hardware <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> developed in 1967 by <link xlink:type="simple" xlink:href="../893/1938893.xml">
Robert Tomasulo</link> from <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
. It allows sequential instructions that would normally be stalled due to certain dependencies to execute non-sequentially (<link xlink:type="simple" xlink:href="../307/1002307.xml">
out-of-order execution</link>). It was first implemented for the <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../294/29294.xml">
IBM360/91â€™s</link></horizontal_surface>
</surface>
</artifact>
</platform>
 floating point unit.<p>

This algorithm differs from <link xlink:type="simple" xlink:href="../102/4543102.xml">
scoreboarding</link> in that it utilizes <link xlink:type="simple" xlink:href="../852/435852.xml">
register renaming</link>. Where scoreboarding resolves Write-after-Write (WAW) and Write-after-Read (WAR) <link xlink:type="simple" xlink:href="../569/390569.xml">
hazards</link> by stalling, register renaming allows the continual issuing of instructions. The Tomasulo algorithm also uses a <link>
common data bus</link> (CDB) on which computed values are broadcast to all the <link xlink:type="simple" xlink:href="../249/4543249.xml">
reservation stations</link> that may need it. This allows for improved parallel execution of instructions which may otherwise stall under the use of scoreboarding.</p>
<p>

Robert Tomasulo received the <link xlink:type="simple" xlink:href="../513/4466513.xml">
Eckert-Mauchly Award</link> in 1997 for this algorithm.</p>

<sec>
<st>
Implementation Concepts</st>
<p>

The following are the concepts necessary to the implementation of Tomasulo's Algorithm.</p>
<p>

<list>
<entry level="1" type="bullet">

Instructions are issued sequentially so that the effects of a sequence of instructions such as exceptions raised by these instructions occur in the same order as they would in a non-pipelined processor, regardless of the fact that they are being executed non-sequentially.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

All general-purpose and <link>
reservation station</link> registers hold either real or virtual values.  If a real value is unavailable to a destination register during the issue stage, a virtual value is initially used.  The functional unit that is computing the real value is assigned as the virtual value.  The virtual register values are converted to real values as soon as the designated functional unit completes its computation.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Functional units use <link>
reservation stations</link> with multiple slots.  Each slot holds information needed to execute a single instruction, including the operation and the operands.  The functional unit begins processing when it is free and when all source operands needed for an instruction are real.</entry>
</list>
</p>

</sec>
<sec>
<st>
Instruction Lifecycle</st>
<p>

The three stages listed below are the stages through which each instruction passes from the time it is issued to the time its execution is complete.</p>

<ss1>
<st>
Stage 1: Issue</st>

<p>

In the Issue stage, instructions are issued for execution if all operands and reservation stations are ready or else they are stalled.  Registers are renamed in this step, eliminating WAR and WAW hazards.</p>
<p>

<list>
<entry level="1" type="bullet">

Retrieve the next instruction from the head of the instruction queue</entry>
<entry level="1" type="bullet">

If the instruction operands are currently in the registers</entry>
<entry level="2" type="bullet">

If there is a matching empty reservation station (functional unit is available)</entry>
<entry level="3" type="bullet">

Issue the instruction</entry>
<entry level="2" type="bullet">

Else, there is not a matching empty reservation station (functional unit is not available)</entry>
<entry level="3" type="bullet">

Stall the instruction until a station or buffer is free</entry>
<entry level="1" type="bullet">

Else, the operands are not in the registers</entry>
<entry level="2" type="bullet">

Use virtual values, the functional unit calculating the real value, to keep track of the functional units that will produce the operands</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Stage 2: Execute</st>

<p>

In the Execute stage, the instruction operations are carried out.  Instructions are delayed in this step until all of their operands available, eliminating RAW hazards.  Program correctness is maintained through effective address calculation to prevent hazards through memory.</p>
<p>

<list>
<entry level="1" type="bullet">

If one or more of the operands is not yet available</entry>
<entry level="2" type="bullet">

Monitor the common data bus (CDB) while waiting for it to be computed</entry>
<entry level="2" type="bullet">

Place operands into corresponding reservation station when they become available</entry>
<entry level="1" type="bullet">

When all operands are available</entry>
<entry level="2" type="bullet">

If the instruction is a load or store</entry>
<entry level="3" type="bullet">

Compute the effective address when the base register is available</entry>
<entry level="3" type="bullet">

Place the effective address in the load or store buffer</entry>
<entry level="3" type="bullet">

If the instruction is a load</entry>
<entry level="4" type="bullet">

Execute as soon as the memory unit is available</entry>
<entry level="3" type="bullet">

Else, the instruction is a store</entry>
<entry level="4" type="bullet">

Wait for the value to be stored before sending it to the memory unit</entry>
<entry level="2" type="bullet">

Else, the instruction is an ALU operation</entry>
<entry level="3" type="bullet">

Execute the instruction at the corresponding functional unit</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Stage 3: Write Result</st>
<p>

In the Write Result stage, ALU operations results are written back to registers and store operations are written back to memory.
<list>
<entry level="1" type="bullet">

If the instruction was an ALU operation</entry>
<entry level="2" type="bullet">

If the result is available, </entry>
<entry level="3" type="bullet">

Write it on the CDB and from there into the registers and any reservation stations waiting for this result</entry>
<entry level="1" type="bullet">

Else, if the instruction was a store</entry>
<entry level="2" type="bullet">

Write the data to memory during this step</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../468/390468.xml">
Re-order buffer</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../960/245960.xml">
Instruction level parallelism</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../307/1002307.xml">
Out-of-order execution</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/class/fall2001/cmsc411/projects/dynamic/tomasulo.html">
Dynamic Scheduling - Tomasulo's Algorithm</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 Bibliography </st>
<p>

<list>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://domino.research.ibm.com/tchjr/journalindex.nsf/0/ed39cdf7e40549ec85256bfa00683f73?OpenDocument">
An Efficient Algorithm for Exploiting Multiple Arithmetic Units</weblink></it>,  IBM Journal of Research and Development, 11(1):25-33, January 1967.</entry>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://www.dcs.ed.ac.uk/home/hase/webhase/demo/tomasulo.html">
WebHASE: Tomasulo's Algorithm: HASE Java applet simulation of the Tomasulo's Algorithm</weblink></it>, Institute for Computing Systems Architecture, Edinburgh University.</entry>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://www.ecs.umass.edu/ece/koren/architecture/Tomasulo1/tomasulo.htm">
TOMASULO'S ALGORITHM FOR DYNAMIC SCHEDULING</weblink>''</it></entry>
<entry level="1" type="bullet">

 <it>Computer Architecture: A Quantitative Approach</it>, John L. Hennessy &amp; David A. Patterson</entry>
</list>
</p>



</sec>
</bdy>
</article>
