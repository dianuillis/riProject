<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:39:11[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<header>
<title>Digital electronics</title>
<id>39068</id>
<revision>
<id>244546671</id>
<timestamp>2008-10-11T10:41:50Z</timestamp>
<contributor>
<username>Chbarts</username>
<id>106221</id>
</contributor>
</revision>
<categories>
<category>Digital electronics</category>
<category>Articles lacking in-text citations</category>
<category>Electronic design automation</category>
<category>Electronic design</category>
<category>Digital systems</category>
<category>Electronic engineering</category>
</categories>
</header>
<bdy>
<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Text_document_with_red_question_mark.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 This article or section includes a  or , but its sources remain unclear because it lacks <b>.</b>
You can  this article by introducing more precise citations . <it>(February 2008)''</it></col>
</row>
</table>

</p>
<p>

<image location="right" width="270px" src="relogio_binario.JPG" type="thumb">
<caption>

A digital circuit that acts as a <link xlink:type="simple" xlink:href="../189/650189.xml">
binary clock</link>, hand-wired on a series of <link xlink:type="simple" xlink:href="../799/80799.xml">
breadboard</link>s
</caption>
</image>
</p>
<p>

<b>Digital electronics</b> are <link xlink:type="simple" xlink:href="../663/9663.xml">
electronics</link> systems that use <link xlink:type="simple" xlink:href="../504/47504.xml">
digital signal</link>s. Digital electronics are representations of <link xlink:type="simple" xlink:href="../239/2701239.xml">
Boolean algebra</link> also see <link xlink:type="simple" xlink:href="../362/30362.xml">
truth tables</link> and are used in <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>s, <link xlink:type="simple" xlink:href="../137/19644137.xml">
mobile phone</link>s, and other <link xlink:type="simple" xlink:href="../008/6347008.xml">
consumer product</link>s. In a digital circuit, a signal is represented in one of two states or <link xlink:type="simple" xlink:href="../077/5652077.xml">
logic level</link>s. The advantages of digital techniques stem from the fact it is easier to get an electronic device to switch into one of two states, then to accurately reproduce a continuous range of values. </p>
<p>

Digital electronics or any <b>digital circuit</b> are usually made from large assemblies of <link xlink:type="simple" xlink:href="../168/18168.xml">
logic gate</link>s, simple electronic representations of Boolean logic functions.</p>
<p>

To most electronic engineers, the terms "digital circuit", "digital system" and "<link xlink:type="simple" xlink:href="../225/3729225.xml">
logic</link>" are interchangeable in the context of digital circuits.</p>

<sec>
<st>
 Advantages </st>
<p>

One advantage of digital circuits when compared to analog circuits is <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> that signals represented digitally can be transmitted without degrading because of <link xlink:type="simple" xlink:href="../415/41415.xml">
noise</link>.  For example, a continuous audio signal, transmitted as a sequence of 1s and 0s, can be reconstructed without error provided the noise picked up in transmission is not enough to prevent identification of the 1s and 0s. An hour of music can be stored on a <link xlink:type="simple" xlink:href="../429/6429.xml">
compact disc</link> as about 6 billion  binary digits. </p>
<p>

In a digital system, a more precise representation of a signal can be obtained by using more binary digits to represent it.  While this requires more digital circuits to process the signals, each digit is handled by the same kind of hardware. In an analog system, additional resolution requires fundamental improvements in the linearity and noise charactersitics of each step of the signal chain. </p>
<p>

Computer-controlled digital systems can be controlled by software, allowing new functions to be added without changing hardware.  Often this can be done outside of the factory by updating the product's software.  So, the product's design errors can be corrected after the product is in a customer's hands.</p>
<p>

Information storage can be easier in digital systems than in analog ones.  The noise-immunity of digital systems permits data to be stored and retrieved without degradation.  In an analog system, noise from aging and wear degrade the information stored.  In a digital system, as long as the total noise is below a certain level, the information can be recovered perfectly.</p>

</sec>
<sec>
<st>
 Disadvantages </st>

<p>

In some cases, digital circuits use more energy than analog circuits to accomplish the same tasks, thus producing more heat as well.  In portable or battery-powered systems this can limit use of digital systems.</p>
<p>

For example, battery-powered cellular telephones often use a low-power analog front-end to <link xlink:type="simple" xlink:href="../214/3214.xml">
amplify</link> and <link xlink:type="simple" xlink:href="../156/11950156.xml">
tune</link> in the <link xlink:type="simple" xlink:href="../428/15368428.xml">
radio</link> signals from the base station.  However, a base station has grid power and can use power-hungry, but very flexible <link xlink:type="simple" xlink:href="../137/83137.xml">
software radio</link>s.  Such base stations can be easily reprogrammed to process the signals used in new cellular standards.</p>
<p>

Digital circuits are sometimes more expensive, especially in small quantities.</p>
<p>

The sensed world is analog, and signals from this world are analog quantities. For example, light, temperature, sound, electrical conductivity, electric and magnetic fields are analog.   Most useful digital systems must translate from continuous analog signals to discrete digital signals.  This causes <link xlink:type="simple" xlink:href="../321/25321.xml">
quantization</link> errors.  </p>
<p>

Quantization error can be reduced if the system stores enough digital data to represent the signal to the desired degree of <link xlink:type="simple" xlink:href="../103/605103.xml">
fidelity</link>.  The <link xlink:type="simple" xlink:href="../864/37864.xml">
Nyquist-Shannon sampling theorem</link> provides an important guideline as to how much digital data is needed to accurately portray a given analog signal.</p>
<p>

In some systems, if a single piece of digital data is lost or misinterpreted, the meaning of large blocks of related data can completely change.  Because of the <link xlink:type="simple" xlink:href="../223/5952223.xml">
cliff effect</link>, it can be difficult for users to tell if a particular system is right on the edge of failure, or if it can tolerate much more noise before failing.</p>
<p>

Digital fragility can be reduced by designing a digital system for robustness.  For example, a <link xlink:type="simple" xlink:href="../467/194467.xml">
parity bit</link> or other <link xlink:type="simple" xlink:href="../375/10375.xml">
error management method</link> can be inserted into the signal path.  These schemes help the system detect errors, and then either <link xlink:type="simple" xlink:href="../375/10375.xml">
correct the errors</link>, or at least ask for a new copy of the data.  In a state-machine, the state transition logic can be designed to catch unused states and trigger a reset sequence or other error recovery routine.  </p>
<p>

<link xlink:type="simple" xlink:href="../630/46630.xml">
Embedded software designs</link> that employ <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../565/8008565.xml">
Immunity Aware Programming</link></instrumentality>
</artifact>
</system>
, such as the practice of filling unused program memory with interrupt instructions that point to an error recovery routine. This helps guard against failures that corrupt the microcontroller's instruction pointer which could otherwise cause random code to be executed.</p>
<p>

Digital memory and transmission systems can use techniques such as <link xlink:type="simple" xlink:href="../375/10375.xml">
error detection and correction</link> to  use additional data to correct any errors in transmission and storage.  </p>
<p>

On the other hand, some techniques used in digital systems make those systems more vulnerable to single-bit errors. These techniques are acceptable when the underlying bits are reliable enough that such errors are highly unlikely.
<list>
<entry level="1" type="bullet">

 A single-bit error in audio data stored directly as <link xlink:type="simple" xlink:href="../949/1499949.xml">
linear pulse code modulation</link> (such as on a <recording wordnetid="104063868" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<sound_recording wordnetid="104262678" confidence="0.8">
<memory_device wordnetid="103744840" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<phonograph_record wordnetid="103924069" confidence="0.8">
<medium wordnetid="106254669" confidence="0.8">
<link xlink:type="simple" xlink:href="../902/18959902.xml">
CD-ROM</link></medium>
</phonograph_record>
</device>
</memory_device>
</sound_recording>
</instrumentality>
</artifact>
</recording>
 causes, at worst, a single click. Instead, many people use <link xlink:type="simple" xlink:href="../025/18950025.xml">
audio compression</link> to save storage space and download time, even though a single-bit error may corrupt the entire song.</entry>
</list>
</p>

<ss1>
<st>
 Analog issues in digital circuits </st>

<p>

Digital circuits are made from analog components.  The design must assure that the analog nature of the components doesn't dominate the desired digital behavior.  Digital systems must manage noise and timing margins, parasitic inductances and capacitances, and <link xlink:type="simple" xlink:href="../533/1866533.xml">
filter</link> power connections.  </p>
<p>

Bad designs have intermittent problems such as "glitches", vanishingly-fast pulses that may trigger some logic but not others, "<link xlink:type="simple" xlink:href="../987/309987.xml">
runt pulse</link>s" that do not reach valid "threshold" voltages, or unexpected  ("undecoded") combinations of logic states.</p>
<p>

Since digital circuits are made from analog components, digital circuits calculate more slowly than low-precision analog circuits that use a similar amount of space and power.  However, the digital circuit will calculate more repeatably, because of its high noise immunity.  On the other hand, in the high-precision domain (for example, where 14 or more bits of precision are needed), analog circuits require much more power and area than digital equivalents.</p>

</ss1>
</sec>
<sec>
<st>
Construction</st>
<p>
 
A digital circuit is often constructed from small electronic circuits called <link xlink:type="simple" xlink:href="../168/18168.xml">
logic gate</link>s.  Each logic gate represents a function of <link xlink:type="simple" xlink:href="../124/12351124.xml">
boolean logic</link>.  A logic gate is an arrangement of electrically controlled switches.  </p>
<p>

The output of a logic gate is an electrical <link xlink:type="simple" xlink:href="../207/6207.xml">
flow</link> or <link xlink:type="simple" xlink:href="../615/59615.xml">
voltage</link>, that can, in turn, control more logic gates.  </p>
<p>

Logic gates often use the fewest number of transistors in order to reduce their size, power consumption and cost, and increase their reliability.  </p>
<p>

<link xlink:type="simple" xlink:href="../150/15150.xml">
Integrated circuit</link>s, are the least expensive way to make logic gates in large volumes.  Integrated circuits are usually designed by engineers using <link xlink:type="simple" xlink:href="../881/216881.xml">
electronic design automation</link> software (See below for more information).</p>
<p>

Another form of digital circuit is constructed from lookup tables, (many sold as "<link xlink:type="simple" xlink:href="../215/73215.xml">
programmable logic device</link>s", though other kinds of PLDs exist).  Lookup tables can perform the same functions as machines based on logic gates, but can be easily reprogrammed without changing the wiring.  This means that a designer can often repair design errors without changing the arrangement of wires.  Therefore, in small volume products, programmable logic devices are often the preferred solution.  They are usually designed by engineers using <link xlink:type="simple" xlink:href="../881/216881.xml">
electronic design automation</link> software (See below for more information).</p>
<p>

When the volumes are medium to large, and the logic can be slow, or involves complex algorithms or sequences, often a small <link xlink:type="simple" xlink:href="../017/21017.xml">
microcontroller</link> is <link xlink:type="simple" xlink:href="../783/5783.xml">
programmed</link> to make an <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded system</link>.  These are usually programmed by <link xlink:type="simple" xlink:href="../010/27010.xml">
software engineers</link>.</p>
<p>

When only one digital circuit is needed, and its design is totally customized, as for a factory production line controller, the conventional solution is a <link xlink:type="simple" xlink:href="../992/24992.xml">
programmable logic controller</link>, or PLC.  These are usually programmed by electricians, using <link xlink:type="simple" xlink:href="../251/66251.xml">
ladder logic</link>.</p>

<ss1>
<st>
Structure of digital systems</st>

<p>

Engineers use many methods to minimize logic functions, in order to reduce the circuit's complexity.  When the complexity is less, the circuit also has fewer errors and less electronics, and is therefore less expensive.</p>
<p>

The most widely used simplification is a minimization algorithm like the <link xlink:type="simple" xlink:href="../395/12152395.xml">
Espresso heuristic logic minimizer</link> within a <link xlink:type="simple" xlink:href="../315/37315.xml">
CAD</link> system, although historically, <link xlink:type="simple" xlink:href="../855/576855.xml">
binary decision diagrams</link>, an automated <link>
Quine–McCluskey algorithm</link>, <link xlink:type="simple" xlink:href="../362/30362.xml">
truth table</link>s, <link xlink:type="simple" xlink:href="../684/10854684.xml">
Karnaugh Map</link>s, and <link xlink:type="simple" xlink:href="../239/2701239.xml">
Boolean algebra</link> have been used.</p>
<p>

Representations are crucial to an engineer's design of digital circuits.  Some analysis methods only work with particular representations.</p>
<p>

The classical way to represent a digital circuit is with an equivalent set of <link xlink:type="simple" xlink:href="../168/18168.xml">
logic gates</link>.  Another way, often with the least electronics, is to construct an equivalent system of electronic switches (usually <link xlink:type="simple" xlink:href="../011/30011.xml">
transistor</link>s).  One of the easiest ways is to simply have a memory containing a <link xlink:type="simple" xlink:href="../362/30362.xml">
truth table</link>.  The inputs are fed into the address of the memory, and the data outputs of the memory become the outputs.</p>
<p>

For automated analysis, these representations have digital file formats that can be processed by computer programs.  Most digital engineers are very careful to select computer programs ("tools") with compatible file formats.</p>
<p>

To choose representations, engineers consider types of digital systems.  Most digital systems divide into "combinatorial systems" and "sequential systems."  A combinatorial system always presents the same output when given the same inputs.  It is basically a representation of a set of logic functions, as already discussed. </p>
<p>

A sequential system is a combinatorial system with some of the outputs fed back as inputs.  This makes the digital machine perform a "sequence" of operations.  The simplest sequential system is probably a <link xlink:type="simple" xlink:href="../777/11777.xml">
flip flop</link>, a mechanism that represents a <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> <link xlink:type="simple" xlink:href="../685/49685.xml">
digit</link> or "<link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link>".</p>
<p>

Sequential systems are often designed as <link xlink:type="simple" xlink:href="../931/10931.xml">
state machine</link>s.  In this way, engineers can design a system's gross behavior, and even test it in a simulation, without considering all the details of the logic functions.</p>
<p>

Sequential systems divide into two further subcategories. <link xlink:type="simple" xlink:href="../129/1627129.xml">
 "Synchronous" sequential system</link>s change state all at once, when a "clock" signal changes state.  <link xlink:type="simple" xlink:href="../097/3801097.xml">
 "Asynchronous" sequential system</link>s propagate changes whenever inputs change.  Synchronous sequential systems are made of well-characterized asynchronous circuits such as flip-flops, that change only when the clock changes, and which have carefully designed timing margins. </p>
<p>

The usual way to implement a synchronous sequential state machine is divide it into a piece of combinatorial logic and a set of flip flops called a "state register."  Each time a clock signal ticks, the state register captures the feedback generated from the previous state of the combinatorial logic, and feeds it back as an unchanging input to the combinatorial part of the state machine.  The fastest rate of the clock is set by the most time-consuming logic calculation in the combinatorial logic.</p>
<p>

The state register is just a representation of a binary number.  If the states in the state machine are numbered (easy to arrange), the logic function is some combinatorial logic that produces the number of the next state.</p>
<p>

In comparison, asynchronous systems are very hard to design because all possible states, in all possible timings must be considered.  The usual method is to construct a table of the minimum and maximum time that each such state can exist, and then adjust the circuit to minimize the number of such states, and force the circuit to periodically wait for all of its parts to enter a compatible state.  (This is called "self-resynchronization.")  Without such careful design, it is easy to accidentally produce asynchronous logic that is "unstable", that is, real electronics will have unpredictable results because of the cumulative delays caused by small variations in the values of the electronic components. Certain circuits (such as the synchronizer flip-flops, switch <link>
debounce</link>rs, and the like which allow external unsynchronized signals to enter synchronous logic circuits) are inherently asynchronous in their design and must be analyzed as such.</p>
<p>

As of 2005, almost all digital machines are synchronous designs because it is much easier to create and verify a synchronous design -- the software currently used to simulate digital machines does not yet handle asynchronous designs. However, asynchronous logic is thought to be superior, if it can be made to work, because its speed is not constrained by an arbitrary clock; instead, it simply runs at the maximum speed permitted by the propagation rates of the logic gates from which it is constructed. Building an asynchronous  circuit using faster parts implicitly makes the circuit "go" faster. </p>
<p>

More generally, many digital systems are data flow machines.  These are usually designed using synchronous <link xlink:type="simple" xlink:href="../084/963084.xml">
register transfer logic</link>, using hardware description languages such as <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../410/43410.xml">
VHDL</link></language>
 or <standard wordnetid="107260623" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../863/63863.xml">
Verilog</link></system_of_measurement>
</language>
</standard>
.</p>
<p>

In register transfer logic, <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> <link xlink:type="simple" xlink:href="../690/21690.xml">
number</link>s are stored in groups of flip flops called <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link>s.  The outputs of each register are a bundle of wires called a "<link xlink:type="simple" xlink:href="../631/6631.xml">
bus</link>" that carries that number to other calculations.  A calculation is simply a piece of combinatorial logic.  Each calculation also has an output bus, and these may be connected to the inputs of several registers.  Sometimes a register will have a <link xlink:type="simple" xlink:href="../542/38542.xml">
multiplexer</link> on its input, so that it can store a number from any one of several buses.  Alternatively, the outputs of several items may be connected to a bus through <link xlink:type="simple" xlink:href="../463/1972463.xml">
buffers</link> that can turn off the output of all of the devices except one.  A sequential state machine controls when each register accepts new data from its input.</p>
<p>

In the 1980s, some researchers discovered that almost all synchronous register-transfer machines could be converted to asynchronous designs by using first-in-first-out synchronization logic.  In this scheme, the digital machine is characterized as a set of data flows.  In each step of the flow, an asynchronous "synchronization circuit" determines when the outputs of that step are valid, and presents a signal that says, "grab the data" to the  stages that use that stage's inputs.  It turns out that just a few relatively simple synchronization circuits are needed.</p>
<p>

The most general-purpose register-transfer logic machine is a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>.  This is basically an <link xlink:type="simple" xlink:href="../749/189749.xml">
automatic</link> <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> <link xlink:type="simple" xlink:href="../655/655.xml">
abacus</link>. The <link xlink:type="simple" xlink:href="../557/6557.xml">
control unit</link> of a computer is usually designed as a <link xlink:type="simple" xlink:href="../999/19999.xml">
microprogram</link> run by a <link xlink:type="simple" xlink:href="../509/127509.xml">
microsequencer</link>.  A microprogram is much like a  player-piano roll.  Each table entry or "word" of the microprogram commands the state of every bit that controls the computer.  The sequencer then counts, and the count addresses the memory or combinatorial logic machine that contains the microprogram.  The bits from the microprogram control the <link xlink:type="simple" xlink:href="../504/199504.xml">
arithmetic logic unit</link>, <link xlink:type="simple" xlink:href="../844/18844.xml">
memory</link> and other parts of the computer, including the <link xlink:type="simple" xlink:href="../509/127509.xml">
microsequencer</link> itself.</p>
<p>

In this way, the complex task of designing the controls of a computer is reduced to a simpler task of programming a relatively independent collection of much simpler logic machines.</p>
<p>

<link xlink:type="simple" xlink:href="../509/6509.xml">
Computer architecture</link> is a specialized engineering activity that tries to arrange the registers, calculation logic, buses and other parts of the computer in the best way for some purpose.  Computer architects have applied large amounts of ingenuity to computer design to reduce the cost and increase the speed and immunity to programming errors of computers.  An increasingly common goal is to reduce the power used in a battery-powered computer system, such as a cell-phone.  Many computer architects serve an extended apprenticeship as microprogrammers.</p>
<p>

"Specialized computers" are usually a conventional computer with a special-purpose microprogram.</p>

</ss1>
<ss1>
<st>
Automated design tools</st>

<p>

To save costly engineering effort, much of the effort of designing large logic machines has been automated.  The computer programs are called "<link xlink:type="simple" xlink:href="../881/216881.xml">
electronic design automation</link> tools" or just "EDA."</p>
<p>

Simple truth table-style descriptions of logic are often optimized with EDA that automatically produces reduced systems of logic gates or smaller lookup tables that still produce the desired outputs. The most common example of this kind of software is the <link xlink:type="simple" xlink:href="../395/12152395.xml">
Espresso heuristic logic minimizer</link>.</p>
<p>

Most practical algorithms for optimizing large logic systems use <link xlink:type="simple" xlink:href="../263/317263.xml">
algebraic manipulations</link> or <link xlink:type="simple" xlink:href="../855/576855.xml">
binary decision diagram</link>s, and there are promising experiments with <link xlink:type="simple" xlink:href="../254/40254.xml">
genetic algorithm</link>s and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/172244.xml">
annealing optimization</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s.</p>
<p>

To automate costly engineering processes, some EDA can take <link xlink:type="simple" xlink:href="../857/548857.xml">
state table</link>s that describe <link xlink:type="simple" xlink:href="../931/10931.xml">
state machine</link>s and automatically produce a <link xlink:type="simple" xlink:href="../362/30362.xml">
truth table</link> or a <link>
function table</link> for the combinatorial part of a state machine.  The state table is a piece of text that lists each state, together with the conditions controlling the transitions between them and the belonging output signals.</p>
<p>

It is common for the function tables of such computer-generated state-machines to be optimized with logic-minimization software such as <link xlink:type="simple" xlink:href="../395/12152395.xml">
Minilog</link>.  </p>
<p>

Often, real logic systems are designed as a series of sub-projects, which are combined using a "tool flow."  The tool flow is usually a "script," a simplified computer language that can invoke the software design tools in the right order.  </p>
<p>

Tool flows for large logic systems such as microprocessors can be thousands of commands long, and combine the work of hundreds of engineers.  </p>
<p>

Writing and debugging tool flows is an established engineering specialty in companies that produce digital designs.  The tool flow usually terminates in a detailed computer file or set of files that describe how to physically construct the logic.  Often it consists of instructions to draw the <link xlink:type="simple" xlink:href="../011/30011.xml">
transistors</link> and wires on an <link xlink:type="simple" xlink:href="../150/15150.xml">
integrated circuit</link> or a <link xlink:type="simple" xlink:href="../910/65910.xml">
printed circuit board</link>.</p>
<p>

Parts of tool flows are "debugged" by verifying the outputs of simulated logic against expected inputs.  The test tools take computer files with sets of inputs and outputs, and highlight discrepancies between the simulated behavior and the expected behavior.</p>
<p>

Once the input data is believed correct, the design itself must still be verified for correctness.  Some tool flows verify designs by first producing a design, and then scanning the design to produce compatible input data for the tool flow.  If the scanned data matches the input data, then the tool flow has probably not introduced errors.</p>
<p>

The functional verification data are usually called "test vectors."  The functional test vectors may be preserved and used in the factory to test that newly constructed logic works correctly.  However, functional test patterns don't discover common fabrication faults.  Production tests are often designed by software tools called "<link>
test pattern generators</link>." These generate test vectors by examining the structure of the logic and systematically generating tests for particular faults. This way the <link xlink:type="simple" xlink:href="../718/3731718.xml">
fault coverage</link> can closely approach 100%, provided the design is properly made testable (see next section).</p>
<p>

Once a design exists, and is verified and testable, it often needs to be processed to be manufacturable as well.  Modern integrated circuits have features smaller than the wavelength of the light used to expose the photoresist.  Manufacturability software adds interference patterns to the exposure masks to eliminate open-circuits, and enhance the masks' resolution and contrast.</p>

</ss1>
<ss1>
<st>
Design for testability</st>

<p>

A large logic machine (say, with more than a hundred logical variables) can have an astronomical number of possible states.  Obviously, in the factory, testing every state is impractical if testing each state takes a microsecond, and there are more states than the number of microseconds since the universe began.  Unfortunately, this ridiculous-sounding case is typical.</p>
<p>

Fortunately, large logic machines are almost always designed as assemblies of smaller logic machines.  To save time, the smaller sub-machines are isolated by permanently-installed "design for test" circuitry, and are tested independently.</p>
<p>

One common test scheme known as "scan design" moves test bits serially (one after another) from external test equipment through one or more serial <link xlink:type="simple" xlink:href="../699/41699.xml">
shift register</link>s known as "scan chains".  Serial scans have only one or two wires to carry the data, and minimize the physical size and expense of the infrequently-used test logic. </p>
<p>

After all the test data bits are in place, the design is reconfigured to be in "normal mode" and one or more clock pulses are applied, to test for faults (e.g. stuck-at low or stuck-at high) and capture the test result into <link xlink:type="simple" xlink:href="../777/11777.xml">
flip-flop</link>s and/or latches in the scan shift register(s).  Finally, the result of the test is shifted out to the block boundary and compared against the predicted "good machine" result.  </p>
<p>

In a board-test environment, serial to parallel testing has been formalized with a standard called "<link xlink:type="simple" xlink:href="../112/638112.xml">
JTAG</link>" (named after the "Joint Test Action Group" that proposed it).</p>
<p>

Another common testing scheme provides a test mode that forces some part of the logic machine to enter a "test cycle."  The test cycle usually exercises large independent parts of the machine.</p>

</ss1>
<ss1>
<st>
Trade-offs</st>

<p>

Several numbers determine the practicality of a system of digital logic.  Engineers explored numerous electronic devices to get an ideal combination of <link xlink:type="simple" xlink:href="../955/289955.xml">
fanout</link>, speed, low cost and reliability.</p>
<p>

The cost of a logic gate is crucial.  In the 1930s, the earliest digital logic systems were constructed from telephone relays because these were inexpensive and relatively reliable.  After that, engineers always used the cheapest available electronic switches that could still fulfill the requirements.  </p>
<p>

The earliest <link xlink:type="simple" xlink:href="../150/15150.xml">
integrated circuit</link>s were a happy accident.  They were constructed not to save money, but to save weight, and permit the <computer wordnetid="103082979" confidence="0.8">
<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../887/188887.xml">
Apollo Guidance Computer</link></machine>
</device>
</instrumentality>
</artifact>
</system>
</computer>
 to control an <link xlink:type="simple" xlink:href="../148/201148.xml">
inertial guidance system</link> for a spacecraft. The first integrated circuit logic gates cost nearly $50 (in 1960 dollars, when an engineer earned $10,000/year).  To everyone's surprise, by the time the circuits were mass-produced, they had become the least-expensive method of constructing digital logic.  Improvements in this technology have driven all subsequent improvements in cost.</p>
<p>

With the rise of <link xlink:type="simple" xlink:href="../150/15150.xml">
integrated circuits</link>, reducing the absolute number of chips used represented another way to save costs. The goal of a designer is not just to make the simplest circuit, but to keep the component count down. Sometimes this results in slightly more complicated designs with respect to the underlying digital logic but nevertheless reduces the number of components, board size, and even power consumption.</p>
<p>

For example, in some logic families, <link xlink:type="simple" xlink:href="../001/510001.xml">
NAND</link> gates are the simplest digital gate to build.  All other logical operations can be implemented by <link xlink:type="simple" xlink:href="../001/510001.xml">
NAND</link> gates. If a circuit already required a single <link xlink:type="simple" xlink:href="../001/510001.xml">
NAND</link> gate, and a single chip normally carried four <link xlink:type="simple" xlink:href="../001/510001.xml">
NAND</link> gates, then the remaining gates could be used to implement other logical operations like <link>
logical and</link>.  This could eliminate the need for a separate chip containing those different types of gates.</p>
<p>

The "reliability" of a logic gate describes its mean time between failure (MTBF).  Digital machines often have millions of logic gates.  Also, most digital machines are "optimized" to reduce their cost.  The result is that often, the failure of a single logic gate will cause a digital machine to stop working.</p>
<p>

Digital machines first became useful when the MTBF for a switch got above a few hundred hours.  Even so, many of these machines had complex, well-rehearsed repair procedures, and would be nonfunctional for hours because a tube burned-out, or a moth got stuck in a relay.  Modern transistorized integrated circuit logic gates have MTBFs of nearly a trillion (1×1012) hours, and need them because they have so many logic gates.</p>
<p>

<link xlink:type="simple" xlink:href="../955/289955.xml">
Fanout</link> describes how many logic inputs can be controlled by a single logic output.  The minimum practical fanout is about five.  Modern electronic logic using <link xlink:type="simple" xlink:href="../420/49420.xml">
CMOS</link> <link xlink:type="simple" xlink:href="../011/30011.xml">
transistor</link>s for switches have fanouts near fifty, and can sometimes go much higher.  </p>
<p>

The "switching speed" describes how many times per second an inverter (an electronic representation of a "logical not" function) can change from true to false and back.  Faster logic can accomplish more operations in less time.  Digital logic first became useful when switching speeds got above fifty <link xlink:type="simple" xlink:href="../121/14121.xml">
hertz</link>, because that was faster than a team of humans operating mechanical calculators.  Modern electronic digital logic routinely switches at five <link xlink:type="simple" xlink:href="../121/14121.xml">
gigahertz</link> (5×109 hertz), and some laboratory systems switch at more than a <link xlink:type="simple" xlink:href="../348/362348.xml">
terahertz</link> (1×1012 hertz).</p>

</ss1>
<ss1>
<st>
Logic families</st>

<p>

Design started with <link xlink:type="simple" xlink:href="../590/26590.xml">
relay</link>s. Relay logic was relatively inexpensive and reliable, but slow.  Occasionally a mechanical failure would occur. <link xlink:type="simple" xlink:href="../955/289955.xml">
Fanout</link>s were typically about ten, limited by the resistance of the coils and arcing on the contacts from high voltages.</p>
<p>

Later, <link xlink:type="simple" xlink:href="../496/32496.xml">
vacuum tube</link>s were used.  These were very fast, but generated heat, and were  unreliable because the filaments would burn out.  Fanouts were typically five to seven, limited by the heating from the tubes' current.  In the 1950s, special "computer tubes" were developed with filaments that omitted volatile elements like silicon.  These ran for hundreds of thousands of hours.</p>
<p>

The first <link xlink:type="simple" xlink:href="../709/27709.xml">
semiconductor</link> logic family was <link xlink:type="simple" xlink:href="../749/417749.xml">
Resistor-transistor logic</link>.  This was a thousand times more reliable than tubes, ran cooler, and used less power, but had a very low <link xlink:type="simple" xlink:href="../425/4110425.xml">
fan-in</link> of three. <link xlink:type="simple" xlink:href="../752/417752.xml">
Diode-transistor logic</link> improved the fanout up to about seven, and reduced the power.  Some DTL designs used two power-supplies with alternating layers of NPN and PNP transistors to increase the fanout.</p>
<p>

<link xlink:type="simple" xlink:href="../769/47769.xml">
Transistor transistor logic</link> (TTL) was a great improvement over these.  In early devices, fanout improved to ten, and later variations reliably achieved twenty.  TTL was also fast, with some variations achieving switching times as low as twenty nanoseconds.  TTL is still used in some designs.</p>
<p>

Another contender was <link xlink:type="simple" xlink:href="../936/205936.xml">
emitter coupled logic</link>.  This is very fast but uses a lot of power.  It's now used mostly in radio-frequency circuits.</p>
<p>

Modern integrated circuits mostly use variations of <link xlink:type="simple" xlink:href="../420/49420.xml">
CMOS</link>, which is acceptably fast, very small and uses very little power.  Fanouts of forty or more are possible, with some speed penalty.</p>

</ss1>
</sec>
<sec>
<st>
Non-electronic logic</st>

<p>

It is possible to construct non-electronic digital mechanisms.  In principle, any technology capable of representing discrete states and representing logic operations could be used to build mechanical logic. <link xlink:type="simple" xlink:href="../908/328908.xml">
Danny Hillis</link>, co-author of <link xlink:type="simple" xlink:href="../760/68760.xml">
The Connection Machine</link>, once built a working computer from <link xlink:type="simple" xlink:href="../559/564559.xml">
Tinker toys</link>, string, a brick, and a sharpened pencil, which is supposed to be in the <artifact wordnetid="100021939" confidence="0.8">
<science_museum wordnetid="104147364" confidence="0.8">
<facility wordnetid="103315023" confidence="0.8">
<depository wordnetid="103177349" confidence="0.8">
<museum wordnetid="103800563" confidence="0.8">
<link xlink:type="simple" xlink:href="../355/3688355.xml">
Houston Museum of Natural Science</link></museum>
</depository>
</facility>
</science_museum>
</artifact>
.</p>
<p>

Hydraulic, pneumatic and mechanical versions of logic gates exist and are used in situations where electricity cannot be used.  The first two types are considered under the heading of <link xlink:type="simple" xlink:href="../106/966106.xml">
fluidics</link>.  One application of fluidic logic is in military hardware that is likely to be exposed to a nuclear <link xlink:type="simple" xlink:href="../097/41097.xml">
electromagnetic pulse</link> (nuclear EMP, or NEMP) that would destroy electrical circuits.  </p>
<p>

Mechanical logic is frequently used in inexpensive controllers, such as those in washing machines.  Famously, the first computer design, by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../698/5698.xml">
Charles Babbage</link></scientist>
, was designed to use mechanical logic.  Mechanical logic might also be used in very small computers that could be built by <link xlink:type="simple" xlink:href="../488/21488.xml">
nanotechnology</link>.</p>
<p>

Another example is that if two particular enzymes are required to prevent the construction of a particular protein, this is the equivalent of a biological "NAND" gate.</p>

</sec>
<sec>
<st>
Recent developments</st>
<p>

The discovery of <link xlink:type="simple" xlink:href="../884/26884.xml">
superconductivity</link> has enabled the development of <link xlink:type="simple" xlink:href="../564/667564.xml">
Rapid Single Flux Quantum</link> (RSFQ) circuit technology, which uses <link xlink:type="simple" xlink:href="../712/446712.xml">
Josephson junction</link>s instead of transistors. Most recently, attempts are being made to construct purely <link xlink:type="simple" xlink:href="../832/370832.xml">
optical computing</link> systems capable of processing digital information using <link xlink:type="simple" xlink:href="../103/146103.xml">
nonlinear</link> optical elements.</p>

</sec>
<sec>
<st>
Branch pages</st>
<p>

<link xlink:type="simple" xlink:href="../663/9663.xml">
Electronics</link> - <link xlink:type="simple" xlink:href="../371/89371.xml">
Combinatorial logic</link> - <link xlink:type="simple" xlink:href="../239/2701239.xml">
Boolean algebra</link> - <link xlink:type="simple" xlink:href="../097/1958097.xml">
Fuzzy electronics</link> - <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../613/40613.xml">
Logic analyzer</link></instrumentality>
</artifact>
</system>
 - <link xlink:type="simple" xlink:href="../168/18168.xml">
Logic gate</link> - <link xlink:type="simple" xlink:href="../005/310005.xml">
Glitch</link> - <link xlink:type="simple" xlink:href="../023/310023.xml">
Ringing</link> - <arrangement wordnetid="107938773" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<array wordnetid="107939382" confidence="0.8">
<link xlink:type="simple" xlink:href="../215/73215.xml">
Programmable logic device</link></array>
</group>
</arrangement>
 - <link xlink:type="simple" xlink:href="../371/188371.xml">
Reconfigurable system</link> - <register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../432/486432.xml">
Register</link></written_record>
</evidence>
</indication>
</record>
</register>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../156/295156.xml">
List of electronics topics</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../281/1665281.xml">
Analog circuit</link> - <link xlink:type="simple" xlink:href="../643/8707643.xml">
Electronic circuit</link> - <link xlink:type="simple" xlink:href="../420/49420.xml">
CMOS</link> - <written_communication wordnetid="106349220" confidence="0.8">
<code wordnetid="106667317" confidence="0.8">
<link xlink:type="simple" xlink:href="../714/294714.xml">
Data strobe encoding</link></code>
</written_communication>
 - <process wordnetid="105701363" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../669/64669.xml">
De Morgan's laws</link></higher_cognitive_process>
</theory>
</explanation>
</rule>
</thinking>
</concept>
</idea>
</process>
 - <link xlink:type="simple" xlink:href="../276/8276.xml">
Digital</link> - <link xlink:type="simple" xlink:href="../TN$$/HT$C$_T$yT$N$.xml">
Digital signal processing</link> - <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<electrical_device wordnetid="103269401" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<circuit wordnetid="103033362" confidence="0.8">
<link xlink:type="simple" xlink:href="../559/9559.xml">
Electrical network</link></circuit>
</device>
</electrical_device>
</instrumentality>
</artifact>
 - <link xlink:type="simple" xlink:href="../663/9663.xml">
Electronics</link> - <link xlink:type="simple" xlink:href="../357/11357.xml">
Field effect transistor</link> - <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../931/10931.xml">
Finite state machine</link></method>
</know-how>
 - <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../054/270054.xml">
Formal verification</link></method>
</know-how>
 - <link xlink:type="simple" xlink:href="../554/74554.xml">
Hardware description language</link> - <link xlink:type="simple" xlink:href="../314/220314.xml">
Instruction pipelining</link> - <link xlink:type="simple" xlink:href="../150/15150.xml">
Integrated circuit</link> - <link xlink:type="simple" xlink:href="../366/399366.xml">
Logical effort</link> - <link xlink:type="simple" xlink:href="../374/11245374.xml">
Logic minimization</link> - <link xlink:type="simple" xlink:href="../374/89374.xml">
Sequential logic</link> - <link xlink:type="simple" xlink:href="../377/19377.xml">
Microelectronics</link> - <link xlink:type="simple" xlink:href="../005/310005.xml">
Glitch</link> - <link xlink:type="simple" xlink:href="../023/310023.xml">
Ringing</link> - <link xlink:type="simple" xlink:href="../355/2930355.xml">
NMOS</link> - <link xlink:type="simple" xlink:href="../011/30011.xml">
Transistor</link> - <link xlink:type="simple" xlink:href="../769/47769.xml">
Transistor-transistor logic</link> - <link xlink:type="simple" xlink:href="../363/5829363.xml">
Transparent latch</link> - <link xlink:type="simple" xlink:href="../904/249904.xml">
Ternary logic</link> - <link xlink:type="simple" xlink:href="../987/309987.xml">
Runt pulse</link> - <link xlink:type="simple" xlink:href="../811/41811.xml">
Transmission line</link> - <link xlink:type="simple" xlink:href="../411/43411.xml">
VHSIC</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../693/5693.xml">
Claude E. Shannon</link> : used <link xlink:type="simple" xlink:href="../239/2701239.xml">
Boolean algebra</link> for building digital circuits.</entry>
<entry level="1" type="bullet">

 List of electrical <link>
Input/Output standards</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ibiblio.org/obp/electricCircuits/Digital/">
Lessons in Electric Circuits - Volume IV (Digital)</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-004Computation-StructuresFall2002/CourseHome/">
MIT OpenCourseWare introduction to digital design class materials ("6.004: Computation Structures")</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://ebooks.avrguide.com/">
Digital circuits, electronic related books and projects</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/cedarlogic">
 Free Digital Logic Simulation CAD Tool</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 R.H. Katz, <it>Contemporary Logic Design</it>, The Benjamin/Cummings Publishing Company, 1994.</entry>
<entry level="1" type="bullet">

 P.K. Lala, <it>Practical Digital Logic Design and Testing</it>, Prentice Hall, 1996.</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../276/8276.xml">
Digital</link>systems</header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
Components</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../168/18168.xml">
Logic gate</link>&nbsp;·  <link xlink:type="simple" xlink:href="../068/39068.xml">
digital circuit</link>&nbsp;·  <link xlink:type="simple" xlink:href="../150/15150.xml">
integrated circuit</link>(IC)</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Theory</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<link xlink:type="simple" xlink:href="../124/12351124.xml">
Boolean logic</link>&nbsp;·  <link xlink:type="simple" xlink:href="../TN$$/HT$C$_T$yT$N$.xml">
digital signal processing</link>&nbsp;·  <link xlink:type="simple" xlink:href="../509/6509.xml">
computer architecture</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Applications</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../712/53712.xml">
Audio</link>&nbsp;·  <link xlink:type="simple" xlink:href="../597/3616597.xml">
Photography</link>&nbsp;·  <link xlink:type="simple" xlink:href="../733/8733.xml">
Video</link></col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</instrumentality>
</artifact>
</system>
</article>
