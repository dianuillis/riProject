<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:56:54[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<language  confidence="0.9511911446218017" wordnetid="106282651">
<header>
<title>Job Control Language</title>
<id>391487</id>
<revision>
<id>243384456</id>
<timestamp>2008-10-06T08:33:09Z</timestamp>
<contributor>
<username>Philcha</username>
<id>2404663</id>
</contributor>
</revision>
<categories>
<category>Domain-specific programming languages</category>
<category>Job scheduling</category>
<category>Scripting languages</category>
<category>IBM Mainframe computer operating systems</category>
</categories>
</header>
<bdy>

<b>Job Control Language</b> (<b>JCL</b>) is a <link xlink:type="simple" xlink:href="../524/29524.xml">
scripting language</link> used on <link xlink:type="simple" xlink:href="../872/14872.xml">
IBM mainframe</link> operating systems to instruct the system on how to run a <link xlink:type="simple" xlink:href="../285/37285.xml">
batch job</link> or start a subsystem.  The term "Job Control Language" can also be used generically to refer to all languages which perform these functions, such as <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../524/4524.xml">
Burroughs</link></institution>
</company>
' <link xlink:type="simple" xlink:href="../537/1455537.xml">
 WFL</link> and <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../789/515789.xml">
 ICL</link></institution>
</company>
's OCL. This article is specifically about IBM's JCL.<p>

There are actually 2 IBM JCLs: one for the operating system lineage that begins with <link xlink:type="simple" xlink:href="../229/626229.xml">
DOS/360</link> and whose latest member is <link xlink:type="simple" xlink:href="../682/32682.xml">
z/VSE</link>; and the other for the lineage from <link xlink:type="simple" xlink:href="../737/14387737.xml">
OS/360</link> to <link xlink:type="simple" xlink:href="../122/39122.xml">
z/OS</link>. They share some basic syntax rules and a few basic concepts, but are otherwise very different.</p>

<sec>
<st>
Features common to DOS and OS JCL</st>

<ss1>
<st>
Jobs, steps and procedures</st>
<p>

In both JCLs the unit of work is the job. A job consists of one (or several) steps, each of which is a request to run one specific program. For example before the days of <link xlink:type="simple" xlink:href="../873/25873.xml">
relational database</link>s a job to produce a printed report for management might consist of the following steps: a user-written program to select the appropriate records and copy them to a temporary file; <link xlink:type="simple" xlink:href="../442/28442.xml">
 sort</link> the temporary file into the required order, usually using a general-purpose utility; a user-written program to present the information in a way that is easy for the end-users to read and includes other useful information such as sub-totals.</p>
<p>

In both DOS and OS JCL the first "card" must be the JOB card, which:
<list>
<entry level="1" type="bullet">

Identifies the job.</entry>
<entry level="1" type="bullet">

Usually provides information to enable the computer services department to bill the appropriate user department.</entry>
<entry level="1" type="bullet">

Defines how the job as a whole is to be run, e.g. its priority relative to other jobs in the queue.</entry>
</list>
</p>
<p>

Procedures (commonly called <it>procs</it>) are pre-written JCL for steps or groups of steps, inserted into a job.  Both JCLs allow such procedures. Procs are used for repeating steps which are used several times in one job, or in several different jobs. They save programmer time and reduce the risk of errors. To run a procedure one simply includes in the JCL file a single "card" which copies the procedure from a specified file, and inserts it into the jobstream.  Also, procs can include <it>parameters</it> to customize the procedure for each use.</p>

</ss1>
<ss1>
<st>
Basic syntax</st>
<p>

Both DOS and OS JCL have a maximum usable line length of 80 characters, because when <link xlink:type="simple" xlink:href="../229/626229.xml">
DOS/360</link> and <link xlink:type="simple" xlink:href="../737/14387737.xml">
OS/360</link> were first used the main method of providing new input to a computer system was 80-column <link xlink:type="simple" xlink:href="../420/24420.xml">
punched card</link>s. It later became possible to submit jobs via disk or tape files with longer record lengths, but the operating system's job submission components ignored everything after character 80.</p>
<p>

Strictly speaking both operating system families use only 71 characters per line. Characters 73-80 are usually card sequence numbers which the system printed on the end-of-job report and are useful for identifying the locations of any errors reported by the operating system. Character 72 is usually left blank to separate the real JCL from any sequence numbers, but in OS JCL it can contain a continuation character for comments (see below).</p>
<p>

All commands, parameter names and values have to be in capitals, except for <link xlink:type="simple" xlink:href="../535/593535.xml">
USS</link> filenames.</p>
<p>

All lines except for in-stream input (see below) have to begin with a slash "/", and all lines which the operating system processes have to begin with two slashes "//" - always starting in the <it>first column</it>. However, there are two exceptions: the delimiter statement and the comment statement. A delimiter statements begins with a slash and an asterisk (/*), and a comment statement begins with a pair of slash and asterisk (//*).</p>
<p>

Many JCL statements are too long to fit within 71 characters, but can be extended on to an indefinite number of continuation cards by:
<list>
<entry level="1" type="bullet">

Ending all actual JCL cards except the last at a point where the syntax requires a comma ",".</entry>
<entry level="1" type="bullet">

Starting each continuation card with "//" in column 1 and then at least 1 space.</entry>
</list>
</p>
<p>

The structure of the most common types of card is:
<list>
<entry level="1" type="bullet">

"//"</entry>
<entry level="1" type="bullet">

Name of whatever the card applies to, following "//" with no space between.</entry>
<entry level="1" type="bullet">

Space(s)</entry>
<entry level="1" type="bullet">

Statement type</entry>
<entry level="1" type="bullet">

Space(s)</entry>
<entry level="1" type="bullet">

Parameters which vary depending on the statement type, separated by commas and with no space between them.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
In-stream input</st>
<p>

DOS and OS JCL both allow in-stream input, i.e. "cards" which are to be processed by the application program rather than the operating system. Data which is to be kept for a long time will normally be stored on disk, but before the use of <link xlink:type="simple" xlink:href="../528/644528.xml">
interactive</link> terminals became common the only way to create and edit such disk files was by supplying the new data on cards.</p>
<p>

DOS and OS JCL have different ways of signaling the start of in-stream input, but both end in-stream input with "/*" at column 1 of the card following the last in-stream data card. This makes the operating system resume processing JCL in the card following the "/*" card.</p>
<p>

DD statements can be used to describe in-stream data, as well as data sets. A DD statement dealing with in-stream data has an asterisk (*) following the DD identifier. JCL statements can be included as part of in-stream data by using the DD DATA statements.</p>

</ss1>
<ss1>
<st>
Complexity</st>
<p>

This is best illustrated by a simple example. To copy a file in <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../027/20027.xml">
MS-DOS</link></O>
 one simply types in a command like
copy oldFile newFile</p>
<p>

In the <link xlink:type="simple" xlink:href="../737/14387737.xml">
OS/360</link> family one would use something like
//IS198CPY JOB (IS198T30500),'COPY JOB',CLASS=L,MSGCLASS=X
//COPY01   EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DSN=OLDFILE,DISP=SHR
//SYSUT2   DD DSN=NEWFILE,
//            DISP=(NEW,CATLG,DELETE),
//            SPACE=(CYL,(40,5),RLSE),
//            DCB=(LRECL=115,BLKSIZE=1150)
//SYSIN    DD DUMMY</p>
<p>

Some of the complexity is due to poor design - but quite a lot of the complexity is due to the environment in which JCL was expected to be used:
<list>
<entry level="1" type="bullet">

Low-end <link xlink:type="simple" xlink:href="../294/29294.xml">
System/360</link> CPUs were much less powerful and vastly more expensive than the mid-1980s PCs for which MS-DOS was designed. <link xlink:type="simple" xlink:href="../737/14387737.xml">
OS/360</link> was intended for systems with a minimum of 32 KB memory and <link xlink:type="simple" xlink:href="../229/626229.xml">
DOS/360</link> for systems with a minimum of 16 KB; and a 360/30 CPU (low-end when System/360 was announced in 1964) processed a mere 5K to 13K instructions per second.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> The first <link xlink:type="simple" xlink:href="../032/15032.xml">
IBM PC</link> (model <link xlink:type="simple" xlink:href="../032/15032.xml">
 5150</link> in 1981) had 16KB or 64KB of memory and would process about 330,000 instructions per second.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> As a result, JCL had to be easy for the <it>computer</it> to process, and ease of use by programmers was a much lower priority.</entry>
<entry level="1" type="bullet">

JCL was designed for <link xlink:type="simple" xlink:href="../285/37285.xml">
batch processing</link>, often by a computer in a different building from the user's office. So it has to tell the operating system everything, including what to do depending on the result of the step. For example DISP=(NEW,CATLG,DELETE) means "if the program runs successfully, create a new file and catalog it; otherwise delete the new file."</entry>
<entry level="1" type="bullet">

System/360 machines were designed to be shared by all the users in an organization. So the JOB card tells the operating system how to bill the users (account IS198T30500), what priority the job has relative to other users' jobs (CLASS=L), and several other things. //SYSPRINT DD  SYSOUT=* tells the computer to print the program's report on the default printer which is loaded with ordinary paper, not on some other printer which might be loaded with blank checks. DISP=SHR tells the operating system that other programs can read OLDFILE <link xlink:type="simple" xlink:href="../857/6857.xml">
 at the same time</link>.</entry>
</list>
</p>
<p>

Despite these difficulties IBM considered it necessary to retain all the features of the original JCLs, to avoid forcing customers to rewrite all their JCL files. But it later introduced easier alternatives such as <link xlink:type="simple" xlink:href="../542/391542.xml">
CLIST</link>. And of course most users save as a <it>procedure</it> any set of JCL statements which is likely to be used more than once or twice.</p>

</ss1>
</sec>
<sec>
<st>
DOS JCL</st>

<ss1>
<st>
Positional parameters</st>
<p>

// TLBL TAPEFIL,'COPYTAPE.JOB',,,,2
// ASSGN SYS005,DISK,VOL=VOL01,SHR
// DLBL DISKFIL,'COPYTAPE.JOB',0,SD
// EXTENT SYS005,VOL01,1,0,800,1600</p>
<p>

In DOS JCL parameters are positional, which makes them harder to read and write:
<list>
<entry level="1" type="bullet">

 The programmer must remember which item goes in which position in every type of statement.</entry>
<entry level="1" type="bullet">

 If some optional parameters are omitted but later ones are included, the omitted parameters must be represented by commas with no spaces, as in the TLBL statement above.</entry>
</list>
</p>
<p>

DOS JCL to some extent mitigates the difficulties of positional parameters by using more statements with fewer parameters than OS JCL. In the example the ASSGN, DLBL and EXTENT statements do the same work (specifying where a new disk file should be stored) as a single DD statement in OS JCL.</p>

</ss1>
<ss1>
<st>
Device dependence</st>
<p>

In the original <link xlink:type="simple" xlink:href="../229/626229.xml">
DOS/360</link> and in most versions of <link xlink:type="simple" xlink:href="../229/626229.xml">
DOS/VS</link> one had to specify the model number of the device which was to be used for each disk or tape file - even for existing files and for temporary files which would be deleted at the end of the job. This meant that, if a customer upgraded to a more modern type of device, many JCL files had to be changed.</p>
<p>

Later members of the DOS/360 family reduced the number of situations in which model numbers were required.</p>

</ss1>
</sec>
<sec>
<st>
OS JCL</st>

<p>

OS JCL consists of only 3 basic statements:
<list>
<entry level="1" type="bullet">

 JOB statement, which identifies the start of the job, and information about the whole job, such as billing, run priority, and time &amp; space limits.</entry>
<entry level="1" type="bullet">

 EXEC statement, which identifies the program to be executed in this step of the job, and information about the step.</entry>
<entry level="1" type="bullet">

 DD (Data Description) statements, which identify a data file to be used in a step, and detailed info about that file.  DD statements can be in any order within the step.</entry>
</list>
</p>
<p>

Right from the start JCL for the OS family (up to and including <link xlink:type="simple" xlink:href="../122/39122.xml">
z/OS</link>) was more flexible and easier to use.</p>
<p>

The examples below use the old style of syntax which was provided right from the launch of <link xlink:type="simple" xlink:href="../294/29294.xml">
System/360</link> in 1964. The old syntax is still quite common in jobs which have been running for over 20 years with only minor changes - these old jobs are often complex, and converting them to use the <link xlink:type="simple" xlink:href="../542/391542.xml">
CLIST</link> syntax would be tricky and time-consuming.</p>
<p>

Although the CLIST syntax is easier to read, programmers still have to provide the same amount of information as they would using the old syntax.</p>

<ss1>
<st>
Keyword parameters</st>
<p>

//NEWFILE DD DSN=MYFILE01,UNIT=DISK,SPACE=(TRK,50,10),
//           DCB=(LRECL=100,BLKSIZE=1000)
//           DISP=(NEW,CATLG,DELETE)
All of the major parameters of OS JCL statements are identified by keywords and can be presented in any order. A few of these contain 2 or more sub-parameters, like SPACE (how much disk space to allocate to a new file) and DCB (detailed specification of a file's layout) in the example above. Sub-parameters are sometimes positional, as in SPACE, but the most complex parameters, such as DCB, have keyword sub-parameters.</p>
<p>

Positional parameter must precede keyword parameters. Keyword parameters always assign values to a keyword using the equals sign (=).</p>

</ss1>
<ss1>
<st>
Device independence</st>
<p>

From the very beginning the JCL for the OS family of operating systems offered a high degree of device independence. Even for new files which were to be kept after the end of the job one could specify the device type in generic terms, e.g. UNIT=DISK or UNIT=TAPE. Of course if it mattered one could specify a model number or even a specific device address.</p>

</ss1>
<ss1>
<st>
Parameterized procedures</st>
<p>

OS JCL procedures were parameterized from the start, making them rather like <link xlink:type="simple" xlink:href="../368/1368.xml#xpointer(//*[./st=%22Macros%22])">
 macros</link> or even simple <link xlink:type="simple" xlink:href="../988/40988.xml">
subroutine</link>s and thus increasing their <link xlink:type="simple" xlink:href="../559/1086559.xml">
 reusability</link> in a wide range of situations.
//MYPROC PROC &amp;FNAME=MYFILE01,&amp;SPTYPE=TRK,&amp;SPINIT=50,&amp;SPEXT=10,&amp;LR=100,&amp;BLK=1000
.....
//NEWFILE DD DSN=&amp;FNAME,UNIT=DISK,SPACE=(&amp;SPTYPE,&amp;SPINIT,&amp;SPEXT),
//           DCB=(LRECL=&amp;LR,BLKSIZE=&amp;BLK),DISP=(NEW,CATLG,DELETE)
....
In this example all the values beginning with ampersands "&amp;" are parameters which will be specified when a job requests that the procedure be used. The PROC statement, in addition to giving the procedure a name, allows the programmer to specify default values for each parameter. So one could use the one procedure in this example to create new files of many different sizes and layouts. For example:
//JOB01  JOB ..........
//STEP01 EXEC MYPROC FNAME=JOESFILE,SPTYPE=CYL,SPINIT=10,SPEXT=2,LR=100,BLK=2000
or 
//JOB02  JOB ..........
//STEP01 EXEC MYPROC FNAME=SUESFILE,SPTYPE=TRK,SPINIT=500,SPEXT=100,LR=100,BLK=5000</p>

</ss1>
<ss1>
<st>
Override capabilities</st>
<p>

OS allows programmers to override in JCL some of the specifications of file structure which programs might contain. This facility is mostly used for creating new files. For example in
//STEP01  EXEC PGM=MYPROG
//NEWFILE DD DSN=MYFILE01,UNIT=DISK,SPACE=(TRK,50,10),DCB=BLKSIZE=1000,
//           DISP=(NEW,CATLG,DELETE)
the new file will have a <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../667/313667.xml">
 block size</link></instrumentality>
</artifact>
</system>
 of 1000 bytes even if code in program MYPROG says the block size should be something else - so there's no need to change program  MYPROG. On the other hand since this example does not specify the LRECL (record length) sub-parameter of DCB, the record length will be whatever MYPROG says.</p>

</ss1>
<ss1>
<st>
Referbacks</st>
<p>

In multi-step jobs, a later step can use a referback instead of specifying in full a file which has already been specified in an earlier step. For example in this <it>procedure</it>
//MYPROC ................
//MYPR01 EXEC PGM=..........
//NEWFILE DD DSN=&amp;MYFILE,UNIT=DISK,SPACE=(TRK,50,10),
//           DCB=(LRECL=100,BLKSIZE=1000),DISP=(NEW,CATLG,DELETE)
....
//MYPR02 EXEC PGM=..........
//INPUT01 DD DSN=*.MYPR01.NEWFILE
step MYPR02 uses the file identified as NEWFILE in step MYPR01 (DSN means "dataset name" and specifies the name of the file).</p>
<p>

In jobs which contain a mixture of job-specific JCL and procedure calls, a job-specific step can refer back to a file which was fully specified in a procedure, for example
//MYJOB JOB ..........
//STEP01 EXEC MYPROC             Using a procedure
//STEP02 EXEC PGM=.........      Step which is specific to this job
//INPUT01 DD DSN=*.STEP01.MYPR01.NEWFILE
where DSN=STEP01.MYPR01.NEWFILE means "use the file identified as NEWFILE in step MYPR01 of the procedure used by step STEP01 of this job". Using the name of the step which called the procedure rather than the name of the procedure allows a programmer to use the same procedure several times in the same job without confusion about which instance of the procedure is used in the referback.</p>

</ss1>
<ss1>
<st>
Comments</st>
<p>

JCL files can be long and complex, and the language is not easy to read. OS JCL allows programmers to include two types of explanatory comment:
<list>
<entry level="1" type="bullet">

On the same line as a JCL statement. They can be extended by placing a continuation character (usually "X") in column 71, followed by "//" in columns 1–2 of the next line.</entry>
<entry level="1" type="bullet">

Lines which contain only comment, often used to explain major points about the overall structure of the JCL rather than local details. Comment-only lines are also used to divide long, complex JCL files into sections.</entry>
</list>

//MYJOB JOB ..........
//*  Lines containing only comments.
//******** Often used to divide JCL listing into sections ********
//STEP01 EXEC MYPROC             Comment 2 on same line as statement
//STEP02 EXEC PGM=.........      Comment 3 has been extended and      X
//         overflows into another line.
//INPUT01 DD DSN=STEP01.MYPR01.NEWFILE</p>

</ss1>
<ss1>
<st>
Concatenating input files</st>
<p>

OS JCL allows programmers to concatenate ("chain") input files so that they appear to the program as <it>one</it> file, for example
//INPUT01 DD DSN=MYFILE01,DISP=SHR
//        DD DSN=JOESFILE,DISP=SHR
//        DD DSN=SUESFILE,DISP=SHR
The 2nd and third statements have no value in the name field, so OS treats them as concatenations. The files must be of the same basic type (almost always sequential), and must have the same record length.</p>

</ss1>
<ss1>
<st>
Conditional processing</st>
<p>

OS expects programs to set a return code which specifies how successful the <it>program</it> thought it was. The most common conventional values are:
<list>
<entry level="1" type="bullet">

0 = all OK</entry>
<entry level="1" type="bullet">

4 = minor errors or problems</entry>
<entry level="1" type="bullet">

8 = significant errors or problems</entry>
<entry level="1" type="bullet">

12 = major errors or problems, the results (e.g. files or reports produced) should not be trusted.</entry>
<entry level="1" type="bullet">

16 = very serious problems, do not use the results!</entry>
</list>
</p>
<p>

OS JCL refers to the return code as COND ("condition code"), and can use it to decide whether to run subsequent steps.  However, unlike most modern programming languages, conditional steps in OS JCL are <it>not</it> executed if the specified condition is true&mdash;thus giving rise to the <link xlink:type="simple" xlink:href="../411/40411.xml">
mnemonic</link>, "If it's true, pass on through [without running the code]."  To complicate matters further, the condition can only be specified <it>after</it> the step to which it refers.  For example:
//MYJOB JOB ...........
//STEP01 EXEC PGM=PROG01
....
//STEP02 EXEC PGM=PROG02,COND=(4,GT,STEP01)
....
//STEP03 EXEC PGM=PROG03,COND=(8,LE)
....
//STEP04 EXEC PGM=PROG04,COND=(ONLY,STEP01)
....
//STEP05 EXEC PGM=PROG05,COND=(EVEN,STEP03)
....
means:
<list>
<entry level="1" type="number">

 Run STEP01, and collect its return code.</entry>
<entry level="1" type="number">

 Run STEP02 unless the number 4 is greater than STEP01's return code.</entry>
<entry level="1" type="number">

 Run STEP03 unless the number 8 is less than or equal to any previous return code.</entry>
<entry level="1" type="number">

 Run STEP04 only if STEP01 abnormally ended.</entry>
<entry level="1" type="number">

 Run STEP05, even if STEP03 abnormally ended.</entry>
</list>
</p>
<p>

This translates to the following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>:
run STEP01</p>
<p>

<b>if</b> STEP01's return code <b>is greater than</b> 4 <b>then</b>
run STEP02
<b>end if</b></p>
<p>

<b>if</b> any previous return code <b>is less than or equal to</b> 8 <b>then</b>
run STEP03
<b>end if</b></p>
<p>

<b>if</b> STEP01 abnormally ended <b>then</b>
run STEP04
<b>end if</b></p>
<p>

<b>if</b> STEP03 abnormally ended <b>then</b>
run STEP05
<b>else</b>
run STEP05
<b>end if</b></p>
<p>

Note that by reading the steps containing COND statements backwards, one can understand them fairly easily.  This is an example of <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link>
logical transposition</link></rule>
</concept>
</idea>
.</p>

</ss1>
<ss1>
<st>
JCL utilities</st>
<p>

JCL uses a number of IBM utility programs to assist in the processing of data. Utilities are most useful in batch processing. The utilities can be grouped into three sets:
(1) Data Set Utilities - to create, print, copy, move and delete data sets;
(2) System Utilities - to maintain and manage catalogs;
(3) Access Method Services - to process VSAM (Virtual storage access method) and non-VSAM data sets.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../999/1272999.xml">
IBM mainframe utility programs</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://listserv.uark.edu/scripts/wa.exe?A2=ind0404&amp;L=vmesa-l&amp;P=34608">
CPU MIPS ratings</weblink></entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.vintage-computer.com/ibm_pc.shtml">
IBM PC</weblink></entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://www3.iath.virginia.edu/elab/hfl0108.html">
IBM-compatible computers</weblink> History of PCs</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://publib.boulder.ibm.com/infocenter/zoslnctr/v1r7/index.jsp?topic=/com.ibm.zconcepts.doc/zconc_whatisjcl.html">
What is JCL?</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://publibz.boulder.ibm.com/epubs/pdf/iea2b540.pdf">
z/OS V1R6.0-V1R8.0 MVS JCL User's Guide</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://publibz.boulder.ibm.com/epubs/pdf/iea2b661.pdf">
z/OS V1R7.0-V1R8.0 MVS JCL Reference</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.zjournal.com/index.cfm?section=article&amp;aid=293">
VSE: A Look at the Past 40 Years</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://library.thinkquest.org/22522/timeline3b_en.html">
Computer Chronicles: 1972 - 1981</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 System 370/390 JCL 4th Edition, Gary DeWard Brown</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ibmmainframes.com/jcls.php">
Sample Mainframe JCLs</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ibmmainframes.com/viewforum.php?f=7">
Job Community Forums</weblink></entry>
</list>
</p>



</sec>
</bdy>
</language>
</article>
