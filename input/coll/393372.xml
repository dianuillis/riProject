<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:57:45[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Graham scan</title>
<id>393372</id>
<revision>
<id>236112677</id>
<timestamp>2008-09-03T22:00:54Z</timestamp>
<contributor>
<username>Paolo.dL</username>
<id>4370711</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Convex geometry</category>
<category>Geometric algorithms</category>
</categories>
</header>
<bdy>

The <b>Graham scan</b> is a method of computing the <link xlink:type="simple" xlink:href="../634/40634.xml">
convex hull</link> of a given set of points in the plane with <link xlink:type="simple" xlink:href="../543/7543.xml">
time complexity</link> <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it> log <it>n</it>). It is named after <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<theorist wordnetid="110706812" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../694/240694.xml">
Ronald Graham</link></associate>
</mathematician>
</scientist>
</causal_agent>
</colleague>
</intellectual>
</theorist>
</person>
</peer>
</physical_entity>
, who published the original algorithm in 1972<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. The algorithm finds all vertices of the convex hull ordered along its boundary. It may also be easily modified to report all input points that lie on the boundary of their convex hull.
<sec>
<st>
Algorithm</st>

<p>

<image location="right" width="150px" src="Graham_Scan.svg" type="frame">
<caption>

As one can see, A to B and B to C are counterclockwise, but C to D isn't. The algorithm detects this situation and discards previously chosen segments until the turn taken is counterclockwise (B to D in this case.)
</caption>
</image>

The first step in this algorithm is to find the point with the lowest y-coordinate.  If there is a tie, the point with the lowest x-coordinate out of the tie breaking candidates should be chosen.  Call this point <it>P</it>. This step takes <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>), where <it>n</it> is the number of points in question.</p>
<p>

Next, the set of points must be sorted in increasing order of the angle they and the point <it>P</it> make with the x-axis.  Any general-purpose <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link> is appropriate for this, for example <link xlink:type="simple" xlink:href="../995/13995.xml">
heapsort</link> (which is O(<it>n</it> log <it>n</it>)).  In order to speed up the calculations, it is not actually necessary to calculate the actual angle these points make with the x-axis; instead, it suffices to calculate the <link xlink:type="simple" xlink:href="../367/30367.xml#xpointer(//*[./st=%22Tangent%22])">
tangent</link> of this angle, which can be done with simple arithmetic.</p>
<p>

The algorithm proceeds by considering each of the points in the sorted array in sequence.  For each point, it is determined whether moving from the two previously considered points to this point is a "left turn" or a "right turn".  If it is a "right turn", this means that the second-to-last point is not part of the convex hull and should be removed from consideration.  This process is continued for as long as the set of the last three points is a "right turn".  As soon as a "left turn" is encountered, the algorithm moves on to the next point in the sorted array.  (If at any stage the three points are collinear, one may opt either to discard or to report it, since in some applications it is required to find all points on the boundary of the convex hull.)</p>
<p>

Again, determining whether three points constitute a "left turn" or a "right turn" does not require computing the actual angle between the two line segments, and can actually be achieved with simple arithmetic only.  For three points <math>(x_1,y_1)</math>, <math>(x_2,y_2)</math> and <math>(x_3,y_3)</math>, simply compute the direction of the <link xlink:type="simple" xlink:href="../092/157092.xml">
cross product</link> of the two <link xlink:type="simple" xlink:href="../533/32533.xml">
vector</link>s defined by points <math>(x_1,y_1)</math>, <math>(x_2,y_2)</math> and <math>(x_1,y_1)</math>, <math>(x_3,y_3)</math>, characterized by the sign of the expression <math>(x_2-x_1)(y_3-y_1)-(y_2-y_1)(x_3-x_1)</math>.  If the result is 0, the points are collinear; if it is positive, the three points constitute a "left turn", otherwise a "right turn".</p>
<p>

This process will eventually return to the point at which it started, at which point the algorithm is completed and the array now contains the points on the convex hull in counterclockwise order.</p>

</sec>
<sec>
<st>
Time complexity</st>

<p>

Sorting the points has time complexity O(<it>n</it> log <it>n</it>). 
While it may seem that the time complexity of the loop is O(<it>n</it>2), because for each point it goes back to check if any of the previous points make a "right turn", it is actually O(<it>n</it>),  because each point is considered only once.  Each point considered either terminates the inner loop, or it is removed from the array and thus never considered again.  The overall time complexity is therefore O(<it>n</it> log <it>n</it>), since the time to sort dominates the time to actually compute the convex hull.</p>

</sec>
<sec>
<st>
Pseudocode</st>

<p>

The result will be stored on Stack.</p>
<p>

Find pivot P;
Sort Points by angle (with points with equal angle further sorted by distance from P);</p>
<p>

<list>
<entry level="1" type="number">

 Points[1] is the pivot</entry>
</list>

Stack.push(Points[1]);
Stack.push(Points[2]);
FOR i = 3 TO Points.length
WHILE Stack.length &amp;gt;= 2 and Cross_product(Stack.second, Stack.top, Points[i]) = 0
Stack.pop;
ENDWHILE
Stack.push(Points[i]);
NEXT i</p>
<p>

FUNCTION Cross_product(p1, p2, p3)
RETURN (p2.x - p1.x)*(p3.y - p1.y) - (p3.x - p1.x)*(p2.y - p1.y);
ENDFUNCTION</p>
<p>

Note 1: it may be necessary to check whether the last point added to the stack (stack.Top) does not fall inside the hull by comparing it to the next-to-last point (stack.Second) and to the point at the bottom of the stack.</p>
<p>

Note 2: to handle the degenerate case of resulting hulls that have less than three points, only one point should be pushed onto the stack to start and if the stack ever has less than two (it will always have at least one) points on it then top should also be popped if the new point is equal to it.  In other words the while condition should be</p>
<p>

Stack.length &amp;gt;= 2 ? Cross_Product(Stack.second, Stack.top, Points[i]) = 0 : Stack.top == Points[i]</p>

</sec>
<sec>
<st>
Notes</st>

<p>

The same basic idea work also if the input is sorted on x-coordinate instead of angle, and the hull is computed in two steps producing the upper and the lower parts of the hull respectively. </p>

</sec>
<sec>
<st>
References</st>


<p>

<reflist>
<entry id="1">
Graham, R.L. (1972). <weblink xlink:type="simple" xlink:href="http://www.sciencedirect.com/science?_ob=IssueURL&amp;_tockey=%23TOC%235645%231972%23999989995%23299179%23FLP%23&amp;_auth=y&amp;view=c&amp;_acct=C000050221&amp;_version=1&amp;_urlVersion=0&amp;_userid=10&amp;md5=5d4861b6aa0cc6f286e142e7d22047c1">
An Efficient Algorithm for Determining the Convex Hull of a Finite Planar Set</weblink>. Information Processing Letters 1, 132-133</entry>
</reflist>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Cormen-2001" style="font-style:normal" class="book"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Cormen, Thomas H.</link></scientist>
;&#32;<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Leiserson, Charles E.</link></scientist>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../057/68057.xml">
Rivest, Ronald L.</link></scientist>
</person>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Stein, Clifford</link></scientist>
&#32;[1990]&#32;(2001).&#32;"33.3: Finding the convex hull", <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, 2nd edition,&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../601/719601.xml">
MIT Press</link></company>
 and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../269/651269.xml">
McGraw-Hill</link></company>
,&#32;pp. 949&ndash;955. ISBN 0-262-03293-7.</cite>&nbsp;</entry>
</list>
</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.partow.net/projects/fastgeo/index.html">
C++ and Object Pascal Graham Scan Implementations</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
