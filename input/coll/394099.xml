<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 16:57:15[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Test-and-set</title>
<id>394099</id>
<revision>
<id>231303073</id>
<timestamp>2008-08-11T20:38:56Z</timestamp>
<contributor>
<username>Henry Merrivale</username>
<id>4844128</id>
</contributor>
</revision>
<categories>
<category>Concurrency control</category>
<category>Computer arithmetic</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>test-and-set</b> instruction is an instruction used to both test and (conditionally) write to a memory location as part of a single <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic</link> (i.e. non-interruptible) operation.  This means setting a value, but first performing some test (such as, the value is equal to another given value).  If the test fails, the value is not set.  If multiple processes may access the same memory, and if a process is currently performing a test-and-set, no other process may begin another test-and-set until the first process is done.  <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link>s may use test-and-set instructions offered by other electronic components, such as Dual-Port RAM (DPRAM); CPUs may also offer a test-and-set instruction themselves.
<sec>
<st>
 Hardware Implementation </st>

<p>

DPRAM test-and-set instructions can work in many ways.  Here are two variations, both of which describe a DPRAM which provides exactly 2 ports, allowing 2 separate electronic components (such as 2 CPUs) access to every memory location on the DPRAM.</p>

<ss1>
<st>
Variation 1</st>

<p>

When CPU 1 issues a test-and-set instruction, the DPRAM first makes an "internal note" of this by storing the address of the memory location in a special place.  If at this point, CPU 2 happens to issue a test-and-set instruction for the same memory location, the DPRAM first checks its "internal note", recognizes the situation, and issues a BUSY interrupt, which tells CPU 2 that it must wait and retry.  This is an implementation of a <link xlink:type="simple" xlink:href="../489/671489.xml">
busy waiting</link> or <link xlink:type="simple" xlink:href="../603/244603.xml">
spinlock</link> using the interrupt mechanism.  Since this all happens at hardware speeds, CPU 2's wait to get out of the spin-lock is very short.</p>
<p>

Whether or not CPU 2 was trying access the memory location, the DPRAM performs the test given by CPU 1.  If the test succeeds, the DPRAM sets the memory location to the value given by CPU 1.  Then the DPRAM wipes out its "internal note" that CPU 1 was writing there.  At this point, CPU 2 could issue a test-and-set, which would succeed.</p>

</ss1>
<ss1>
<st>
Variation 2</st>

<p>

CPU 1 issues a test-and-set instruction to write to "memory location A".  The DPRAM does not immediately store the value in memory location A, but instead simultaneously moves the current value to a special register, while setting the contents of memory location A to a special "flag value".  If at this point, CPU 2 issues a test-and-set to memory location A, the DPRAM detects the special flag value, and as above, issues a BUSY interrupt.</p>
<p>

Whether or not CPU 2 was trying access the memory location, the DPRAM now performs CPU 1's test.  If the test succeeds, the DPRAM sets memory location A to the value specified by CPU 1.  If the test fails, the DPRAM copies the value back from the special register to memory location A.  Either operation wipes out the special flag value.  If CPU 2 now issues a test-and-set, it will succeed.</p>

</ss1>
</sec>
<sec>
<st>
 Code </st>

<p>

The test and set instruction when used with boolean values behaves like the following function. Crucially the entire function is executed <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomically</link>: no process can interrupt the function mid-execution and hence see a state that only exists during the execution of the function. This code only serves to help explain the behaviour of test-and-set; atomicity requires explicit hardware support and hence can't be implemented as a simple function.  NOTE: In this example, 'lock' is assumed
to be passed by reference (or by name) but the assignment to 'initial' creates a new value (not just copying a reference).</p>
<p>

<b>function</b> TestAndSet(<it>boolean</it> lock) {
<it>boolean</it> initial = lock
lock = true
<b>return</b> initial
}</p>
<p>

The above code segment is not atomic in the sense of the test-and-set instruction.  It also differs from the descriptions of DPRAM hardware test-and-set above in that here the "set" value and the test are fixed and invariant, and the "set" part of the operation is done regardless of the outcome of the test, whereas in the description of DPRAM test-and-set, the memory is set only upon passage of the test, and the value to set and the test condition are specified by the CPU.  Here, the value to set can only be 1, but if 0 and 1 are considered the only valid values for the memory location, and "value is nonzero" is the only allowed test, then this equates to the case described for DPRAM hardware (or, more specifically, the DPRAM case reduces to this under these constraints).  From that viewpoint, this can correctly be called "test-and-set" in the full conventional sense of the term.  The essential point to note, which this software function does embody, is the general intent and principle of test-and-set: that a value both is tested and is set in one atomic operation such that no other program thread might cause the target memory location to change after it is tested but before it is set, which would violate the logic requiring that the location will only be set when it has a certain value.  (That is, critically, as opposed to merely when it very recently had that value.)</p>
<p>

In the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
, the implementation would be like:</p>
<p>

int TestAndSet(int* lockPtr) {
int oldValue;
oldValue = SwapAtomic(lockPtr, 1);
return oldValue != 0;
}</p>
<p>

where SwapAtomic atomically first reads the current value pointed to by lockPtr and then writes 1 to the location. Being atomic, SwapAtomic never uses cached values and always commits to the shared memory store (RAM).</p>
<p>

The code also shows that TestAndSet is really two operations: an atomical swap and a test. Only the swap needs to be atomic.  (This is true because delaying the value comparison itself by any amount of time will not change the result of the test, once the value to test has been obtained.  Once the swap acquires the initial value, the result of the test has been determined, even if it has not been computed yet--e.g. in the C language example, by the != operator.)</p>

<ss1>
<st>
 Implementing mutual exclusion with TestAndSet </st>

<p>

Thus mutual exclusion can be implemented using:</p>
<p>

<it>boolean</it> lock = false
<b>function</b> Critical(){
<b>while</b> TestAndSet(lock) 
skip <it>//spin until lock is acquired
critical section </it>//only one process can be in this section at a time
lock = false <it>//release lock when finished with the critical section
}</it></p>
<p>

In pseudo C it would be like:</p>
<p>

volatile int lock = 0;</p>
<p>

void Critical() {
while (TestAndSet(&amp;lock) == 1);
critical section <it>//only one process can be in this section at a time
lock = 0 </it>//release lock when finished with the critical section
}</p>
<p>

Note the <it><link xlink:type="simple" xlink:href="../846/944846.xml">
volatile</link></it> keyword. In absence of volatile, the compiler and/or the cpus will quite certainly optimize access to lock and/or use cached values, thus rendering the above code erroneous.</p>
<p>

Conversely, and unfortunately, the presence of <it>volatile</it> does <it>not</it> guarantee that reads and writes are committed to memory. Some compilers issue <link xlink:type="simple" xlink:href="../216/728216.xml">
memory barrier</link>s to ensure that operations are committed to memory, but since the semantics of <it>volatile</it> in C/C++ is quite vague, not all compilers will do that. Consult your compiler's documentation to determine if it does.</p>
<p>

This function can be called by multiple processes, but it is guaranteed that only one process will be in the critical section at a time. The solution is unfortunately inefficient in multiprocessor machines as the constant reading and writing of the lock causes <link>
cache coherence</link> problems. <link xlink:type="simple" xlink:href="../574/2084574.xml">
Test and Test-and-set</link> is a more efficient solution. This usage of test-and-set is an example of a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../603/244603.xml">
Spinlock</link></concept>
</idea>
: the while-loop spins waiting to acquire the lock.</p>

</ss1>
</sec>
<sec>
<st>
 Using test-and-set to implement semaphores </st>

<p>

It's possible to use the test-and-set instruction to implement <link xlink:type="simple" xlink:href="../557/164557.xml">
semaphore</link>s.  In uniprocessor systems this technique isn't needed (unless using multiple processes to access the same data); to use semaphores, it is sufficient to disable <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>s before accessing a semaphore.  However, in multiprocessor systems, it is undesirable, if not impossible, to disable interrupts on all processors at the same time.  Even with interrupts disabled, two or more processors could be attempting to access the same semaphore's memory at the same time.  In this case, the test-and-set instruction may be used.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../276/2050276.xml">
Fetch-and-add</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../574/2084574.xml">
Test and Test-and-set</link></entry>
<entry level="1" type="bullet">

<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/2882985.xml">
Load-Link/Store-Conditional</link></concept>
</idea>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../224/632224.xml">
Compare-and-swap</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://edis.win.tue.nl/sys/test-and-set/">
Description</weblink> from <link>
Encyclopaedia of Delay-Insensitive Systems</link></entry>
<entry level="1" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/355291.html">
Wait-free Test-and-Set</weblink>" by <link>
Yehuda Afek</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.clemson.edu/~wayne/cpsc823/threads/testandset.s">
int testandset(int *lock)</weblink> - C-callable routine written in Sun Sparc assembly language</entry>
</list>
</p>


</sec>
</bdy>
</article>
