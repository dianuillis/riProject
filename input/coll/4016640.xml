<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:56:42[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Constraint learning</title>
<id>4016640</id>
<revision>
<id>163623057</id>
<timestamp>2007-10-10T18:44:35Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Constraint satisfaction</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../652/211652.xml">
constraint satisfaction</link> <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s, <b>constraint learning</b> is a technique for improving efficiency. It works by recording new constraints whenever an inconsistency is found. This new constraint may reduce the <link xlink:type="simple" xlink:href="../707/389707.xml">
search space</link>, as future partial evaluations may be found inconsistent without further search. <b>Clause learning</b> is the name of this technique when applied to <link xlink:type="simple" xlink:href="../715/4715.xml">
propositional satisfiability</link>.
<sec>
<st>
Definition</st>

<p>

Backtracking algorithms work by choosing an unassigned variable and recursively solve the problems obtained by assigning a value to this variable. Whenever the current partial solution is found inconsistent, the algorithm goes back to the previously assigned variable, as expected by recursion. A constraint learning algorithm differs because it tries to record some information, before backtracking, in form of a new constraint. This can reduce the further search because the subsequent search may encounter another partial solution that is inconsistent with this new constraint. If the algorithm has learned the new constraint, it will backtrack from this solution, while the original backtracking algorithm would do a subsequent search.</p>
<p>

If the partial solution <math>x_1=a_1,\ldots,x_k=a_k</math> is inconsistent, the problem instance implies the constraint stating that <math>x_i=a_i</math> cannot be true for all <math>i \in [1,k]</math> at the same time. However, recording this constraint is not useful, as this partial solution will not be encountered again due to the way backtracking proceed.</p>
<p>

On the other hand, if a subset of this evaluation is inconsistent, the corresponding constraint may be useful in the subsequent search, as the same subset of the partial evaluation may occur again in the search. For example, the algorithm may encounter an evaluation extending the subset <math>x_2=a_2, x_5=a_5, x_{k-1}=a_{k-1}</math> of the previous partial evaluation. If this subset is inconsistent and the algorithm has stored this fact in form of a constraint, no further search is needed to conclude that the new partial evaluation cannot be extended to form a solution.</p>
<p>

<table cellpadding="20">
<row>
<col>
 <image width="150px" src="Constraint-learning-1.svg">
<caption>

Constraint-learning-1.svg
</caption>
</image>
</col>
<col>
 <image width="150px" src="Constraint-learning-2.svg">
<caption>

Constraint-learning-2.svg
</caption>
</image>
</col>
<col>
 <image width="150px" src="Constraint-learning-3.svg">
<caption>

Constraint-learning-3.svg
</caption>
</image>
</col>
</row>
<row>
<col>
Search has reached a dead end.</col>
<col>
Inconsistency may be caused by the values of <math>x_1</math> and <math>x_4</math> only. This fact can be stored in a new constraint.</col>
<col>
If the algorithm reaches the same values of <math>x_1</math> and <math>x_4</math> again, the new constraint blocks the search.</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
Efficiency of constraint learning</st>

<p>

The efficiency of constraint learning algorithm is balanced between two factors. On one hand, the more often a recorded constraint is violated, the more often backtracking avoids doing useless search. Small inconsistent subsets of the current partial solution are usually better than large ones, as they correspond to constraints that are easier to violate. On the other hand, finding a small inconsistent subset of the current partial evaluation may require time, and the benefit may not be balanced by the subsequent reduction of the search time.</p>
<p>

Size is however not the only feature of learned constraints to take into account. Indeed, a small constraint may be useless in a particular state of the search space because the values that violate it will not be encountered again. A larger constraint whose violating values are more similar to the current partial assignment may be preferred in such cases.</p>
<p>

Various constraint learning techniques exist, differing in strictness of recorded constraints and cost of finding them.</p>

</sec>
<sec>
<st>
Graph-based learning</st>

<p>

If the algorithm proves all values of <math>x_{k+1}</math> to be inconsistent with <math>x_1=a_1,\ldots,x_k=a_k</math>, then this evaluation was consistent, as otherwise the algorithm would not have evaluated <math>x_{k+1}</math> at all; as a result, the constraints violated by a value of <math>x_{k+1}</math> together with <math>x_1=a_1,\ldots,x_k=a_k</math> all contain <math>x_{k+1}</math>.</p>
<p>

As a result, an inconsistent evaluation is the restriction of the truth evaluation of <math>x_1,\ldots,x_k</math> to variables that are in a constraint with <math>x_{k+1}</math>, provided that this constraint contains no unassigned variable.</p>
<p>

Learning constraints representing these partial evaluation is called graph-based learning. It uses the same rationale of <link xlink:type="simple" xlink:href="../690/4001690.xml">
graph-based backjumping</link>. These methods are called "graph-based" because they are based on pairs of variables are in the same constraint, which can be found out from the graph associated to the constraint satisfaction problem.</p>

</sec>
<sec>
<st>
Jumpback learning</st>

<p>

Jumpback learning is based on storing as constraints the inconsistent assignments that would be found by <link xlink:type="simple" xlink:href="../690/4001690.xml">
conflict-based backjumping</link>. Whenever a partial assignment is found inconsistent, this algorithm selects the violated constraint that is minimal according to an ordering based on the order of instantiation of variables. The evaluation restricted of the variables that are in this constraint is inconsistent and is usually shorter than the complete evaluation. Jumpback learning stores this fact as a new constraint.</p>
<p>

The ordering on constraints is based on the order of assignment of variable. In particular, the least of two constraint is the one whose latest non-common variable has been instantiated first. When an inconsistent assignment is reached, jumpback learning selects the violated constraint that is minimal according to this ordering, and restricts the current assignment to its variables. The constraint expressing the inconsistency of this assignment is stored.</p>

</sec>
<sec>
<st>
Constraint maintenance</st>

<p>

Constraint learning algorithms differ not only on the choice of constraint corresponding to a given inconsistent partial evaluation, but also on the choice of which constraint they maintain and which ones they discard.</p>
<p>

In general, learning all inconsistencies in form of constraints and keeping them indefinitedly may exhaust the available memory and increase the cost of checking consistency of partial evaluations. These problems can be solved either by storing only some learned constraints or by occasionally discarding constraints.</p>
<p>

<it>Bounded learning</it> only stores constraints if the inconsistent partial evaluation they represent is smaller than a given constrant number. <it>Relevance-bounded learning</it> discards constraints (or does not store them at all) that are considered not relevant given the current point of the search space; in particular, it discards or does not store all constraints that represent inconsistent partial evaluations that differ from the current partial evaluation on no more than a given fixed number of variables.</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../464/3978464.xml">
Look-ahead (backtracking)</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../690/4001690.xml">
Backjumping</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Dechter-2003" style="font-style:normal" class="book">Dechter, Rina&#32;(2003). <weblink xlink:type="simple" xlink:href="http://www.ics.uci.edu/~dechter/books/index.html">
Constraint Processing</weblink>.&#32;Morgan Kaufmann.</cite>&nbsp; ISBN 1-55860-890-7</entry>
</list>
</p>

</sec>
</bdy>
</article>
