<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:57:29[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Dijkstra-Scholten algorithm</title>
<id>4032816</id>
<revision>
<id>185531236</id>
<timestamp>2008-01-19T23:51:54Z</timestamp>
<contributor>
<username>Michael Hardy</username>
<id>4626</id>
</contributor>
</revision>
<categories>
<category>Termination algorithms</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>

The <b>Dijkstra-Scholten algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for detecting <link xlink:type="simple" xlink:href="../658/6782658.xml">
termination</link> in a <link xlink:type="simple" xlink:href="../501/8501.xml">
distributed system</link>. The algorithm was proposed by Dijkstra and Scholten in <link xlink:type="simple" xlink:href="../640/34640.xml">
1980</link>.<p>

First, let us consider the case of a simple process graph which is a tree. A distributed computation which is tree-structured is not uncommon. Such a process graph may arise when the computation is strictly divide-and-conquer type. A node starts the computation and divides the problem in two (or more, usually a multiple of 2) roughly equal parts and distribute those parts to other processors. This process continues recursively until the problems are of sufficiently small size to solve in a single processor.</p>

<sec>
<st>
 Algorithm </st>

<p>

Dijkstra-Scholten's algorithm is a tree-based algorithm which can be described by the following:</p>
<p>

<list>
<entry level="1" type="bullet">

 The initiator of a computation is the root of the tree.</entry>
<entry level="1" type="bullet">

 Upon receiving a computational message:</entry>
<entry level="2" type="bullet">

 If the receiving process is currently not in the computation: the process joins the tree by becoming a child of the sender of the message. (No acknowledgement message is sent at this point.)</entry>
<entry level="2" type="bullet">

 If the receiving process is already in the computation: the process immediately sends an acknowledgement message to the sender of the message.</entry>
<entry level="1" type="bullet">

 When a process has no more children and has become idle, the process detaches itself from the tree by sending an acknowledgement message to its tree parent.</entry>
<entry level="1" type="bullet">

 Termination occurs when the initiator has no children and has become idle.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Dijkstra-Scholten algorithm for a tree </st>

<p>

<list>
<entry level="1" type="bullet">

 For a tree, it is easy to detect termination. When a leaf process determines that it has terminated, it sends a signal to its parent. In general, a process waits for all its children to send signals and then it sends a signal to its parent.</entry>
<entry level="1" type="bullet">

 The program terminates when the root receives signals from all its children.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Dijkstra-Scholten algorithm for acyclic directed graphs </st>

<p>

<list>
<entry level="1" type="bullet">

 The algorithm for a tree can be extended to acyclic directed graphs. We add an additional edge <link xlink:type="simple" xlink:href="../605/312605.xml">
Deficit</link> to each edge.</entry>
<entry level="1" type="bullet">

 On an incoming edge, Deficit will denote the difference between the number of messages received and the number of signals sent in reply.</entry>
<entry level="1" type="bullet">

 When a node wishes to terminate, it waits until it has received signals from outgoing edges reducing their deficits to zero.</entry>
<entry level="1" type="bullet">

 Then it sends enough signals to ensure that the deficit is zero on each incoming edge.</entry>
<entry level="1" type="bullet">

 Since the graph is acyclic, some nodes will have no outgoing edges and these nodes will be the first to terminate after sending enough signals to their incoming edges. After that the nodes at higher levels will terminate level by level.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Dijkstra-Scholten algorithm for cyclic directed graphs </st>

<p>

<list>
<entry level="1" type="bullet">

 If cycles are allowed, the previous algorithm does not work. This is because, there may not be any node with zero outgoing edges. So, potentially there is no node which can terminate without consulting other nodes.</entry>
<entry level="1" type="bullet">

 The Dijkstra-Scholten algorithm solves this problem by implicitly creating a <link xlink:type="simple" xlink:href="../770/455770.xml">
spanning tree</link> of the graph. A spanning-tree is a tree which includes each node of the underlying graph once and the edge-set is a subset of the original set of edges.</entry>
<entry level="1" type="bullet">

 The tree will be directed (i.e., the channels will be directed) with the source node (which initiates the computation) as the root.</entry>
<entry level="1" type="bullet">

 The spanning-tree is created in the following way. A variable <it>First_Edge</it> is added to each node. When a node receives a message for the first time, it initializes <it>First_Edge</it> with the edge through which it received the message. <it>First_Edge</it> is never changed afterwards. Note that, the spanning tree is not unique and it depends on the order of messages in the system.</entry>
<entry level="1" type="bullet">

 Termination is handled by each node in three steps :</entry>
<entry level="2" type="number">

 Send signals on all incoming edges except the first edge. (Each node will send signals which reduces the deficit on each incoming edge to zero.)</entry>
<entry level="2" type="number">

 Wait for signals from all outgoing edges. (The number of signals received on each outgoing edge should reduce each of their deficits to zero.)</entry>
<entry level="2" type="number">

 Send signals on <it>First_Edge</it>. (Once steps 1 and 2 are complete, a node informs its parent in the spanning tree about its intention of terminating.)</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
 Huang's algorithm </link></entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
