<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:51:05[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<parlance  confidence="0.8" wordnetid="107081177">
<formulation  confidence="0.8" wordnetid="107069948">
<expressive_style  confidence="0.8" wordnetid="107066659">
<header>
<title>Recursion (computer science)</title>
<id>4044867</id>
<revision>
<id>243982016</id>
<timestamp>2008-10-08T20:33:50Z</timestamp>
<contributor>
<username>Kernel Saunters</username>
<id>4080342</id>
</contributor>
</revision>
<categories>
<category>Control flow</category>
<category>Articles with example C code</category>
<category>Theoretical computer science</category>
<category>Articles with example Scheme code</category>
<category>Recursion theory</category>
<category>Programming idioms</category>
</categories>
</header>
<bdy>

<b><link xlink:type="simple" xlink:href="../407/25407.xml">
Recursion</link> in computer science</b> is a way of thinking about and solving problems.  It is, in fact, one of the central ideas of computer science. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>  Solving a problem using recursion means the solution depends on solutions to smaller instances of the same problem. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>  <p>

"The power of recursion evidently lies in the possibility of defining an infinite set of objects by a finite statement.  In the same manner, an infinite number of computations can be described by a finite recursive program, even if this program contains no explicit repetitions." <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

<p>

Most high-level computer programming languages support recursion by allowing a function to call itself within the program text.  <link xlink:type="simple" xlink:href="../847/197847.xml">
 Imperative languages</link> define looping constructs like “while” and “for” loops that are used to perform repetitive actions.  Some <link xlink:type="simple" xlink:href="../933/10933.xml">
 functional programming languages</link> do not define any looping constructs but rely solely on recursion to repeatedly call code.  <link xlink:type="simple" xlink:href="../136/442136.xml">
 Computability theory</link> has proven that these recursive only languages are mathematically equivalent to the imperative languages, meaning they can solve the same kinds of problems even without the typical control structures like “while” and “for”.<image width="150px" src="recursiveTree.JPG" type="thumb">
<caption>

Tree created using the <music wordnetid="107020895" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<suite wordnetid="107047011" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<musical_composition wordnetid="107037465" confidence="0.8">
<link xlink:type="simple" xlink:href="../334/18334.xml">
Logo programming language</link></musical_composition>
</language>
</suite>
</auditory_communication>
</music>
 and relying heavily on recursion.
</caption>
</image>
</p>

<sec>
<st>
Recursive algorithms</st>
<p>

A common method of simplification is to divide a problem into sub-problems of the same type.This is known as dialecting. As a <link xlink:type="simple" xlink:href="../311/5311.xml">
computer programming</link> technique, this is called <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer</link>, and it is key to the design of many important algorithms, as well as a fundamental part of <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>.</p>
<p>

Virtually all <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s in use today allow the direct specification of recursive functions and procedures. When such a function is called, the computer (for most languages on most stack-based architectures) or the language implementation keeps track of the various instances of the function (on many architectures, by using a <link xlink:type="simple" xlink:href="../105/1718105.xml">
call stack</link>, although other methods may be used). Conversely, every recursive function can be transformed into an iterative function by using a <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link>.</p>
<p>

Any function that can be evaluated by a computer can be expressed in terms of recursive functions without the use of <link xlink:type="simple" xlink:href="../833/68833.xml">
iteration</link>, in <link xlink:type="simple" xlink:href="../852/749852.xml">
continuation-passing style</link>; and conversely any recursive function can be expressed in terms of iteration.</p>
<p>

To make a very literal example out of this: If an unknown word is seen in a book, the reader can make a note of the current page number and put the note on a stack (which is empty so far). The reader can then look the new word up and, while reading on the subject, may find yet another unknown word. The page number of this word is also written down and put on top of the stack. At some point an article is read that does not require any explanation. The reader then returns to the previous page number and continues reading from there. This is repeated, sequentially removing the topmost note from the stack. Finally, the reader returns to the original book.  This is a recursive approach.</p>
<p>

Some languages designed for <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic programming</link> and <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming</link> provide recursion as the only means of repetition directly available to the programmer. Such languages generally make <link xlink:type="simple" xlink:href="../742/30742.xml">
tail recursion</link> as efficient as iteration, letting programmers express other repetition structures (such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
's map and for) in terms of recursion.</p>
<p>

Recursion is deeply embedded in the <link xlink:type="simple" xlink:href="../402/30402.xml">
theory of computation</link>, with the theoretical equivalence of <link>
μ-recursive function</link>s and <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
s at the foundation of ideas about the universality of the modern computer.</p>

</sec>
<sec>
<st>
Recursive programming</st>
<p>

Creating a recursive procedure essentially requires defining a "base case", and then defining rules to break down more complex cases into the base case.  Key to a recursive procedure is that with each recursive call, the problem domain must be reduced in such a way that eventually the base case is arrived at.  </p>
<p>

Some authors classify recursion as either "generative" or "structural".  The distinction is made based on where the procedure gets the data that it works on.  If the data comes from a data structure like a list, then the procedure is "structurally recursive"; otherwise, it is "generatively recursive".<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>

<p>

Many well-known recursive algorithms generate an entirely new piece of data from the given data and recur on it.  HTDP (How To Design Programs) refers to this kind as generative recursion.  Examples of generative recursion include: <link xlink:type="simple" xlink:href="../354/12354.xml">
gcd</link>, <link xlink:type="simple" xlink:href="../249/3268249.xml">
quicksort</link>, <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link>, <link xlink:type="simple" xlink:href="../039/20039.xml">
mergesort</link>, <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, <link xlink:type="simple" xlink:href="../913/10913.xml">
fractal</link>s, and <link>
adaptive integration</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>


<ss1>
<st>
 Examples of recursively defined procedures (generative recursion) </st>

<ss2>
<st>
 Factorial </st>
<p>

A classic example of a recursive procedure is the function used to calculate the <link xlink:type="simple" xlink:href="../606/10606.xml">
factorial</link> of an <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>.</p>
<p>

Function definition: 
<math> fact(n) =
 \begin{cases}
 1 &amp; \mbox{if } n = 0 \\
 n \times fact(n-1) &amp; \mbox{if } n &amp;gt; 0 \\
 \end{cases}
</math></p>
<p>

<table class="wikitable">
<row>
<header>
 <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
(recursive):</header>
</row>
<row>
<col>
<b>function</b> factorial is:
<b>input</b>: integer <it>n</it> such that <it>n</it> &amp;gt;= 1
<b>output</b>: [''n'' &#215; (''n''-1) &#215; (''n''-2) &#215; &#8230; &#215; 1]<p>

1. if <it>n</it> is 0, <b>return</b> 1
2. otherwise, <b>return</b> [ ''n'' &#215; factorial(''n''-1) ]<b>end</b> factorial</p>
</col>
</row>
</table>
</p>
<p>

A <link xlink:type="simple" xlink:href="../806/146806.xml">
recurrence relation</link> is an equation that relates later terms in the sequence to earlier terms<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>.
Recurrence relation for factorial:
bn = n * bn-1 
b0 = 1</p>
<p>

<table class="wikitable">
<row>
<header>
Computing the recurrence relation for n = 4:</header>
</row>
<row>
<col>
b4           = 4 * b3
= 4 * 3 * b2
= 4 * 3 * 2 * b1
= 4 * 3 * 2 * 1 * b0
= 4 * 3 * 2 * 1 * 1
= 4 * 3 * 2 * 1
= 4 * 3 * 2
= 4 * 6
= 4 * 6
= 24</col>
</row>
</table>
</p>

<p>

Example Implementations:
<table class="wikitable">
<row>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
(recursive)</header>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
(recursive)</header>
</row>
<row>
<col>
<list>
<entry level="2" type="definition">

 Input: Integer n such that n &amp;gt;= 0</entry>
</list>

(define (fact n)
(if (= n 0)
1
(* n (fact (- n 1)))))</col>
<col>
//INPUT: n is an integer such that n &amp;gt;= 0
int fact(int n)
{
if (n == 0)
return 1;
else
return n * fact(n - 1);
}</col>
</row>
</table>
</p>
<p>

This factorial function can also be described without using recursion by making use of the typical looping constructs found in imperative programming languages:</p>
<p>

<table class="wikitable">
<row>
<header>
 <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
(iterative):</header>
</row>
<row>
<col>
<b>function</b> factorial is:
<b>input</b>: integer <it>n</it> such that <it>n</it> &amp;gt;= 0
<b>output</b>: [''n'' &#215; (''n''-1) &#215; (''n''-2) &#215; &#8230; &#215; 1]1. <b>create</b> new variable called <it>running_total</it> with a value of 1<p>

2. <b>begin</b> loop
1. if <it>n</it> is 0, <b>exit</b> loop
2. <b>set</b> <it>running_total</it> to (<it>running_total</it> &#215; <it>n</it>)
3. <b>decrement</b> <it>n</it>
4. <b>repeat</b> loop</p>
<p>

3. <b>return</b> <it>running_total</it></p>
<p>

<b>end</b> factorial</p>
</col>
</row>
</table>
</p>
<p>

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
, however, is a <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming language</link> and does not define any looping constructs.  It relies solely upon recursion to perform all looping.  Because Scheme is tail-recursive, a recursive procedure can be defined that implements the factorial procedure as an iterative process &mdash; meaning that it uses constant space but linear time.</p>
<p>

Example implementations:</p>
<p>

<table class="wikitable">
<row>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
(iterative)</header>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
(iterative)</header>
</row>
<row>
<col>
<list>
<entry level="2" type="definition">

 Input: Integer n such that n &amp;gt;= 0</entry>
</list>

(define (fact n)
(fact-iter 1 n))<p>

(define (fact-iter running_total n)
(if (= n 0)
running_total
(fact-iter (* running_total n) (- n 1))))</p>
</col>
<col>
int fact(int n)
{
int running_total;
for (running_total = 1; n != 0; --n)
running_total *= n;
return running_total;
}</col>
</row>
</table>
</p>

</ss2>
<ss2>
<st>
 Fibonacci </st>

<p>

Another well known recursive sequence is the <link xlink:type="simple" xlink:href="../918/10918.xml">
Fibonacci number</link>s.  The first few elements of this sequence are: 0, 1, 1, 2, 3, 5, 8, 13, 21...</p>
<p>

Function definition: 
<math> fib(n) =
 \begin{cases}
 0 &amp; \mbox{if } n = 0 \\
 1 &amp; \mbox{if } n = 1 \\
 fib(n-1) + fib(n-2) &amp; \mbox{if } n &amp;gt;= 2  \\
 \end{cases}
</math></p>
<p>

<table class="wikitable">
<row>
<header>
 <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
</header>
</row>
<row>
<col>
<b>function</b> fib is:
<b>input</b>: integer n such that n &amp;gt;= 0<p>

1. if n is 0, <b>return</b> 0
2. if n is 1, <b>return</b> 1
3. otherwise, <b>return</b> [ fib(n-1) + fib(n-2) ]<b>end</b> fib</p>
</col>
</row>
</table>
</p>

<p>

<link xlink:type="simple" xlink:href="../806/146806.xml">
Recurrence relation</link> for Fibonacci:
bn = bn-1 + bn-2
b1 = 1, b0 = 0</p>
<p>

<table class="wikitable">
<row>
<header>
Computing the recurrence relation for n = 4:</header>
</row>
<row>
<col>
b4            = b3 + b2
= b2 + b1 + b1 + b0
= b1 + b0 + 1 + 1 + 0
= 1 + 0 + 1 + 1 + 0
= 3</col>
</row>
</table>
</p>
<p>

Example Implementations:</p>
<p>

<table class="wikitable">
<row>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
</header>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
</header>
</row>
<row>
<col>
<list>
<entry level="2" type="definition">

 n is an integer such that n &amp;gt;= 0</entry>
</list>

(define (fib n)
(cond ((= n 0) 0)
((= n 1) 1)
(else
(+ (fib (- n 1))
(fib (- n 2))))))</col>
<col>
int fib(int n)
{
if (n == 0)
return 0;
else if (n == 1)
return 1;
else 
return fib(n-1) + fib(n-2);
}</col>
</row>
</table>
</p>
<p>

These implementations are especially bad because each time the function is executed, it will make two function calls to itself each of which in turn makes two more function calls and so on until they "bottom out" at 1 or 0. This is an example of "tree recursion", and grows exponentially in time and linearly in space requirements.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</ss2>
<ss2>
<st>
 Greatest common divisor </st>

<p>

Another famous recursive function is the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, used to compute the <link xlink:type="simple" xlink:href="../354/12354.xml">
greatest common divisor</link> of two integers. </p>
<p>

Function definition: 
<math> gcd(x,y) =
 \begin{cases}
 x &amp; \mbox{if } y = 0 \\
 gcd(y, remainder(x,y)) &amp; \mbox{if } x &amp;gt;= y \mbox{ and } y &amp;gt; 0 \\
 \end{cases}
</math></p>
<p>

<table class="wikitable">
<row>
<header>
 <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
(recursive):</header>
</row>
<row>
<col>
<b>function</b> gcd is:
<b>input</b>: integer <it>x</it>, integer <it>y</it> such that <it>x</it> &amp;gt;= <it>y</it> and <it>y</it> &amp;gt; 0<p>

1. if <it>y</it> is 0, <b>return</b> <it>x</it>
2. otherwise, <b>return</b> [ gcd( ''y'', (remainder of ''x''/''y'') ) ]<b>end</b> gcd</p>
</col>
</row>
</table>
</p>
<p>

Recurrence relation for greatest common divisor, where "x % y" expresses the remainder of x / y:
gcd(x,y) = gcd(y, x % y) 
gcd(x,0) = x</p>
<p>

<table class="wikitable">
<row>
<header>
Computing the recurrence relation for x = 27 and y = 9:</header>
</row>
<row>
<col>
gcd(27, 9)   = gcd(9, 27 % 9)
= gcd(9, 0)
= 9</col>
</row>
<row>
<header>
Computing the recurrence relation for x = 259 and y = 111:</header>
</row>
<row>
<col>
gcd(259, 111)   = gcd(111, 259 % 111)
= gcd(111, 37)
= gcd(37, 0)
= 37</col>
</row>
</table>
</p>
<p>

Example Implementations:</p>
<p>

<table class="wikitable">
<row>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
(recursive)</header>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
(recursive)</header>
</row>
<row>
<col>
<list>
<entry level="2" type="definition">

 Input: Integers x, y such that x &amp;gt;= y and y &amp;gt; 0</entry>
</list>

(define (gcd x y)
(if (= y 0)
x
(gcd y (remainder x y))))</col>
<col>
int gcd(int x, int y)
{
if (y == 0)
return x;
else
return gcd(y, x % y);
}</col>
</row>
</table>
</p>
<p>

Notice that both "recursive" examples above are in fact merely tail-recursive, which means they are equivalent to an iterative algorithm. Below is the same algorithm using explicit iteration. It does not accumulate a chain of deferred operations; rather, its state is maintained entirely in the variables <it>x</it> and <it>y</it>. Its "number of steps grows the as the logarithm of the numbers involved."<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>
<p>

<table class="wikitable">
<row>
<header>
 <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudocode</link></subject>
</message>
(iterative):</header>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
(iterative)</header>
</row>
<row>
<col>
<b>function</b> gcd is:
<b>input</b>: integer <it>x</it>, integer <it>y</it> such that <it>x</it> &amp;gt;= <it>y</it> and <it>y</it> &amp;gt; 0<p>

1. <b>create</b> new variable called <it>remainder</it></p>
<p>

2. <b>begin</b> loop
1. if <it>y</it> is zero, <b>exit</b> loop
2. <b>set</b> <it>remainder</it> to the remainder of x/y
3. <b>set</b> x to y
4. <b>set</b> y to <it>remainder</it>
5. <b>repeat</b> loop</p>
<p>

3. <b>return</b> <it>x</it></p>
<p>

<b>end</b> gcd</p>
</col>
<col>
int gcd(int x, int y)
{
while (y != 0) {
int remainder = x % y;
x = y;
y = remainder;
}
return x;
}</col>
</row>
</table>
</p>
<p>

The iterative algorithm requires a temporary variable, and even given knowledge of the Euclidean algorithm it is more difficult to understand the process by simple inspection, although the two algorithms are very similar in their steps.</p>

</ss2>
<ss2>
<st>
 Towers of Hanoi </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../990/56990.xml">
Towers of Hanoi</link></it>
</indent>

For a full discussion of this problem's description, history and solution see the main article or one of the many references.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> Simply put the problem is this: given three pegs, one with a set of N disks of increasing size, determine the minimum (optimal) number of steps it take to move all the disks from their initial position to another peg without placing a larger disk on top of a smaller one.</p>
<p>

Function definition: 
<math> hanoi(n) =
 \begin{cases}
 1 &amp; \mbox{if } n = 1 \\
 2 * hanoi(n-1) + 1 &amp; \mbox{if } n &amp;gt; 1\\
 \end{cases}
</math>
Recurrence relation for hanoi:
hn = 2*hn-1+1
h1 = 1</p>
<p>

<table class="wikitable">
<row>
<header>
Computing the recurrence relation for n = 4:</header>
</row>
<row>
<col>
hanoi(4)     = 2*hanoi(3) + 1
= 2*(2*hanoi(2) + 1) + 1
= 2*(2*(2*hanoi(1) + 1) + 1) + 1
= 2*(2*(2*1 + 1) + 1) + 1
= 2*(2*(3) + 1) + 1
= 2*(7) + 1
= 15</col>
</row>
</table>
</p>
<p>

Example Implementations:</p>
<p>

<table class="wikitable">
<row>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme (programming language)</link></programming_language>
:</header>
<header>
 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C (programming language)</link></programming_language>
:</header>
</row>
<row>
<col>
<list>
<entry level="2" type="definition">

 Input: Integer n such that n &amp;gt;= 1</entry>
</list>

(define (hanoi n)
(if (= n 1)
1
(+ (* 2 (hanoi (- n 1)))
1)))</col>
<col>
/* Input: Integer n such that n &amp;gt;= 1 */
int hanoi(int n)
{
if (n == 1)
return 1;
else
return 2*hanoi(n-1) + 1;
}</col>
</row>
</table>
</p>
<p>

Although not all recursive functions have an explicit solution, the Tower of Hanoi sequence can be reduced to an explicit formula. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> 
<table class="wikitable">
<row>
<header>
An explicit formula for Towers of Hanoi:</header>
</row>
<row>
<col>
h1 = 1   = 21 - 1
h2 = 3   = 22 - 1
h3 = 7   = 23 - 1
h4 = 15  = 24 - 1
h5 = 31  = 25 - 1
h6 = 63  = 26 - 1
h7 = 127 = 27 - 1<p>

In general:
hn = 2n - 1, for all n &amp;gt;= 1</p>
</col>
</row>
</table>
</p>

</ss2>
<ss2>
<st>
 Binary search </st>

<p>

The <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link> algorithm is a method of searching an ordered array for a single element by cutting the array in half with each pass.  The trick is to pick a midpoint near the center of the array, compare the data at that point with the data being searched and then responding to one of three possible conditions: the data is found, the data at the midpoint is greater than the data being searched for, or the data at the midpoint is less than the data being searched for.  </p>
<p>

Recursion is used in this algorithm because with each pass a new array is created by cutting the old one in half.  The binary search procedure is then called recursively, this time on the new (and smaller) array.  Typically the array's size is adjusted by manipulating a beginning and ending index.  The algorithm exhibits a logarithmic order of growth because it essentially divides the problem domain in half with each pass.</p>
<p>

Example Implementation of Binary Search:</p>

<p>

/*
Call binary_search with proper initial conditions.</p>
<p>

INPUT: 
data is a array of integers SORTED in ASCENDING order,
toFind is the integer to search for,
count is the total number of elements in the array</p>
<p>

OUTPUT:
result of binary_search</p>
<p>

<list>
<entry level="1" type="bullet">

/</entry>
</list>

int search(int *data, int toFind, int count)
{
//  Start = 0 (beginning index)
//  End = count - 1 (top index)
return binary_search(data, toFind, 0, count-1);
}</p>
<p>

/*
Binary Search Algorithm.</p>
<p>

INPUT: 
data is a array of integers SORTED in ASCENDING order,
toFind is the integer to search for,
start is the minimum array index,
end is the maximum array index
OUTPUT: 
position of the integer toFind within array data, 
-1 if not found
<list>
<entry level="1" type="bullet">

/</entry>
</list>

int binary_search(int *data, int toFind, int start, int end)
{
//Get the midpoint.
int mid = start + (end - start)/2;   //Integer division</p>
<p>

//Stop condition.
if (start &amp;gt; end)
return -1;
else if (data[mid] == toFind)        //Found?
return mid;
else if (data[mid] &amp;gt; toFind)         //Data is greater than toFind, search lower half
return binary_search(data, toFind, start, mid-1);
else                                 //Data is less than toFind, search upper half
return binary_search(data, toFind, mid+1, end);
}</p>


</ss2>
</ss1>
<ss1>
<st>
 Recursive data structures (structural recursion) </st>
<p>

An important application of recursion in computer science is in defining dynamic data structures such as Lists and Trees.  Recursive data structures can dynamically grow to a theoretically infinite size in response to runtime requirements; in contrast, a static array's size requirements must be set at compile time.</p>

<p>

"Recursive algorithms are particularly appropriate when the underlying problem or the data to be treated are defined in recursive terms." <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></p>

<p>

The examples in this section illustrate what is known as "structural recursion".  This term refers to the fact that the recursive procedures are acting on data that is defined recursively.  </p>

<p>

As long as a programmer derives the template from a data definition, functions employ structural recursion. That is, the recursions in a function's body consume some immediate piece of a given compound value.  <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></p>


<ss2>
<st>
 <link xlink:type="simple" xlink:href="../167/18167.xml">
Linked list</link>s </st>

<p>

Below is a simple definition of a linked list node.  Notice especially how the node is defined in terms of itself.  The "next" element of struct node is a pointer to a struct node.  </p>

<p>

struct node
{
int n;              // some data
struct node *next;  // pointer to another struct node
};</p>
<p>

// LIST is simply a synonym for struct node * (aka syntactic sugar).
typedef struct node *LIST;</p>

<p>

Procedures that operate on the LIST data structure can be implemented naturally as a recursive procedure because the data structure it operates on (LIST) is defined recursively.  The printList procedure defined below walks down the list until the list is empty (NULL), for each node it prints the data element (an integer).  In the C implementation, the list remains unchanged by the printList procedure.</p>

<p>

void printList(LIST lst)
{
if (!isEmpty(lst))         // base case
{
printf("%d ", lst-&amp;gt;n);  // print integer followed by a space
printList(lst-&amp;gt;next);   // recursive call
}
}</p>


</ss2>
<ss2>
<st>
 <link xlink:type="simple" xlink:href="../321/4321.xml">
Binary tree</link>s </st>

<p>

Below is a simple definition for a binary tree node.  Like the node for Linked Lists, it is defined in terms of itself (recursively).  There are two self-referential pointers - left (pointing to the left sub-tree) and right (pointing to the right sub-tree).  </p>

<p>

struct node
{
int n;               // some data
struct node *left;   // pointer to the left subtree
struct node *right;  // point to the right subtree
};</p>
<p>

// TREE is simply a synonym for struct node * (aka syntactic sugar).
typedef struct node *TREE;</p>

<p>

Operations on the tree can be implemented using recursion.  Note that because there are two self-referencing pointers (left and right), that tree operations will require two recursive calls.  For a similar example see the Fibonacci function and explanation above.  </p>

<p>

void printTree(TREE t) {
if (!isEmpty(t)) {            // base case                          
printTree(t-&amp;gt;left);   // go left
printf("%d ", t-&amp;gt;n);  // print the integer followed by a space
printTree(t-&amp;gt;right);  // go right
}
}</p>

<p>

The above example illustrates an <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../584/597584.xml">
 in-order traversal</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 of the binary tree.  A <plant wordnetid="100017222" confidence="0.8">
<tree wordnetid="113104059" confidence="0.8">
<vascular_plant wordnetid="113083586" confidence="0.8">
<woody_plant wordnetid="113103136" confidence="0.8">
<link xlink:type="simple" xlink:href="../320/4320.xml">
Binary search tree</link></woody_plant>
</vascular_plant>
</tree>
</plant>
 is a special case of the binary tree where the data elements of each node are in order.</p>

</ss2>
</ss1>
<ss1>
<st>
Recursion versus iteration</st>
<p>

In the "factorial" example the iterative implementation is likely to be slightly faster in practice than the recursive one. This is almost definite for the Euclidean Algorithm implementation. This result is typical, because iterative functions do not pay the "function-call overhead" as many times as recursive functions, and that overhead is relatively high in many languages. (Note that an even faster implementation for the factorial function on small integers is to use a <link xlink:type="simple" xlink:href="../457/356457.xml">
lookup table</link>.)</p>
<p>

There are other types of problems whose solutions are inherently recursive, because they need to keep track of prior state. One example is <link xlink:type="simple" xlink:href="../584/597584.xml">
tree traversal</link>; others include the <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
 and <link xlink:type="simple" xlink:href="../154/201154.xml">
divide-and-conquer algorithm</link>s such as <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../249/3268249.xml">
Quicksort</link></algorithm>
. All of these algorithms can be implemented iteratively with the help of a <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link>, but the need for the stack arguably nullifies the advantages of the iterative solution.</p>
<p>

Another possible reason for choosing an iterative rather than a recursive algorithm is that in today's programming languages, the stack space available to a thread is often much less than the space available in the heap, and recursive algorithms tend to require more stack space than iterative algorithms. However, see the caveat below regarding the special case of <link xlink:type="simple" xlink:href="../742/30742.xml">
tail recursion</link>.</p>

</ss1>
</sec>
<sec>
<st>
Tail-recursive functions</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../742/30742.xml">
Tail recursion</link></it>
</indent>
Tail-recursive functions are functions ending in a recursive call that does not build-up any deferred operations. For example, the gcd function (re-shown below) is tail-recursive; however, the factorial function (also re-shown below) is "augmenting recursive" because it builds up deferred operations that must be performed even after the final recursive call completes.  With a compiler that automatically optimizes tail-recursive calls, a tail-recursive function such as gcd will execute using constant space.  Thus the process it generates is iterative and equivalent to using imperative language control structures like the "for" and "while" loops.</p>
<p>

<table class="wikitable">
<row>
<header>
 <link xlink:type="simple" xlink:href="../742/30742.xml">
Tail recursion</link>:</header>
<header>
Augmenting recursion:</header>
</row>
<row>
<col>
//INPUT: Integers x, y such that x &amp;gt;= y and y &amp;gt; 0
int gcd(int x, int y)
{
if (y == 0)
return x;
else
return gcd(y, x % y);
}</col>
<col>
//INPUT: n is an Integer such that n &amp;gt;= 1
int fact(int n)
{
if (n == 1)
return 1;
else
return n * fact(n - 1);
}</col>
</row>
</table>
</p>
<p>

The significance of tail recursion is that when making a tail-recursive call, the caller's return position need not be saved on the <link xlink:type="simple" xlink:href="../105/1718105.xml">
call stack</link>; when the recursive call returns, it will branch directly on the previously saved return position. Therefore, on compilers which support tail-recursion optimization, tail recursion saves both space and time.</p>

</sec>
<sec>
<st>
Order of function calling</st>

<p>

The order of calling a function may change the execution of a function, see this example in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 language:</p>

<ss1>
<st>
Function 1</st>


<p>

void recursiveFunction(int num) {
if (num  5) {
printf("%d\n", num);
recursiveFunction(num + 1);
}
}</p>

<p>

<image width="150px" src="RecursiveFunction1_execution.png">
<caption>

RecursiveFunction1 execution.png
</caption>
</image>
</p>

</ss1>
<ss1>
<st>
Function 2 with swapped lines</st>


<p>

void recursiveFunction(int num) {
if (num  5) {
recursiveFunction(num + 1);
printf("%d\n", num);
}
}</p>

<p>

<image width="150px" src="RecursiveFunction2_execution.png">
<caption>

RecursiveFunction2 execution.png
</caption>
</image>
</p>

</ss1>
</sec>
<sec>
<st>
Direct and indirect recursion </st>

<p>

Direct recursion is when function calls itself.  Indirect recursion is when (for example) function A calls function B, function B calls function C, and then function C calls function A. Long chains and branches are possible, see <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../089/70089.xml">
Recursive descent parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../034/20034.xml">
Mutual recursion</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../599/3062599.xml">
Anonymous recursion</link></entry>
<entry level="1" type="bullet">

<link>
μ-recursive function</link></entry>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/24829.xml">
Primitive recursive function</link></function>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
Functional programming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</entry>
<entry level="1" type="bullet">

<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<contradiction wordnetid="107206887" confidence="0.8">
<paradox wordnetid="106724559" confidence="0.8">
<falsehood wordnetid="106756407" confidence="0.8">
<link xlink:type="simple" xlink:href="../729/14258729.xml">
Kleene-Rosser paradox</link></falsehood>
</paradox>
</contradiction>
</message>
</statement>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../665/222665.xml">
McCarthy 91 function</link></entry>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<link>
Sierpiński curve</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Notes and References</st>

<p>

<reflist>
<entry id="1">
 <cite id="Reference-Epp-1995" style="font-style:normal" class="book">Epp, Susanna&#32;(1995). Discrete Mathematics with Applications, 2nd,&#32;427.</cite>&nbsp;</entry>
<entry id="2">
 <cite id="Reference-Graham-1990" style="font-style:normal" class="book">Graham, Ronald;&#32;Donald Knuth, Oren Patashnik&#32;(1990). <weblink xlink:type="simple" xlink:href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html">
Concrete Mathematics</weblink>,&#32;Chapter 1: Recurrent Problems.</cite>&nbsp;</entry>
<entry id="3">
 <cite id="Reference-Wirth-1976" style="font-style:normal" class="book">Wirth, Niklaus&#32;(1976). Algorithms + Data Structures = Programs.&#32;Prentice-Hall,&#32;126.</cite>&nbsp;</entry>
<entry id="4">
 <cite style="font-style:normal" class="book">Felleisen, Matthias;&#32;Robert Bruce Findler, Matthew Flatt, Shriram Krishnamurthi&#32;(2001). <weblink xlink:type="simple" xlink:href="http://www.htdp.org/2003-09-26/Book/curriculum-Z-H-31.html">
How to Design Programs: An Introduction to Computing and Programming</weblink>.&#32;Cambridge, MASS:&#32;MIT Press,&#32;Part V "Generative Recursion".</cite>&nbsp;
</entry>
<entry id="5">
 <cite id="CITEREFFelleisen2002" style="font-style:normal">Felleisen, Matthias&#32;(2002),&#32;"Developing Interactive Web Programs", in&#32;Jeuring, Johan,&#32;<it>Advanced Functional Programming: 4th International School</it>, Oxford, UK: Springer, pp. 108</cite>&nbsp;.</entry>
<entry id="6">
 <cite id="Reference-Epp-1995" style="font-style:normal" class="book">Epp, Susanna&#32;(1995). Discrete Mathematics with Applications.&#32;Brooks-Cole Publishing Company,&#32;p424.</cite>&nbsp;</entry>
<entry id="7">
 <cite id="Reference-Abelson-1996" style="font-style:normal" class="book">Abelson, Harold;&#32;Gerald Jay Sussman&#32;(1996). <weblink xlink:type="simple" xlink:href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.2">
Structure and Interpretation of Computer Programs</weblink>,&#32;Section 1.2.2.</cite>&nbsp;</entry>
<entry id="8">
 <cite id="Reference-Abelson-1996" style="font-style:normal" class="book">Abelson, Harold;&#32;Gerald Jay Sussman&#32;(1996). <weblink xlink:type="simple" xlink:href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2.5">
Structure and Interpretation of Computer Programs</weblink>,&#32;Section 1.2.5.</cite>&nbsp;</entry>
<entry id="9">
 <cite id="Reference-Graham-1990" style="font-style:normal" class="book">Graham, Ronald;&#32;Donald Knuth, Oren Patashnik&#32;(1990). <weblink xlink:type="simple" xlink:href="http://www-cs-faculty.stanford.edu/~knuth/gkp.html">
Concrete Mathematics</weblink>,&#32;Chapter 1, Section 1.1: The Tower of Hanoi.</cite>&nbsp;</entry>
<entry id="10">
 <cite id="Reference-Epp-1995" style="font-style:normal" class="book">Epp, Susanna&#32;(1995). Discrete Mathematics with Applications, 2nd,&#32;427-430: The Tower of Hanoi.</cite>&nbsp;</entry>
<entry id="11">
 <cite id="Reference-Epp-1995" style="font-style:normal" class="book">Epp, Susanna&#32;(1995). Discrete Mathematics with Applications, 2nd,&#32;447-448: An Explicit Formula for the Tower of Hanoi Sequence.</cite>&nbsp;</entry>
<entry id="12">
 <cite id="Reference-Wirth-1976" style="font-style:normal" class="book">Wirth, Niklaus&#32;(1976). Algorithms + Data Structures = Programs.&#32;Prentice-Hall,&#32;p127.</cite>&nbsp;</entry>
<entry id="13">
 <cite id="CITEREFFelleisen2002" style="font-style:normal">Felleisen, Matthias&#32;(2002),&#32;"Developing Interactive Web Programs", in&#32;Jeuring, Johan,&#32;<it>Advanced Functional Programming: 4th International School</it>, Oxford, UK: Springer, pp. 108</cite>&nbsp;.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mitpress.mit.edu/sicp/full-text/book/book.html">
Harold Abelson and Gerald Sussman: "Structure and Interpretation Of Computer Programs"</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-128.ibm.com/developerworks/linux/library/l-recurs.html">
IBM DeveloperWorks: "Mastering Recursive Programming"</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.cmu.edu/~dst/LispBook/">
 David S. Touretzky: "Common Lisp: A Gentle Introduction to Symbolic Computation"</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.htdp.org/2003-09-26/Book/">
Matthias Felleisen: "How To Design Programs: An Introduction to Computing and Programming"</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codeproject.com/KB/cpp/Recursion_Prmr_CPP_01.aspx">
Recursion Primer Using C++: Part 1</weblink> by <link>
Zeeshan Amjad</link></entry>
</list>
</p>


</sec>
</bdy>
</expressive_style>
</formulation>
</parlance>
</article>
