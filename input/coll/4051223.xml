<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:47:54[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Seqlock</title>
<id>4051223</id>
<revision>
<id>243601041</id>
<timestamp>2008-10-07T06:37:22Z</timestamp>
<contributor>
<username>Stepheng3</username>
<id>5878081</id>
</contributor>
</revision>
<categories>
<category>Concurrency control</category>
<category>Linux kernel</category>
</categories>
</header>
<bdy>

A <b>seqlock</b> (short for "sequential lock") is a special <link>
lock</link>ing mechanism used in <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 for supporting fast writes of shared variables between two parallel <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> routines. The semantics stabilized as of version 2.5.59, and they are present in the 2.6.x stable kernel series. The seqlocks were developed by <link>
Stephen Hemminger</link> and originally called frlocks, based on earlier work by <link>
Andrea Arcangeli</link>. The first implementation was in the x86-64 time code where it was needed to synchronize with
ring 3 user space where it was not possible to use a real lock.<p>

It is a <link xlink:type="simple" xlink:href="../100/4189100.xml">
reader-writer</link> consistent mechanism which avoids the problem of writer starvation. A seqlock consists of storage for saving a sequence number in addition to a lock. The lock is to support synchronization between two writers and the counter is for indicating consistency in readers. In addition to updating the shared data, the writer increments the sequence number, both after acquiring the lock and before releasing the lock. Readers read the sequence number before and after reading the shared data. If the sequence number is odd on either occasion, a writer had taken the lock while the data was being read and it may have changed. If the sequence numbers are different, a writer has changed the data while it was being read. In either case readers simply retry (using a loop) until they read the same even sequence number before and after.</p>
<p>

It should be noted that the reader never blocks, but it may have to retry if a write is in progress; this speeds up the readers in the case where the data was not modified, since they do not have to acquire the lock as they would with a traditional read-write lock.  Also, writers do not wait for readers, whereas with traditional read-write locks they do, leading to potential resource starvation in a situation where there are a number of readers (because the writer must wait for there to be no readers).  Because of these two factors, seqlocks are more efficient than traditional read-write locks for the situation where there are many readers and few writers. The drawback is that if there is too much write activity or the reader
is too slow they might livelock.</p>
<p>

It should also be noted that the technique will not work for data that contains pointers, because any writer could invalidate a pointer that a reader has already followed.</p>
<p>

This was first applied to system time counter updating. Each time interrupt updates the time of the day; there may be many readers of the time for operating system internal use and applications, but writes are relatively infrequent and only occur one at a time.  The BSD timecounter code for instance appears to use a similar technique.</p>
<p>

One subtle issue of using seqlocks for a time counter is that it is impossible to step through it with a debugger. The retry log will trigger all the time
because the debugger is slow enough to make the read race occur always.
</p>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../738/28738.xml">
Synchronization</link></entry>
<entry level="1" type="bullet">

 <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../603/244603.xml">
Spinlock</link></concept>
</idea>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

Effective synchronisation on Linux systems, <weblink xlink:type="simple" xlink:href="http://www.lameter.com/gelato2005.pdf">
http://www.lameter.com/gelato2005.pdf</weblink></entry>
<entry level="1" type="bullet">

Driver porting: mutual exclusion with seqlocks, <weblink xlink:type="simple" xlink:href="http://lwn.net/Articles/22818/">
http://lwn.net/Articles/22818/</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
