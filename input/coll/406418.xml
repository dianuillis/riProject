<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:01:20[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<measure  confidence="0.9511911446218017" wordnetid="100174412">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Levenshtein distance</title>
<id>406418</id>
<revision>
<id>239352310</id>
<timestamp>2008-09-18T18:44:10Z</timestamp>
<contributor>
<username>Danicc</username>
<id>2356020</id>
</contributor>
</revision>
<categories>
<category>Discrete mathematics</category>
<category>String similarity measures</category>
<category>Algorithms on strings</category>
<category>Dynamic programming</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../773/14773.xml">
information theory</link> and <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>Levenshtein distance</b> is a <link xlink:type="simple" xlink:href="../306/9809306.xml">
metric</link> for measuring the amount of difference between two sequences (i.e., the so called <link xlink:type="simple" xlink:href="../427/406427.xml">
edit distance</link>). The Levenshtein distance between two <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link> is given by the minimum number of operations needed to transform one string into the other, where an operation is an insertion, deletion, or substitution of a single character.  A generalization of the Levenshtein distance (<link xlink:type="simple" xlink:href="../630/3417630.xml">
Damerau-Levenshtein distance</link>) allows the <link xlink:type="simple" xlink:href="../819/41819.xml">
transposition</link> of two characters as an operation.<p>

The metric is named after <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<theorist wordnetid="110706812" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/3072406.xml">
Vladimir Levenshtein</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</theorist>
</person>
</physical_entity>
, who considered this distance in <link xlink:type="simple" xlink:href="../750/34750.xml">
1965</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
It is often used in applications that need to determine how similar, or different, two strings are, such as <link xlink:type="simple" xlink:href="../869/605869.xml">
spell checker</link>s.</p>
<p>

For example, the Levenshtein distance between "kitten" and "sitting" is 3, since the following three edits change one into the other, and there is no way to do it with fewer than three edits:</p>
<p>

<list>
<entry level="1" type="number">

 kitten → sitten (substitution of 's' for 'k')</entry>
<entry level="1" type="number">

 sitten → sittin (substitution of 'i' for 'e')</entry>
<entry level="1" type="number">

 sittin → sitting (insert 'g' at the end).</entry>
</list>
</p>
<p>

It can be considered a generalization of the <link xlink:type="simple" xlink:href="../227/41227.xml">
Hamming distance</link>, which is used for strings of the same length and only considers substitution edits.</p>

<sec>
<st>
 The algorithm </st>
<p>

A commonly-used bottom-up <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> algorithm for computing the Levenshtein distance involves the use of an (n + 1) × (m + 1) matrix, where n and m are the lengths of the two strings. This algorithm is based on the Wagner-Fischer algorithm for edit distance. Here is <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link> for a function <it>LevenshteinDistance</it> that takes two strings, <it>s</it> of length <it>m</it>, and <it>t</it> of length <it>n</it>, and computes the Levenshtein distance between them:</p>
<p>

<b>int</b> LevenshteinDistance(<b>char</b> s[1..m], <b>char</b> t[1..n])
<it>// d is a table with m+1 rows and n+1 columns</it>
<b>declare</b> <b>int</b> d[0..m, 0..n]</p>
<p>

<b>for</b> i <b>from</b> 0 <b>to</b> m
d[i, 0] := i
<b>for</b> j <b>from</b> 0 <b>to</b> n
d[0, j] := j</p>
<p>

<b>for</b> i <b>from</b> 1 <b>to</b> m
<b>for</b> j <b>from</b> 1 <b>to</b> n
<b>{</b>
<b>if</b> s[i] = t[j] <b>then</b> cost := 0
<b>else</b> cost := 1
d[i, j] := minimum(
d[i-1, j] + 1,     <it>// deletion</it>
d[i, j-1] + 1,     <it>// insertion</it>
d[i-1, j-1] + cost   <it>// substitution</it>
)
<b>}</b></p>
<p>

<b>return</b> d[m, n]</p>
<p>

Two examples of the resulting matrix (the minimum steps to be taken are highlighted):</p>

<p>

<table>
<row>
<col>
<table class="wikitable">
<row>


<header>
k</header>
<header>
i</header>
<header>
t</header>
<header>
t</header>
<header>
e</header>
<header>
n</header>
</row>
<row>

<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
</row>
<row>
<header>
s</header>
<col>
1</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
</row>
<row>
<header>
i</header>
<col>
2</col>
<col>
2</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
</row>
<row>
<header>
t</header>
<col>
3</col>
<col>
3</col>
<col>
2</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
</row>
<row>
<header>
t</header>
<col>
4</col>
<col>
4</col>
<col>
3</col>
<col>
2</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
</row>
<row>
<header>
i</header>
<col>
5</col>
<col>
5</col>
<col>
4</col>
<col>
3</col>
<col>
2</col>
<col>
2</col>
<col>
3</col>
</row>
<row>
<header>
n</header>
<col>
6</col>
<col>
6</col>
<col>
5</col>
<col>
4</col>
<col>
3</col>
<col>
3</col>
<col>
2</col>
</row>
<row>
<header>
g</header>
<col>
7</col>
<col>
7</col>
<col>
6</col>
<col>
5</col>
<col>
4</col>
<col>
4</col>
<col>
3</col>
</row>
</table>
</col>
<col>
<table class="wikitable">
<row>


<header>
S</header>
<header>
a</header>
<header>
t</header>
<header>
u</header>
<header>
r</header>
<header>
d</header>
<header>
a</header>
<header>
y</header>
</row>
<row>

<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
<col>
7</col>
<col>
8</col>
</row>
<row>
<header>
S</header>
<col>
1</col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
<col>
7</col>
</row>
<row>
<header>
u</header>
<col>
2</col>
<col>
1</col>
<col>
1</col>
<col>
2</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
</row>
<row>
<header>
n</header>
<col>
3</col>
<col>
2</col>
<col>
2</col>
<col>
2</col>
<col>
3</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
</row>
<row>
<header>
d</header>
<col>
4</col>
<col>
3</col>
<col>
3</col>
<col>
3</col>
<col>
3</col>
<col>
4</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
</row>
<row>
<header>
a</header>
<col>
5</col>
<col>
4</col>
<col>
3</col>
<col>
4</col>
<col>
4</col>
<col>
4</col>
<col>
4</col>
<col>
3</col>
<col>
4</col>
</row>
<row>
<header>
y</header>
<col>
6</col>
<col>
5</col>
<col>
4</col>
<col>
4</col>
<col>
5</col>
<col>
5</col>
<col>
5</col>
<col>
4</col>
<col>
3</col>
</row>
</table>
</col>
</row>
</table>
</p>


<p>

The <link xlink:type="simple" xlink:href="../638/1126638.xml">
invariant</link> maintained throughout the algorithm is that we can transform the initial segment s[1..i] into t[1..j] using a minimum of d[i,j] operations. At the end, the bottom-right element of the array contains the answer.</p>
<p>

This algorithm is essentially part of a solution to the <condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../105/236105.xml">
Longest common subsequence problem</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
 (LCS), in the particular case of 2 input lists.</p>

<ss1>
<st>
 Proof of correctness </st>
<p>

As mentioned earlier, the <link xlink:type="simple" xlink:href="../638/1126638.xml">
invariant</link> is that we can transform the initial segment s[1..i] into t[1..j] using a minimum of d[i,j] operations. This invariant holds since:
<list>
<entry level="1" type="bullet">

 It is initially true on row and column 0 because s[1..i] can be transformed into the empty string t[1..0] by simply dropping all i characters. Similarly, we can transform s[1..0] to t[1..j] by simply adding all j characters.</entry>
<entry level="1" type="bullet">

 The minimum is taken over three distances, each of which is feasible:</entry>
<entry level="2" type="bullet">

 If we can transform s[1..i] to t[1..j-1] in k operations, then we can simply add t[j] afterwards to get t[1..j] in k+1 operations.</entry>
<entry level="2" type="bullet">

 If we can transform s[1..i-1] to t[1..j] in k operations, then we can do the same operations on s[1..i] and then remove the original s[i] at the end in k+1 operations.</entry>
<entry level="2" type="bullet">

 If we can transform s[1..i-1] to t[1..j-1] in k operations, we can do the same to s[1..i] and then do a substitution of t[j] for the original s[i] at the end if necessary, requiring k+cost operations.</entry>
<entry level="1" type="bullet">

 The operations required to transform s[1..n] into t[1..m] is of course the number required to transform all of s into all of t, and so d[n,m] holds our result.</entry>
</list>
</p>
<p>

This proof fails to validate that the number placed in d[i,j] is in fact minimal; this is more difficult to show, and involves an <link xlink:type="simple" xlink:href="../418/25418.xml">
argument by contradiction</link> in which we assume d[i,j] is smaller than the minimum of the three, and use this to show one of the three is not minimal.</p>

</ss1>
<ss1>
<st>
 Possible improvements </st>
<p>

Possible improvements to this algorithm include:
<list>
<entry level="1" type="bullet">

 We can adapt the algorithm to use less space, <link xlink:type="simple" xlink:href="../578/44578.xml">
<it>O''</it></link>(<it>m</it>) instead of <it>O</it>(<it>mn</it>), since it only requires that the previous row and current row be stored at any one time.</entry>
<entry level="1" type="bullet">

 We can store the number of insertions, deletions, and substitutions separately, or even the positions at which they occur, which is always j.</entry>
<entry level="1" type="bullet">

 We can normalize the distance to the interval [0,1].</entry>
<entry level="1" type="bullet">

 If we are only interested in the distance if it is smaller than a threshold <it>k</it>, then it suffices to compute a diagonal stripe of width <it>2k+1</it> in the matrix. In this way, the algorithm can be run in <link xlink:type="simple" xlink:href="../578/44578.xml">
<it>O''</it></link>(<it>kl</it>) time, where <it>l</it> is the length of the shortest string.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></entry>
<entry level="1" type="bullet">

 We can give different penalty costs to insertion, deletion and substitution. We can also give penalty costs that depend on which characters are inserted, deleted or substituted. </entry>
<entry level="1" type="bullet">

 The initialization of d[i,0] can be moved inside the main outer loop.</entry>
<entry level="1" type="bullet">

 By initializing the first row of the matrix with <it>0</it>, the algorithm can be used for <link xlink:type="simple" xlink:href="../881/308881.xml">
fuzzy string search</link> of a string in a text <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>. This modification gives the end-position of matching substrings of the text. To determine the start-position of the matching substrings, the number of insertions and deletions can be stored separately and used to compute the start-position from the end-position <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></entry>
<entry level="1" type="bullet">

 This algorithm <link xlink:type="simple" xlink:href="../162/145162.xml">
parallelizes</link> poorly, due to a large number of <link xlink:type="simple" xlink:href="../217/4118217.xml">
data dependencies</link>. However, all the cost values can be computed in parallel, and the algorithm can be adapted to perform the minimum function in phases to eliminate dependencies.</entry>
<entry level="1" type="bullet">

 By examining diagonals instead of rows, and by using <link xlink:type="simple" xlink:href="../155/18155.xml">
lazy evaluation</link>, we can find the Levenshtein distance in <it>O</it>(<it>m</it> (1 + <it>d</it>)) time (where <it>d</it> is the Levenshtein distance), which is much faster than the regular dynamic programming algorithm if the distance is small. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Upper and lower bounds </st>

<p>

The Levenshtein distance has several simple upper and lower bounds that are useful in applications which compute many of them and compare them. These include:</p>
<p>

<list>
<entry level="1" type="bullet">

 It is always at least the difference of the sizes of the two strings.</entry>
<entry level="1" type="bullet">

 It is at most the length of the longer string.</entry>
<entry level="1" type="bullet">

 It is zero if and only if the strings are identical.</entry>
<entry level="1" type="bullet">

 If the strings are the same size, the <link xlink:type="simple" xlink:href="../227/41227.xml">
Hamming distance</link> is an upper bound on the Levenshtein distance.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
See also</st>


<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../939/308939.xml">
agrep</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../223/2242223.xml">
Bitap algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../630/3417630.xml">
Damerau-Levenshtein distance</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../673/79673.xml">
diff</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../855/342855.xml">
Dynamic time warping</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/308881.xml">
Fuzzy string searching</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../227/41227.xml">
Hamming distance</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../884/1127884.xml">
Hamming weight</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../756/2203756.xml">
Jaccard index</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../835/6782835.xml">
Jaro-Winkler</link> distance</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../161/3345161.xml">
Levenshtein automaton</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../105/236105.xml">
Longest common subsequence problem</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../923/522923.xml">
Lucene</link></room>
</library>
</area>
</artifact>
</structure>
 (an open source search engine that implements edit distance.) </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../354/408354.xml">
Manhattan distance</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../018/20018.xml">
Metric space</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../679/1004679.xml">
Needleman-Wunsch algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../523/532523.xml">
Similarity (mathematics)</link></entry>
<entry level="1" type="bullet">

 <link>
Similarity space</link> on <link xlink:type="simple" xlink:href="../763/2213763.xml">
Numerical taxonomy</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../195/1606195.xml">
Smith-Waterman algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link>
Sørensen similarity index</link></entry>
</list>
</p>


</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
В.И. Левенштейн (1965) Двоичные коды с исправлением выпадений, вставок и замещений символов. <it>Доклады Академий Наук СССР</it> 163.4:845–848. Appeared in English as: V. I. Levenshtein, Binary codes capable of correcting deletions, insertions, and reversals. <it>Soviet Physics Doklady</it> 10 (1966):707–710.</entry>
<entry id="2">
Dan Gusfield. Algorithms on strings, trees, and sequences: computer science and computational biology. Cambridge University Press, New York, NY, USA, 1997.</entry>
<entry id="3">
Gonzalo Navarro. A guided tour to approximate string matching. ACM Computing
Surveys, 33(1):31–88, 2001.</entry>
<entry id="4">
Bruno Woltzenlogel Paleo. <weblink xlink:type="simple" xlink:href="http://www.logic.at/people/bruno/Papers/2007-GATE-ESSLLI.pdf">
An approximate gazetteer for GATE based on levenshtein distance</weblink>. Student Section of the European Summer School in Logic, Language and Information (<link>
ESSLLI</link>), 2007.</entry>
<entry id="5">
L. Allison, Lazy Dynamic-Programming can be Eager. Inf. Proc. Letters 43(4) pp207-212, Sept' 1992 http://www.csse.monash.edu.au/~lloyd/tildeStrings/Alignment/92.IPL.html</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.levenshtein.net/">
The description of Levenshtein algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://corsis.de/res/levenshtein">
Highly optimized C# implementation</weblink> (uses GNU's <weblink xlink:type="simple" xlink:href="http://webcleaner.svn.sourceforge.net/viewvc/webcleaner/trunk/webcleaner2/wc/levenshtein.c?revision=6015&amp;view=markup">
levenshtein.c</weblink> as source and makes heavy use of C#'s pointer arithmetics capability)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.merriampark.com/ld.htm#FLAVORS">
Java, C++ and VB implementations of the algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/Levenshtein.html">
NIST's Dictionary of Algorithms and Data Structures: Levenshtein Distance</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-igm.univ-mlv.fr/~lecroq/seqcomp/node2.html">
Levenshtein Distance visualized</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.php.net/manual/function.levenshtein.php">
Inbuilt function in PHP</weblink>, and <weblink xlink:type="simple" xlink:href="http://gtools.org/tool/levenshtein-calculate/">
example implementation</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-users.med.cornell.edu/~jdvicto/metricdf.html">
Continuous variants, spike train metrics, and applications to neurophysiology</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.logic.at/people/bruno/Programs/BWPGazetteer/">
BWPGazetteer</weblink>: an implementation of Levenshtein Distance in Java within the GATE (<software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../152/11270152.xml">
General Architecture for Text Engineering</link></software>
) framework for <link xlink:type="simple" xlink:href="../652/21652.xml">
Natural Language Processing</link> and <link xlink:type="simple" xlink:href="../162/383162.xml">
Information Extraction</link>.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.mindrot.org/projects/py-editdist/">
py-editdist</weblink>: Python module implementation of Levenshtein Edit Distance between two strings.</entry>
</list>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</measure>
</article>
