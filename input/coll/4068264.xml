<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:48:49[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Tridiagonal matrix algorithm</title>
<id>4068264</id>
<revision>
<id>241957267</id>
<timestamp>2008-09-30T07:02:48Z</timestamp>
<contributor>
<username>NE2</username>
<id>1757249</id>
</contributor>
</revision>
<categories>
<category>Numerical linear algebra</category>
</categories>
</header>
<bdy>

The <b>tridiagonal matrix algorithm (TDMA)</b>, also known as the <b>Thomas algorithm</b>, is a simplified form of <link xlink:type="simple" xlink:href="../035/13035.xml">
Gaussian elimination</link> that can be used to solve <link xlink:type="simple" xlink:href="../218/519218.xml">
 tridiagonal systems of equations</link>.  A tridiagonal system for <it>n</it> unknowns may be written as<p>

<indent level="1">

<math>
a_i x_{i - 1}  + b_i x_i  + c_i x_{i + 1}  = d_i , \,\!</math>
</indent>
where <math> a_1  = 0\, </math> and <math> c_n = 0\, </math>.  In matrix form, this system is written as
<math> 
\left[ 
\begin{matrix}
   {b_1} &amp; {c_1} &amp; {   } &amp; {   } &amp; { 0 } \\ 
   {a_2} &amp; {b_2} &amp; {c_2} &amp; {   } &amp; {   } \\ 
   {   } &amp; {a_3} &amp; {b_3} &amp; \cdot &amp; {   } \\ 
   {   } &amp; {   } &amp; \cdot &amp; \cdot &amp; {c_{n-1}}\\ 
   { 0 } &amp; {   } &amp; {   } &amp; {a_n} &amp; {b_n}\\ 
\end{matrix}
\right]
\left[ 
\begin{matrix}
   {x_1 }  \\ 
   {x_2 }  \\ 
   \cdot   \\
   \cdot   \\
   {x_n }  \\
\end{matrix}
\right]
=
\left[ 
\begin{matrix}
   {d_1 }  \\ 
   {d_2 }  \\ 
   \cdot   \\
   \cdot   \\
   {d_n }  \\
\end{matrix}
\right].
</math></p>
<p>

For such systems, the solution can be obtained in <math>O(n)</math> operations instead of <math>O(n^3)</math> required by <link xlink:type="simple" xlink:href="../035/13035.xml">
Gaussian elimination</link>. A first sweep eliminates the <math>a_i</math>'s, and then an (abbreviated) backward substitution produces the solution.  Example of such matrices commonly arise from the discretization of 1D <link xlink:type="simple" xlink:href="../735/193735.xml">
Poisson equation</link> (e.g., the 1D <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/166415.xml">
diffusion problem</link></mathematical_statement>
</equation>
</message>
</statement>
).</p>

<sec>
<st>
 Method </st>
<p>

The first step consists of modifying the coefficients as follows, denoting the new modified coefficients with primes:</p>
<p>

<indent level="1">

<math>c'_i = 
\begin{cases}
\begin{array}{lcl}
  \cfrac{c_1}{b_1}                  &amp; ; &amp; i = 1 \\
  \cfrac{c_i}{b_i - c'_{i - 1} a_i} &amp; ; &amp; i = 2, 3, \dots, n - 1 \\
\end{array}
\end{cases}
\,</math>
</indent>

<indent level="1">

<math>d'_i = 
\begin{cases}
\begin{array}{lcl}
  \cfrac{d_1}{b_1}                  &amp; ; &amp; i = 1 \\
  \cfrac{d_i - d'_{i - 1} a_i}{b_i - c'_{i - 1} a_i} &amp; ; &amp; i = 2, 3, \dots, n \\
\end{array}
\end{cases}
\,</math>
</indent>

This is the forward sweep. The solution is then obtained by back substitution:</p>
<p>

<indent level="1">

<math>x_n = d'_n\,</math>
</indent>

<indent level="1">

<math>x_i = d'_i - c'_i x_{i + 1} \qquad ; \ i = n - 1, n - 2, \ldots, 1</math>
</indent>

</p>
<ss1>
<st>
 Implementation in C </st>
<p>

The following <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 function will solve a general tridiagonal system. Note that the index <math>i</math> here is <link xlink:type="simple" xlink:href="../052/2052.xml#xpointer(//*[./st=%22Indexing%22])">
zero based</link>, in other words <math>i = 0, 1, \dots, n - 1</math> where <math>n</math> is the number of unknowns.</p>

<p>

/* Fills solution into x. Warning: will modify c and d! */
void TridiagonalSolve(const double *a, const double *b, double *c, double *d, double *x, unsigned int n){
int i;</p>
<p>

/* Modify the coefficients. */
c[0] /= b[0];				/* Division by zero risk. */
d[0] /= b[0];
for(i = 1; i  n; i++){
double id = 1.0/(b[i] - c[i - 1]*a[i]);	/* Division by zero risk. */
c[i] *= id;				/* Last value calculated is redundant. */
d[i] = (d[i] - d[i - 1]*a[i])*id;
}</p>
<p>

/* Now back substitute. */
x[n - 1] = d[n - 1];
for(i = n - 2; i &amp;gt;= 0; i--)
x[i] = d[i] - c[i]*x[i + 1];
}</p>


</ss1>
<ss1>
<st>
 Implementation in C# </st>

<p>

double TDMASolve(double a, double b, double c, double d)
{
double cc = new double[c.Length];
double dd = new double[d.Length];</p>
<p>

double x = new double[f.Length];
int N = d.Length;
cc[0] = c[0] / b[0];
dd[0] = d[0] / b[0];
for (int i = 1; i  N; i++)
{
double m = b[i] - cc[i - 1] * a[i];
cc[i] = c[i] / m;
dd[i] = (d[i] - dd[i - 1] * a[i]) / m;
}
x[N - 1] = d[N - 1];
for (int i = N - 2; i &amp;gt;= 0; i--)
{
x[i] = dd[i - 1] - cc[i - 1] * x[i + 1];
}
return x;
}</p>


</ss1>
</sec>
<sec>
<st>
 Derivation </st>
<p>

The derivation of the <link xlink:type="simple" xlink:href="../264/4068264.xml">
tridiagonal matrix algorithm</link> involves manually performing some specialized <link xlink:type="simple" xlink:href="../035/13035.xml">
Gaussian elimination</link> in a generic manner.</p>
<p>

Suppose that the unknowns are <math>x_1,\ldots, x_n</math>, and that the equations to be solved are:</p>
<p>

<indent level="1">

<math>\begin{align}
b_1 x_1 + c_1 x_2 &amp; = d_1;&amp; i &amp; = 1 \\
a_i x_{i - 1} + b_i x_i  + c_i x_{i + 1} &amp; = d_i;&amp; i &amp; = 2, \ldots, n - 1 \\
a_n x_{n - 1} + b_n x_n &amp; = d_n;&amp; i &amp; = n
\end{align}
</math>
</indent>

Consider modifying the second (<math>i = 2</math>) equation with the first equation as follows:</p>
<p>

<indent level="1">

<math>
(\mbox{equation 2}) \cdot b_1 - (\mbox{equation 1}) \cdot a_2
</math>
</indent>

which would give:</p>
<p>

<indent level="1">

<math>
(a_2 x_1 + b_2 x_2  + c_2 x_3) b_1 - (b_1 x_1  + c_1 x_2) a_2 = d_2 b_1 - d_1 a_2
\,</math>
</indent>

<indent level="1">

<math>
(b_2 b_1 - c_1 a_2) x_2  + c_2 b_1 x_3 = d_2 b_1 - d_1 a_2
\,</math>
</indent>

and the effect is that <math>x_1</math> has been eliminated from the second equation. Using a similar tactic with the <b>modified</b> second equation on the third equation yields:</p>
<p>

<indent level="1">

<math>
(a_3 x_2 + b_3 x_3 + c_3 x_4) (b_2 b_1 - c_1 a_2) -
((b_2 b_1 - c_1 a_2) x_2 + c_2 b_1 x_3) a_3
= d_3 (b_2 b_1 - c_1 a_2) - (d_2 b_1 - d_1 a_2) a_3
\,</math>
</indent>

<indent level="1">

<math>
(b_3 (b_2 b_1 - c_1 a_2) - c_2 b_1 a_3 )x_3 + c_3 (b_2 b_1 - c_1 a_2) x_4
= d_3 (b_2 b_1 - c_1 a_2) - (d_2 b_1 - d_1 a_2) a_3
\,</math>
</indent>

This time <math>x_2</math> was eliminated. If this procedure is repeated until the <math>n^{th}</math> row; the (modified) <math>n^{th}</math> equation will involve only one unknown, <math>x_n</math>. This may be solved for and then used to solve the <math>(n - 1)^{th}</math> equation, and so on until all of the unknowns are solved for.</p>
<p>

Clearly, the coefficients on the modified equations get more and more complicated if stated explicitly. By examining the procedure, the modified coefficients (notated with tildes) may instead be defined recursively:</p>
<p>

<indent level="1">

<math>\tilde a_i = 0\,</math>
</indent>

<indent level="1">

<math>\tilde b_1 = b_1\,</math>
</indent>
:<math>\tilde b_i = b_i \tilde b_{i - 1} - \tilde c_{i - 1} a_i\,</math></p>
<p>

<indent level="1">

<math>\tilde c_1 = c_1\,</math>
</indent>
:<math>\tilde c_i = c_i \tilde b_{i - 1}\,</math></p>
<p>

<indent level="1">

<math>\tilde d_1 = d_1\,</math>
</indent>
:<math>\tilde d_i = d_i \tilde b_{i - 1} - \tilde d_{i - 1} a_i\,</math></p>
<p>

To further hasten the solution process, <math>\tilde b_i</math> may be divided out (if there's no division by zero risk), the newer modified coefficients notated with an asterisk will be:</p>
<p>

<indent level="1">

<math>a'_i = 0\,</math>
</indent>

<indent level="1">

<math>b'_i = 1\,</math>
</indent>

<indent level="1">

<math>c'_1 = \frac{c_1}{b_1}\,</math>
</indent>
:<math>c'_i = \frac{c_i}{b_i - c'_{i - 1} a_i}\,</math></p>
<p>

<indent level="1">

<math>d'_1 = \frac{d_1}{b_1}\,</math>
</indent>
:<math>d'_i = \frac{d_i - d'_{i - 1} a_i}{b_i - c'_{i - 1} a_i}\,</math></p>
<p>

This gives the following system with the same unknowns and coefficients defined in terms of the original ones above:</p>
<p>

<indent level="1">

<math>\begin{array}{lcl}
x_i + c'_i x_{i + 1} = d'_i \qquad &amp;;&amp; \ i = 1, \ldots, n - 1 \\
x_n = d'_n \qquad &amp;;&amp; \ i = n \\
\end{array}
\,</math>
</indent>

The last equation involves only one unknown. Solving it in turn reduces the next last equation to one unknown, so that this backward substitution can be used to find all of the unknowns:</p>
<p>

<indent level="1">

<math>x_n = d'_n\,</math>
</indent>

<indent level="1">

<math>x_i = d'_i - c'_i x_{i + 1} \qquad ; \ i = n - 1, n - 2, \ldots, 1</math>
</indent>

</p>
</sec>
<sec>
<st>
 Variants </st>
<p>

In some situations, particularly those involving periodic boundary conditions, a slightly perturbed form of the tridiagonal system may need to be solved:</p>
<p>

<indent level="1">

<math>
\begin{align}
a_1 x_{n}  + b_1 x_1  + c_1 x_2  &amp; = d_1, \\
a_i x_{i - 1}  + b_i x_i  + c_i x_{i + 1}  &amp; = d_i,\quad\quad i = 2,\ldots,n-1 \\
a_n x_{n-1}  + b_n x_n  + c_n x_1  &amp; = d_n.
\end{align}
</math>
</indent>

In this case, we can make use of the <link xlink:type="simple" xlink:href="../798/2556798.xml">
Sherman-Morrison formula</link> to avoid the additional operations of Gaussian elimination and still use the Thomas algorithm.</p>
<p>

In other situations, the system of equations may be <b>block tridiagonal</b> (see <link xlink:type="simple" xlink:href="../464/457464.xml">
block matrix</link>), with smaller submatrices arranged as the individual elements in the above matrix system(e.g., the 2D <link xlink:type="simple" xlink:href="../147/5138147.xml">
Poisson problem</link>). Simplified forms of Gaussian elimination have been developed for these situations.</p>
<p>

A variant of the Thomas algorithm is the Hu-Gallash algorithm, which uses forward substitution instead of backwards substitution.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book">Conte, S.D., and deBoor, C.&#32;(1972). Elementary Numerical Analysis.&#32;McGraw-Hill, New York..</cite>&nbsp;</entry>
<entry level="1" type="bullet">

This article incorporates text from the article <weblink xlink:type="simple" xlink:href="http://www.cfd-online.com/Wiki/Tridiagonal">
matrix algorithm &mdash; TDMA (Thomas algorithm) Tridiagonal matrix algorithm &mdash; TDMA (Thomas algorithm)</weblink> on <weblink xlink:type="simple" xlink:href="http://www.cfd-online.com/Wiki/Main_Page">
CFD-Wiki</weblink> that is under the <link xlink:type="simple" xlink:href="../782/18938782.xml">
GFDL</link> license.</entry>
</list>
</p>



</sec>
<sec>
<st>
 External links </st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.arbredeslemuriens.com/Categorie.php?IDCategorie=AlgoScilab&amp;IDTitre=182">
Thomas algorithm &mdash; SCILAB</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.arbredeslemuriens.com/Categorie.php?IDCategorie=AlgoScilab&amp;IDTitre=185">
Thomas algorithm for tridiagonal superior periodic matrix &mdash; SCILAB</weblink></entry>
</list>
</p>
</sec>
</bdy>
</article>
