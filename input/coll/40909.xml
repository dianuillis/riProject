<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:40:57[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Booting</title>
<id>40909</id>
<revision>
<id>244571447</id>
<timestamp>2008-10-11T14:13:04Z</timestamp>
<contributor>
<username>Kozuch</username>
<id>1339567</id>
</contributor>
</revision>
<categories>
<category>Articles lacking in-text citations</category>
<category>Booting</category>
<category>BIOS</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="50px" src="Text_document_with_red_question_mark.svg">
</image>
</p>
</col>
<col style="" class="mbox-text">
 This article or section includes a  or , but its sources remain unclear because it has <b>insufficient  .</b>
You can  this article by introducing more precise citations . <it>(October 2008)''</it></col>
</row>
</table>


In <link xlink:type="simple" xlink:href="../213/5213.xml">
computing</link>, <b>booting</b> (<b>booting up</b>) is a <link xlink:type="simple" xlink:href="../679/6885679.xml">
bootstrapping</link> process that starts <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s when the user turns on a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer system</link>. A <b>boot sequence</b> is the initial set of operations that the computer performs when it is switched on. The bootloader typically loads the main <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> for the computer.
<sec>
<st>
 History </st>
<p>

The computer word boot is short for <link xlink:type="simple" xlink:href="../211/4211.xml">
'bootstrap'</link> (short for 'bootstrap load'). The term bootstrap began as a metaphor derived from pull straps sewed onto the backs of leather boots with which a person could pull on their boots without outside help.  In computers in the 1950s, pressing a bootstrap button caused a hardwired program to read a bootstrap program from a punched card and then execute the loaded boot program which loaded a larger system of programs from punched cards into memory, without further help from the human operator. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> In a computing context, that word has been used since at least 1958<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>. </p>
<p>

The <link xlink:type="simple" xlink:href="../659/58659.xml">
GE 645</link> (c. 1965) had a 'BOOT' button<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> &ndash; it could be that the contraction started as a way to label the button with fewer letters than the full word.</p>
<p>

The <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../847/18847.xml">
Multics</link></O>
 operating system (c. 1967) had a boot command.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
Multics documents also refer to 'boot tapes', but it is hard to determine exactly when that term was first used.</p>
<p>

In the <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 operating system, the earliest reference for 'boot' is probably in <it>The Unix Programmer's Manual</it>, first edition 1971.11.03<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>.</p>
<p>

The bootstrap concept was used in the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/192701.xml">
IBM 701</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 computer (1952-1956) which had a "load button" which initiated reading of the first 36-bit word from a punched card in a card reader, or from a magnetic tape unit, or drum unit (predecessor of the harddisk drive).  The left 18-bit half-word was then executed as an instruction which read additional words into memory.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>

</sec>
<sec>
<st>
 Boot loader </st>

<p>

Computing systems powered by the central processor (or a set of processors) can only execute code found in the operating memory, also known as systems memory, that may be implemented in several technologies covered by the general types of: Read-Only Memory or ROM, and Random Access Memory or RAM.  Modern operating systems and application program code and data are stored on nonvolatile or persistent local or remote peripheral memories or mass storage devices.  Typical examples of such persistent storage devices are: hard disk, CD, DVD, USB flash drive and Floppy drive. When a computer is first powered on, it must initially rely only on the code and data stored in nonvolatile portion of the systems memory map, such as ROM, NVRAM or CMOS RAM. Persistent code and data residing in the systems memory map represent the bare minimum needed to access peripheral persistent devices and load into the systems memory all of the missing parts of the operating system. Truly speaking at power-on time the computing system  does not have an operating system in memory. Among many things, the computer's hardware alone (processor and systems memory) cannot perform many complex systems actions of which loading program files from the disk based file systems is one of the most important tasks.</p>
<p>

The program that starts the "chain reaction" which ends with the entire operating system being loaded is known as bootstrap loader. Early computer designers creatively imagined that before being ready to "run" a <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>, a small initiating program called a <it><link xlink:type="simple" xlink:href="../679/6885679.xml">
bootstrap loader</link></it>, <it>bootstrap</it> or <it>boot loader</it> had to run first. This program's only job is to load other software for the operating system to start. Often, multiple-stage boot loaders are used, in which several small programs of increasing complexity sequentially summon one after the other in a process of <link xlink:type="simple" xlink:href="../027/5481027.xml">
chain loading</link>, until the last of them loads the operating system. The name <it>bootstrap loader</it> comes from the image of one pulling oneself up by one's <link xlink:type="simple" xlink:href="../211/4211.xml">
boot straps</link>. </p>
<p>

Early computers (such as the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../965/23965.xml">
PDP-1</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 through <link xlink:type="simple" xlink:href="../364/24364.xml">
PDP-8</link> and early models of the <link xlink:type="simple" xlink:href="../399/24399.xml">
PDP-11</link>) had a row of <link xlink:type="simple" xlink:href="../974/317974.xml">
toggle switch</link>es on the front panel to allow the operator to manually enter the <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link></instrumentality>
</artifact>
</system>
 boot instructions into memory before transferring control to the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link>. The boot loader would then read the operating system in from an outside storage medium such as <link xlink:type="simple" xlink:href="../761/49761.xml">
paper tape</link>, <link xlink:type="simple" xlink:href="../420/24420.xml">
punched card</link>, or a <link xlink:type="simple" xlink:href="../472/Species_8472.xml">
disk drive</link>.</p>
<p>

<link xlink:type="simple" xlink:href="../185/24185.xml">
Pseudo</link>-<link xlink:type="simple" xlink:href="../368/1368.xml">
assembly code</link> for the bootloader might be as simple as the following eight instructions:</p>
<p>

0: set the P register to 8
1: check paper tape reader ready
2: if not ready, jump to 1
3: read a byte from paper tape reader to accumulator
4: if end of tape, jump to 8
5: store accumulator to address in P register
6: increment the P register
7: jump to 1</p>
<p>

A related example is based on a loader for a 1970's Nicolet Instrument Corporation <link xlink:type="simple" xlink:href="../272/20272.xml">
minicomputer</link>.  Note that the bytes of the second-stage loader are read from paper tape in reverse order.</p>
<p>

0: set the P register to 106
1: check paper tape reader ready
2: if not ready, jump to 1
3: read a byte from paper tape reader to accumulator
4: store accumulator to address in P register
5: decrement the P register 
6: jump to 1</p>
<p>

The length of the second stage loader is such that the final byte overwrites location 6.  After the instruction in location 5 executes, location 6 starts the second stage loader executing.  The second stage loader then waits for the much longer tape containing the operating system to be placed in the tape reader.  The difference between the boot loader and second stage loader is the addition of checking code to trap paper tape read errors, a frequent occurrence with the hardware of the time, which in this case was an <link xlink:type="simple" xlink:href="../684/1507684.xml">
ASR-33</link> <link xlink:type="simple" xlink:href="../247/31247.xml">
teletype</link>.</p>
<p>

Some computer systems, upon receiving a boot signal from a human operator or a peripheral device, may load a very small number of fixed instructions into memory at a specific location, initialize at least one CPU, and then point the CPU to the instructions and start their execution.  These instructions typically start an input operation from some peripheral device (which may be switch-selectable by the operator). Other systems may send hardware commands directly to peripheral devices or I/O controllers that cause an extremely simple input operation (such as "read sector zero of the system device into memory starting at location 1000") to be carried out, effectively loading a small number of bootload instructions into memory; a completion signal from the I/O device may then be used to start execution of the instructions by the CPU.</p>
<p>

Smaller computers often use less flexible but more automatic bootload mechanisms to ensure that the computer starts quickly and with a predetermined software configuration. In many desktop computers, for example, the bootstrapping process begins with the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> executing software contained in ROM (for example, the <generic wordnetid="107899976" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../473/Form_4473.xml">
BIOS</link></generic>
 of an <link xlink:type="simple" xlink:href="../032/15032.xml">
IBM PC</link>) at a predefined address (the CPU is designed to execute this software after reset without outside help). This software contains rudimentary functionality to search for devices eligible to participate in booting, and load a small program from a special section (most commonly the <link xlink:type="simple" xlink:href="../381/216381.xml">
boot sector</link>) of the most promising device. It is usually possible to configure the BIOS so that only a certain device can be booted from and/or to give priority to some devices over others (a CD or DVD drive is usually given priority over a hard disk, for instance).</p>
<p>

Boot loaders may face peculiar constraints, especially in size; for instance, on the IBM PC and compatibles, the first stage of boot loaders located on hard drives must fit into the first 446 <link xlink:type="simple" xlink:href="../365/3365.xml">
bytes</link> of the <link xlink:type="simple" xlink:href="../389/55389.xml#xpointer(//*[./st=%22Structure+of+a+Master+Boot+Record%22])">
Master Boot Record</link>, in order to leave room for the 64-byte <link xlink:type="simple" xlink:href="../380/55380.xml">
partition table</link> and the 2-byte 0xAA55 'signature', which the BIOS requires for a proper boot loader.</p>
<p>

Some operating systems, most notably pre-1995 <link xlink:type="simple" xlink:href="../979/19006979.xml">
Macintosh</link> systems from <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../856/856.xml">
Apple</link></company>
, are so closely interwoven with their hardware that it is impossible to natively boot an operating system other than the standard one. This is the opposite extreme of the bootload using switches mentioned above; it is highly inflexible but relatively error-proof and foolproof as long as all hardware is working normally. A common solution in such situations is to design a bootloader that works as a program belonging to the standard OS that hijacks the system and loads the alternative OS. This technique was used by Apple for its <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../604/238604.xml">
A/UX</link></O>
 <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 implementation and copied by various freeware operating systems and <link xlink:type="simple" xlink:href="../801/4801.xml">
BeOS Personal Edition 5</link>. </p>

<ss1>
<st>
 Second-stage boot loader </st>
<p>

<image location="right" width="150px" src="GRUB_screenshot.png" type="thumb">
</image>

The small program is most often not itself an operating system, but only a second-stage boot loader, such as <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<laborer wordnetid="110241300" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<workman wordnetid="110791221" confidence="0.8">
<stevedore wordnetid="110655169" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../817/287817.xml">
GRUB</link></employee>
</stevedore>
</workman>
</causal_agent>
</laborer>
</worker>
</person>
</physical_entity>
, <link xlink:type="simple" xlink:href="../810/287810.xml">
LILO</link> or <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<laborer wordnetid="110241300" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<workman wordnetid="110791221" confidence="0.8">
<stevedore wordnetid="110655169" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../844/287844.xml">
NTLDR</link></employee>
</part>
</stevedore>
</workman>
</causal_agent>
</laborer>
</worker>
</component>
</concept>
</idea>
</person>
</physical_entity>
. It will then be able to load the operating system properly, and finally transfer execution to it. The system will initialize itself, and may load <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>s and other programs that are needed for the normal operation of the OS.</p>
<p>

Many bootloaders (like GRUB, Bootmgr, LILO, and NTLDR) can be configured to give the user multiple booting choices. These choices can include different operating systems (for <link xlink:type="simple" xlink:href="../756/494756.xml">
dual or multi-booting</link> from different partitions or drives), different kernel versions of the same operating system (e.g., when a newer Linux kernel is installed, this gives one the option of using a <it>known good</it> kernel if problems arise), different kernel options (e.g., booting into a rescue or safe mode) or some standalone program that can function without an operating system, such as memory testers (e.g., <link xlink:type="simple" xlink:href="../989/695989.xml">
memtest86+</link>) or even games. Usually a default choice is preselected with a time delay during which you can press a key to change the choice, after which the default choice is automatically run, so normal booting can occur without interaction.</p>
<p>

The boot process is considered complete when the computer is ready to interact with the user, or the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> is capable of running ordinary applications. Typical modern <link xlink:type="simple" xlink:href="../137/18457137.xml">
PCs</link> boot in about one minute (of which about 15 seconds are taken by a <link xlink:type="simple" xlink:href="../425/1699425.xml">
power-on self test</link> (POST) and a preliminary boot loader, and the rest by loading the operating system); whereas, large servers may take several minutes to boot and start all their services.</p>
<p>

Many <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded system</link>s must boot immediately. For example, waiting a minute for a <link xlink:type="simple" xlink:href="../485/628485.xml">
digital television</link> or <link xlink:type="simple" xlink:href="../480/18752480.xml">
sat-nav</link> to start is generally unacceptable. Therefore such devices have their complete operating system in ROM or <link xlink:type="simple" xlink:href="../595/50595.xml">
flash memory</link> so the device can begin functioning immediately. For these types of embedded system little or no loading is necessary, since the loading can be precomputed and stored on the ROM when the device is made.</p>
<p>

Large and complex systems may have boot procedures that proceed in multiple phases, each phase loading a more complex version of itself, until finally the actual operating system is loaded and ready to execute.  Because most operating systems are designed as if they never start or stop, bootload processes sometimes construct a near-snapshot of a running operating system, configure themselves as a mere process within that operating system, and then irrevocably transfer control into the operating system; the bootload process then terminates normally as any other process would, and the operating system need not have any awareness of the bootload.</p>

</ss1>
<ss1>
<st>
 Flash boot loader </st>
<p>

Embedded systems especially in automotive applications rely heavily on Flash Bootloaders to ensure that the <link xlink:type="simple" xlink:href="../111/570111.xml">
ECU</link> (Electronic Control Unit) is programmable either in production or in service. A Flash Bootloader resides in Flash memory, and is always the first application to run after a reset. The Flash bootloader decides whether an application is ready and thereby either stays in the ECU or jumps to the application to start execution. The benefit of having a Flash Bootloader on an ECU is mainly to allow erasing and programming new applications on a single ECU in case of application updates, a recall, or changing a configuration by downloading new calibration files.
The most popular Flash Bootloaders are <link xlink:type="simple" xlink:href="../284/231284.xml">
CAN</link> based, i.e. use the Control Area Network protocol to download data to an ECU. These bootloaders use a <link xlink:type="simple" xlink:href="../525/18507525.xml">
Diagnostics</link> protocol to communicate and download to an ECU.</p>

</ss1>
<ss1>
<st>
 Network booting </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../258/8002258.xml">
Network booting</link></it>
</indent>

Most computers are also capable of booting over a <link xlink:type="simple" xlink:href="../592/4122592.xml">
computer network</link>. In this scenario, the operating system is stored on the disk of a <link xlink:type="simple" xlink:href="../116/42116.xml">
server</link>, and certain parts of it are transferred to the client using a simple protocol such as the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../806/52806.xml">
Trivial File Transfer Protocol</link></rule>
</direction>
</protocol>
</message>
. After these parts have been transferred, the operating system then takes over control of the booting process.</p>

</ss1>
</sec>
<sec>
<st>
 Boot devices </st>


<p>

The boot device is the device from which the operating system is loaded. A modern PC <generic wordnetid="107899976" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../473/Form_4473.xml">
BIOS</link></generic>
 supports booting from various devices, typically a local <link xlink:type="simple" xlink:href="../777/13777.xml">
hard disk drive</link> (or one of several <link xlink:type="simple" xlink:href="../380/55380.xml">
partitions</link> on such a disk), an <link xlink:type="simple" xlink:href="../592/299592.xml">
optical disc drive</link>, a <bus wordnetid="102924116" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../073/32073.xml">
USB</link></bus>
 device (flash drive, hard disk drive, optical disc drive, etc.), or a network interface card (using <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../253/432253.xml">
PXE</link></system_of_measurement>
</standard>
). Older, less common bootable devices include <link xlink:type="simple" xlink:href="../361/304361.xml">
floppy disk drives</link>, <link xlink:type="simple" xlink:href="../313/28313.xml">
SCSI</link> devices, <link xlink:type="simple" xlink:href="../025/278025.xml">
Zip drive</link>s, and <link xlink:type="simple" xlink:href="../759/271759.xml">
LS-120</link> drives.</p>
<p>

Typically, the BIOS will allow the user to configure a <it>boot order</it>. If the boot order is set to "firstly, the DVD drive; secondly, the hard disk drive", then the BIOS will try to boot from the DVD drive, and if this fails (e.g. because there is no DVD in the drive), it will try to boot from the local hard drive.</p>
<p>

For example, on a PC with <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/33879.xml">
Windows XP</link></version>
 installed on the hard drive, the user could set the boot order to that given above, and then insert a <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../125/158125.xml">
Knoppix</link></O>
 <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../137/331137.xml">
Live CD</link></distribution>
</arrangement>
</structure>
 in order to try out <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 without having to install an operating system onto their hard drive. This is an example of <link xlink:type="simple" xlink:href="../756/494756.xml">
dual booting</link> - the user choosing which operating system to start after the computer has performed its <link xlink:type="simple" xlink:href="../425/1699425.xml">
Power On Self Test</link>. In this example of dual booting, the user chooses by inserting or removing the CD from the computer, but it is more common to choose which operating system to boot by selecting from a menu using the computer keyboard. (Typically, the boot loader which presents the menu will select a default option if the user does nothing for a configured time period, e.g. 30 seconds. This facilitates unattended rebooting into a default environment.)</p>

</sec>
<sec>
<st>
 Boot sequence on standard PC (IBM-PC compatible) </st>
<p>

Upon starting, a <link xlink:type="simple" xlink:href="../137/18457137.xml">
personal computer</link>'s <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> runs the instruction located at the memory location F000:FFF0 (on 286s and 386SXs, the base of the code segment is actually 0xFF0000 and on 386s it is 0xFFFF0000)  of the <generic wordnetid="107899976" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../473/Form_4473.xml">
BIOS</link></generic>
. This memory location is close to the end of system memory. It contains a jump instruction that transfers execution to the location of the BIOS start-up program. This program runs a <link xlink:type="simple" xlink:href="../425/1699425.xml">
power-on self test</link> (POST) to check that devices the computer will rely on are functioning; it also initializes these devices. Then, the BIOS goes through a preconfigured list of <link xlink:type="simple" xlink:href="../629/780629.xml">
non-volatile storage devices</link> ("boot device sequence") until it finds one that is bootable. A bootable device is one such that it can be read from and the last two bytes of the first sector contain the <link xlink:type="simple" xlink:href="../344/1613344.xml">
word</link> 0xAA55 (also known as the boot signature). On some IBM PCs and derivatives made by IBM, if it finds no such device, control is transferred to <link xlink:type="simple" xlink:href="../584/5134584.xml">
IBM Cassette BASIC</link> in ROM. On other <link xlink:type="simple" xlink:href="../803/49803.xml">
IBM PC compatible</link>s, an error message is generated and the boot process stops. </p>
<p>

Once BIOS has found a bootable device, BIOS loads the bootsector to hexadecimal <link>
Sector</link>:<link>
Offset</link> address 0000:7C00 and transfers execution to the <link xlink:type="simple" xlink:href="../381/216381.xml">
boot sector</link>.  In the case of a hard drive, this is referred to as the <link xlink:type="simple" xlink:href="../389/55389.xml">
master boot record</link> (<it>MBR</it>) and is often not operating system specific. The conventional MBR code checks the MBR's <link xlink:type="simple" xlink:href="../380/55380.xml">
partition table</link> for an <it>active partition</it>(the one with <it>active</it> flag set)<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref>. If one is found, the MBR code loads that partition's <link xlink:type="simple" xlink:href="../381/216381.xml">
boot sector</link> and executes it. The boot sector is often operating system specific, however in most operating systems its main function is to load and execute the operating system <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link>, which continues startup. If there is no active partition or the active partition's boot sector is invalid, the MBR may load a secondary boot loader and pass control to it and this secondary boot loader will select a partition (often via user input) and load its boot sector, which usually loads the corresponding operating system kernel. </p>
<p>

Newer systems that have <link xlink:type="simple" xlink:href="../065/866065.xml">
EFI</link>-compliant firmware can boot from that to either MBR or <link xlink:type="simple" xlink:href="../892/2543892.xml">
GPT</link> drives. Compatibility with x86 operating systems, such as 32-bit Windows XP and Vista, require “legacy BIOS” interfaces to operate, which is handled through a compatibility support module (CSM). The CSM includes a 16-bit binary (CSM16) supplied by BIOS vendors, like <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../819/1265819.xml">
American Megatrends</link></company>
 (AMI) and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../669/4248669.xml">
Insyde Software</link></company>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> or <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../856/856.xml">
Apple Inc.</link></company>
 which offers it as a firmware update for Intel Macintosh computers.</p>

</sec>
<sec>
<st>
 Other kinds of boot sequence </st>
<p>

Some other processors have other kinds of boot modes; most <link xlink:type="simple" xlink:href="../505/154505.xml">
digital signal processor</link>s have the following boot modes:
<list>
<entry level="1" type="bullet">

Serial mode boot</entry>
<entry level="1" type="bullet">

Parallel mode boot</entry>
<entry level="1" type="bullet">

HPI boot</entry>
</list>
</p>

<ss1>
<st>
 Initial Program Load </st>

<p>

In <link xlink:type="simple" xlink:href="../872/14872.xml">
IBM mainframe</link> systems, the boot process is known as <b>IPL (Initial Program Load)</b>. The term was coined by IBM for the design of the <link xlink:type="simple" xlink:href="../294/29294.xml">
System/360</link> and continues to be used in those environments today<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref>.  In systems that share the System/360 heritage&mdash;and in some that have been inspired by it, including smaller systems such as the <link xlink:type="simple" xlink:href="../965/565965.xml">
IBM 1130</link>&mdash;IPL is a hardware function, not a program run on the system itself. In its basic form, an IPL is initiated by the computer operator by selecting the (three digit) device address using rotary switches on the computer console, followed by pressing the 'IPL' button. This starts a tiny (typically 24 byte) program entirely implemented in hardware, consisting merely of a few <link>
channel command word</link>s initiating a read operation from the designated device. Usually this is a disk drive, but exactly the same procedure is also used to boot from other devices, such as <link xlink:type="simple" xlink:href="../109/31109.xml">
tape drive</link>s, or even <link xlink:type="simple" xlink:href="../518/4397518.xml">
card reader</link>s, in a device-independent manner, allowing e.g. the installation of an operating system on a pristine computer from a magnetic distribution tape. Of course, the disk, tape or card deck must contain a special program to load the actual operating system into memory, a multi-stage procedure similar to most booting procedures (see elsewhere in this article). </p>
<p>

The System/360 IPL function reads 24 bytes from an operator-specified or pre-configured device into memory starting at location zero.  The second and third groups of eight bytes are treated as Channel Command Words (CCWs) to continue loading the startup program.  When the I/O channel commands are complete, the first group of eight bytes is then loaded into the Program Status Word (PSW) register and the startup program begins execution at the designated location.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>
<p>

A noteworthy variation of this is found on the <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../524/4524.xml">
Burroughs</link></institution>
</company>
 <link xlink:type="simple" xlink:href="../356/1416356.xml">
B1700</link> where there is neither a bootstrap ROM nor a hardwired IPL operation. Instead, after the system is reset it reads and executes opcodes sequentially from a tape drive mounted on the front panel, this sets up a boot loader in RAM which is then executed. However, since this makes few assumptions about the system it can equally well be used to load diagnostic (Maintenance Test Routine) tapes which display an intelligible code on the <link xlink:type="simple" xlink:href="../390/4793390.xml">
front panel</link> even in cases of gross CPU failure.</p>

</ss1>
</sec>
<sec>
<st>
 Rebooting </st>

<ss1>
<st>
 Hard reboot </st>
<p>

A <it>hard reboot</it> (also known as a <it>cold reboot</it>, <it>cold boot</it> or <it>cold start</it>) is when power to a computer is <link xlink:type="simple" xlink:href="../445/7242445.xml">
cycled</link> (turned off and then on) or a special reset signal to the <link xlink:type="simple" xlink:href="../218/5218.xml">
processor</link> is triggered (from a front panel switch of some sort).  This restarts the computer without first performing any shut-down procedure.  (With many <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s, especially those using <link xlink:type="simple" xlink:href="../829/6829.xml">
disk cache</link>s, after a hard reboot the filesystem may be in an "unclean" state, and an automatic scan of on-disk filesystem structures will be done before normal operation can begin.)  It may be caused by power failure, be done by accident, or be done deliberately as a last resort to forcibly retrieve the system from instances such as a <link xlink:type="simple" xlink:href="../324/2638324.xml">
critical error</link> or <link xlink:type="simple" xlink:href="../196/18994196.xml">
virus</link>-inflicted <link xlink:type="simple" xlink:href="../776/39776.xml">
DoS attack</link>.</p>

</ss1>
<ss1>
<st>
 Soft reboot </st>
<p>

A <it>soft reboot</it> (also known as a <it>warm reboot</it>) is restarting a computer under software control, without removing <link xlink:type="simple" xlink:href="../043/3270043.xml">
power</link> or (directly) triggering a reset line.  It usually, though not always, refers to an orderly <link xlink:type="simple" xlink:href="../830/17699830.xml">
shutdown</link> and restarting of the machine.</p>
<p>

The <link xlink:type="simple" xlink:href="../728/305728.xml">
Control-Alt-Delete</link> key combination on the original <link xlink:type="simple" xlink:href="../032/15032.xml">
IBM PC</link> was designed to allow a soft reboot for a quicker and more convenient (and, some argue, less stressful on system components) restart than powering the computer completely down then back up.</p>
<p>

The Linux kernel has optional support for the <link xlink:type="simple" xlink:href="../360/18345360.xml">
kexec</link> <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link>, which shuts down the currently running kernel and executes another one. The entire process is done independent of the system firmware. Note that the kernel being executed does not have to be a Linux kernel.</p>
<p>

Most <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<furnishing wordnetid="103405265" confidence="0.8">
<table wordnetid="104379243" confidence="0.8">
<furniture wordnetid="103405725" confidence="0.8">
<console_table wordnetid="103092883" confidence="0.8">
<link xlink:type="simple" xlink:href="../979/11979.xml">
Nintendo Game Boy</link></console_table>
</furniture>
</table>
</furnishing>
</instrumentality>
</artifact>
 games feature a soft reset feature when the A, B, Start, and Select buttons are pressed together. This was carried over to the <system wordnetid="104377057" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../022/438022.xml">
Nintendo DS</link></system>
, with the sequence L, R, Start, and Select. Many <system wordnetid="104377057" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../525/53525.xml">
Nintendo GameCube</link></system>
 games have a similar feature, with the sequence Start, B, A, and X.</p>

</ss1>
<ss1>
<st>
 Random reboot </st>
<p>

<it>Random reboot</it> is a non-technical term referring to an unintended (and often undesired) <link>
reboot</link> for which the cause is not immediately evident to the user. Such reboots may occur due to a multitude of software and hardware problems, such as <link xlink:type="simple" xlink:href="../321/387321.xml">
triple fault</link>s.</p>
<p>

As Windows XP/Vista has an option to skip its <screen wordnetid="104152829" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/18909256.xml">
Blue Screen of Death</link></surface>
</artifact>
</screen>
 (Blue Screens of Death in Windows XP/Vista offer no option of pressing any key and seeing if the computer continues functioning) and immediately restarts the computer in the event of a fatal error, users can be mistaken in thinking a Windows XP/Vista computer suffers from random rebooting.</p>

</ss1>
<ss1>
<st>
 Errors </st>
<p>

In Windows, when an error occurs in the boot process, a <screen wordnetid="104152829" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/18909256.xml">
Blue Screen of Death</link></surface>
</artifact>
</screen>
 or a <screen wordnetid="104152829" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<link xlink:type="simple" xlink:href="../114/1371114.xml">
Black Screen of Death</link></surface>
</artifact>
</screen>
 may occur. On Unix and Unix-like operating systems, like Linux, a fatal error in the boot process may cause a <link xlink:type="simple" xlink:href="../277/221277.xml">
kernel panic</link>.</p>

</ss1>
</sec>
<sec>
<st>
Quick boot</st>
<p>

Number of devices is abailable that enable user to "quick-boot" to a usually <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
-powered OS for various simple tasks like Internet access (<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../776/13621776.xml">
Splashtop</link></O>
 etc.).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref></p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../361/304361.xml">
Boot disk</link>, <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../137/331137.xml">
Live CD</link></distribution>
</arrangement>
</structure>
, <structure wordnetid="105726345" confidence="0.8">
<arrangement wordnetid="105726596" confidence="0.8">
<distribution wordnetid="105729036" confidence="0.8">
<link xlink:type="simple" xlink:href="../416/5321416.xml">
Live USB</link></distribution>
</arrangement>
</structure>
</entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../381/216381.xml">
Boot sector</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../148/10077148.xml">
Comparison of boot loaders</link></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../065/866065.xml">
Extensible Firmware Interface</link> (EFI)</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../244/10439244.xml">
Linux startup process</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../479/1169479.xml">
Microreboot</link></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../258/8002258.xml">
Network booting</link></entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<laborer wordnetid="110241300" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<workman wordnetid="110791221" confidence="0.8">
<stevedore wordnetid="110655169" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../624/2676624.xml">
RedBoot</link></employee>
</stevedore>
</workman>
</causal_agent>
</laborer>
</worker>
</person>
</physical_entity>
 open source boot loader for embedded systems</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../076/3733076.xml">
Windows NT Startup Process</link></entry>
<entry level="1" type="bullet">

<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../986/5881986.xml">
Windows Vista startup process</link></part>
</component>
</concept>
</idea>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://dictionary.reference.com/search?r=2&amp;q=bootstrap">
bootstrap</weblink>, Dictionary.com</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.thefreedictionary.com/bootstrap">
bootstrap</weblink>, The free dictionary.com</entry>
<entry id="3">
 <cite style="font-style:normal" class="book"> Oxford English Dictionary.&#32;<link xlink:type="simple" xlink:href="../797/31797.xml">
Oxford University</link>.</cite>&nbsp;</entry>
<entry id="4">
Van Vleck, Tom.&#32;"<weblink xlink:type="simple" xlink:href="http://www.landley.net/history/mirror/unix/multics/mgb.html">
Glossary of Multics acronyms and terms</weblink>".&#32;Retrieved on <link>
2008-01-07</link>.</entry>
<entry id="5">
 <cite style="font-style:normal" class="book">Bensoussan, A.&#32;(<link>
1967-06-30</link>).&#32;"BC.4.01 System Initialization and Bootload", <weblink xlink:type="simple" xlink:href="http://www.multicians.org/mspmtoc.html">
Multics System Programmer's Manual</weblink>.</cite>&nbsp;</entry>
<entry id="6">
 <cite style="font-style:normal" class="book">Dunten, S. D.;&#32;T. H. Van Vleck&#32;(<link>
1968-05-03</link>).&#32;"BV.1.01 BOS Bootload: boot", <weblink xlink:type="simple" xlink:href="http://www.multicians.org/mspmtoc.html">
Multics System Programmer's Manual</weblink>.</cite>&nbsp;</entry>
<entry id="7">
 <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../747/10817747.xml">
Thompson, Ken</link></scientist>
</person>
;&#32;<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../218/8218.xml">
Dennis Ritchie</link></scientist>
</person>
&#32;(<link>
1971-11-03</link>). <weblink xlink:type="simple" xlink:href="http://www.cs.bell-labs.com/who/dmr/1stEdman.html">
The Unix Programmer's Manual</weblink>, 1st edition. Retrieved on <link>
2008-01-07</link>.</cite>&nbsp;</entry>
<entry id="8">
<it>From Gutenberg to the Internet</it>, Jeremy M. Norman, 2005, page 436, ISBN 0-930405-87-0</entry>
<entry id="9">
Note that the active partition <b>is not required to be primary</b>. However, the boot sector code may require it to be such to work properly.</entry>
<entry id="10">
"<weblink xlink:type="simple" xlink:href="http://www.intel.com/technology/framework/">
Intel Platform Innovation Framework for EFI</weblink>".&#32;  <link xlink:type="simple" xlink:href="../617/14617.xml">
Intel</link>.&#32;Retrieved on <link>
2008-01-07</link>.</entry>
<entry id="11">
 <cite style="font-style:normal" class="book">&#32;(September 2005) <weblink xlink:type="simple" xlink:href="http://publibz.boulder.ibm.com/epubs/pdf/a2278324.pdf">
z/Architecture Principles of Operation</weblink>&#32;(PDF),&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
,&#32;Chapter 17. Retrieved on <link>
2007-04-14</link>.</cite>&nbsp;</entry>
<entry id="12">
http://www.linuxdevices.com/news/NS2560585344.html</entry>
<entry id="13">
http://www.phoronix.com/scan.php?page=article&amp;item=splashtop_voodoo&amp;num=1</entry>
<entry id="14">
http://www.youtube.com/watch?v=InUpF5Uetfc</entry>
<entry id="15">
http://www.gadgets-reviews.com/voodoo-envy-133.html</entry>
<entry id="17">
http://www.linuxdevices.com/news/NS7654890804.html</entry>
<entry id="16">
http://www.voodoopc.com/</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading </st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://duartes.org/gustavo/blog/post/how-computers-boot-up">
How Computers Boot Up</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.societyofrobots.com/bootloader_50_robot.shtml">
Pratical bootloader tutorial for ATmega microcontrollers</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.pixelbeat.org/docs/disk/">
How GRUB fits into the hardisk layout on a PC</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.osdcom.info/content/view/33/39/">
Booting with Grub</weblink> at OSDEV Community</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.viralpatel.net/taj/tutorial/hello_world_bootloader.php">
A tutorial on writing hello world bootloader</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.vsubhash.com/writeups/multiboot_os.asp">
A tutorial on dualbooting/multibooting with Windows NTLDR and Linux LILO/GRUB</weblink></entry>
<entry level="1" type="bullet">

Booting From Scratch</entry>
<entry level="2" type="bullet">

Matthew Vea.&#32;"<weblink xlink:type="simple" xlink:href="http://www.vnutz.com/content/program_a_bootstrap_loader">
x86 BootStrap Programming Tutorial</weblink>".</entry>
<entry level="1" type="bullet">

FreeBSD</entry>
<entry level="2" type="bullet">

Nathan Boeger and Mana Tominaga.&#32;"<weblink xlink:type="simple" xlink:href="http://www.khmere.com/freebsd_book/html/ch02.html">
Bootstrapping FreeBSD</weblink>".</entry>
<entry level="1" type="bullet">

Linux</entry>
<entry level="2" type="bullet">

Roberto Alsina.&#32;"<weblink xlink:type="simple" xlink:href="http://lateral.netmanagers.com.ar/stories/23.html">
The Linux boot process unveiled</weblink>".</entry>
<entry level="2" type="bullet">

Greg O'Keefe.&#32;"<weblink xlink:type="simple" xlink:href="http://www.tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html">
From power up to Linux bash prompt HOWTO</weblink>".</entry>
<entry level="2" type="bullet">

Chao-Kuei Hung 洪朝貴.&#32;"<weblink xlink:type="simple" xlink:href="http://people.ofset.org/~ckhung/p/mk-boot-usb/">
Mk-boot-usb: a Script to Create Multiple-Bootable USB Keys</weblink>".</entry>
<entry level="1" type="bullet">

Mac OS X</entry>
<entry level="2" type="bullet">

Amit Singh.&#32;"<weblink xlink:type="simple" xlink:href="http://www.kernelthread.com/mac/osx/arch_boot.html">
Mac OS X Boot Process</weblink>".</entry>
<entry level="1" type="bullet">

Windows</entry>
<entry level="2" type="bullet">

Jonathan de Boyne Pollard&#32;(1996).&#32;"<weblink xlink:type="simple" xlink:href="http://homepages.tesco.net./~J.deBoynePollard/FGA/dos-windows-boot-process.html">
The DOS and DOS/Windows boot processes</weblink>".</entry>
<entry level="2" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.pcnineoneone.com/howto/multiboot1.html">
Multi-booting, running different versions of Windows on your PC</weblink>".</entry>
<entry level="2" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.pocketpcfaq.com/faqs/5.0/reset.htm">
Windows Mobile 5.0 Soft Reset</weblink>".</entry>
<entry level="2" type="bullet">

"<weblink xlink:type="simple" xlink:href="http://www.hardreset.eu/index_en.html">
Pocket PC devices hard reset and soft reset</weblink>".</entry>
</list>
</p>


</sec>
</bdy>
</article>
