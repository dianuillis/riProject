<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 20:58:30[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Local search (constraint satisfaction)</title>
<id>4149194</id>
<revision>
<id>139398764</id>
<timestamp>2007-06-20T10:00:39Z</timestamp>
<contributor>
<username>Alexmf</username>
<id>4666094</id>
</contributor>
</revision>
<categories>
<category>Constraint satisfaction</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../966/949966.xml">
constraint satisfaction</link>, <b>local search</b> is an incomplete method for finding a solution to a <link xlink:type="simple" xlink:href="../652/211652.xml">
problem</link>. It is based on iteratively improving an assignment of the variables until all constraints are satisfied. In particular, local search algorithms typically modify the value of a variable in an assignment at each step. The new assignment is close to the previous one in the space of assignment, hence the name <it>local search</it>.<p>

All local search algorithms use a function that evaluates the quality of assignment, for example the number of constraints violated by the assignment. This amount is called the <it>cost</it> of the assignment. The aim of local search is that of finding an assignment of minimal cost, which is a solution if any exists. </p>
<p>

<image width="150px" src="Local-search-plateau.svg" type="thumb">
<caption>

Point A is not a solution, but no local move from there decreases cost. However, a solution exists at point B.
</caption>
</image>

Two classes of local search algorithms exist. The first one is that of greedy or non-randomized algorithms. These algorithms proceed by changing the current assignment by always trying to decrease (or at least, non-increase) its cost.  The main problem of these algorithms is the possible presence of <it>plateau</it>s, which are regions of the space of assignments where no local move decreases cost. The second class of local search algorithm have been invented to solve this problem. They escape these plateaus by doing random moves, and are called randomized local search algorithms.</p>

<sec>
<st>
Greedy algorithms</st>

<ss1>
<st>
Hill climbing</st>

<p>

<indent level="1">

<it>Main article: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it>
</indent>

The most basic form of local search is based on choosing the change that maximally decreases the cost of the solution. This method, called <it>hill climbing</it>, proceed as follows: first, a random assignment is chosen; then, a value is changed in such as to maximally improve the quality of the resulting assignment. If no solution has been found after a given number of changes, a new random assignment is selected. Hill climbing algorithms can only escape a plateau by doing changes that do not change the quality of the assignment. As a result, they can be stuck in a plateau where the quality of assignment has a local maxima.</p>
<p>

<link xlink:type="simple" xlink:href="../275/2445275.xml">
GSAT</link> (greedy sat) was the first local search algorithm for satisfiability, and is a form of hill climbing.</p>

</ss1>
<ss1>
<st>
Constraint weighting or breakout method</st>

<p>

A method for escaping from a local minimum is that of using a weighted sum of violated constraints as a measure of cost, and changing some weights when no improving move is available. More precisely, if no change reduces the cost of the assignment, the algorithm increases the weight of constraints violated by the current assignment. </p>
<p>

This way, every move that would not otherwise change the cost of the solution decreases it. Moreover, the weight of constraints that remain violated for a large number of moves keeps increasing. Therefore, during a number of moves not satisfying a constraint, the cost of moves to assignments satisfying that constraint keeps increasing.</p>

</ss1>
<ss1>
<st>
Tabu search</st>

<p>

<indent level="1">

<it>Main article: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../937/381937.xml">
Tabu search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it>
</indent>

A drawback of hill climbing with moves that do not decrease cost, is that it may cycle over assignments of the same cost. <it>Tabu search</it> overcomes this problem by maintaining a list of "forbidden" assignments, called the <it>tabu list</it>. In particular, the tabu list typically contains the list of the last changes. More precisely, it contains the last variable/value such that the variable has been recently assigned to the value.</p>
<p>

This list is updated every time the assignment is changed. If a variable is assigned to a value, the pair variable/value is added to the list, and the oldest pair is removed from it. This way, the list only contains the most recent assignments to a variable. If a variable/value pair is in the tabu list, changing the current assignment by setting the variable to the value is forbidden. The algorithm can only choose the best move among the ones that are not forbidden. This way, it cannot cycle over the same solution unless the number of moves in this cycle is larger than the length of the tabu list.</p>

</ss1>
</sec>
<sec>
<st>
Random walk</st>

<p>

A random walk algorithm sometimes moves like greedy algorithms but sometimes move randomly. They depend on a parameter <math>p</math>, which is a real number between 0 and 1. At every move, with probability <math>p</math> the algorithm proceed like a greedy algorithm, trying to maximally decrease the cost of the assignment. With probability <math>1-p</math>, however, the solution is changed in some other way, which involves some degree of randomness.</p>

<ss1>
<st>
WalkSAT</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../246/2853246.xml">
WalkSAT</link></it>
</indent>

The random move of WalkSAT is changing the value of a random variable of a random violated constraint. For <link xlink:type="simple" xlink:href="../715/4715.xml">
propositional satisfiability</link> of <link xlink:type="simple" xlink:href="../342/73342.xml">
conjunctive normal form</link> formulae, which is the original settings of this algorithm, every such a move changes the value of the variable from true to false or vice versa, and produce the satisfiability of the violated constraint. As for all random walk strategies, a random move is only done with a given probability, and a move maximally decreasing the cost is done otherwise.</p>

</ss1>
<ss1>
<st>
Simulated annealing</st>

<p>

<indent level="1">

<it>Main article: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/172244.xml">
Simulated annealing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it>
</indent>

The technique of simulated annealing is based on changing the probability of doing a random move over one that maximally decreasing the cost. In particular, the name originates from the strategy of decreasing the probability of doing random moves during the execution of the algorithm, thus virtually "freezing" the space of search.</p>
<p>

In particular, if the improvement of cost <math>d</math> of a move is negative (the move increases cost), this move is done with probability <math>e^{-d \cdot T}</math>, where <math>T</math> is real number. Since the probability of doing this move increases with <math>T</math>, this parameter is called the <it>temperature</it>. Simulated annealing decreases this temperature over time, thus allowing more random moves at the beginning and less after time.</p>

</ss1>
</sec>
<sec>
<st>
Local search on a cycle cutset</st>

<p>

Local search usually works on all variables, improving a complete assignment to them. However, local search can also be run on a subset of variables, using some other mechanism for the other variables. A proposed algorithm works on a <it>cycle cutset</it>, which is a set of variables that, if removed from the problem, makes it acyclic.</p>
<p>

For any assignment of the variables of the cutset, the remaining problem has a <link xlink:type="simple" xlink:href="../560/48560.xml">
forest</link> as primal graph. As a result, it can be solved efficiently. In order to guide local search, an algorithm detecting the minimal number of constraints that can be violated is used in place of a satisfiability algorithm on the for forest part of the problem.</p>
<p>

This minimal number is found by determining the cost of each variable assignment. This cost is the minimal number of constraints violated by an assignment of the variables in the subtree rooted at the variable, when the variable takes the given value. This cost can be calculated as follows. If <math>Cost(x=a)</math> denotes the cost of the assignment <math>x=a</math> and <math>y_1,\ldots,y_n</math> are the children of <math>x</math>, the following formula holds. In this formula, <math>Violates(x=a, y_i=b)</math> is the 0 or 1 depending on whether the assignment <math>x=a, y_i=b</math> violates the constraint between <math>x</math> and <math>y</math>.</p>
<p>

<indent level="1">

<math>Cost(x=a) = \sum_{i=1,\ldots,n} \min_{y_i=b} ( Cost(y_i=b) + Violates(x=a, y_i=b) ) </math>
</indent>

The cost for variables in the cutset is zero, and these variables are assumed to be allowed to take only their given value. With these assumptions, the above formula allows computing the cost of all variable evaluations by iteratively proceeding bottom-up from the leaves to the root(s) of the forest.</p>
<p>

The cost of variable evaluations can be used by local search for computing the cost of a solution. The cost of values of the roots of the forest is indeed the minimal number of violated constraints in the forest for these given values. These costs can therefore used to evaluate the cost of the assignment to the cutset variables and to estimate the cost of similar assignments on the cutset variables. </p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nlsde.buaa.edu.cn/~kexu/benchmarks/benchmarks.htm">
Forced Satisfiable CSP and SAT Benchmarks of Model RB</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Dechter-2003" style="font-style:normal" class="book">Dechter, Rina&#32;(2003). <weblink xlink:type="simple" xlink:href="http://www.ics.uci.edu/~dechter/books/index.html">
Constraint Processing</weblink>.&#32;Morgan Kaufmann. ISBN 978-1-55860-890-0.</cite>&nbsp;</entry>
</list>
</p>

</sec>
</bdy>
</article>
