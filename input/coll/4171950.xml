<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:04:35[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Constraint optimization</title>
<id>4171950</id>
<revision>
<id>233371366</id>
<timestamp>2008-08-21T18:07:10Z</timestamp>
<contributor>
<username>Mike Peel</username>
<id>214232</id>
</contributor>
</revision>
<categories>
<category>Constraint satisfaction</category>
<category>Mathematical optimization</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../966/949966.xml">
constraint satisfaction</link>, <b>constraint optimization</b> (also called <it>constrained optimization</it>) seeks for a solution maximizing or minimizing a <link xlink:type="simple" xlink:href="../033/52033.xml">
cost function</link>.
<sec>
<st>
Definition</st>

<p>

A constraint optimization problem can be defined as a regular <link xlink:type="simple" xlink:href="../652/211652.xml">
constraint satisfaction problem</link> in which constraints are weighted and the goal is to find a solution maximizing the weight of satisfied constraints.</p>
<p>

Alternatively, a constraint optimization problem can be defined as a regular constraint satisfaction problem augumented with a number of "local" cost functions. The aim of constraint optimization is to find a solution to the problem whose cost, evaluated as the sum of the cost functions, is maximized or minimized. The regular constraints are called <it>hard constraints</it>, while the cost functions are called <it>soft constraints</it>. These names illustrate that hard constraints are to be necessarily satisfied, while soft constraints only express a preference of some solutions (those having a high or low cost) over other ones (those having lower/higher cost).</p>

</sec>
<sec>
<st>
Branch and bound</st>

<p>

Constraint optimization can be solved by <link xlink:type="simple" xlink:href="../580/456580.xml">
branch and bound</link> algorithms. These are backtracking algorithms storing the cost of the best solution found during execution and use it for avoiding part of the search. More precisely, whenever the algorithm encounters a partial solution that cannot be extended to form a solution of better cost than the stored best cost, the algorithm backtracks, instead of trying to extend this solution.</p>
<p>

Assuming that cost is to be maximized, the efficiency of these algorithms depends on how the cost that can be obtained from extending a partial solution is evaluated. Indeed, if the algorithm can backtrack from a partial solution, part of the search is skipped. The lower the estimated cost, the better the algorithm, as a lower estimated cost is more likely to be lower than the best cost of solution found so far.</p>
<p>

On the other hand, this estimated cost cannot be lower than the effective cost that can be obtained by extending the solution, as otherwise the algorithm could backtrack while a solution better than the best found so far exists. As a result, the algorithm requires an upper bound on the cost that can be obtained from extending a partial solution, and this upper bound should be as small as possible.</p>

<ss1>
<st>
First-choice bounding functions</st>

<p>

One way for evaluating this upper bound for a partial solution is to consider each soft constraint separately. For each soft constraint, the maximal possible value for any assignment to the unassigned variables is assumed. The sum of these values is an upper bound because the soft constraints cannot assume a higher value. It is exact because the maximal values of soft constraints may derive from different evaluations: a soft constraint may be maximal for <math>x=a</math> while another constraint is maximal for <math>x=b</math>.</p>

</ss1>
<ss1>
<st>
Russian doll search</st>

<p>

This method runs a branch-and-bound algorithm on <math>n</math> problems, where <math>n</math> is the number of variables. Each such problem is the subproblem obtained by dropping a sequence of variables <math>x_1,\ldots,x_i</math> from the original problem, along with the constraints containing them. After the problem on variables <math>x_{i+1},\ldots,x_n</math> is solved, its optimal cost can be used as an upper bound while solving the other problems,</p>
<p>

In particular, the cost estimate of a solution having <math>x_{i+1},\ldots,x_n</math> as unassigned variables is added to the cost that derives from the evaluated variables. Virtually, this corresponds on ignoring the evaluated variables and solving the problem on the unassigned ones, except that the latter problem has already been solved. More precisely, the cost of soft constraints containing both assigned and unassigned variables is estimated as above (or using an arbitrary other method); the cost of soft constraints containing only unassigned variables is instead estimated using the optimal solution of the corresponding problem, which is already known at this point.</p>

</ss1>
</sec>
<sec>
<st>
Bucket elimination</st>

<p>

The <link xlink:type="simple" xlink:href="../747/3923747.xml">
bucket elimination</link> algorithm can be adapted for constraint optimization. A given variable can be indeed removed from the problem by replacing all soft constraints containing it with a new soft constraint. The cost of this new constraint is computed assuming a maximal value for every value of the removed variable. Formally, if <math>x</math> is the variable to be removed, <math>C_1,\ldots,C_n</math> are the soft constraints containing it, and <math>y_1,\ldots,y_m</math> are their variables except <math>x</math>, the new soft constraint is defined by:</p>

<p>

<indent level="1">

<math>C(y_1=a_1,\ldots,y_n=a_n) = \max_{a} \sum_i C_i(x=a,y_1=a_1,\ldots,y_n=a_n)</math>
</indent>

Bucket elimination works with an (arbitrary) ordering of the variables. Every variable is associated a bucket of constraints; the bucket of a variable contains all constraints having the variable has the highest in the order. Bucket elimination proceed from the last variable to the first. For each variable, all constraints of the bucket are replaced as above to remove the variable. The resulting constraint is then placed in the appropriate bucket.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../513/4255513.xml">
Distributed constraint optimization</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Dechter-2003" style="font-style:normal" class="book">Dechter, Rina&#32;(2003). <weblink xlink:type="simple" xlink:href="http://www.ics.uci.edu/~dechter/books/index.html">
Constraint Processing</weblink>.&#32;Morgan Kaufmann. ISBN 1-55860-890-7.</cite>&nbsp;</entry>
</list>
</p>

</sec>
</bdy>
</article>
