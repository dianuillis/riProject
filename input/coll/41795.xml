<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:40:59[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<condition  confidence="0.8" wordnetid="113920835">
<state  confidence="0.8" wordnetid="100024720">
<problem  confidence="0.8" wordnetid="114410605">
<difficulty  confidence="0.8" wordnetid="114408086">
<header>
<title>Minimum spanning tree</title>
<id>41795</id>
<revision>
<id>243407720</id>
<timestamp>2008-10-06T11:45:14Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Spanning tree</category>
<category>Polynomial-time problems</category>
</categories>
</header>
<bdy>

<image location="right" width="300px" src="Minimum_spanning_tree.svg" type="thumb">
<caption>

The minimum spanning tree of a <link xlink:type="simple" xlink:href="../314/24314.xml">
planar graph</link>. Each edge is labeled with its weight, which here is roughly proportional to its length.
</caption>
</image>

Given a <link xlink:type="simple" xlink:href="../492/1614492.xml">
connected</link>, <link xlink:type="simple" xlink:href="../806/325806.xml">
undirected graph</link>, a <link xlink:type="simple" xlink:href="../770/455770.xml">
spanning tree</link> of that graph is a <link>
subgraph</link> which is a <link>
tree</link> and connects all the <link xlink:type="simple" xlink:href="../899/638899.xml">
vertices</link> together. A single graph can have many different spanning trees. We can also assign a <it>weight</it> to each edge, which is a number representing how unfavorable it is, and use this to assign a weight to a spanning tree by computing the sum of the weights of the edges in that spanning tree. A <b>minimum spanning tree</b> or <b>minimum weight spanning tree</b> is then a spanning tree with weight less than or equal to the weight of every other spanning tree. More generally, any undirected graph (not necessarily connected) has a <b>minimum spanning forest</b>, which is a union of minimum spanning trees for its <link xlink:type="simple" xlink:href="../223/246223.xml">
connected components</link>.<p>

One example would be a cable TV company laying cable to a new neighborhood.  If it is constrained to bury the cable only along certain paths, then there would be a graph representing which points are connected by those paths.  Some of those paths might be more expensive, because they are longer, or require the cable to be buried deeper; these paths would be represented by edges with larger weights.  A <it>spanning tree</it> for that graph would be a subset of those paths that has no cycles but still connects to every house. There might be several spanning trees possible.  A <it>minimum spanning tree</it> would be one with the lowest total cost.</p>

<sec>
<st>
Properties</st>

<ss1>
<st>
Possible multiplicity</st>
<p>

<it>There may be several minimum spanning trees of the same weight</it>; in particular, if all weights are the same, every spanning tree is minimum. </p>

</ss1>
<ss1>
<st>
Uniqueness</st>
<p>

<it>If each edge has a distinct weight then there will only be one, unique minimum spanning tree</it>. The proof to this fact can be done by <link xlink:type="simple" xlink:href="../736/393736.xml">
induction</link>. This is true in many realistic situations, such as the cable TV company example above, where it's unlikely any two paths have <it>exactly</it> the same cost. This generalizes to spanning forests as well.</p>

</ss1>
<ss1>
<st>
Minimum-cost subgraph</st>
<p>

<it>If the weights are non-negative, then a minimum spanning tree is in fact the minimum-cost subgraph connecting all vertices</it>, since subgraphs containing cycles necessarily have more total weight.</p>

</ss1>
<ss1>
<st>
Cycle property</st>
<p>

<it>For any cycle </it>C<it> in the graph, if the weight of an edge </it>e<it> of </it>C<it> is larger than the weights of other edges of </it>C<it>, then this edge cannot belong to an MST.</it> Indeed, <link xlink:type="simple" xlink:href="../418/25418.xml">
assume the contrary</link>, i.e., <it>e</it> belongs to an MST T1. If we delete it, T1 will be broken into two subtrees with the two ends of <it>e</it> in different subtrees. The remainder of <it>C</it> reconnects the subtrees, hence there is an edge <it>f</it> of <it>C</it> with ends in different subtrees, i.e., it reconnects the subtrees into a tree T2 with weight less than that of T1, because the weight of <it>f</it> is less than the weight of <it>e</it>.</p>

</ss1>
<ss1>
<st>
Cut property</st>

<p>

<it>For any <link xlink:type="simple" xlink:href="../494/2180494.xml">
cut</link> </it>C<it> in the graph,  if the weight of an edge </it>e<it> of </it>C<it> is smaller than the weights of other edges of </it>C<it>, then this edge belong to all MSTs of the graph.</it> Indeed, <link xlink:type="simple" xlink:href="../418/25418.xml">
assume the contrary</link>, i.e., <it>e</it> does not belong to an MST T1. then adding <it>e</it> to T1 will produce a cycle, which must have another edge <it>e2</it> from T1 in the cut <it>C</it>. Replacing <it>e2</it> with <it>e</it> would produce a tree T1 of smaller weight.</p>

</ss1>
</sec>
<sec>
<st>
 Pseudo Code </st>

<p>

For the most general case,
<b>function</b> MST(<it>G</it>,<it>W</it>):
<it>T</it> = {}
<b>while</b> <it>T</it> does not form a spanning tree:
find an edge in <it>E</it> that is safe for <it>T</it>
<it>T</it> = <it>T</it> union {(<it>u</it>,<it>v</it>)}
<b>return</b> <it>T</it></p>
<p>

where "safe" means that it forms an MST.</p>

</sec>
<sec>
<st>
 Algorithms </st>
<p>

The first algorithm for finding a minimum spanning tree was developed by Czech scientist <link>
Otakar Borůvka</link> in 1926 (see <link>
Borůvka's algorithm</link>). Its purpose was an efficient electrical coverage of <region wordnetid="108630985" confidence="0.8">
<region wordnetid="108630039" confidence="0.8">
<administrative_district wordnetid="108491826" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<district wordnetid="108552138" confidence="0.8">
<country wordnetid="108544813" confidence="0.8">
<link xlink:type="simple" xlink:href="../216/20216.xml">
Moravia</link></country>
</district>
</location>
</administrative_district>
</region>
</region>
.  There are now two algorithms commonly used, <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. All three are <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link>s that run in polynomial time, so the problem of finding such trees is in <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/663347.xml">
FP</link></group>
</collection>
</class>
</b>, and related <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>s such as determining whether a particular edge is in the MST or determining if the minimum total weight exceeds a certain value are in <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
</b>.  Another greedy algorithm not as commonly used is the <link xlink:type="simple" xlink:href="../059/9516059.xml">
reverse-delete algorithm</link>, which is the reverse of Kruskal's algorithm.</p>
<p>

The fastest minimum spanning tree algorithm to date was developed by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../825/1051825.xml">
Bernard Chazelle</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, which is based on the Soft Heap,
an approximate priority queue.
<weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/355541.355562">
http://doi.acm.org/10.1145/355541.355562</weblink>
<weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/355541.355554">
http://doi.acm.org/10.1145/355541.355554</weblink>
Its running time is <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link></it>(<it>e</it>&nbsp;α(<it>e</it>,<it>v</it>)), where <it>e</it> is the number of edges, <it>v</it> is the number of vertices and α is the classical functional inverse of the <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
. The function α grows extremely slowly, so that for all practical purposes it may be considered a constant no greater than 4; thus Chazelle's algorithm takes very close to linear time.  </p>
<p>

What is the fastest possible algorithm for this problem? That is one of the oldest open questions in computer science. There is clearly a linear lower bound, since we must at least examine all the weights. If the edge weights are integers with a bounded bit length, then deterministic algorithms are known with linear running time.
<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016/S0022-0000(05)80064-9">
http://dx.doi.org/10.1016/S0022-0000(05)80064-9</weblink>
For general weights, there are <link xlink:type="simple" xlink:href="../383/495383.xml">
randomized algorithms</link> whose <it><link xlink:type="simple" xlink:href="../653/9653.xml">
expected</link></it> running time is linear.
<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=201019.201022&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=60207697&amp;CFTOKEN=18906052">
http://portal.acm.org/citation.cfm?id=201019.201022&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=60207697&amp;CFTOKEN=18906052</weblink>
<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=545381.545477&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=60207697&amp;CFTOKEN=18906052">
http://portal.acm.org/citation.cfm?id=545381.545477&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=60207697&amp;CFTOKEN=18906052</weblink></p>
<p>

Whether there exists a deterministic algorithm with linear running time for general weights is still an open question. However, Seth Pettie and Vijaya Ramachandran have found a provably optimal deterministic minimum spanning tree algorithm, the computational complexity of which is unknown. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=505241.505243">
http://portal.acm.org/citation.cfm?doid=505241.505243</weblink></p>
<p>

More recently, research has focused on solving the minimum spanning tree problem in a highly parallelized manner.
With a linear number of processors it is possible to solve the problem in <math>O(\log n)</math> time.
<weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/375827.375847">
http://doi.acm.org/10.1145/375827.375847</weblink>
<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137/S0097539700371065">
http://dx.doi.org/10.1137/S0097539700371065</weblink>.
A 2003 paper "Fast Shared-Memory Algorithms for Computing the Minimum Spanning Forest of Sparse Graphs" by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../647/1759647.xml">
David A. Bader</link></scientist>
</person>
 and <link>
Guojing Cong</link> demonstrates a pragmatic algorithm that can compute MSTs 5 times faster on 8 processors than an optimized sequential algorithm.<weblink xlink:type="simple" xlink:href="http://www.cs.unm.edu/~treport/tr/03-12/MST-bader.pdf">
http://www.cs.unm.edu/~treport/tr/03-12/MST-bader.pdf</weblink> Typically, parallel algorithms are based on Boruvka's algorithm &mdash; Prim's and especially Kruskal's algorithm do not scale as well to additional processors.</p>
<p>

Other specialized algorithms have been designed for computing minimum spanning trees of a graph so large that most of it must be stored on disk at all times. These <it>external storage</it> algorithms, for example as described in "Engineering an External Memory Minimum Spanning Tree Algorithm" by Roman Dementiev et al.,<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/dementiev04engineering.html">
http://citeseer.ist.psu.edu/dementiev04engineering.html</weblink> can operate as little as 2 to 5 times slower than a traditional in-memory algorithm; they claim that "massive minimum spanning tree problems filling several hard disks can be solved overnight on a PC." They rely on efficient external storage <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>s and on graph contraction techniques for reducing the graph's size efficiently.</p>

</sec>
<sec>
<st>
MST on complete graphs</st>
<p>

It has been shown by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../544/9324544.xml">
J. Michael Steele</link></associate>
</mathematician>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 based on work by <link xlink:type="simple" xlink:href="../451/19252451.xml">
Alan M. Frieze</link> that given a <link xlink:type="simple" xlink:href="../816/85816.xml">
complete graph</link> on <it>n</it> vertices, with edge weights chosen from a continuous random distribution <math>f</math> such that <math>f'(0) &amp;gt; 0</math>, as <it>n</it> approaches <link xlink:type="simple" xlink:href="../455/15455.xml">
infinity</link> the size of the MST approaches <math>\zeta(3)/f'(0)</math>, where <math>\zeta</math> is the <link xlink:type="simple" xlink:href="../809/25809.xml">
Riemann zeta function</link>.</p>
<p>

For uniform random weights in <math>[0,1]</math>, the exact expected size of the minimum spanning tree has been computed for small complete graphs.</p>
<p>

<table class="wikitable">
<header>
Vertices</header>
<header>
Expected size</header>
<row>
<col>
2</col>
<col>
1 / 2</col>
</row>
<row>
<col>
3</col>
<col>
3 / 4</col>
</row>
<row>
<col>
4</col>
<col>
31 / 35</col>
</row>
<row>
<col>
5</col>
<col>
893 / 924</col>
</row>
<row>
<col>
6</col>
<col>
278 / 273</col>
</row>
<row>
<col>
7</col>
<col>
30739 / 29172</col>
</row>
<row>
<col>
8</col>
<col>
199462271 / 184848378</col>
</row>
<row>
<col>
9</col>
<col>
126510063932 / 115228853025</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Related problems </st>
<p>

A related graph is the <link xlink:type="simple" xlink:href="../079/1152079.xml">
<it>k</it>-minimum spanning tree</link> (<it>k</it>-MST) which is the tree that spans some subset of <it>k</it> vertices in the graph with minimum weight.</p>
<p>

A set of <it>k-smallest spanning trees</it> is a subset of k spanning trees (out of all possible spanning trees) such that no spanning tree outside the subset has smaller weight. <weblink xlink:type="simple" xlink:href="http://p.oisono.us/misc/gabow77.pdf">
http://p.oisono.us/misc/gabow77.pdf</weblink>  (Note that this problem is unrelated to the k-minimum spanning tree.)</p>
<p>

The <link xlink:type="simple" xlink:href="../597/1040597.xml">
Euclidean minimum spanning tree</link> is a spanning tree of a graph with edge weights corresponding to the Euclidean distance between vertices.</p>
<p>

In the distributed model, where each node is considered a computer and no node knows anything except its own connected links, one can consider <link xlink:type="simple" xlink:href="../392/6183392.xml">
Distributed minimum spanning tree</link>. Mathematical definition of the problem is the same but has different approaches for solution.</p>
<p>

For <link xlink:type="simple" xlink:href="../986/19721986.xml">
directed graph</link>s, the minimum spanning tree problem can be solved in quadratic time using the <link>
Chu–Liu/Edmonds algorithm</link>.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../059/9516059.xml">
Reverse-Delete algorithm</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../761/98761.xml">
Spanning tree protocol</link></rule>
</direction>
</protocol>
</message>
, used in switched networks</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../650/11510650.xml">
Edmonds's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/nesetril00otakar.html">
Otakar Boruvka on Minimum Spanning Tree Problem (translation of the both 1926 papers, comments, history) (2000) Jaroslav Nesetril, Eva Milková, Helena Nesetrilová</weblink> (section 7 gives his algorithm, which looks like a cross between Prim's and Kruskal's)</entry>
<entry level="1" type="bullet">

 Bernard Chazelle. <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/355541.355562">
A Minimum Spanning Tree Algorithm with Inverse-Ackermann Type Complexity</weblink>. <it>JACM</it> 47(6):1028--1047, 2000.</entry>
<entry level="1" type="bullet">

 Bernard Chazelle. <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/355541.355554">
The Soft Heap: An Approximate Priority Queue with Optimal Error Rate</weblink>. <it>JACM</it>  47(6):1012--1027, 2000.</entry>
<entry level="1" type="bullet">

 David Karger, Philip Klein, and Robert Tarjan. <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/201019.201022">
A Randomized Linear Time Algorithm to Find Minimum Spanning Trees</weblink>. <it>JACM</it> 42(2):321--328, 1995.</entry>
<entry level="1" type="bullet">

 Seth Pettie and Vijaya Ramachandran. <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/505241.505243">
An Optimal Minimum Spanning Tree Algorithm</weblink>. <it>JACM</it> 49(1):16--34, 2002.</entry>
<entry level="1" type="bullet">

 K. W. Chong, Y. Han, and T. W. Lam <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/375827.375847">
Concurrent Threads and Optimal Minimum Spanning Trees Algorithm</weblink>. <it>JACM</it> 48(1)297--323, 2001.</entry>
<entry level="1" type="bullet">

 Seth Pettie and Vijaya Ramachandran. <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137/S0097539700371065">
A Randomized Time-Work Optimal Algorithm to Find a Minimum Spanning Forest</weblink>. <it>SIAM J. Comput.</it> 31(6):1879--1895, 2002.</entry>
<entry level="1" type="bullet">

 Michael Fredman and Dan Willard. <weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016/S0022-0000(05)80064-9">
Trans-dichotomous Algorithms for Minimum Spanning Trees and Shortest Paths</weblink>. <it>J. Comput. Syst. Sci.</it> 48(3):533--551, 1994.</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 23: Minimum Spanning Trees, pp.561&ndash;579.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://p.oisono.us/misc/gabow77.pdf">
Two Algorithms for Generating Weighted Spanning Trees in Order</weblink>, Harold Gabow, 1977</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.jhu.edu/~jason/papers/index.html#ms97">
State-of-the-Art Algorithms for Minimum Spanning Trees: A Tutorial Discussion</weblink>, Jason Eisner, 1997</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.boost.org/libs/graph/doc/table_of_contents.html">
Implemented in BGL, the Boost Graph Library</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.sunysb.edu/~algorith/files/minimum-spanning-tree.shtml">
The Stony Brook Algorithm Repository - Minimum Spanning Tree codes</weblink></entry>
</list>
</p>


</sec>
</bdy>
</difficulty>
</problem>
</state>
</condition>
</article>
