<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:40:59[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<condition  confidence="0.8" wordnetid="113920835">
<state  confidence="0.8" wordnetid="100024720">
<problem  confidence="0.8" wordnetid="114410605">
<difficulty  confidence="0.8" wordnetid="114408086">
<header>
<title>Shortest path problem</title>
<id>41985</id>
<revision>
<id>243470031</id>
<timestamp>2008-10-06T17:25:01Z</timestamp>
<contributor>
<username>Giftlite</username>
<id>37986</id>
</contributor>
</revision>
<categories>
<category>Graph theory</category>
<category>Polynomial-time problems</category>
<category>Network theory</category>
</categories>
</header>
<bdy>

<image width="150px" src="6n-graf.svg" type="thumb">
<caption>

A graph with 6 vertices and 7 edges
</caption>
</image>

In <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link>, the <b>shortest path problem</b> is the problem of finding a <link xlink:type="simple" xlink:href="../889/638889.xml">
path</link> between two <link xlink:type="simple" xlink:href="../899/638899.xml">
vertices</link> (or nodes) such that the sum of the <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<glossary wordnetid="106420781" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<wordbook wordnetid="106418693" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../802/325802.xml#xpointer(//*[./st=%22Weighted+graphs+and+networks%22])">
weights</link></publication>
</reference_book>
</book>
</wordbook>
</artifact>
</glossary>
</creation>
</product>
</work>
 of its constituent edges is minimized. An example is finding the quickest way to get from one location to another on a road map; in this case, the vertices represent locations and the edges represent segments of road and are weighted by the time needed to travel that segment.<p>

Formally, given a weighted graph (that is, a set <it>V</it> of vertices, a set <it>E</it> of edges, and a <link xlink:type="simple" xlink:href="../491/19725491.xml">
real</link>-valued weight function <it>f</it>&nbsp;: <it>E</it>&nbsp;&amp;rarr;&nbsp;<b>R</b>), and one element <it>v</it> of <it>V</it>, find a path <it>P</it> from <it>v</it> to each <it>v' </it> of <it>V</it> so that</p>
<p>

<indent level="1">

<math>\sum_{p\in P} f(p)</math>
</indent>

is minimal among all paths connecting <it>v</it> to <it>v' </it>.</p>
<p>

The problem is also sometimes called the <b>single-pair shortest path problem</b>, to distinguish it from the following generalizations:
<list>
<entry level="1" type="bullet">

 The <b>single-source shortest path problem</b>, in which we have to find shortest paths from a source vertex <it>v</it> to all other vertices in the graph.</entry>
<entry level="1" type="bullet">

 The <b>single-destination shortest path problem</b>, in which we have to find shortest paths from all vertices in the graph to a single destination vertex <it>v</it>. This can be reduced to the single-source shortest path problem by reversing the edges in the graph.</entry>
<entry level="1" type="bullet">

 The <b>all-pairs shortest path problem</b>, in which we have to find shortest paths between every pair of vertices <it>v</it>, <it>v' </it> in the graph.</entry>
</list>
</p>
<p>

These generalizations have significantly more efficient algorithms than the simplistic approach of running a single-pair shortest path algorithm on all relevant pairs of vertices.</p>

<sec>
<st>
Algorithms</st>
<p>

The most important algorithms for solving this problem are:
<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 solves the single-pair, single-source, and single-destination shortest path problems.</entry>
<entry level="1" type="bullet">

 <condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
 solves single source problem if edge weights may be negative.</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A* search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 solves for single pair shortest path using heuristics to try to speed up the search.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link> solves all pairs shortest paths.</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 solves all pairs shortest paths, and may be faster than Floyd-Warshall on <link xlink:type="simple" xlink:href="../546/963546.xml">
sparse graph</link>s.</entry>
<entry level="1" type="bullet">

 <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../140/102140.xml">
Perturbation theory</link></mathematical_statement>
</equation>
</concept>
</idea>
</message>
</statement>
 finds (at worst) the locally shortest path.</entry>
</list>
</p>

</sec>
<sec>
<st>
Applications</st>
<p>

Shortest path algorithms are applied in an obvious way to automatically find directions between physical locations, such as driving directions on <link xlink:type="simple" xlink:href="../200/8561200.xml">
web mapping</link> websites like <link xlink:type="simple" xlink:href="../505/311505.xml">
Mapquest</link>.</p>
<p>

If one represents a nondeterministic <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link> as a graph where vertices describe states and edges describe possible transitions, shortest path algorithms can be used to find an optimal sequence of choices to reach a certain goal state, or to establish lower bounds on the time needed to reach a given state. For example, if vertices represents the states of a puzzle like a <vogue wordnetid="105750163" confidence="0.8">
<puzzle wordnetid="106784639" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<fashion wordnetid="105750657" confidence="0.8">
<discrimination wordnetid="105748054" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<fad wordnetid="105751173" confidence="0.8">
<basic_cognitive_process wordnetid="105701944" confidence="0.8">
<problem wordnetid="106784003" confidence="0.8">
<question wordnetid="106783768" confidence="0.8">
<taste wordnetid="105749619" confidence="0.8">
<link xlink:type="simple" xlink:href="../971/25971.xml">
Rubik's Cube</link></taste>
</question>
</problem>
</basic_cognitive_process>
</fad>
</subject>
</discrimination>
</fashion>
</message>
</process>
</puzzle>
</vogue>
 and each directed edge corresponds to a single move or turn, shortest path algorithms can be used to find a solution that uses the minimum possible number of moves.</p>
<p>

In a networking or telecommunications mindset, this shortest path problem is sometimes called the min-delay path problem and usually tied with a widest path problem.  e.g.: Shortest (min-delay) widest path or Widest shortest (min-delay) path.</p>
<p>

A more lighthearted application is the games of "<link xlink:type="simple" xlink:href="../629/73629.xml">
six degrees of separation</link>" that try to find the shortest path in graphs like movie stars appearing in the same film. </p>
<p>

Other applications cited by Danny Z. Chen include "<link xlink:type="simple" xlink:href="../476/43476.xml">
operations research</link>, plant and facility layout, <link xlink:type="simple" xlink:href="../673/46673.xml">
robotics</link>, <link xlink:type="simple" xlink:href="../879/18580879.xml">
transportation</link>, and <link xlink:type="simple" xlink:href="../823/32823.xml">
VLSI</link> design".<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
Related problems</st>

<p>

For shortest path problems in <link xlink:type="simple" xlink:href="../927/176927.xml">
computational geometry</link>, see <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../022/10976022.xml">
Euclidean shortest path</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>
<p>

The <link xlink:type="simple" xlink:href="../248/31248.xml">
traveling salesman problem</link> is the problem of finding the shortest path that goes through every vertex exactly once, and returns to the start.  Unlike the shortest path problem, this problem is <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 and, as such, is believed not to be efficiently solvable (see <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../115/6115.xml">
P = NP problem</link></group>
</collection>
</difficulty>
</problem>
</class>
</state>
</condition>
) .  The problem of <link xlink:type="simple" xlink:href="../567/18757567.xml">
finding the longest path</link> in a graph is also NP-complete.</p>
<p>

The <link xlink:type="simple" xlink:href="../373/18210373.xml">
Canadian traveller problem</link> and the stochastic shortest path problem are generalizations where either the graph isn't completely known to the mover, changes over time, or where actions (traversals) are probabilistic.</p>

</sec>
<sec>
<st>
 Notes </st>
<p>

<reflist>
<entry id="1">
Danny Z. Chen. Developing Algorithms and Software for Geometric Path Planning Problems. <it>ACM Computing Surveys</it> 28A(4), December 1996.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapters 24: Single-Source Shortest Paths, and 25: All-Pairs Shortest Paths, pp.580&ndash;642.</entry>
</list>
</p>


</sec>
</bdy>
</difficulty>
</problem>
</state>
</condition>
</article>
