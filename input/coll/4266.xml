<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:22:10[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9508927676800064" wordnetid="105847438">
<header>
<title>Binary search algorithm</title>
<id>4266</id>
<revision>
<id>244318297</id>
<timestamp>2008-10-10T06:33:10Z</timestamp>
<contributor>
<username>CiaPan</username>
<id>258338</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Self-contradictory articles</category>
</categories>
</header>
<bdy>
<template>
<name>Infobox Algorithm</name>
<parameters>

<image width="150px" src="">

</image>
<time>
<it>О(</it>log<it> n)''</it></time>
<data>
<link xlink:type="simple" xlink:href="../052/2052.xml">
Array</link></data>
<class>
<link xlink:type="simple" xlink:href="../249/28249.xml">
Search algorithm</link></class>
<optimal>
Yes</optimal>
<space>
<it>O(1)''</it></space>
</parameters>
</template>


A <b>binary search algorithm</b> (or <b>binary chop</b>) is a technique for locating a particular value in a <link xlink:type="simple" xlink:href="../489/7489.xml">
sorted list</link> of values. To cast this in the frame of the guessing game (see Example below), realize that we seek to guess the <it>index</it>, or numbered place, of the value in the list. The method makes progressively better guesses, and closes in on the location of the sought value by selecting the middle element in the span (which, because the list is in sorted order, is the <link xlink:type="simple" xlink:href="../837/18837.xml">
median</link> value), comparing its value to the target value, and determining if the selected value is greater than, less than, or equal to the target value. A guessed index whose value turns out to be too high becomes the new upper bound of the span, and if its value is too low that index becomes the new lower bound. Only the sign of the difference is inspected: there is no attempt at an <link xlink:type="simple" xlink:href="../895/69895.xml">
interpolation search</link> based on the size of the difference. Pursuing this strategy iteratively, the method reduces the search span by a factor of two each time, and soon finds the target value or else determines that it is not in the list at all. A binary search is an example of a  <link xlink:type="simple" xlink:href="../223/3021223.xml">
dichotomic</link> <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer</link> <link xlink:type="simple" xlink:href="../249/28249.xml">
search algorithm</link>.<p>

Finding the index of a specific value in a <link xlink:type="simple" xlink:href="../442/28442.xml">
sorted list</link> is useful because, given the index, other data structures will contain associated information. Suppose a data structure containing the classic collection of name, address, telephone number and so forth has been accumulated, and an array is prepared containing the names, numbered from one to <it>N</it>. A query might be: what is the telephone number for a given name <it>X</it>. To answer this the array would be searched and the index (if any) corresponding to that name determined, whereupon the associated telephone number array would have <it>X</it>'s telephone number at that index, and likewise the address array and so forth. Appropriate provision must be made for the name not being in the list (typically by returning an <it>index</it> value of zero), indeed the question of interest might be only whether <it>X</it> is in the list or not.</p>
<p>

If the list of names is in sorted order, a binary search will find a given name with far fewer probes than the simple procedure of probing each name in the list, one after the other in a <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link>, and the procedure is much simpler than organizing a <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link>. However, once created, searching with a hash table may well be faster, typically averaging just over one probe per lookup. With a non-uniform distribution of values, if it is known that some few items are <it>much</it> more likely to be sought for than the majority, then a linear search with the list ordered so that the most popular items are first may do better than binary search. The choice of the best method may not be immediately obvious. If, between searches, items in the list are modified or items are added or removed, maintaining the required organisation may consume more time than the searches.</p>

<sec>
<st>
 Examples </st>

<ss1>
<st>
Number guessing game</st>
<p>

This rather simple game begins something like "I'm thinking of an integer between forty and sixty inclusive, and to your guesses I'll respond 'High', 'Low', or 'Yes!' as might be the case." 
Supposing that <it>N</it> is the number of possible values (here, twenty-one as "inclusive" was stated), then at most <math>\lceil\log_2 N\rceil</math> questions are required to determine the number, since each question halves the search space. Note that one less question (iteration) is required than for the general algorithm, since the number is already constrained to be within a particular range.</p>
<p>

Even if the number we're guessing can be arbitrarily large, in which case there is no upper bound <it>N</it>, we can still find the number in at most <math>2\lceil \log_2 k \rceil</math> steps (where k is the (unknown) selected number) by first finding an upper bound by repeated doubling. For example, if the number were 11, we could use the following sequence of guesses to find it: 1, 2, 4, 8, 16, 12, 10, 11</p>
<p>

One could also extend the technique to include negative numbers; for example the following guesses could be used to find −13: 0, −1, −2, −4, −8, −16, −12, −14, −13</p>

</ss1>
<ss1>
<st>
Word lists</st>
<p>

People typically use a mixture of the binary search and interpolative search algorithms when searching a <link xlink:type="simple" xlink:href="../263/162263.xml">
telephone book</link>, after the initial guess we exploit the fact that the entries are sorted and can rapidly find the required entry. For example when searching for Smith, if Rogers and Thomas have been found, one can flip to a page about halfway between the previous guesses. If this shows Samson, we know that Smith is somewhere between the Samson and Thomas pages so we can bisect these.</p>

</ss1>
<ss1>
<st>
Applications to <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity theory</link></st>
<p>

Even if we do not know a fixed range the number <it>k</it> falls in, we can still determine its value by asking <math>2\lceil\log_2k\rceil</math> simple yes/no questions of the form "Is <it>k</it> greater than <it>x</it>?" for some number <it>x</it>. As a simple consequence of this, if you can answer the question "Is this integer property <it>k</it> greater than a given value?" in some amount of time then you can find the value of that property in the same amount of time with an added factor of log2 <it>k</it>. This is called a <it><link xlink:type="simple" xlink:href="../067/848067.xml">
reduction</link></it>, and it is because of this kind of reduction that most complexity theorists concentrate on <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>s, algorithms that produce a simple yes/no answer.</p>
<p>

For example, suppose we could answer "Does this <it>n</it> x <it>n</it> matrix have <link xlink:type="simple" xlink:href="../468/8468.xml">
determinant</link> larger than <it>k</it>?" in O(<it>n</it>2) time. Then, by using binary search, we could find the (ceiling of the) determinant itself in O(<it>n</it>2log <it>d</it>) time, where <it>d</it> is the determinant; notice that <it>d</it> is not the size of the input, but the size of the output.</p>

</ss1>
</sec>
<sec>
<st>
The method</st>
<p>

<image location="right" width="150px" src="BinarySearch.Flowchart.png">
</image>

In order to discuss the method in detail, a more formal description is necessary. The basic idea is that there is a data structure represented by array <it>A</it> in which individual elements are identified as <it>A(1), A(2),…,A(N)</it> and may be accessed in any order. The data structure contains a sub-element or data field called here <it>Key</it>, and the array is ordered so that the successive values <it>A(1).Key ≤ A(2).Key</it> and so on. The requirement is that given some value <it>x</it>, find an index <it>p</it> (not necessarily the one and only) such that <it>A(p).Key = x</it>.</p>
<p>

To begin with, the span to be searched is the full supplied list of elements, as marked by variables <it>L</it> and <it>R</it>, and their values are changed with each iteration of the search process, as depicted by the <link xlink:type="simple" xlink:href="../453/527453.xml">
flowchart</link>. Note that the division by two is integer division, with any remainder lost, so that 3/2 comes out as 1, not 1½. The search finishes either because the value has been found, or else, the specified value is not in the list.</p>

<ss1>
<st>
That it works</st>
<p>

The method relies on and upholds the notion <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../643/1126643.xml">
If x is to be found, it will be amongst elements <it>(L + 1)</it> to <it>(R − 1)''</it></link></method>
</know-how>
 of the array. </p>
<p>

The initialisation of <it>L</it> and <it>R</it> to 0 and <it>N + 1</it> make this merely a restatement of the supplied problem, that elements 1 to <it>N</it> are to be searched, so the notion is established to begin with. The first step of each iteration is to check that there is something to search, which is to say whether there are any elements in the search span <it>(L + 1)</it> to <it>(R − 1)</it>. The number of such elements is <it>(R − L − 1)</it> so computing <it>(R − L)</it> gives (number of elements + 1); halving that number (with integer division) means that if there was one element (or more) then <it>p = 1</it> (or more), but if none <it>p = 0</it>, and in that case the method terminates with the report "Not found". Otherwise, for <it>p &amp;gt; 0</it>, the search continues with <it>p:=L + p</it>, which by construction is within the bounds <it>(L + 1)</it> to <it>(R − 1)</it>. That this position is at or adjacent to the middle of the span is not important here, merely that it is a valid choice.</p>
<p>

Now compare <it>x</it> to <it>A(p).Key</it>. If <it>x = A(p).Key</it> then the method terminates in success. Otherwise, suppose <it>x  A(p).Key</it>. If so, then <it>because the array is in sorted order</it>, <it>x</it> will also be less than all later elements of the array, all the way to element <it>(R − 1)</it> as well. Accordingly, the value of the right-hand bound index R can be changed to be the value <it>p</it>, since, by the test just made, <it>x  A(p).Key</it> and so, if x is to be found, it will be amongst elements earlier than <it>p</it>, that is <it>(p − 1)</it> and earlier. And contrariwise, for the case <it>x &amp;gt; A(p).Key</it>, the value of <it>L</it> would be changed. Thus, whichever bound is changed the ruling notion is upheld, and further, the span remaining to be searched is reduced. If <it>L</it> is changed, it is changed to a higher number (at least <it>L + 1</it>), whereas if <it>R</it> is changed, it is to a lower number (at most <it>R − 1</it>) because those are the limits for <it>p</it>.</p>
<p>

Should there have been just one value remaining in the search span (so that <it>L + 1 = p = R − 1</it>), and <it>x</it> did not match, then depending on the sign of the comparison either <it>L</it> or <it>R</it> will receive the value of <it>p</it> and at the start of the next iteration the span will be found to be empty.</p>
<p>

Accordingly, with each iteration, if the search span is empty the result is "Not found", otherwise either <it>x</it> is found at the probe point <it>p</it> or the search span is reduced for the next iteration. Thus the method works, and so can be called an <link xlink:type="simple" xlink:href="../775/775.xml">
Algorithm</link>.</p>

</ss1>
<ss1>
<st>
That it is fast</st>
<p>

The interval being searched is successively halved (actually slightly better than halved) in width with each iteration, so the number of iterations required is at most the base two logarithm of <it>N</it>. – Zero for empty lists. More precisely, each probe both removes one element from further consideration and selects one or the other half of the interval for further searching.</p>
<p>

Suppose that the number of items in the list is odd. Then there is a definite middle element at <it>p = (N + 1)/2</it> – this is proper division without discarding remainders. If that element's key does not match <it>x</it>, then the search proceeds either with the first half, elements 1 to <it>p − 1</it> or the second, elements <it>p + 1</it> to <it>N</it>. These two spans are equal in extent, having <it>(N − 1)/2</it> elements. Conversely, suppose that the number of elements is even. Then the probe element will be <it>p = N/2</it> and again, if there is no match one or the other of the subintervals will be chosen. They are not equal in size; the first has <it>N/2 − 1</it> elements and the second (elements <it>p + 1</it> to <it>N</it> as before) has <it>N/2</it> elements.</p>
<p>

Now supposing that it is just as likely that <it>N</it> will be even as odd in general, on average an interval with <it>N</it> elements in it will become an interval with <it>(N − 1)/2</it> elements.</p>
<p>

Working in the other direction, what might be the maximum number of elements that could be searched in <it>p</it> probes? Clearly, one probe can check a list with one element only (to report a match, or, "not found") and two probes can check a list of three elements. This is not very impressive because a linear search would only require three probes at most for that. But now the difference increases exponentially. Seven elements can be checked with three probes, fifteen with four, and so forth. In short, to search <it>N</it> elements requires at most <it>p</it> probes where <it>p</it> is the smallest integer such that <math>2^p &amp;gt; N</math> Taking the binary logarithm of both sides, <math>p &amp;gt; lb(N)</math></p>
<p>

Or, <math>lb(N)</math> (with any fractional part rounded up to the next integer), is the maximum number of probes required to search <it>N</it> elements.
</p>
<ss2>
<st>
Average performance</st>
<p>

There are two cases: for searches that will fail because the value is not in the list, the search interval must be successively halved until no more elements remain and this process will require at most the <it>p</it> probes just defined, or one less. This latter occurs because the search interval is not in fact exactly halved, and depending on the value of <it>N</it> and which elements of the list the absent value <it>x</it> is between, the interval may be closed early.</p>
<p>

For searches that will succeed because the value is in the list, the search may finish early because a probed value happens to match. Loosely speaking, half the time the search will finish one iteration short of the maximum and a quarter of the time, two early. Consider then a test in which a list of <it>N</it> elements is searched once for each of the <it>N</it> values in the list, and determine the number of probes <it>n</it> for all <it>N</it> searches.</p>
<p>

N =  1   2    3    4     5     6     7     8     9    10     11     12     13
n/N =  1  3/2  5/3  8/4  11/5  14/6  17/7  21/8  25/9  29/10  33/11  37/12  41/13
1  1.5  1.66  2    2.2  2.33  2.43  2.63  2.78   2.9    3     3.08   3.15</p>
<p>

In short <math>lb(N) - 1</math> is about the expected number of probes in an average successful search, and the worst case is <math>lb(N)</math>, just one more probe. If the list is empty, no probes at all are made.</p>
<p>

Suppose the list to be searched contains N even numbers (say, 2,4,6,8 for <it>N</it> = 4) and a search is done for values 1, 2, 3, 4, 5, 6, 7, 8, and 9. The even numbers will be found, and the average number of iterations can be calculated as described. In the case of the odd numbers, they will not be found, and the collection of test values probes every possible position (with regard to the numbers that <it>are</it> in the list) that they might be not found in, and an average is calculated. The maximum value is for each N the greatest number of iterations that were required amongst the various trail searches of those N elements. The first plot shows the iteration counts for <it>N</it> = 1 to 63 (with <it>N</it> = 1, all results are 1), and the second plot is for <it>N</it> = 1 to 32767.</p>
<p>

<image width="150px" src="BinarySearchStats63.png">
<caption>

BinarySearchStats63.png
</caption>
</image>
 
<image width="150px" src="BinarySearchStats32767.png">
<caption>

BinarySearchStats32767.png
</caption>
</image>
</p>
<p>

Thus binary search is a <link xlink:type="simple" xlink:href="../860/17860.xml">
logarithmic algorithm</link> and executes in <link xlink:type="simple" xlink:href="../578/44578.xml">
O(<math>\log N</math>)</link> time. In most cases it is considerably faster than a <link xlink:type="simple" xlink:href="../171/18171.xml">
linear search</link>. It can be implemented using <link xlink:type="simple" xlink:href="../833/68833.xml">
iteration</link> (as shown above), or <link xlink:type="simple" xlink:href="../407/25407.xml">
recursion</link>. In some languages it is more elegantly expressed recursively; however, in some C-based languages tail recursion is not eliminated and the recursive version requires more stack space.</p>
<p>

Binary search can interact poorly with the memory hierarchy (i.e. <link xlink:type="simple" xlink:href="../829/6829.xml">
caching</link>), because of its random-access nature.  For in-memory searching, if the interval to be searched is small, a linear search may have superior performance simply because it exhibits better locality of reference. For external searching, care must be taken or each of the first several probes will lead to a disk seek. A common technique is to abandon binary searching for linear searching as soon as the size of the remaining interval falls below a small value such as 8 or 16 or even more in recent computers. The exact value depends entirely on the machine running the algorithm.</p>
<p>

Notice that for multiple searches <it>with a fixed value for N</it>, then (with the appropriate regard for integer division), the first iteration always selects the middle element at <it>N</it>/2, and the second always selects either <it>N</it>/4 or 3<it>N</it>/4, and so on. Thus if the array's key values are in some sort of slow storage (on a disc file, in virtual memory, not in the cpu's on-chip memory), keeping those three keys in a local array for a special preliminary search will avoid accessing widely separated memory. Escalating to seven or fifteen such values will allow further levels at not much cost in storage. On the other hand, if the searches are frequent and not separated by much other activity, the computer's various storage control features will more or less automatically promote frequently-accessed elements into faster storage.</p>
<p>

When multiple binary searches are to be performed for the same key in related lists, <link xlink:type="simple" xlink:href="../270/7543270.xml">
fractional cascading</link> can be used to speed up successive searches after the first one.</p>

</ss2>
</ss1>
<ss1>
<st>
Extensions</st>
<p>

There is no particular requirement that the array being searched has the bounds 1 to <it>N</it>. It is possible to search a specified range, elements <it>first</it> to <it>last</it> instead of 1 to <it>N</it>. All that is necessary is that the intialisation be <it>L:=first − 1</it> and <it>R:=last + 1</it>, then all proceeds as before.</p>
<p>

In more complex contexts, it might be that the data structure has many sub fields, such as a telephone number along with the name. An indexing array such as <it>xref</it> could be introduced so that elements <it>A(xref(1)).Telephone ≤ A(xref(2)).Telephone … ≤ A(xref(N)).Telephone</it> so that, "viewed through" array <it>xref</it> the array can be regarded as being sorted on the telephone number, and a search would be to find a given telephone number. In this case, <it>A(i).Key</it> would be replaced by <it>A(xref(i)).Telephone</it> and all would be as before. Thus, with auxiliary <it>xref</it> arrays, an array can be treated as if it is sorted in different ways without it having to be resorted for each different usage.</p>
<p>

When a search returns the result "Not found", it may be helpful to have some indication as to where the missing value would be located so that the list can be augmented. A possible approach would be to return the value <it>−L</it> (rather than just −1 or 0, say), the negative indicating failure. This however can conflict with the array indexing protocol, if it includes zero as a valid index (since of course −0 = 0, and 0 would be a findable result) so caution is needed.</p>
<p>

The elements of the list are not necessarily all unique. If one searches for a value that occurs multiple times in the list, the index returned will be of the first-encountered equal element, and this will not necessarily be that of the first, last, or middle element of the run of equal-key elements but will depend on the positions of the values. Modifying the list even in seemingly unrelated ways such as adding elements elsewhere in the list may change the result.
To find all equal elements an upward and downward linear search can be carried out from the initial result, stopping each search when the element is no longer equal. Thus, e.g. in a table of cities sorted by country, we can find all cities in a given country.</p>
<p>

A list of pairs (p,q) can be sorted based on just p. Then the comparisons in the algorithm need only consider the values of p, not those of q. For example, in a table of cities sorted on a column "country" we can find cities in Germany by comparing country names with "Germany", instead of comparing whole rows. Such partial content is called a sort key.</p>
<p>

Several algorithms closely related to or extending binary search exist. For instance, <b>noisy binary search</b> solves the same class of projects as regular binary search, with the added complexity that any given test can return a false value at random. (Usually, the number of such erroneous results are bounded in some way, either in the form of an average error rate, or in the total number of errors allowed per element in the search space.) Optimal algorithms for several classes of noisy binary search problems have been known since the late seventies, and more recently, optimal algorithms for noisy binary search in quantum computers (where several elements can be tested at the same time) have been discovered.</p>

</ss1>
<ss1>
<st>
Variations</st>
<p>

There are many, and they are easily confused. 
</p>
<ss2>
<st>
Exclusive or inclusive bounds</st>
<p>

The most significant differences are between the "exclusive" and "inclusive" forms of the bounds. This description uses the "exclusive" bound form, that is the span to be searched is <it>(L + 1)</it> to <it>(R − 1)</it>, and this may seem clumsy when the span to be searched could be described in the "inclusive" form, as <it>L</it> to <it>R</it>. This form may be attained by replacing all appearances of "L" by "(L − 1)" and "R" by "(R + 1)" then rearranging. Thus, the initialisation of <it>L:=0</it> becomes <it>(L − 1):=0</it> or <it>L:=1</it>, and <it>R:=N + 1</it> becomes <it>(R + 1):=N + 1</it> or <it>R:=N</it>. So far so good, but note now that the changes to L and R are no longer simply transferring the value of <it>p</it> to <it>L</it> or <it>R</it> as appropriate but now must be <it>(R + 1):=p</it> or <it>R:=p − 1</it>, and <it>(L − 1):=p</it> or <it>L:=p + 1</it>.</p>
<p>

Thus, the gain of a simpler initialisation, done once, is lost by a more complex calculation, and which is done for every iteration. If that is not enough, the test for an empty span is more complex also, as compared to the simplicity of checking that the value of <it>p</it> is zero. Nevertheless, this is the form found in many publications, such as <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
. <it>The Art of Computer Programming</it>, Volume 3: <it>Sorting and Searching</it>, Third Edition.</p>

</ss2>
<ss2>
<st>
Locate the middle in one step</st>
<p>

The other main variation is to combine the two step calculation of the probe position into one step, that is, <it>p:=(R − L)/2; p:=p + L;</it> into <it>p:=(L + R)/2;</it> which is indeed less work, but, the saving is lost because rather than <it>if p = 0</it> (which tests the just-computed value of <it>p</it> directly) the test becomes <it>if p = L</it> and this second form requires the subtraction of the value of <it>L</it>. Pseudo machine code should read somewhat as follows:
Load       R
Subtract   L
IntDiv     2           Do not store this intermediate result into <it>p</it> yet.
JumpZN     NotFound    if result is Zero or Negative, Jump to NotFound.
Add        L
Store      p
That is, the (human) compiler has recognised that in the three statements <it>p:=(R − L)/2; if p = 0 return(−L); p:=p + L;</it> the value of <it>p</it> is already in the working register and need not be stored and retrieved until the end where it is stored once. The two-statement version, <it>p:=(L + R)/2; if p = L return(−L);</it> would become
Load       L
Add        R
IntDiv     2
Store      p           Thus <it>p:=(L + R)/2;</it>
Subtract   L           Compare <it>p</it> to <it>L</it> for <it>if p = L</it>
JumpZN     NotFound
This version has the slight disadvantages of an unnecessary store to <it>p</it> if NotFound and that the value of <it>p</it> is no longer in the working register ready to be used to index the array in <it>A(p).Key</it> of the next statement, but ordinarily it will involve the same number of actions, though computer compilers may not produce such code. Thus a tie: there is no advantage in locating the middle in one step. However there is a very good reason not to use the two-statement form, due to the risk of overflow described <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Numerical+difficulties%22])">
below</link>.</p>

</ss2>
<ss2>
<st>
Deferred detection of equality</st>
<p>

Because of the syntax difficulties discussed <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Syntax+difficulties%22])">
below</link>, so that distinguishing the three states , =, and &amp;gt; would have to be done with two comparisons, it is possible to use just one comparison and at the end when the span is reduced to zero, equality can be tested for. The <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Single+comparison+per+iteration%22])">
example</link> distinguishes only  from &amp;gt;=.</p>

</ss2>
<ss2>
<st>
Midpoint and width</st>
<p>

An entirely different variation involves abandoning the <it>L</it> and <it>R</it> pointers in favour of a current position <it>p</it> and a width <it>w</it> where at each iteration, <it>p</it> is adjusted by + or − <it>w</it> and <it>w</it> is halved. Professor Knuth remarks "It is possible to do this, but only if extreme care is paid to the details" – Section 6.2.1, page 414 of <it>The Art of Computer Programming</it>, Volume 3: <it>Sorting and Searching</it>, Third Edition, outlines an algorithm, with the further remark "Simpler approaches are doomed to failure!"</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
Computer usage</st>
<p>

"Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky…" — Professor <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
</p>
<p>

When <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../316/3635316.xml">
Jon Bentley</link></scientist>
</causal_agent>
</person>
</physical_entity>
 assigned it as a problem in a course for professional programmers, he found that an astounding ninety percent failed to code a binary search correctly after several hours of working on it<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, and another study shows that accurate code for it is only found in five out of twenty textbooks (Kruse, 1999). Furthermore, Bentley's own implementation of binary search, published in his 1986 book <it>Programming Pearls</it>, contains an error that remained undetected for over twenty years.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> </p>
<p>

Careful thought is required. The first issue is minor to begin with – how to signify "Not found". If the array is indexed 1 to N, then a returned index of zero is an obvious choice. However, some computer languages (notably C <it>et al</it>) insist that arrays have a lower bound of zero. In such a case, the array might be indexed 0 to <it>N − 1</it> and so a negative result would be chosen for "Not found". Except that this can interfere with the desire to use unsigned integers for indexing. If the plan is to return <it>−L</it> for "not found", then unsigned integers cannot be used at all.</p>

<ss1>
<st>
Numerical difficulties</st>
<p>

More serious are the limitations of computer arithmetic. Variables have limited size, for instance the (very common) sixteen-bit <link xlink:type="simple" xlink:href="../145/307145.xml">
two's complement</link> signed integer can only hold values of −32768 to +32767. (Exactly the same problems arise with unsigned or other size integers, except that the digit strings are longer.) If the array is to be indexed with such variables, then the values <it>first − 1</it> and <it>last + 1</it> must be representable, that is, <it>last</it> ≤ 3276<b>6</b>, <it>not</it> 3276<b>7</b>. Using the "inclusive" form of the method won't help, because although <it>R</it> might safely hold the value 32767, should the sought value <it>x</it> follow the last element in the array then eventually the search will compare <it>x</it> to <it>A(p).Key</it> (with <it>p</it> safely holding 32767), then attempt to store <it>p + 1</it> into <it>L</it> and fail. Similarly, the lower bound <it>first</it> may be zero (for arrays whose indexing starts at zero), in which case a value −1 must be representable, which precludes the use of unsigned integers. General-purpose testing is unlikely to present a test with these boundaries exercised, and so the detail can be overlooked. Formal proofs often do not attend to differences between computer arithmetic and mathematics.</p>
<p>

It is of course unlikely that if the collections being searched number around thirty thousand that sixteen bit integers will be used, but a second problem arises much sooner. A common variation computes the midpoint of the interval in one step, as <it>p:=(L + R)/2;</it> this means that the <it>sum</it> must not exceed the sixteen-bit limit for all to be well, and this  detail is easily forgotten. The problem may be concealed on some computers, which use wider registers to perform sixteen-bit arithmetic so that there will be no overflow of intermediate results. But on a different computer, perhaps not. Thus, when tested and working code was transferred from a 16-bit version (in which there were never more than about fifteen thousand elements being searched) to a 32-bit version, and then the problem sizes steadily inflated, the forgotten limit can suddenly become relevant again. This was the mistake not noticed for decades, and is found in many textbooks – they concentrate on the description of the method, in a context where integer limits are far away.</p>
<p>

To put this in simple terms, if the computer variables can hold a value of 0 to <it>max</it> then the binary search method will only work for <it>N</it> up to <it>max − 1</it>, not for all possible values of <it>N</it>. Reducing a limit from <it>max</it> to <it>max − 1</it> is not an onerous constraint, however, if the variant form <it>p:=(L + R)/2</it> is used, then should a search wander into indices beyond <it>max/2</it> it will fail. Losing half the range for N is worth avoiding.</p>

</ss1>
<ss1>
<st>
Syntax difficulties</st>
<p>

Another difficulty is presented by the absence in most computer languages of a three-way result from a comparison, which forces a comparison to be performed twice. The form is somewhat as follows:
if a  b then action1
else if a &amp;gt; b then action2
else action3;
About half the time, the first test will be true so that there will be only one comparison of <it>a</it> and <it>b</it>, but the other half of the time it will be false, and a second comparison forced. This is so grievous that some versions are recast so as <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Single+comparison+per+iteration%22])">
not to make a second test at all</link> thus not determining equality until the span has been reduced to zero, and thereby foregoing the possibility of early termination – remember that about half the time the search will happen on a matching value one iteration short of the limit. The problem is exacerbated for floating point variables that offer the special value <link xlink:type="simple" xlink:href="../244/49244.xml">
NaN</link>, which violates even the notion of equality: x = x is <it>false</it> if x has the value <link xlink:type="simple" xlink:href="../244/49244.xml">
NaN</link>!</p>
<p>

Since <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
 does offer a three-way test, here is a version for searching an array of floating-point numbers. For labels Fortran uses numbers at the start of statements, thus the 1, 2, 3, and 4. The <it>if</it> statement performs a <it>go to</it> to one of the three nominated labels according to the sign of its arithmetic expression.
Integer <b>Function</b> BinarySearch(A,X,N)
Real A(*),X             !The array is indexed 1 to ?         
Integer N               !Stated number of elements.               
Integer L,R,P
L = 0                  !<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link>
Exclusive</link></algorithm>
 bounds,
R = N + 1              !To search elements 1 to N.
1   P = (R - L)/2          !Probe; integer division. <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link>
<it>Not (L + R)/2!''</it></link></algorithm>

<b>if</b> (P = 0) <b>Return</b>(-L) !Search exhausted.
P = L + P              !Convert an offset from L to an array index.
<b>if</b> (X - A(P)) 3,4,2    !Test: negative,zero,positive.
2   L = P                  !A(P)  X. Shift the left bound up.
<b>go to</b> 1
3   R = P                  !X  A(P). Shift the right bound down.
<b>go to</b> 1
4   <b>Return</b>(P)              !X = A(P). Found at index P.
<b>End Function</b> BinarySearch
It can be seen that the flow chart of this routine corresponds to the flow chart of a <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22The+method%22])">
proven working method</link>, and so, the code should work.</p>
<p>

Well, yes and no… Leaving aside the problem of integer bounds, it remains possible that the routine might be presented with perverse parameters. For instance, <it>N</it>  0 would cause trouble, and for this reason the test is <it>if (P = 0)</it> rather than <it>if (P = 0)</it> as it can be performed with no extra effort. Similarly, the values in array <it>A</it> might not in fact be in sorted order, or the actual array size might be smaller than <it>N</it>. To check that the array is sorted requires inspecting every value, and this vitiates the whole reason for searching with a fast method. The proof of correctness relies on its presumption that the array is sorted, etc., and not meeting these requirements is not the fault of the method. Deciding how much checking and what to do is a troublesome issue.</p>

</ss1>
</sec>
<sec>
<st>
Implementations</st>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="38px" src="Ambox_contradict.svg">
<caption>

Accuracy dispute
</caption>
</image>
</p>
</col>
<col style="" class="mbox-text">
 This article or section appears to <b>contradict</b> itself. Please help <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Binary_search_algorithm&amp;action=edit">
fix&nbsp;this&nbsp;problem</weblink>.</col>
</row>
</table>


</p>
<ss1>
<st>
Recursive</st>
<p>

The most straightforward implementation is recursive, which recursively searches the subrange dictated by the comparison:
BinarySearch(A[0..N-1], value, low, high) {
if (high  low)
return -1 // not found
mid = (low + high) / 2
if (A[mid] &amp;gt; value)
return BinarySearch(A, value, low, mid-1)
else if (A[mid]  value)
return BinarySearch(A, value, mid+1, high)
else
return mid // found
}
It is invoked with initial low and high values of 0 and N-1. We can eliminate the <link xlink:type="simple" xlink:href="../742/30742.xml">
tail recursion</link> above and convert this to an iterative implementation:</p>
<p>

Java Sample:</p>
<p>

public static int BinarySearch (int a, int low, int high, int searchValue)
{
// recursive version
int mid;
if (high  low)
return -1;
mid = (low + high) / 2;</p>
<p>

if (a [mid] &amp;gt; searchValue)
{
return BinarySearch (a, low, mid, searchValue);
}
else if (a [mid]  searchValue)
{
return BinarySearch (a, mid + 1, high, searchValue);
}
else //when a[mid] is the search value..
{
return mid;
}
} //end function</p>


</ss1>
<ss1>
<st>
Iterative</st>
<p>

BinarySearch(A[0..N-1], value) {
low = 0
high = N - 1
while (low = high) {
mid = (low + high) / 2
if (A[mid] &amp;gt; value)
high = mid - 1
else if (A[mid]  value)
low = mid + 1
else
return mid // found
}
return -1 // not found
}
</p>
</ss1>
<ss1>
<st>
Single comparison per iteration</st>
<p>

Some implementations may not include the early termination branch, preferring to check at the end if the value was found, shown below. Checking to see if the value was found <it>during</it> the search (as opposed to at the <it>end</it> of the search) may seem a good idea, but there are extra computations involved in each iteration of the search.  Also, with an array of length <it>N</it> using the <it>low</it> and <it>high</it> indices, the probability of actually finding the value on the first iteration is 1 / <it>N</it>, and the probability of finding it later on (before the end) is the about 1 / (<it>high</it> − <it>low</it>). The following checks for the value at the end of the search:
low = 0
high = N
while (low  high) {
mid = (low + high)/2;
if (A[mid]  value)
low = mid + 1; 
else
//can't be high = mid-1: here A[mid] &amp;gt;= value,
//so high can't be  mid if A[mid] == value
high = mid; 
}
// high == low, using high or low depends on taste 
if ((low  N) &amp;&amp; (A[low] == value))
return low // found
else
return -1 // not found        
This algorithm has two other advantages.  At the end of the loop, <it>low</it> points to the first entry greater than or equal to <it>value</it>, so a new entry can be inserted if no match is found.  Moreover, it only requires one comparison; which could be significant for complex keys in languages which do not allow the result of a comparison to be saved.</p>
<p>

In practice, one frequently uses a <link xlink:type="simple" xlink:href="../760/11026760.xml">
three-way comparison</link> instead of two comparisons per loop. Also, real implementations using fixed-width integers with modular arithmetic need to account for the possibility of overflow. One frequently-used technique for this is to compute mid, so that two smaller numbers are ultimately added:
mid = low + ((high - low) / 2)
</p>
</ss1>
</sec>
<sec>
<st>
 Language support </st>
<p>

Many standard libraries provide a way to do binary search. <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 provides <weblink xlink:type="simple" xlink:href="http://linux.die.net/man/3/bsearch">
bsearch(3)</weblink> in its standard library. <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
's <link xlink:type="simple" xlink:href="../777/156777.xml">
STL</link> provides <link xlink:type="simple" xlink:href="../988/40988.xml">
algorithm function</link>s binary_search, lower_bound and upper_bound. <link xlink:type="simple" xlink:href="../446/4718446.xml">
Java</link> offers a set of overloaded binarySearch() static methods in the classes <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Arrays.html">
Arrays</weblink> and <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/util/Collections.html">
Collections</weblink> for performing binary searches on Java arrays and Lists, respectively. They must be arrays of primitives, or the arrays or Lists must be of a type that implements the Comparable interface, or you must specify a custom Comparator object. <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../001/19001.xml">
Microsoft</link></company>
's <link xlink:type="simple" xlink:href="../402/60402.xml">
.NET Framework</link> 2.0 offers static <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../837/105837.xml">
generic</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 versions of the Binary Search algorithm in its collection base classes. An example would be <link>
System.Array</link>'s method BinarySearch(T array, T value). <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 provides the bisect module. <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link> can perform binary search on internal tables using the SEARCH ALL statement.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../763/1603763.xml">
Index (information technology)</link> Very fast 'lookup' using an index to directly select an entry</entry>
<entry level="1" type="bullet">

 <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../800/6894800.xml">
Branch table</link></concept>
</idea>
s Alternative indexed 'lookup' technique for decision making</entry>
<entry level="1" type="bullet">

 <plant wordnetid="100017222" confidence="0.8">
<tree wordnetid="113104059" confidence="0.8">
<vascular_plant wordnetid="113083586" confidence="0.8">
<woody_plant wordnetid="113103136" confidence="0.8">
<link xlink:type="simple" xlink:href="../310/378310.xml">
Self-balancing binary search tree</link></woody_plant>
</vascular_plant>
</tree>
</plant>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../ury/23rd_century.xml">
Run-time analysis</link>, illustrating binary search technique on machines of differing speeds</entry>
</list>

</p>
</sec>
<sec>
<st>
References</st>
<p>
 
<reflist>
<entry id="1">
 <cite id="Reference-Bentley-2000" style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../316/3635316.xml">
Bentley, Jon</link></scientist>
</causal_agent>
</person>
</physical_entity>
&#32;[1986]&#32;(2000). Programming Pearls, 2nd edition,&#32;<link xlink:type="simple" xlink:href="../080/1180080.xml">
Addison-Wesley</link>,&#32;p34. ISBN 0201657880.</cite>&nbsp;</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">
Extra, Extra – Read All About It: Nearly All Binary Searches and Mergesorts are Broken</weblink>, Google Research Blog</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
. <it>The Art of Computer Programming</it>, Volume 3: <it>Sorting and Searching</it>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89685-0. Section 6.2.1: Searching an Ordered Table, pp.409&ndash;426.</entry>
<entry level="1" type="bullet">

 Kruse, Robert L.: "Data Structures and Program Design in C++", Prentice-Hall, 1999, ISBN 0-13-768995-0, page 280.</entry>
<entry level="1" type="bullet">

 Netty van Gasteren, Wim Feijen. <it><weblink xlink:type="simple" xlink:href="http://www.mathmeth.com/wf/files/wf2xx/wf214.pdf">
The Binary Search Revisited</weblink></it>, AvG127/WF214, 1995. (investigates the foundations of the Binary Search, debunking the myth that it applies only to sorted arrays)</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/binarySearch.html">
NIST Dictionary of Algorithms and Data Structures: binary search</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.sparknotes.com/cs/searching/binarysearch/">
Sparknotes: Binary search</weblink>. Simplified overview of binary search.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://blogs.netindonesia.net/adrian/articles/6288.aspx">
Binary Search Implementation in Visual Basic .NET (partially in English)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/2cy9f6wb.aspx">
msdn2.microsoft.com/en-us/library/2cy9f6wb.aspx</weblink> .NET Framework Class Library Array.BinarySearch Generic Method (T, T)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">
Google Research: Nearly All Binary Searches and Mergesorts are Broken</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://en.literateprograms.org/Category:Binary_search">
Implementations of binary search on  LiteratePrograms</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.datastructures.info/what-is-a-binary-seach-algorithm-and-how-does-it-work/">
Explained and commented Binary search algorithm in C++</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.paked.net/subject_pages/computer_science/prog1.htm">
Binary Search using C++ </weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</article>
