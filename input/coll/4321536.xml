<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:06:22[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>IBM Basic assembly language</title>
<id>4321536</id>
<revision>
<id>224423059</id>
<timestamp>2008-07-08T19:53:47Z</timestamp>
<contributor>
<username>GimmeBot</username>
<id>3188459</id>
</contributor>
</revision>
<categories>
<category>Assembly languages</category>
<category>IBM software</category>
</categories>
</header>
<bdy>
<p>

<b>BAL</b> (Basic <link xlink:type="simple" xlink:href="../368/1368.xml">
Assembly Language</link>) is a low-level language used on <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 <link xlink:type="simple" xlink:href="../266/20266.xml">
mainframes</link> from the earliest 360 series, through systems 370, 390 and z/Series. The earliest version was provided with the <link xlink:type="simple" xlink:href="../294/29294.xml">
System/360</link> in 1964; the latest version is known as the <link xlink:type="simple" xlink:href="../788/3013788.xml">
IBM High Level Assembler (HLASM)</link>.  Programmers utilizing this family of assemblers refer to them as ALC, for Assembly Language Common, or simply "assembler".</p>

<sec>
<st>
General characteristics</st>

<p>

The architecture of IBM mainframes has taken many forms over the years, including System/360, System/370 XA, ESA/390, and <link xlink:type="simple" xlink:href="../144/1856144.xml">
z/Architecture</link>. Each of these architectures has retained <link xlink:type="simple" xlink:href="../930/40930.xml">
compatibility</link> with most of the features of its predecessor. "<b>BAL</b>" uses the native <link xlink:type="simple" xlink:href="../772/47772.xml">
instruction set</link> of these machines. It is thus as close to the hardware as a typical programmer is likely to get.</p>
<p>

The instruction set consists of the low-level operations supported by the hardware, such as 
<list>
<entry level="1" type="bullet">

 "Load" (<b>L</b>) - copy a value from memory to a register, </entry>
<entry level="1" type="bullet">

 "Store" (<b>ST</b>) - copy a value from a register to memory, </entry>
<entry level="1" type="bullet">

 "Compare" (<b>C</b>) - compare a register value with a value in memory, </entry>
<entry level="1" type="bullet">

 "Shift" (<b>SLL,SRL</b>) - move the bits of a register left or right and </entry>
<entry level="1" type="bullet">

 "Execute Channel Program" (<b>EXCP</b>) - perform an I/O operation such as reading data from a disk or tape (usually by the Operating System). </entry>
</list>

The extreme simplicity of these operations means that a program written in Assembler will usually be much longer and harder to read than an equivalent program in, say, <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link> or <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
. In the past, the speed of hand-coded Assembler programs was often felt to make up for this drawback, but with the advent of optimizing compilers, "<b><link xlink:type="simple" xlink:href="../013/5200013.xml">
C</link></b>" for the mainframe, and other advances, Assembler has lost much of its appeal. IBM continues to upgrade the Assembler, however, and it is still used when the need for speed or very fine control is paramount.</p>

</sec>
<sec>
<st>
A small example</st>
<p>

The following fragment shows how the logic "If SEX = 'M', add 1 to MALES; else, add 1 to FEMALES" would be performed in Assembler.</p>
<p>


         CLI   SEX,'M'        Male?
         BNE   IS_FEM         If not, branch around
         L     7,MALES        Load current value of MALES into register 7
         LA    7,1(,7)        add 1 (pre-XA max value 24 bits)
         ST    7,MALES        and store back the result
         B     GO_ON          Finished with this portion
IS_FEM   EQU   *              A label
         L     7,FEMALES      If not male, load current value in FEMALES 
         LA    7,1(,7)        add 1 (pre-XA max value 24 bits)
         ST    7,FEMALES      and store
GO_ON    EQU   *              - rest of program -
*
MALES    DC    F'0'            defines 31 bit memory location (initially=0)
FEMALES  DC    F'0'            ""     ""
</p>
<p>

The following is the ubiquitous <link xlink:type="simple" xlink:href="../834/13834.xml">
Hello world</link> program, and would, executing under an IBM Operating systems such as <link>
OS VS/1</link> and <link xlink:type="simple" xlink:href="../649/19649.xml">
MVS</link>, display the words 'Hello World' on the operator's console:</p>
<p>


HELLO    CSECT               The name of this program is 'HELLO'
*                            Register 15 points here on entry from Op/sys or caller.
         USING *,12          Tell assembler what register we are using for pgm. base
         STM   14,12,12(13)  Save registers 14,15,and 0 thru 12 in callers Save area
         LR    12,15         Set up base register with programs entry point address       
         LA    15,SAVE       Now Point at our own save area
         ST    15,8(13)      Set forward chain
         ST    13,4(15)      Set back chain               
         LR    13,15         Now switch to new save area
*                            -end of housekeeping (similar for most programs) -
         WTO   'Hello World' Write To Operator  (Operating System macro)
*
         L     13,4(13)      point at caller's-provided save area                     
         LM    14,12,12(13)  Restore registers as on entry
         BR    14            Return to caller
*           
SAVE     DS    18A           Define 18 fullwords for calling
         END  HELLO          This is the end of the program           

Note: "WTO" is an Assembler macro that generates an Operating System call 
Because of saving registers and later restoring and returning, this  small program is usable as a batch program invoked directly by the operating system <link xlink:type="simple" xlink:href="../487/391487.xml">
Job control language</link> (JCL) like this 
// EXEC PGM=HELLO
or, alternatively, it can be CALLed as a subroutine from such a program.
CALL HELLO</p>

</sec>
<sec>
<st>
Types of instructions</st>
<p>

Three main types of instructions are found in the source code  of a program written in Assembler.</p>

<ss1>
<st>
Machine instructions (<link xlink:type="simple" xlink:href="../411/40411.xml">
Mnemonic</link>)</st>
<p>

As with any language, the heart of Assembler programming is understanding the instructions that usually have, in this case, a "one-to-one" relationship with <link xlink:type="simple" xlink:href="../683/20683.xml">
machine instruction</link>s. The full mnemonic instruction set is described in the <it>Principles of Operation</it> manual for each processor. The general syntax for the instruction operands is fairly straightforward
<list>
<entry level="1" type="bullet">

 The target for an instruction appears first, then the source on the right, (as with "a = 6" in <link xlink:type="simple" xlink:href="../013/5200013.xml">
C</link> or <natural_object wordnetid="100019128" confidence="0.8">
<celestial_body wordnetid="109239740" confidence="0.8">
<star wordnetid="109444100" confidence="0.8">
<link xlink:type="simple" xlink:href="../394/1394.xml">
Algol</link></star>
</celestial_body>
</natural_object>
 programming). After one or more blanks, any comment may follow on the same line. A line starting with an asterisk (*) is considered entirely comments.</entry>
</list>

Examples:
<list>
<entry level="1" type="bullet">

 This is a comment line</entry>
</list>

L    3,ZIGGY         load the fullword integer stored at location labeled 'ZIGGY' into general register 3
SLA  4,5             shift the value in general register 4 left by 5 bits
MVC  TARGET,SOURCE   move characters from memory location 'SOURCE' to 'TARGET'
AP   COUNT,=P'1'     add 1 to value in memory location 'COUNT' (packed decimal format)
B    NEXT            unconditional branch to label 'NEXT'
HERE  EQU   *              This is a label
CLC   TARGET,=C'ADDRESS'  Compare memory location 'TARGET' to string 'ADDRESS'
BE    THERE               branch if equal to program label 'THERE'</p>

</ss1>
<ss1>
<st>
Assembler instructions</st>
<p>

The assembler itself needs instructions from the programmer too. For instance, <b>CSECT</b> means "start a section of code here"; <b>DC</b> means define a constant to be placed in the object code.</p>

</ss1>
<ss1>
<st>
Macros and conditional assembly</st>
<p>

The programmer can group instructions together into <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../560/20560.xml">
macros</link></concept>
</idea>
 and add them to a library, which can then be invoked in other programs, usually with parameters, much like the preprocessor facilities in C and related languages. Macros can include conditional assembler instructions, such as AIF (an IF construct), used to generate different code according to the chosen parameters.</p>

<ss2>
<st>
Operating system macros</st>
<p>

Most programs will require services from the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>, and the OS provides standard macros for requesting those services. These are analogous to <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link>s. For instance, in <link xlink:type="simple" xlink:href="../649/19649.xml">
MVS</link> (later z/OS) for example, 'GETMAIN' dynamically allocates a block of memory, and 'GET' retrieves the next logical record from a file.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://publibz.boulder.ibm.com/bookmgr_OS390/libraryserver/zosv1r7/">
z/OS library&mdash;look for "High Level Assembler" and "Principles of Operation" on the left</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
