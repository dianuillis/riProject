<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:41:45[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Linear programming</title>
<id>43730</id>
<revision>
<id>244409657</id>
<timestamp>2008-10-10T17:41:13Z</timestamp>
<contributor>
<username>Peterkingiron</username>
<id>284588</id>
</contributor>
</revision>
<categories>
<category>Operations research</category>
<category>Mathematical optimization</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematics</link>, <b>linear programming</b> (LP) is a technique for <link xlink:type="simple" xlink:href="../033/52033.xml">
optimization</link> of a <link xlink:type="simple" xlink:href="../591/91591.xml">
linear</link>  <link xlink:type="simple" xlink:href="../033/52033.xml">
objective function</link>, subject to <link xlink:type="simple" xlink:href="../570/17570.xml">
linear equality</link> and <link xlink:type="simple" xlink:href="../563/19575563.xml">
linear inequality</link> <link xlink:type="simple" xlink:href="../540/7418540.xml">
constraints</link>.  Informally, linear programming determines the way to achieve the best outcome (such as maximum profit or lowest cost) in a given <link xlink:type="simple" xlink:href="../590/20590.xml">
mathematical model</link> given some list of requirements represented as linear equations.<p>

More formally, given a <link xlink:type="simple" xlink:href="../471/23471.xml">
polytope</link> (for example, a <link xlink:type="simple" xlink:href="../621/23621.xml">
polygon</link> or a <link xlink:type="simple" xlink:href="../470/23470.xml">
polyhedron</link>), and a <link xlink:type="simple" xlink:href="../491/19725491.xml">
real</link>-valued <link xlink:type="simple" xlink:href="../449/38449.xml">
affine function</link></p>
<p>

<indent level="1">

 <math>f(x_1, x_2, \dots, x_n)=c_1x_1+c_2x_2+\cdots +c_nx_n+d\,</math>
</indent>

defined on this polytope, a linear programming method will find a point in the polytope where this function has the smallest (or largest) value. Such points may not exist, but if they do, searching through the polytope vertices is guaranteed to find at least one of them. </p>
<p>

Linear programs are problems that can be expressed in <link xlink:type="simple" xlink:href="../096/515096.xml">
canonical form</link>:
<indent level="1">

  Maximize   <math>\mathbf{c}^T \mathbf{x} </math>
</indent>
:  Subject to <math>A\mathbf{x} \leq \mathbf{b}</math></p>
<p>

<math>\mathbf{x}</math> represents the vector of variables (to be determined), while <math>\mathbf{c}</math> and <math>\mathbf{b}</math> are vectors of (known) coefficients and <math>\mathbf{A}</math> is a (known) matrix of coefficients. The expression to be maximized or minimized is called the objective function (<math>\mathbf{c}^T \mathbf{x} </math> in this case). The equations <math>A\mathbf{x} \leq \mathbf{b}</math> are the constraints which specify a <link xlink:type="simple" xlink:href="../292/6292.xml">
convex polyhedron</link> over which the objective function is to be optimized. </p>
<p>

Linear programming can be applied to various fields of study. Most extensively it is used in business and economic situations, but can also be utilized for some engineering problems. Some industries that use linear programming models include transportation, energy, telecommunications, and manufacturing. It has proved useful in modeling diverse types of problems in planning, routing, scheduling, assignment, and design. </p>

<sec>
<st>
History of linear programming</st>
<p>

The problem of solving a system of linear inequalities dates back at least as far as <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../946/173946.xml">
Fourier</link></scientist>
</person>
, after whom the method of <link xlink:type="simple" xlink:href="../671/9203671.xml">
Fourier-Motzkin elimination</link> is named.  Linear programming arose as a mathematical model developed during <military_action wordnetid="100952963" confidence="0.8">
<group_action wordnetid="101080366" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<conflict wordnetid="100958896" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<war wordnetid="100973077" confidence="0.8">
<link xlink:type="simple" xlink:href="../927/32927.xml">
the second world war</link></war>
</psychological_feature>
</act>
</conflict>
</event>
</group_action>
</military_action>
 to plan expenditures and returns in order to reduce costs to the army and increase losses to the enemy. It was kept secret until 1947. Postwar, many industries found its use in their daily planning. </p>
<p>

The founders of the subject are <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<analyst wordnetid="109790482" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<statistician wordnetid="110653238" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../rry/Bill_B$erry.xml">
George B. Dantzig</link></research_worker>
</mathematician>
</scientist>
</causal_agent>
</statistician>
</person>
</analyst>
</expert>
</physical_entity>
, who published the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../458/349458.xml">
simplex method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 in 1947, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../942/15942.xml">
John von Neumann</link></scientist>
</person>
, who developed the theory of the duality in the same year, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../660/194660.xml">
Leonid Kantorovich</link></scientist>
, a Russian mathematician who used similar techniques in economics before Dantzig and won the Nobel prize in 1975 in economics.  The linear programming problem was first shown to be solvable in polynomial time by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../462/565462.xml">
Leonid Khachiyan</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 in 1979, but a larger major theoretical and practical breakthrough in the field came in 1984 when <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../259/1162259.xml">
Narendra Karmarkar</link></research_worker>
</mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 introduced a new <link xlink:type="simple" xlink:href="../862/1622862.xml">
interior point method</link> for solving linear programming problems.</p>
<p>

Dantzig's original example of finding the best assignment of 70 people to 70 jobs exemplifies the usefulness of linear programming. The computing power required to test all the permutations to select the best assignment is vast; the number of possible configurations exceeds the number of particles in the universe.  However, it takes only a moment to find the optimum solution by posing the problem as a linear program and applying the simplex algorithm.  The theory behind linear programming drastically reduces the number of possible optimal solutions that must be checked.</p>

</sec>
<sec>
<st>
Uses</st>
<p>

Linear programming is an important field of optimization for several reasons. Many practical problems in <link xlink:type="simple" xlink:href="../476/43476.xml">
operations research</link> can be expressed as linear programming problems. Certain special cases of linear programming, such as <it>network flow</it> problems and <it>multicommodity flow</it> problems are considered important enough to have generated much research on specialized algorithms for their solution. A number of algorithms for other types of optimization problems work by solving LP problems as sub-problems.  Historically, ideas from linear programming have inspired many of the central concepts of optimization theory, such as <it>duality,</it> <it>decomposition,</it> and the importance of <it>convexity</it> and its generalizations.
Likewise, linear programming is heavily used in <link xlink:type="simple" xlink:href="../819/18819.xml">
microeconomics</link> and business management, either to maximize the income or minimize the costs of a production scheme. Some examples are food blending, inventory management, portfolio and finance management, resource allocation for human and machine resources, planning advertisement campaigns, etc.</p>

</sec>
<sec>
<st>
 Standard form </st>
<p>

<it>Standard form</it> is the usual and most intuitive form of describing a linear programming problem. It consists of the following three parts:
<list>
<entry level="1" type="bullet">

 A <b>linear function to be maximized</b></entry>
<entry level="1" type="indent">

 e.g. maximize <math>c_1 x_1 + c_2 x_2\,</math></entry>
<entry level="1" type="bullet">

 <b>Problem constraints</b> of the following form</entry>
<entry level="1" type="indent">

 e.g. <math>a_{11} x_1 + a_{12} x_2 \le b_1</math></entry>
<entry level="2" type="indent">

     <math>a_{21} x_1 + a_{22} x_2  \le b_2</math></entry>
<entry level="2" type="indent">

     <math>a_{31} x_1 + a_{32} x_2  \le b_3</math></entry>
<entry level="1" type="bullet">

 <b>Non-negative variables</b></entry>
<entry level="1" type="indent">

 e.g. <math>x_1 \ge 0 </math></entry>
<entry level="2" type="indent">

     <math>x_2 \ge 0 </math></entry>
</list>
</p>
<p>

The problem is usually expressed in <it><link xlink:type="simple" xlink:href="../728/19008728.xml">
matrix</link> form</it>, and then becomes:
<indent level="1">

 maximize <math>\mathbf{c}^T \mathbf{x} </math>
</indent>
: subject to <math>\mathbf{A}\mathbf{x} \le \mathbf{b}, \, \mathbf{x} \ge 0 </math></p>
<p>

Other forms, such as minimization problems, problems with constraints on alternative forms, as well as problems involving negative <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s can always be rewritten into an equivalent problem in standard form.</p>

<ss1>
<st>
 Example </st>
<p>

Suppose that a farmer has a piece of farm land, say <it>A</it> square kilometres large, to be planted with either wheat or barley or some combination of the two. The farmer has a limited permissible amount <it>F</it> of fertilizer and <it>P</it> of insecticide which can be used, each of which is required in different amounts per unit area for wheat (<it>F</it>1, <it>P</it>1) and barley (<it>F</it>2, <it>P</it>2). Let <it>S</it>1 be the selling price of wheat, and <it>S</it>2 the price of barley. If we denote the area planted with wheat and barley by <it>x</it>1 and <it>x</it>2 respectively, then the optimal number of square kilometres to plant with wheat vs barley can be expressed as a linear programming problem:
<table>
<row>
<col colspan="2">
maximize <math> S_1 x_1 + S_2 x_2 \,</math></col>
<col>
(maximize the revenue &mdash; revenue is the "objective function")</col>
</row>
<row>
<col>
subject to</col>
<col>
<math> x_1 + x_2 \le A </math></col>
<col>
(limit on total area)</col>
</row>
<row>

<col>
<math> F_1 x_1 + F_2 x_2 \le F </math></col>
<col>
(limit on fertilizer)</col>
</row>
<row>

<col>
<math> P_1 x_1 + P_2 x_2 \le P </math></col>
<col>
(limit on insecticide)</col>
</row>
<row>

<col>
<math> x_1 \ge 0,\, x_2 \ge 0 </math></col>
<col>
(cannot plant a negative area)</col>
</row>
</table>
</p>
<p>

Which in matrix form becomes:
<indent level="1">

 maximize <math>\begin{bmatrix} S_1 &amp; S_2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} </math>
</indent>
: subject to <math>\begin{bmatrix} 1 &amp; 1 \\ F_1 &amp; F_2 \\ P_1 &amp; P_2 \end{bmatrix} \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \le \begin{bmatrix} A \\ F \\ P \end{bmatrix}, \, \begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \ge 0 </math></p>

</ss1>
</sec>
<sec>
<st>
 Augmented form (slack form) </st>
<p>

Linear programming problems must be converted into <it>augmented form</it> before being solved by the <link xlink:type="simple" xlink:href="../458/349458.xml">
simplex algorithm</link>. This form introduces non-negative <it><link xlink:type="simple" xlink:href="../878/6002878.xml">
slack variable</link>s</it> to replace inequalities with equalities in the constraints. The problem can then be written in the following form:
<indent level="1">

 Maximize <it>Z</it> in:
</indent>
: <math>
  \begin{bmatrix}
    1 &amp; -\mathbf{c}^T &amp; 0 \\
    0 &amp; \mathbf{A} &amp; \mathbf{I}
  \end{bmatrix}
  \begin{bmatrix}
    Z \\ \mathbf{x} \\ \mathbf{x}_s
  \end{bmatrix} = 
  \begin{bmatrix}
    0 \\ \mathbf{b}
  \end{bmatrix}
</math>
<indent level="1">

 <math> \mathbf{x}, \, \mathbf{x}_s \ge 0 </math>
</indent>
where <math>\mathbf{x}_s</math> are the newly introduced slack variables, and  <it>Z</it> is the variable to be maximized.</p>

<ss1>
<st>
 Example </st>
<p>

The example above becomes as follows when converted into augmented form:
<table Z="10x+8Y">
<row>
<col colspan="2">
maximize <math> S_1 x_1 + S_2 x_2\,</math></col>
<col>
(objective function)</col>
</row>
<row Z="10x">
<col>
subject to</col>
<col>
<math> x_1 + x_2 + x_3 = A\,</math></col>
<col>
(augmented constraint)</col>
</row>
<row >

<col>
<math> F_1 x_1 + F_2 x_2 + x_4 = F\,</math></col>
<col>
(augmented constraint)</col>
</row>
<row >

<col>
<math> P_1 x_1 + P_2 x_2 + x_5 = P\,</math></col>
<col>
(augmented constraint)</col>
</row>
<row >

<col>
<math> x_1,x_2,x_3,x_4,x_5 \ge 0</math></col>
</row>
</table>

where <math>x_3,x_4,x_5\,</math> are (non-negative) slack variables.</p>
<p>

Which in matrix form becomes:
<indent level="1">

 Maximize <it>Z</it> &nbsp;&nbsp;in:
</indent>
: <math>
  \begin{bmatrix}
    1 &amp; -S_1 &amp; -S_2 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp;   1    &amp;   1    &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp;  F_1  &amp;  F_2  &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp;  P_1    &amp; P_2 &amp; 0 &amp; 0 &amp; 1 \\
  \end{bmatrix}
  \begin{bmatrix}
    Z \\ x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
  \end{bmatrix} = 
  \begin{bmatrix}
    0 \\ A \\ F \\ P
  \end{bmatrix}, \,
  \begin{bmatrix}
    x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5
  \end{bmatrix} \ge 0
</math></p>

</ss1>
</sec>
<sec>
<st>
 Duality </st>
<p>

Every linear programming problem, referred to as a primal problem, can be converted into a <link xlink:type="simple" xlink:href="../717/3372717.xml">
dual problem</link>, which provides an upper bound to the optimal value of the primal problem. In matrix form, we can express the <it>primal problem</it> as:
<indent level="1">

 maximize <math>\mathbf{c}^T \mathbf{x} </math>
</indent>
: subject to <math>\mathbf{A}\mathbf{x} \le \mathbf{b}, \, \mathbf{x} \ge 0 </math>
The corresponding <it>dual problem</it> is:
<indent level="1">

 minimize   <math>\mathbf{b}^T \mathbf{y} </math>
</indent>
: subject to <math> \mathbf{A}^T \mathbf{y} \ge \mathbf{c}, \, \mathbf{y} \ge 0 </math>
where <it>y</it> is used instead of <it>x</it> as variable vector.</p>
<p>

There are two ideas fundamental to duality theory. One is the fact that the dual of a dual linear program is the original primal linear program. Additionally, every feasible solution for a linear program gives a bound on the optimal value of the objective function of its dual.  The weak duality theorem states that the objective function value of the dual at any feasible solution is always greater than or equal to the objective function value of the primal at any feasible solution. The strong duality theorem states that if the primal has an optimal solution, x*, then the dual also has an optimal solution, y*, such that cTx*=bTy*. </p>
<p>

A linear program can also be unbounded or infeasible. Duality theory tells us that if the primal is unbounded then the dual is infeasible by the weak duality theorem. Likewise, if the dual is unbounded, then the primal must be infeasible. However, it is possible for both the dual and the primal to be infeasible (See also <link xlink:type="simple" xlink:href="../226/2480226.xml">
Farkas' lemma</link>).</p>

<ss1>
<st>
 Example </st>
<p>

Revisit the above example of the farmer who may grow wheat and barley with the set provision of some <it>A</it> land, <it>F</it> fertilizer and <it>P</it> insecticide. Assume now that unit prices for each of these means of production (inputs) are set by a planning board. The planning board's job is to minimize the total cost of procuring the set amounts of inputs while providing the farmer with a floor on the unit price of each of his crops (outputs), S1 for wheat and S2 for barley. This corresponds to the following linear programming problem:</p>
<p>

<table>
<row>
<col colspan="2">
minimize <math> A y_A + F y_F + P y_P \,</math></col>
<col>
(minimize the total cost of the means of production as the "objective function")</col>
</row>
<row>
<col>
subject to</col>
<col>
<math> y_A + F_1 y_F + P_1 y_P \ge S_1 </math></col>
<col>
(the farmer must receive no less than <math> S_1 </math> for his wheat)</col>
</row>
<row>

<col>
<math> y_A + F_2 y_F + P_2 y_P \ge S_2 </math></col>
<col>
(the farmer must receive no less than <math> S_2 </math> for his barley)</col>
</row>
<row>

<col>
<math> y_A \ge 0,\, y_F \ge 0,\, y_P \ge 0 </math></col>
<col>
(prices cannot be negative)</col>
</row>
</table>
</p>
<p>

Which in matrix form becomes:
<indent level="1">

 minimize <math>\begin{bmatrix} A &amp; F &amp; P \end{bmatrix} \begin{bmatrix} y_A \\ y_F \\ y_P \end{bmatrix} </math>
</indent>
: subject to <math>\begin{bmatrix} 1 &amp; F_1 &amp; P_1 \\ 1 &amp; F_2 &amp; P_2 \end{bmatrix} \begin{bmatrix} y_A \\ y_F \\ y_P \end{bmatrix} \ge \begin{bmatrix} S_1 \\ S_2 \end{bmatrix}, \, \begin{bmatrix} y_A \\ y_F \\ y_P \end{bmatrix} \ge 0 </math></p>
<p>

The primal problem deals with physical quantities. With all inputs available in limited quantities, and assuming the unit prices of all outputs is known, what quantities of outputs to produce so as to maximize total revenue? The dual problem deals with economic values. With floor guarantees on all output unit prices, and assuming the available quantity of all inputs is known, what input unit pricing scheme to set so as to minimize total expenditure?</p>
<p>

To each variable in the primal space corresponds an inequality to satisfy in the dual space, both indexed by output type. To each inequality to satisfy in the primal space corresponds a variable in the dual space, both indexed by input type.</p>
<p>

The coefficients which bound the inequalities in the primal space are used to compute the objective in the dual space, input quantities in this example. The coefficients used to compute the objective in the primal space bound the inequalities in the dual space, output unit prices in this example.</p>
<p>

Both the primal and the dual problems make use of the same matrix. In the primal space, this matrix expresses the consumption of physical quantities of inputs necessary to produce set quantities of outputs. In the dual space, it expresses the creation of the economic values associated with the outputs from set input unit prices.</p>
<p>

Since each inequality can be replaced by an equality and a slack variable, this means each primal variable corresponds to a dual slack variable, and each dual variable corresponds to a primal slack variable.  This relation allows us to complementary slackness.</p>

</ss1>
</sec>
<sec>
<st>
Complementary slackness</st>
<p>

It is possible to obtain an optimal solution to the dual when only an optimal solution to the primal is known using the complementary slackness theorem. The theorem states:</p>
<p>

Suppose that x = (x1, x2, . . ., xn) is primal feasible and that y = (y1, y2, . . . , ym) is dual feasible. Let (w1, w2, . . ., wm) denote the corresponding primal slack variables, and let (z1, z2, . . . , zn) denote the corresponding dual slack variables. Then x and y are optimal for their respective problems if and only if
xjzj = 0, for j = 1, 2, . . . , n,
wiyi = 0, for i = 1, 2, . . . , m.</p>
<p>

So if the ith slack variable of the primal is not zero, then the ith variable of the dual is equal zero. Likewise, if the jth slack variable of the dual is not zero, then the jth variable of the primal is equal to zero.</p>

</sec>
<sec>
<st>
Theory</st>
<p>

Geometrically, the linear constraints define a <link xlink:type="simple" xlink:href="../292/6292.xml">
convex</link> <link xlink:type="simple" xlink:href="../470/23470.xml">
polyhedron</link>, which is called the <link xlink:type="simple" xlink:href="../808/1556808.xml">
feasible region</link>. Since the objective function is also linear, hence a convex function, all local optima are automatically global optima (by the <link xlink:type="simple" xlink:href="../362/2397362.xml">
KKT</link> theorem).  The linearity of the objective function also implies that the set of optimal solutions is the <link xlink:type="simple" xlink:href="../634/40634.xml">
convex hull</link> of a finite set of points - usually a single point.</p>
<p>

There are two situations in which no optimal solution can be found.  First, if the constraints contradict each other (for instance, <it>x</it> ≥ 2 and <it>x</it> ≤ 1) then the feasible region is empty and there can be no optimal solution, since there are no solutions at all.  In this case, the LP is said to be <it>infeasible</it>.</p>
<p>

Alternatively, the <link xlink:type="simple" xlink:href="../470/23470.xml">
polyhedron</link> can be unbounded in the direction of the objective function (for example: maximize <it>x</it>1 + 3 <it>x</it>2 subject to <it>x</it>1 ≥ 0, <it>x</it>2 ≥ 0, <it>x</it>1 + <it>x</it>2 ≥ 10), in which case there is no optimal solution since solutions with arbitrarily high values of the objective function can be constructed.</p>
<p>

Barring these two pathological conditions (which are often ruled out by resource constraints integral to the problem being represented, as above), the optimum is always attained at a vertex of the polyhedron. However, the optimum is not necessarily unique: it is possible to have a set of optimal solutions covering an edge or face of the polyhedron, or even the entire polyhedron (This last situation would occur if the objective function were constant).</p>

</sec>
<sec>
<st>
Algorithms</st>

<p>

<image width="240px" src="Linear_programming_example_graph.png" type="thumb">
<caption>

A series of linear constraints on two variables produces a region of possible values for those variables. Solvable problems will have a feasible region in the shape of a <link xlink:type="simple" xlink:href="../530/1059530.xml">
simple polygon</link>.
</caption>
</image>
</p>
<p>

The <link xlink:type="simple" xlink:href="../458/349458.xml">
simplex algorithm</link>, developed by <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<analyst wordnetid="109790482" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<statistician wordnetid="110653238" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../rry/Bill_B$erry.xml">
George Dantzig</link></research_worker>
</mathematician>
</scientist>
</causal_agent>
</statistician>
</person>
</analyst>
</expert>
</physical_entity>
, solves LP problems by constructing an admissible solution at a vertex of the polyhedron and then walking along edges of the polyhedron to vertices with successively higher values of the objective function until the optimum is reached.  Although this <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is quite efficient in practice and can be guaranteed to find the global optimum if certain precautions against <it>cycling</it> are taken, it has poor worst-case behavior: it is possible to construct a linear programming problem for which the simplex method takes a number of steps exponential in the problem size. In fact, for some time it was not known whether the linear programming problem was solvable in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link> (complexity class <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
).</p>
<p>

This long standing issue was resolved by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../462/565462.xml">
Leonid Khachiyan</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 in <link xlink:type="simple" xlink:href="../754/34754.xml">
1979</link> with the introduction of the <link xlink:type="simple" xlink:href="../203/4331203.xml">
ellipsoid method</link>, the first worst-case polynomial-time algorithm for linear programming.  To solve a problem which has <it>n</it> variables and can be encoded in <it>L</it> input bits, this algorithm uses <it>O(n4L)</it> arithmetic operations on numbers with <it>O(L)</it> digits.  It consists of a specialization of the  <link xlink:type="simple" xlink:href="../709/679709.xml">
nonlinear optimization</link> technique developed by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../821/14568821.xml">
Naum Z. Shor</link></scientist>
, generalizing the ellipsoid  method for <link xlink:type="simple" xlink:href="../411/1674411.xml">
convex optimization</link> proposed by <link>
Arkadi Nemirovski</link>, a <link xlink:type="simple" xlink:href="../163/36163.xml">
2003</link> <symbol wordnetid="106806469" confidence="0.8">
<award wordnetid="106696483" confidence="0.8">
<signal wordnetid="106791372" confidence="0.8">
<link xlink:type="simple" xlink:href="../461/16461.xml">
John von Neumann Theory Prize</link></signal>
</award>
</symbol>
 winner, and <link>
D. Yudin</link>.</p>
<p>

Khachiyan's algorithm was of landmark importance for establishing the polynomial-time solvability of linear programs.  The algorithm had little practical impact, as the simplex method is more efficient for all but specially constructed families of linear programs.  However, it inspired  new lines of research in linear programming with the development of <link xlink:type="simple" xlink:href="../862/1622862.xml">
interior point method</link>s, which can be implemented as a practical tool. In contrast to the simplex algorithm, which finds the optimal solution by progresses along points on the boundary of a polyhedral set, interior point methods move through the interior of the feasible region.</p>
<p>

In <link xlink:type="simple" xlink:href="../578/34578.xml">
1984</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../259/1162259.xml">
N. Karmarkar</link></research_worker>
</mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 proposed a new interior point <link xlink:type="simple" xlink:href="../667/3736667.xml">
projective method</link> for linear programming.  <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../667/3736667.xml">
Karmarkar's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 not only improved on Khachiyan's theoretical worst-case polynomial bound (giving <math>O(n^{3.5}L)</math>), but also promised dramatic practical performance improvements over the simplex method.  Since then, many interior point methods have been proposed and analyzed.  Early successful implementations were based on <it>affine scaling</it> variants of the method. For both theoretical and practical properties, <link xlink:type="simple" xlink:href="../647/3382647.xml">
barrier function</link> or <link>
path-following</link> methods are the most common recently.</p>
<p>

The current opinion is that the efficiency of good implementations of simplex-based methods and interior point methods is similar for routine applications of linear programming. </p>
<p>

LP solvers are in widespread use for optimization of various problems in industry, such as optimization of flow in transportation networks, many of which can be transformed into linear programming problems only with some difficulty.</p>

</sec>
<sec>
<st>
 Open problems and recent work </st>

<p>

There are several open problems in the theory of linear programming, the solution of which would represent fundamental breakthroughs in mathematics and potentially major advances in our ability to solve large-scale linear programs.</p>
<p>

<list>
<entry level="1" type="bullet">

 Does LP admit a strongly polynomial-time algorithm?</entry>
<entry level="1" type="bullet">

 Does LP admit a strongly polynomial algorithm to find a strictly complementary solution?</entry>
<entry level="1" type="bullet">

 Does LP admit a polynomial algorithm in the real number (unit cost) model of computation?</entry>
</list>
</p>
<p>

This closely related set of problems has been cited by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../294/40294.xml">
Stephen Smale</link></scientist>
 as among the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../746/8294746.xml">
 18 greatest unsolved problems</link></difficulty>
</problem>
</state>
</condition>
 of the 21st century.  In Smale's words, the third version of the problem "is the main unsolved problem of linear programming theory."  While algorithms exist to solve linear programming in <link xlink:type="simple" xlink:href="../576/44576.xml">
weakly polynomial</link> time, such as the <link xlink:type="simple" xlink:href="../203/4331203.xml">
 ellipsoid methods</link> and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../862/1622862.xml">
 interior-point techniques</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, no algorithms have yet been found that allow <link xlink:type="simple" xlink:href="../576/44576.xml">
strongly polynomial</link>-time performance in the number of constraints and the number of variables.  The development of such algorithms would be of great theoretical interest, and perhaps allow practical gains in solving large LPs as well.</p>
<p>

<list>
<entry level="1" type="bullet">

 Are there pivot rules which lead to polynomial-time Simplex variants?</entry>
<entry level="1" type="bullet">

 Do all polyhedral graphs have polynomially-bounded diameter?</entry>
<entry level="1" type="bullet">

 Is the <link xlink:type="simple" xlink:href="../371/10412371.xml">
Hirsch conjecture</link> true for polyhedral graphs?</entry>
</list>
</p>
<p>

These questions relate to the performance analysis and development of Simplex-like methods.  The immense efficiency of the Simplex algorithm in practice despite its exponential-time theoretical performance hints that there may be variations of Simplex that run in polynomial or even strongly polynomial time.  It would be of great practical and theoretical significance to know whether any such variants exist, particularly as an approach to deciding if LP can be solved in strongly polynomial time.</p>
<p>

The Simplex algorithm and its variants fall in the family of edge-following algorithms, so named because they solve linear programming problems by moving from vertex to vertex along edges of a polyhedron.  This means that their theoretical performance is limited by the maximum number of edges between any two vertices on the LP polyhedron.  As a result, we are interested in knowing the maximum <link xlink:type="simple" xlink:href="../021/1020021.xml">
 graph-theoretical diameter</link> of polyhedral <link xlink:type="simple" xlink:href="../806/325806.xml">
 graphs</link>.  It has been proved that all polyhedra have subexponential diameter, and all experimentally observed polyhedra have linear diameter, it is presently unknown whether any polyhedron has superpolynomial or even superlinear diameter.  If any such polyhedra exist, then no edge-following variant can run in polynomial or linear time, respectively.  Questions about polyhedron diameter are of independent mathematical interest.</p>
<p>

Simplex pivot methods preserve primal (or dual) feasibility.  On the other hand, criss-cross pivot methods do not preserve (primal or dual) feasibility --- they may visit primal feasible, dual feasible or primal-and-dual infeasible bases in any order.  Pivot methods of this type have been studied since the 1970s.  Essentially, these methods attempt to find the shortest pivot path on the <link>
arrangement polytope</link> under the linear programming problem.  In contrast to polyhedral graphs, graphs of arrangement polytopes have small diameter, allowing the possibility of strongly polynomial-time criss-cross pivot method without resolving questions about the diameter of general polyhedra.</p>

</sec>
<sec>
<st>
Integer unknowns</st>

<p>

If the unknown variables are all required to be integers, then the problem is called an <b>integer programming</b> (IP) or <b>integer linear programming</b> (ILP) problem.  In contrast to linear programming, which can be solved efficiently in the worst case, integer programming problems are in many practical situations (those with bounded variables) <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
. <b>0-1 integer programming</b> or <b>binary integer programming</b> (BIP) is the special case of integer programming where variables are required to be 0 or 1 (rather than arbitrary integers). This problem is also classified as <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
, and in fact the decision version was one of <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/2012564.xml">
Karp's 21 NP-complete problems</link></difficulty>
</problem>
</state>
</condition>
.</p>
<p>

If only some of the unknown variables are required to be integers, then the problem is called a <b>mixed integer programming</b> (MIP) problem.  These are generally also <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
.</p>
<p>

There are however some important subclasses of IP and MIP problems that are efficiently solvable, most notably problems where the constraint matrix is <link xlink:type="simple" xlink:href="../773/593773.xml">
totally unimodular</link> and the right-hand sides of the constraints are integers.</p>
<p>

Advanced algorithms for solving integer linear programs include:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../680/1597680.xml">
cutting-plane method</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../580/456580.xml">
branch and bound</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../914/3237914.xml">
branch and cut</link> </entry>
<entry level="1" type="bullet">

 <link>
branch and price</link></entry>
<entry level="1" type="bullet">

 if the problem has some extra structure, it may be possible to apply <link xlink:type="simple" xlink:href="../589/744589.xml">
delayed column generation</link>.</entry>
</list>
</p>

</sec>
<sec>
<st>
 Solvers and Scripting (Programming) Languages </st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../992/3709992.xml">
AIMMS</link></entry>
<entry level="1" type="bullet">

 <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../269/5960269.xml">
Cassowary constraint solver</link></room>
</library>
</area>
</artifact>
</structure>
</entry>
<entry level="1" type="bullet">

 <link>
SYMPHONY</link></entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../724/1249724.xml">
CPLEX</link></software>
</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../314/1438314.xml">
GAMS</link></software>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../552/1009552.xml">
GNU Linear Programming Kit</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../133/2857133.xml">
IMSL Numerical Libraries</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../817/908817.xml">
Lingo</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../412/20412.xml">
Matlab</link></entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../024/49024.xml">
Mathematica</link></software>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../019/3202019.xml">
MINTO</link></entry>
<entry level="1" type="bullet">

 <link>
MOSEK</link></entry>
<entry level="1" type="bullet">

 <link>
OptimJ</link></entry>
<entry level="1" type="bullet">

 <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../449/3180449.xml">
Qoca</link></room>
</library>
</area>
</artifact>
</structure>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../707/376707.xml">
R-Project</link></entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../677/990677.xml">
SAS</link></software>
</entry>
<entry level="1" type="bullet">

 <link>
Xpress-MP</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../297/125297.xml">
Dynamic programming</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../458/349458.xml">
Simplex algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, used to solve LP problems</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../660/194660.xml">
Leonid Kantorovich</link></scientist>
, one of the founders of linear programming</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../196/1913196.xml">
Shadow price</link></entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../471/2370471.xml">
MPS file format</link></format>
</information>
</message>
</entry>
<entry level="1" type="bullet">

 <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../583/2515583.xml">
MIP example, job shop problem</link></difficulty>
</problem>
</state>
</condition>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../668/9283668.xml">
INFORMS</link> Institute for Operations Research and the Management Sciences</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <it>see also the "External links" section below''</it></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>



</sec>
<sec>
<st>
Further reading </st>
<p>

<list>
<entry level="1" type="bullet">

 Alexander Schrijver, <it>Theory of Linear and Integer Programming</it>. John Wiley &amp; sons, 1998, ISBN 0-471-98232-6</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Chapter 29: Linear Programming, pp.770&ndash;821.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><link xlink:type="simple" xlink:href="../372/1709372.xml">
Michael R. Garey</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../983/577983.xml">
David S. Johnson</link></associate>
</scholar>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</peer>
</physical_entity>
&#32;(1979). .&#32;W.H. Freeman. ISBN 0-7167-1045-5.</cite>&nbsp; A6: MP1: INTEGER PROGRAMMING, pg.245.</entry>
<entry level="1" type="bullet">

 Bernd Gärtner, Jiri Matousek (2006). <it>Understanding and Using Linear Programming</it>, Berlin: Springer. ISBN 3-540-30697-8</entry>
<entry level="1" type="bullet">

 V. Chandru and  M.R.Rao, Linear Programming, Chapter 31 in  <it>Algorithms and Theory of Computation Handbook</it>, edited by M.J.Atallah, CRC Press 1999, 31-1 to 31-37. <weblink xlink:type="simple" xlink:href="http://www.cse.iitb.ac.in/dbms/Data/Papers-Other/Algorithms/lp.ps.gz">
http://www.cse.iitb.ac.in/dbms/Data/Papers-Other/Algorithms/lp.ps.gz</weblink></entry>
<entry level="1" type="bullet">

 V. Chandru and  M.R.Rao, Integer Programming, Chapter 32 in <it> Algorithms and Theory of Computation Handbook</it>, edited by M.J.Atallah, CRC Press 1999, 32-1 to 32-45. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/291576.html">
http://citeseer.ist.psu.edu/291576.html</weblink></entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Michael J. Todd&#32;(February 2002).&#32;"The many facets of linear programming". <it>Mathematical Programming</it>&#32;<b>91</b>&#32;(3).</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><link>
Mark de Berg</link>, <link>
Marc van Kreveld</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/1177516.xml">
Mark Overmars</link></research_worker>
</scientist>
</causal_agent>
</person>
</physical_entity>
, and <link>
Otfried Schwarzkopf</link>&#32;(2000). Computational Geometry, 2nd revised edition,&#32;<link xlink:type="simple" xlink:href="../949/1418949.xml">
Springer-Verlag</link>. ISBN 3-540-65620-0.</cite>&nbsp; Chapter 4: Linear Programming: pp.63&ndash;94. Describes a randomized half-plane intersection algorithm for linear programming.</entry>
<entry level="1" type="bullet">

 Jalaluddin Abdullah, <it>Optimization by the Fixed-Point Method, Version 1.97</it>. <weblink xlink:type="simple" xlink:href="http://www.optimization-online.org/DB_HTML/2007/09/1775.html">
http://www.optimization-online.org/DB_HTML/2007/09/1775.html</weblink>.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://people.brunel.ac.uk/~mastjjb/jeb/or/lp.html">
Guidance on Formulating LP problems</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nlsde.buaa.edu.cn/~kexu/benchmarks/pb-benchmarks.htm">
0-1 Integer Programming Benchmarks with Hidden Optimum Solutions</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://glossary.computing.society.informs.org/">
Mathematical Programming Glossary</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://mat.gsia.cmu.edu/orclass/integer/integer.html">
 A Tutorial on Integer Programming</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-unix.mcs.anl.gov/otc/Guide/faq/linear-programming-faq.html">
The linear programming FAQ</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.lionhrtpub.com/orms/surveys/LP/LP-survey.html">
Linear Programming Survey OR/MS Today</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://prejudice.tripod.com/ME30B/index.htm">
Linear Programming: Guide to Formulation, Simplex Algorithm, Goal Programming and Excel Solver examples</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.stanford.edu/group/SOL/dantzig.html">
George Dantzig</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

Software</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.aimms.com/aimms/context/mathematical_programming/linear_programming.html">
AIMMS Optimization Modeling</weblink> <link xlink:type="simple" xlink:href="../992/3709992.xml">
AIMMS</link> &mdash; include <weblink xlink:type="simple" xlink:href="http://www.aimms.com/aimms/context/mathematical_programming/linear_programming.html">
linear programming</weblink> in industry solutions (free trial license available);</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://kohei.us/ooo/solver/">
Calc Optimization Solver</weblink> &mdash; Kohei Yoshida’s spreadsheet add-in for OpenOffice.org Calc</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cgal.org/Pkg/QPSolver">
CGAL</weblink> &mdash; The Computational Geometry Algorithms Library includes a linear solver, which is exact and optimized for problems with few constraints or few variables</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.coin-or.org/">
COIN-OR</weblink> &mdash; COmputational INfrastructure for Operations Research, open-source library</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gams.com">
GAMS</weblink> &mdash; General Algebraic Modeling System</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ilog.com/products/cplex">
Cplex</weblink> &mdash; Commercial library for linear programming</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gnu.org/software/glpk">
GLPK</weblink> &mdash; GNU Linear Programming Kit; open source LP software </entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.vni.com/products/imsl/">
IMSL Numerical Libraries</weblink> &mdash; Commercial libraries of math and statistical algorithms </entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.maths.ed.ac.uk/~gondzio/software/hopdm.html">
HOPDM</weblink> &mdash; Higher Order Primal Dual Method</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.lindo.com/">
LINDO</weblink> &mdash; LP, IP, Global solver/modeling language</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/lpsolve">
lp_solve</weblink> &mdash; open-source solver with C library</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mosek.com/">
MOSEK</weblink> &mdash; Optimization software for LP,IP,QP,SOCP and MIP. Free trial is available. Free for students.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.wolfram.com/">
Mathematica</weblink> &mdash; General technical computing system includes large scale linear programming support</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ateji.com/">
OptimJ</weblink> &mdash; Java-based algebraic modeling language; free evaluation version.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.solver.com/">
Premium Solver</weblink> &mdash; Spreadsheet add-in</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://WhatsOP.home.comcast.net/">
WhatsOP</weblink> &mdash; LP modeling in 6 languages, made practical with easy "what-ifs" for students. Free Trial.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.sas.com/technologies/analytics/optimization/index.html">
SAS</weblink> &mdash; Includes optimization modeling language and solvers for LP, MILP, QP, and NLP</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.lindo.com/">
What's Best!</weblink> &mdash; Spreadsheet add-in</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.dashoptimization.com/">
Xpress-MP</weblink> &mdash; Optimization software free to students</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.vanguardsw.com/products/planning-and-analysis/optimization/">
 Vanguard Linear Programming Optimization Software</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www2.isye.gatech.edu/~wcook/qsopt/">
QSopt</weblink> Optimization software for LP (free for research purposes).</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mips.gsf.de/proj/mdcs">
 Microarray Data Classification Server (MDCS)</weblink>  based on linear programming</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="ftp://garbo.uwasa.fi/pc/ts/tslin35c.zip">
Linear programming and linear goal programming</weblink> A freeware program for MS-DOS</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://people.hofstra.edu/faculty/Stefan_Waner/RealWorld/simplex.html">
Simplex Method Tool</weblink> A quick-loading web page</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-128.ibm.com/developerworks/linux/library/l-glpk1/index.html">
IBM's article on GLPK</weblink> A technical article on <link xlink:type="simple" xlink:href="../552/1009552.xml">
GLPK</link> with an introduction to Linear Programming by IBM</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://staff.feweb.vu.nl/tijms/">
Orstat2000</weblink> &mdash; Includes easy-to-use modules for linear and integer programming (free for educational purposes).</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://trilinos.sandia.gov/">
Trilinos</weblink> is a set of scientific tools with a few linear and non-linear program solvers.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.tomopt.com/">
TOMLAB</weblink> provides optimization solvers in MATLAB, LabVIEW and .NET.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://scip.zib.de/">
SCIP</weblink> It can be used as a standalone program to solve mixed integer programs given in MPS Format.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.optimalon.com/product_gipals32.htm">
GIPALS32.DLL</weblink> &mdash; Linear programming callable library for Windows (free trial and academic license available).</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://abel.ee.ucla.edu/cvxopt">
CVXOPT</weblink> &mdash; Python library that can be used for linear, second-order cone and semidefinite programming (open source, GPLv3)</entry>
</list>
</p>


</sec>
</bdy>
</article>
