<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:13:37[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Event loop</title>
<id>4378023</id>
<revision>
<id>244526081</id>
<timestamp>2008-10-11T06:56:39Z</timestamp>
<contributor>
<username>Afn</username>
<id>392574</id>
</contributor>
</revision>
<categories>
<category>Events (computing)</category>
<category>Control flow</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>event loop</b>, <b>message dispatcher</b>, <b>message loop</b> or <b>message pump</b> is a programming construct that waits for and dispatches <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../599/62599.xml">
events</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 or <link xlink:type="simple" xlink:href="../867/1324867.xml">
messages</link> in a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link>. It works by <link xlink:type="simple" xlink:href="../638/4516638.xml">
polling</link> some internal or external "event provider", which generally <link>
 blocks</link> until an event has arrived, and then calls the relevant <link xlink:type="simple" xlink:href="../300/444300.xml">
event handler</link> ("dispatches the event"). The event-loop may be used in conjunction with a <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../787/12501787.xml">
reactor</link></form>
</structure>
, if the event provider follows the <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22File+interface%22])">
file interface</link> (which can be select()ed or poll()ed).  The event loop almost always operates asynchronously with the message originator.<p>

When the event loop forms the central control flow construct of a program, as it often does, and is thus at the highest level of control within the program, it may be termed the <b>main loop</b> or <b>main event loop</b>.</p>

<sec>
<st>
Message passing</st>
<p>

Message pumps are said to 'pump' messages from the program's <link xlink:type="simple" xlink:href="../709/429709.xml">
message queue</link> (assigned and usually owned by the underlying operating system) into the program for processing.  In the strictest sense, an event loop is a tool of <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link>.  In fact, message processing exists in many systems, and is a <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel-level</link> component of the <link xlink:type="simple" xlink:href="../028/21028.xml">
Mach operating system</link>.  The event loop is a specific implementation technique of systems that use <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link>.</p>

</sec>
<sec>
<st>
Alternative designs</st>
<p>

This approach is in contrast to a number of other alternatives:
<list>
<entry level="1" type="bullet">

 Traditionally, a program simply ran once then terminated. This type of program was very common in the early days of computing, and lacked any form of user interactivity. This is still used frequently, particularly in the form of <link xlink:type="simple" xlink:href="../707/6707.xml">
command line</link> driven programs. Any <link xlink:type="simple" xlink:href="../065/25065.xml">
parameters</link> are set up in advance and passed in one go when the program starts.</entry>
<entry level="1" type="bullet">

 Menu-driven designs. These still may feature a main loop but are not usually thought of as event driven in the usual sense. Instead, the user is presented with an ever-narrowing set of options until the task they wish to carry out is the only option available. Limited interactivity through the menus is available.</entry>
</list>
</p>

</sec>
<sec>
<st>
Usage</st>
<p>

Due to the predominance of <link xlink:type="simple" xlink:href="../293/12293.xml">
GUI</link> interfaces, most modern applications feature a main loop. The get_next_message() routine is typically provided by the operating system, and <link>
 blocks</link> until a message is available. Thus, the loop is only entered when there is something to process.</p>
<p>

<b>function</b> main
initialize()
<b>while</b> program_running
message := get_next_message()
if<b> message </b>=<b> quit </b>thenreturnend if<b>
process_message(message)
</b>repeatend function</p>

</sec>
<sec>
<st>
File interface</st>
<p>

Under <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
, the "everything is a file" paradigm naturally leads to a file-based event loop.  Reading from and writing to files, inter-process communication, network communication and device control are all achieved using file I/O, with the target identified by a <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link>.  The <link xlink:type="simple" xlink:href="../498/10993498.xml">
select</link> and <link>
poll</link> system calls allow a set of file descriptors to be monitored for a change of state, e.g. when data becomes available to be read.</p>
<p>

For example, consider a program that reads from a continuously updated file and displays its contents in the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../147/34147.xml">
X Window System</link></rule>
</direction>
</protocol>
</message>
, which communicates with clients over a socket (either <link xlink:type="simple" xlink:href="../697/4769697.xml">
Unix domain</link> or <link xlink:type="simple" xlink:href="../068/85068.xml">
Berkeley</link>):</p>
<p>

<b>main</b>():     
file_fd = open ("logfile")
x_fd = open_display ()
construct_interface ()
<b>while</b> changed_fds = select ({file_fd, x_fd}):
<b>if</b> file_fd in changed_fds:
data = read_from (file_fd)
append_to_display (data)
send_repaint_message ()
<b>if</b> x_fd in changed_fds:
process_x_messages ()</p>

<ss1>
<st>
Handling signals</st>
<p>

One of the few things in Unix that do not conform to the file interface are asynchronous events (<link xlink:type="simple" xlink:href="../602/938602.xml">
signals</link>).  Signals are received in <link xlink:type="simple" xlink:href="../602/938602.xml">
signal handler</link>s, small, limited pieces of code that run while the rest of the task is suspended; if a signal is received and handled while the task is blocking in select() then select will return early with <link xlink:type="simple" xlink:href="../563/1437563.xml">
EINTR</link>; if a signal is received while the task is <link xlink:type="simple" xlink:href="../697/648697.xml">
CPU bound</link> then the task will be suspended between instructions until the signal handler returns.</p>
<p>

Thus an obvious way to handle signals is for signal handlers to set a global flag and have the event loop check for the flag immediately before and after the select() call; if it is set, handle the signal in the same manner as with events on file descriptors.  Unfortunately, this gives rise to a <link xlink:type="simple" xlink:href="../661/98661.xml">
race condition</link>: if a signal arrives immediately between checking the flag and calling select(), then it will not be handled until select() returns for some other reason (for example, being interrupted by a frustrated user).</p>
<p>

The solution arrived at by <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../305/23305.xml">
POSIX</link></system_of_measurement>
</standard>
 is the <link>
pselect</link> call, which is similar to select() but takes an additional sigmask parameter, which describes a <it>signal mask</it>.  This allows an application to mask signals in the main task, then remove the mask for the duration of the select() call, such that signal handlers are only called while the application is <link xlink:type="simple" xlink:href="../513/648513.xml">
I/O bound</link>.  However, implementations of pselect() have only recently become reliable; versions of Linux prior to 2.6.16 do not have a pselect() <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link>, forcing <link xlink:type="simple" xlink:href="../364/324364.xml">
glibc</link> to emulate it via a method prone to the very same race condition pselect() is intended to avoid!</p>
<p>

An alternative, more portable solution, is to convert asynchronous events to file-based events using the <it>self-pipe trick</it>, where "a signal handler writes a byte to a pipe whose other end is monitored by select() in the main program".<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</ss1>
</sec>
<sec>
<st>
Implementations</st>

<ss1>
<st>
Windows applications</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../223/3987223.xml">
Message loop in Microsoft Windows</link></it>
</indent>
The <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> operating system requires user-interactive processes that wish to run on the operating system to construct a <link xlink:type="simple" xlink:href="../223/3987223.xml">
message loop</link> for responding to events.  In this operating system, a message is equated to an event created and imposed upon the operating system.  An event can range from user interaction, network traffic, system processing, timer activity, and interprocess communication among others.</p>
<p>

The "heart" of most <link xlink:type="simple" xlink:href="../601/81601.xml">
Win32</link> <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<furnishing wordnetid="103405265" confidence="0.8">
<table wordnetid="104379243" confidence="0.8">
<furniture wordnetid="103405725" confidence="0.8">
<console_table wordnetid="103092883" confidence="0.8">
<link xlink:type="simple" xlink:href="../746/454746.xml">
applications</link></console_table>
</furniture>
</table>
</furnishing>
</instrumentality>
</artifact>
 is the <weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/ms633559.aspx">
WinMain</weblink> function, which calls GetMessage(), in a loop. GetMessage blocks until a message, or "event", is received. After some optional processing, it will call DispatchMessage(), which dispatches the message to the relevant handler, also known as <link xlink:type="simple" xlink:href="../097/12005097.xml">
WindowProc</link>. Normally, messages that have no special WindowProc are dispatched to <link xlink:type="simple" xlink:href="../097/12005097.xml#xpointer(//*[./st=%22Default_processing%22])">
DefWindowProc</link>, the default one. DispatchMessage calls the window-proc of the <link>
HWND</link> <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../861/319861.xml">
handle</link></kind>
</type>
</category>
</concept>
</idea>
 of the message (Registered with the RegisterClass function).</p>

<ss2>
<st>
Message ordering</st>
<p>

More recent versions of Microsoft Windows provide the guarantee to the programmer that messages will be delivered to an application's message loop in the order that they were perceived by the system and its peripherals.  This guarantee is essential when considering the design consequences of <link xlink:type="simple" xlink:href="../303/45303.xml">
multithreaded</link> applications.</p>

</ss2>
</ss1>
<ss1>
<st>
X Window System</st>

<ss2>
<st>
Xlib event loop</st>
<p>

<message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../147/34147.xml">
X</link></rule>
</direction>
</protocol>
</message>
 applications using <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../751/1915751.xml">
Xlib</link></room>
</library>
</area>
</artifact>
</structure>
 directly are built around the XNextEvent family of functions; XNextEvent blocks until an event appears on the event queue, whereupon the application processes it appropriately.  The Xlib event loop only handles window system events; applications which need to be able to wait on other files and devices could construct their own event loop from primitives such as ConnectionNumber, but in practice tend to use <link xlink:type="simple" xlink:href="../679/10520679.xml">
multithreading</link>.</p>
<p>

Very few programs use Xlib directly. In the more common case, GUI toolkits based on Xlib usually support adding events. For example, toolkits based on <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../074/1481074.xml">
Xt</link></room>
</library>
</area>
</artifact>
</structure>
 intrinsics have XtAppAddInput() and XtAppAddTimeout(). </p>

</ss2>
</ss1>
<ss1>
<st>
GLib event loop</st>
<p>

The <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../824/1487824.xml">
GLib</link></room>
</library>
</area>
</artifact>
</structure>
 event loop was originally created for use in <link xlink:type="simple" xlink:href="../156/46156.xml">
GTK+</link> but is now used in non-GUI applications as well, such as <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../029/2083029.xml">
D-Bus</link></software>
.  The resource polled is the collection of <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link>s the application is interested in; the polling block will be interrupted if a <link xlink:type="simple" xlink:href="../473/28473.xml">
signal</link> arrives or a <link xlink:type="simple" xlink:href="../758/826758.xml">
timeout</link> expires (e.g. if the application has specified a timeout or idle task).  While GLib has built-in support for file descriptor and child termination events, it is possible to add an event source for any event that can be handled in a prepare-check-dispatch model.<weblink xlink:type="simple" xlink:href="http://developer.gnome.org/doc/API/2.0/glib/glib-The-Main-Event-Loop.html#mainloop-states">
http://developer.gnome.org/doc/API/2.0/glib/glib-The-Main-Event-Loop.html#mainloop-states</weblink></p>
<p>

Application libraries that are built on the GLib event loop include <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../024/584024.xml">
GStreamer</link></software>
 and the <link xlink:type="simple" xlink:href="../953/1880953.xml">
asynchronous I/O</link> methods of <link xlink:type="simple" xlink:href="../729/576729.xml">
GnomeVFS</link>, but <link xlink:type="simple" xlink:href="../156/46156.xml">
GTK+</link> remains the most visible client library.  Events from the <link xlink:type="simple" xlink:href="../967/151967.xml">
windowing system</link> (in <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../147/34147.xml">
X</link></rule>
</direction>
</protocol>
</message>
, read off the X <link xlink:type="simple" xlink:href="../697/4769697.xml">
socket</link>) are translated by <link xlink:type="simple" xlink:href="../891/1487891.xml">
GDK</link> into GTK+ events and emitted as GLib signals on the application's widget objects.</p>

</ss1>
<ss1>
<st>
The ADAPTIVE Communication Environment (ACE(TM))</st>

<ss2>
<st>
ACE_Reactor</st>
<p>

The ADAPTIVE Communication Environment offers a generic event loop called <it>Reactor</it>.
This solution allows to synchronize file events, timeouts and async signals (POSIX).</p>
<p>

See: <weblink xlink:type="simple" xlink:href="http://www.cs.wustl.edu/~schmidt/ACE.html">
http://www.cs.wustl.edu/~schmidt/ACE.html</weblink></p>

</ss2>
</ss1>
</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
BUGS, <weblink xlink:type="simple" xlink:href="http://linux.die.net/man/2/pselect">
pselect(2)</weblink>&#58;&nbsp;synchronous I/O multiplexing&nbsp;â€“&nbsp;<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 <link xlink:type="simple" xlink:href="../332/85332.xml">
man page</link></entry>
</reflist>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../867/1324867.xml">
Message passing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../106/152106.xml">
Inter-process communication</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../953/1880953.xml">
Asynchronous I/O</link></entry>
<entry level="1" type="bullet">

 The <it>game loop</it> in <link xlink:type="simple" xlink:href="../853/773853.xml">
Game programming</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.microsoft.com/msj/0795/dilascia/dilascia.aspx">
Meandering Through the Maze of MFC Message and Command Routing</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winui/winui/windowsuserinterface/windowing/windowprocedures/windowprocedurereference/windowprocedurefunctions/windowproc.asp">
WindowProc (MSDN)</weblink></entry>
</list>


</p>

</sec>
</bdy>
</article>
