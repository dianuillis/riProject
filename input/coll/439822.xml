<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:04:22[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Prefetch input queue</title>
<id>439822</id>
<revision>
<id>163559423</id>
<timestamp>2007-10-10T13:26:39Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Articles to be merged&amp;#32;since October 2007</category>
<category>Instruction processing</category>
<category>All articles to be merged</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-move" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="150px" src="Merge-arrows.svg">
<caption>

Merge arrows
</caption>
</image>
</p>
</col>
<col style="" class="mbox-text">
 It has been suggested that this article or section be  with . ()</col>
</row>
</table>


Most modern processors load their instructions some <link xlink:type="simple" xlink:href="../693/182693.xml">
clock cycle</link>s before they execute them. This is achieved by pre-loading <link xlink:type="simple" xlink:href="../683/20683.xml">
machine code</link> from memory into a  <b>prefetch input queue</b> (PIQ).<p>

This behavior only applies to <link xlink:type="simple" xlink:href="../091/478091.xml">
von Neumann computer</link>s (that is, not <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link> computers) that can run <link xlink:type="simple" xlink:href="../647/217647.xml">
self-modifying code</link> and have some sort of <link xlink:type="simple" xlink:href="../314/220314.xml">
instruction pipelining</link>. Nearly all computers fulfill these three requirements.</p>
<p>

Usually, the prefetching behavior of the PIQ is invisible to the <link xlink:type="simple" xlink:href="../375/2242375.xml">
programming model</link> of the CPU. However, there are some circumstances where the behavior of PIQ is visible, and needs to be taken into account by the programmer.</p>
<p>

When the <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>-processor changes mode from <link xlink:type="simple" xlink:href="../823/79823.xml">
realmode</link> to <link xlink:type="simple" xlink:href="../596/167596.xml">
protected mode</link> and vice versa, the PIQ has to be flushed, or else the CPU will continue to translate the <link xlink:type="simple" xlink:href="../683/20683.xml">
machine code</link> as if it were written in its last mode. If the PIQ is not flushed, the processor might translate its codes wrong and generate an invalid instruction <abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../231/59231.xml">
exception</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
.</p>
<p>

When executing <link xlink:type="simple" xlink:href="../647/217647.xml">
self-modifying code</link>, a change in the processor code immediately in front of the current location of execution might not change how the processor interprets the code, as it is already loaded into its PIQ. It simply executes its old copy already loaded in the PIQ instead of the new and altered version of the code in its <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link> and/or <link xlink:type="simple" xlink:href="../181/849181.xml">
cache</link>.</p>
<p>

This behavior of the PIQ can be used to determine if code is being executed inside an <link xlink:type="simple" xlink:href="../937/18943937.xml">
emulator</link> or directly on the hardware of a real CPU. Most emulators will <it>probably</it> never simulate this behavior. If the PIQ-size is zero (changes in the code <it>always</it> affect the state of the processor immediately), it can be deduced that either the code is being executed in an emulator or the processor invalidates the PIQ upon writes to addresses loaded in the PIQ.</p>

<sec>
<st>
x86 example code</st>

<p>

code_starts_here:
mov eax, ahead
mov [eax], 0x9090
ahead: 
jmp near to_the_end
<list>
<entry level="1" type="definition">

 Some other code</entry>
</list>

to_the_end:</p>
<p>

This <link xlink:type="simple" xlink:href="../647/217647.xml">
self-modifying</link> program will overwrite the <it>jmp to_the_end</it> with two <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../580/390580.xml">
NOP</link></direction>
</message>
s (which is encoded as <it>0x9090</it>). The jump <it>jmp near to_the_end</it> is assembled into two bytes of machine code, so the two <message wordnetid="106598915" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<link xlink:type="simple" xlink:href="../580/390580.xml">
NOP</link></direction>
</message>
s will just overwrite this jump and nothing else. (That is, the jump is replaced with a do-nothing-code.)</p>
<p>

Because the machine code of the jump is already read into the PIQ, and probably also already executed by the processor (<link xlink:type="simple" xlink:href="../702/51702.xml">
superscalar</link> processors execute several instructions at once, but they "pretend" that they don't because of the need for <link xlink:type="simple" xlink:href="../459/4459.xml">
backward compatibility</link>), the change of the code will not have any change of the execution flow.</p>

</sec>
<sec>
<st>
 Example program to detect the size of the PIQ </st>

<p>

This is an example <link xlink:type="simple" xlink:href="../ago/Logan_S$quare=2C_C$hicago.xml">
NASM</link>-<link xlink:type="simple" xlink:href="../860/26860.xml">
syntax</link> <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../647/217647.xml">
self-modifying</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>-<link xlink:type="simple" xlink:href="../368/1368.xml">
assembly</link> algorithm that determines the size of the PIQ:</p>
<p>

code_starts_here:
xor cx, cx                  ; zero register cx
xor ax, ax                  ; zero register ax</p>
<p>

mov dx, cs
mov [code_segment], dx      ; "calculate" codeseg in the far jump below (edx here too)</p>
<p>

around:
cmp ax, 1                   ; check if ax has been alterd
je found_size</p>
<p>

mov [nop_field+cx], 0x90    ; 0x90 = opcode "nop" (NO oPeration)
inc cx</p>
<p>

db 0xEA                     ; 0xEA = opcode "far jump"
dw flush_queue              ; should be followed by offset (rm = "dw", pm = "dd")
code_segment:
dw 0                        ; and then the code segment (calculated above)
flush_queue:</p>
<p>

mov [nop_field+cx], 0x40    ; 0x40 = opcode "inc ax" (INCrease ax)</p>
<p>

nop_field:
nop times 256
jmp around
found_size:
<list>
<entry level="1" type="definition">
</entry>
<entry level="1" type="definition">

    register cx now contains the size of the PIQ</entry>
<entry level="1" type="definition">

    this code is for <link xlink:type="simple" xlink:href="../823/79823.xml">
real mode</link> and <link>
16-bit protected mode</link>, but it could easily be changed into </entry>
<entry level="1" type="definition">

    running for <link>
32-bit protected mode</link> as well. just change the "dw" for </entry>
<entry level="1" type="definition">

    the offset to "dd". you need also change dx to edx at the top as</entry>
<entry level="1" type="definition">

    well. (dw and dx = 16 bit addressing, dd and edx = 32 bit addressing)</entry>
<entry level="1" type="definition">
</entry>
</list>
</p>
<p>

What this code does is basically that it changes the execution flow, and determines by <link xlink:type="simple" xlink:href="../147/236147.xml">
brute force</link> how large the PIQ is. "How far away do I have to change the code in front of me for it to affect me?" 
If it is too near (it is already in the PIQ) the update will not have any effect. If it is far enough, the change of the code will affect the program and the program has then found the size of the processor's PIQ. 
If this code is being executed in protected mode, the operating system must not make any <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>, or else this program may return the wrong value.</p>

</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../314/220314.xml">
Instruction pipeline</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../368/1368.xml">
Assembly language</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../597/7597.xml">
CPU design</link></entry>
</list>
</p>

</sec>
</bdy>
</article>
