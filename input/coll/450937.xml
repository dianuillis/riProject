<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:07:40[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Flat memory model</title>
<id>450937</id>
<revision>
<id>237212964</id>
<timestamp>2008-09-09T04:25:12Z</timestamp>
<contributor>
<username>The Anomebot2</username>
<id>1979668</id>
</contributor>
</revision>
<categories>
<category>Computer memory</category>
</categories>
</header>
<bdy>

<p>

In computer systems design, a <b>flat memory model</b> refers to a linear addressing <link xlink:type="simple" xlink:href="../308/175308.xml">
paradigm</link>, such that the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> can directly (and sequentially) address all of the available memory locations, without having to resort to any sort of <link xlink:type="simple" xlink:href="../396/354396.xml">
bank switching</link> or memory segmentation or paging schemes.</p>
<p>

Memory management and <link>
 logical</link>-to-<link xlink:type="simple" xlink:href="../118/5286118.xml">
physical address</link> translation can still be implemented <it>on top of</it> a flat memory model in order to facilitate the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>'s functionality, resource protection, <link xlink:type="simple" xlink:href="../126/20126.xml">
multi-tasking</link> or to increase the memory capacity beyond the limits imposed by the processor's physical address space, but the key feature of a flat memory model, is that the entire memory space is linear, sequential and contiguous from address zero to MaxBytes-1.</p>
<p>

Memory management is therefore possible, optional. It is neither necessary, nor dictated by the CPU architecture:</p>
<p>

<list>
<entry level="1" type="bullet">

In a simple controller, or in a <it>single tasking</it> embedded application, where memory management is not needed nor desirable, the flat memory model is the most appropriate, because it provides the simplest interface from the programmer's point of view, with direct access to all memory locations and minimum design complexity.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

In a general purpose computer system, which requires multi-tasking, resource allocation and protection, the flat memory system must be augmented by some memory management scheme, which is typically implemented through a combination of dedicated hardware (inside or outside the CPU) and software built into the operating system. The flat memory model (at the physical addressing level) still provides the greatest flexibility for implementing this type of memory management.</entry>
</list>
</p>
<p>

The vast majority of processor architectures do implement a flat memory design, including all early 8-bit processors, the Motorola 68K series ... etc. The original Intel 8086 was an exception to this rule which implemented a <b>segmented</b> memory model, because it provided an easy form of memory management with flexible page boundaries for early operating systems such as DOS.</p>
<p>

Most modern memory models fall into one of three categories:</p>
<p>

<list>
<entry level="1" type="bullet">

 Flat memory model:</entry>
<entry level="2" type="bullet">

 Simple interface for programmers, clean design.</entry>
<entry level="2" type="bullet">

 Greatest flexibility</entry>
<entry level="2" type="bullet">

 Minimum hardware and CPU real estate for simple controller applications</entry>
<entry level="2" type="bullet">

 Maximum execution speed</entry>
<entry level="2" type="bullet">

 Not suitable for general computing or multi-tasking operating systems, unless enhanced with additional memory management hardware/software, but this is almost always the case in modern <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../622/7622.xml">
CISC</link></group>
</collection>
</class>
 processors, which implement advanced memory management and protection technology over a flat memory model.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Paged memory model:</entry>
<entry level="2" type="bullet">

 Suitable for multitasking, general operating system design, resource protection and allocation.</entry>
<entry level="2" type="bullet">

 Suitable for virtual memory implementation.</entry>
<entry level="2" type="bullet">

 More CPU real estate, somewhat lower speed</entry>
<entry level="2" type="bullet">

 More complex to program</entry>
<entry level="2" type="bullet">

 Rigid page boundaries, not always the most memory efficient.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Segmented memory model:</entry>
<entry level="2" type="bullet">

 Similar to paged memory, but paging is achieved by the implicit addition of two relatively shifted registers: <b>segment:offset</b></entry>
<entry level="2" type="bullet">

 Variable page boundaries, more efficient and flexible than the paged memory model</entry>
<entry level="2" type="bullet">

 Quite complex and awkward from a programmer's point of view</entry>
<entry level="2" type="bullet">

 More difficult for compilers.</entry>
<entry level="2" type="bullet">

 Pages can overlap / poor resource protection and isolation</entry>
<entry level="2" type="bullet">

 Many to one address translation correspondence: Many <b>segment:offset</b> combinations resolve to the same physical address</entry>
<entry level="2" type="bullet">

 Greater chance of programming errors</entry>
<entry level="2" type="bullet">

 Implemented in original Intel 8086, 8088, 80186, 80286 and supported by 80386 and all subsequent x86 machines through to present day Pentium and Core 2 processors. This memory model has remained ever since in the x86 machines, which now provide multi-mode operation and rarely operate in the compatible segmented mode anyway.</entry>
</list>
</p>
<p>

Within the x86 architectures, when operating in the real (compatible) mode, physical address is computed as:
Address = 16*segment + offset</p>
<p>

(i.e. The 16-bit segment register is shifted left by 4 bits and added to a 16-bit offset, resulting in a 20 bit address)</p>
<p>

Finally, there seems to be some confusion regarding the relationship between a flat memory model and <link xlink:type="simple" xlink:href="../942/15942.xml">
Von Neumann</link> vs <link xlink:type="simple" xlink:href="../501/18426501.xml">
Harvard</link> architectures.</p>
<p>

A <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../091/478091.xml">
Von Neumann architecture</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 specifies that instructions and data are both stored within the same memory and transferred over the same bus. This type of architecture is the most space efficient, because any memory not used by the program is available for data and vice versa. This type of architecture is most often used in general computing.</p>
<p>

A <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>, on the other hand, separates instructions and data into two separate memories which are typically accessed over two separate buses. The benefit is an increase in system performance because data (for the present instruction) and code (for the future instruction) can be fetched at the same time. Also, in a Harvard architecture, the instruction and data buses can have different speeds and geometries. The drawback is that Harvard architectures force the designer to make assumptions about the ratio of instruction vs data memory, and this memory cannot be re-allocated at run time. The system is therefore unavoidably more wasteful. This type of architecture is most often used in Digital Signal Processing, Real Time Control and ultra-high speed <link xlink:type="simple" xlink:href="../672/3963672.xml">
RISC</link> applications, where performance is of the maximum importance and everything else is secondary.</p>
<p>

The point is that neither of the above architectures makes any claims whether the memory addressing model is flat, segmented, paged or otherwise.</p>

<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../903/18317903.xml">
Memory model (computing)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
