<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:42:27[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Thread safety</title>
<id>45634</id>
<revision>
<id>243427779</id>
<timestamp>2008-10-06T13:48:51Z</timestamp>
<contributor>
<username>Parallelized</username>
<id>6297621</id>
</contributor>
</revision>
<categories>
<category>Threads</category>
</categories>
</header>
<bdy>

<b>Thread safety</b> is a <link xlink:type="simple" xlink:href="../311/5311.xml">
computer programming</link> concept applicable in the context of <link xlink:type="simple" xlink:href="../303/45303.xml">
multi-threaded</link> programs. A piece of code is <b>thread-safe</b> if it functions correctly during simultaneous execution by multiple threads. In particular, it must satisfy the need for multiple <link xlink:type="simple" xlink:href="../303/45303.xml">
thread</link>s to access the same shared data, and the need for a shared piece of data to be accessed by only one thread at any given time.<p>

Thread safety is a key challenge in multi-threaded programming. It was once only a concern of the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> <link xlink:type="simple" xlink:href="../716/23716.xml">
programmer</link> but since the late 1990s has become a commonplace issue. In a multi-threaded program, several threads execute simultaneously in a shared <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link>. Every thread has access to virtually all the <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> of every other thread. Thus the flow of control and the sequence of accesses to data often have little relation to what would be reasonably expected by looking at the text of the program, violating the <link xlink:type="simple" xlink:href="../595/23595.xml">
principle of least astonishment</link>. Thread safety is a property aimed at minimizing surprising <link xlink:type="simple" xlink:href="../805/4805.xml">
behavior</link> by re-establishing some of the correspondences between the actual flow of control and the text of the program.</p>

<sec>
<st>
Identification</st>
<p>

It is not easy to determine if a piece of code is thread-safe or not. However, there are several indicators that suggest the need for careful examination to see if it is unsafe:
<list>
<entry level="1" type="bullet">

accessing <link xlink:type="simple" xlink:href="../611/265611.xml">
global variable</link>s or the <link xlink:type="simple" xlink:href="../117/547117.xml">
heap</link></entry>
<entry level="1" type="bullet">

allocating/reallocating/freeing <link xlink:type="simple" xlink:href="../365/1728365.xml">
resources</link> that have global limits (<link xlink:type="simple" xlink:href="../077/7077.xml">
file</link>s, sub-<link xlink:type="simple" xlink:href="../178/45178.xml">
processes</link>, etc.)</entry>
<entry level="1" type="bullet">

indirect accesses through <link xlink:type="simple" xlink:href="../669/11493669.xml">
handle</link>s or <link xlink:type="simple" xlink:href="../018/459018.xml">
pointer</link>s</entry>
<entry level="1" type="bullet">

any <it>visible <link xlink:type="simple" xlink:href="../519/29519.xml">
side-effect</link></it> (e.g., access to <link xlink:type="simple" xlink:href="../846/944846.xml">
volatile variable</link>s in the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C programming language</link></programming_language>
)</entry>
</list>
</p>
<p>

A <link xlink:type="simple" xlink:href="../988/40988.xml">
subroutine</link> is <link xlink:type="simple" xlink:href="../851/154851.xml">
reentrant</link>, and thus thread-safe, if it only uses variables from the <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link>, depends only on the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../375/324375.xml">
argument</link></concept>
</idea>
s passed in, and only calls other subroutines with similar properties. This is sometimes called a "pure function", and is much like a <link xlink:type="simple" xlink:href="../427/185427.xml">
mathematical function</link>.</p>

</sec>
<sec>
<st>
Implementation</st>
<p>

There are a few ways to achieve thread safety:
<list>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../851/154851.xml">
Re-entrancy</link> : Writing code in such a way that it can be partially executed by one task, <it><link xlink:type="simple" xlink:href="../851/154851.xml">
reentered</link></it> by another task, and then resumed from the original task. This requires the saving of <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/285512.xml">
state</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 information in variables local to each task, usually on its stack, instead of in <link xlink:type="simple" xlink:href="../365/1525365.xml">
static</link> or <link xlink:type="simple" xlink:href="../611/265611.xml">
global</link> variables.</entry>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../827/36827.xml">
Mutual exclusion</link> : Access to shared data is <it>serialized</it> using mechanisms that ensure only one thread reads or writes the shared data at any time. Great care is required if a piece of code accesses multiple shared pieces of dataâ€”problems include <link xlink:type="simple" xlink:href="../661/98661.xml">
race condition</link>s, <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link>s, <link>
livelock</link>s, <link xlink:type="simple" xlink:href="../591/501591.xml">
starvation</link>, and various other ills enumerated in many <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s textbooks.</entry>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../638/1649638.xml">
Thread-local storage</link> : Variables are localized so that each thread has its own private copy. These variables retain their values across <link xlink:type="simple" xlink:href="../988/40988.xml">
subroutine</link> and other code boundaries, and are thread-safe since they are local to each thread, even though the code which accesses them might be reentrant.</entry>
<entry level="1" type="definition">

 <link xlink:type="simple" xlink:href="../310/1204310.xml">
Atomic operations</link> : Shared data are accessed by using <link xlink:type="simple" xlink:href="../074/4695074.xml">
atomic operations</link> which cannot be interrupted by other threads. This usually requires using special <link xlink:type="simple" xlink:href="../683/20683.xml">
machine language</link> instructions, which might be available in a <link xlink:type="simple" xlink:href="../238/473238.xml">
runtime library</link>. Since the operations are atomic, the shared data are always kept in a valid state, no matter what other threads access it. <link xlink:type="simple" xlink:href="../310/1204310.xml">
Atomic operations</link> form the basis of many thread locking mechanisms.</entry>
</list>

One approach to making data thread-safe that combines several of the above elements is to make changes to a private copy of the shared data and then <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic</link></kernel>
</natural_object>
</plant_part>
ally update the shared data from the private copy. Thus, most of the code is <link xlink:type="simple" xlink:href="../467/928467.xml">
concurrent</link>, and little time is spent <link xlink:type="simple" xlink:href="../555/28555.xml">
serialized</link>.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../459/45459.xml">
Control flow analysis</link></entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<invertebrate wordnetid="101905661" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<arthropod wordnetid="101767661" confidence="0.8">
<bug wordnetid="102236355" confidence="0.8">
<insect wordnetid="102159955" confidence="0.8">
<animal wordnetid="100015388" confidence="0.8">
<link xlink:type="simple" xlink:href="../507/521507.xml">
Priority inversion</link></animal>
</insect>
</bug>
</arthropod>
</instrumentality>
</artifact>
</invertebrate>
</system>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../356/217356.xml">
Concurrency control</link></entry>
<entry level="1" type="bullet">

<abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../231/59231.xml">
Exception safety</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../370/247370.xml">
Communicating sequential processes</link> - a technique for analyzing concurrency</entry>
<entry level="1" type="bullet">

<link>
Re-Entrant Read-Write Lock</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://wiki.tcl.tk/3839">
Thread-safe Tcl Extensions</weblink> (wiki page)</entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://javalobby.org/articles/thread-safe/index.jsp">
Thread-safe webapps using Spring</weblink>" by <link>
Steven Devijver</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.javaworld.com/javaworld/javaqa/1999-04/01-threadsafe.html">
Thread-safe design</weblink></entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://www.javaworld.com/javaworld/jw-08-1998/jw-08-techniques.html">
Design for thread safety</weblink>" by <link>
Bill Venners</link></entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://www.javaworld.com/javaworld/jw-07-2004/jw-0712-threadsafe.html">
Write thread-safe servlets</weblink>" by <link>
Phillip Bridgham</link></entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://jelovic.com/articles/smart_pointer_thread_safety.htm">
Smart Pointer Thread Safety</weblink>" by <link>
Dejan Jelovic</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.thinkingparallel.com/2006/10/15/a-short-guide-to-mastering-thread-safety/">
A Short Guide to Mastering Thread-Safety</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
