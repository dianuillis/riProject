<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:42:30[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Dijkstra&apos;s algorithm</title>
<id>45809</id>
<revision>
<id>244688657</id>
<timestamp>2008-10-12T01:39:54Z</timestamp>
<contributor>
<username>David Gale</username>
<id>108816</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Routing algorithms</category>
<category>Combinatorial optimization</category>
<category>Articles with example pseudocode</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>

<b>Dijkstra's algorithm</b>, conceived by Dutch <link xlink:type="simple" xlink:href="../784/328784.xml">
computer scientist</link> <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> in 1959, <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> is a <link xlink:type="simple" xlink:href="../731/6263731.xml">
graph search algorithm</link> that solves the single-source <link xlink:type="simple" xlink:href="../985/41985.xml">
shortest path problem</link> for a <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link> with non negative <link>
edge</link> path costs, outputting a <link xlink:type="simple" xlink:href="../209/9521209.xml">
shortest path tree</link>. This algorithm is often used in <link xlink:type="simple" xlink:href="../750/25750.xml">
routing</link>.<p>

For a given source <link xlink:type="simple" xlink:href="../899/638899.xml">
vertex</link> (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex. It can also be used for finding costs of shortest paths from a single vertex to a single destination vertex by stopping the algorithm once the shortest path to the destination vertex has been determined. For example, if the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road, Dijkstra's algorithm can be used to find the shortest route between one city and all other cities. As a result, the shortest path first is widely used in network <link xlink:type="simple" xlink:href="../059/10123059.xml">
routing protocol</link>s, being <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/39219.xml">
IS-IS</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 and <link xlink:type="simple" xlink:href="../388/43388.xml">
OSPF</link> (Open Shortest Path First) the most notable.
</p>
<sec>
<st>
Algorithm</st>

<p>

It should be noted that distance between nodes can also be referred to as weight.</p>
<p>

<list>
<entry level="1" type="number">

 Create a distance list, a previous vertex list, a visited list, and a current vertex.</entry>
<entry level="1" type="number">

 All the values in the distance list are set to infinity except the starting vertex which is set to zero.</entry>
<entry level="1" type="number">

 All values in visited list are set to false.</entry>
<entry level="1" type="number">

 All values in the previous list are set to a special value signifying that they are undefined, such as <link xlink:type="simple" xlink:href="../807/3009807.xml">
null</link>.</entry>
<entry level="1" type="number">

 Current vertex is set as the starting vertex.</entry>
<entry level="1" type="number">

 Mark the current vertex as visited.</entry>
<entry level="1" type="number">

 Update distance and previous lists based on those vertices which can be immediately reached from the current vertex.</entry>
<entry level="1" type="number">

 Update the current vertex to the unvisited vertex that can be reached by the shortest path from the starting vertex.</entry>
<entry level="1" type="number">

 Repeat (from step 6) until all nodes are visited.</entry>
</list>
</p>

</sec>
<sec>
<st>
Description of the algorithm</st>

<p>

Suppose you create a knotted web of strings, with each knot corresponding to a node, and the strings corresponding to the edges of the web: the length of each string is proportional to the weight of each edge. Now you compress the web into a small pile without making any knots or tangles in it. You then grab your starting knot and pull straight up. As new knots start to come up with the original, you can measure the straight up-down distance to these knots: this must be the shortest distance from the starting node to the destination node. The acts of "pulling up" and "measuring" must be abstracted for the computer, but the general idea of the algorithm is the same: you have two sets, one of knots that are on the table, and another of knots that are in the air. Every step of the algorithm, you take the closest knot from the table and pull it into the air, and mark it with its length. If any knots are left on the table when you're done, you mark them with the distance infinity.</p>
<p>

Or, using a street map, suppose you're marking over the streets (tracing the street with a marker) in a certain order, until you have a route marked in from the starting point to the destination. The order is conceptually simple: from all the street intersections of the already marked routes, find the closest unmarked intersection - closest to the starting point (the "greedy" part). It's the whole marked route to the intersection, plus the street to the new, unmarked intersection. Mark that street to that intersection, draw an arrow with the direction, then repeat. Never mark to any intersection twice. When you get to the destination, follow the arrows backwards. There will be only one path back against the arrows, the shortest one.</p>

</sec>
<sec>
<st>
Pseudocode</st>

<p>

In the following algorithm, the code u := node in <it>Q</it> with smallest dist, searches for the vertex u in the vertex set Q that has the least dist[u] value. That vertex is removed from the set Q and returned to the user. dist_between(u, v) calculates the length between the two neighbor-nodes u and v. alt on line 11 is the length of the path from the root node to the neighbor node v if it were to go through u. If this path is shorter than the current shortest path recorded for v, that current path is replaced with this alt path.  The previous array is populated with a pointer to the "next-hop" node on the source graph to get the shortest route to the source.</p>
<p>

1  <b>function</b> Dijkstra(<it>Graph</it>, <it>source</it>):
2      <b>for each</b> vertex <it>v</it> in <it>Graph</it>:           <it>// Initializations</it>
3          dist[''v''] := infinity               <it>// Unknown distance function from source to v</it>
4          previous[''v''] := undefined          <it>// Previous node in optimal path from source</it>
5      dist[''source''] := 0                     <it>// Distance from source to source</it>
6      <it>Q</it> := the set of all nodes in <it>Graph</it>    <it>// All nodes in the graph are unoptimized - thus are in Q</it>
7      <b>while</b> <it>Q</it> <b>is not</b> empty:                 <it>// The main loop</it>
8          <it>u</it> := node in <it>Q</it> with smallest dist
9          remove <it>u</it> from <it>Q</it>
10          <b>for each</b> neighbor <it>v</it> of <it>u</it>:         <it>// where v has not yet been removed from Q.
11              </it>alt<it> := dist[''u''] + dist_between(</it>u<it>, </it>v<it>)
12              </it>'if<b> <it>alt</it></b><b>  dist[''v'']              <it>// Relax (u,v)</it></b><b>
13                  dist[''v''] := <it>alt</it></b><b>
14                  previous[''v''] := <it>u</it></b><b>
15      </b>return<b> previous</b></p>
<p>

If we are only interested in a shortest path between vertices source and target, we can terminate the search at line 10 if u = target.
Now we can read the shortest path from source to target by iteration:</p>
<p>

1  <it>S</it> := empty sequence
2  <it>u</it> := <it>target</it>
3  <b>while</b> defined previous[''u'']
4      insert <it>u</it> at the beginning of <it>S</it>
5      <it>u</it> := previous[''u'']</p>
<p>

Now sequence S is the list of vertices constituting one of the shortest paths from source to target, or the empty sequence if no path exists.</p>
<p>

A more general problem would be to find all the shortest paths between source and target (there might be several different ones of the same length). Then instead of storing only a single node in each entry of previous we would store all nodes satisfying the relaxation condition. For example, if both r and source connect to target and both of them lie on different shortest paths through target (because the edge cost is the same in both cases), then we would add both r and source to previous[target]. When the algorithm completes, previous data structure will actually describe a graph that is a subset of the original graph with some edges removed. Its key property will be that if the algorithm was run with some starting node, then every path from that node to any other node in the new graph will be the shortest path between those nodes in the original graph, and all paths of that length from the original graph will be present in the new graph. Then to actually find all these short paths between two given nodes we would use a path finding algorithm on the new graph, such as depth-first search.</p>

</sec>
<sec>
<st>
 Running time</st>

<p>

The running time of Dijkstra's algorithm on a graph with edges <it>E</it> and vertices <it>V</it> can be expressed as a function of |<it>E</it>| and |<it>V</it>| using the <link xlink:type="simple" xlink:href="../578/44578.xml#xpointer(//*[./st=%22Graph+theory%22])">
Big-O notation</link>. </p>
<p>

The simplest implementation of the Dijkstra's algorithm stores vertices of set <it>Q</it>  in an ordinary linked list or array, and operation Extract-Min(<it>Q</it>) is simply a linear search through all vertices in <it>Q</it>. In this case, the running time is <it>O</it>(|<it>V</it>|2+|E|)=<it>O</it>(|<it>V</it>|2).</p>
<p>

For <link xlink:type="simple" xlink:href="../546/963546.xml">
sparse graph</link>s, that is, graphs with fewer than |<it>V</it>|2 edges, Dijkstra's algorithm can be implemented more efficiently by storing the graph in the form of <link xlink:type="simple" xlink:href="../431/392431.xml">
adjacency list</link>s and using a <link xlink:type="simple" xlink:href="../890/69890.xml">
binary heap</link>, <link xlink:type="simple" xlink:href="../053/3402053.xml">
pairing heap</link>, or <amount wordnetid="105107765" confidence="0.8">
<magnitude wordnetid="105090441" confidence="0.8">
<property wordnetid="104916342" confidence="0.8">
<number wordnetid="105121418" confidence="0.8">
<link xlink:type="simple" xlink:href="../142/254142.xml">
Fibonacci heap</link></number>
</property>
</magnitude>
</amount>
 as a <link xlink:type="simple" xlink:href="../485/24485.xml">
priority queue</link> to implement the Extract-Min function efficiently. With a binary heap, the algorithm requires <it>O</it>((|<it>E</it>|+|<it>V</it>|) log |<it>V</it>|) time (which is dominated by <it>O</it>(|<it>E</it>| log |<it>V</it>|) assuming every vertex is connected, that is, |<it>E</it>| ≥ |<it>V</it>| - 1), and the <amount wordnetid="105107765" confidence="0.8">
<magnitude wordnetid="105090441" confidence="0.8">
<property wordnetid="104916342" confidence="0.8">
<number wordnetid="105121418" confidence="0.8">
<link xlink:type="simple" xlink:href="../142/254142.xml">
Fibonacci heap</link></number>
</property>
</magnitude>
</amount>
 improves this to <math>O(|E| + |V| \log|V|)</math> <link xlink:type="simple" xlink:href="../683/236683.xml">
amortized time</link>.</p>

</sec>
<sec>
<st>
 Related problems and algorithms </st>
<p>
 
The functionality of Dijkstra's original algorithm can be extended with a variety of modifications. For example, sometimes it is desirable to present solutions which are less than mathematically optimal. To obtain a ranked list of less-than-optimal solutions, the optimal solution is first calculated. A single edge appearing in the optimal solution is removed from the graph, and the optimum solution to this new graph is calculated. Each edge of the original solution is suppressed in turn and a new shortest-path calculated. The secondary solutions are then ranked and presented after the first optimal solution.</p>
<p>

Dijkstra's algorithm is usually the working principle behind <link xlink:type="simple" xlink:href="../632/159632.xml">
link-state routing protocol</link>s, <link xlink:type="simple" xlink:href="../388/43388.xml">
OSPF</link> and <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/39219.xml">
IS-IS</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
 being the most common ones.</p>
<p>

Unlike Dijkstra's algorithm, the <condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
 can be used on graphs with negative edge weights, as long as the graph contains no negative cycle reachable from the source vertex <it>s</it>. (The presence of such cycles means there is no shortest path, since the total weight becomes lower each time the cycle is traversed.)</p>
<p>

The <link xlink:type="simple" xlink:href="../558/100558.xml">
A* algorithm</link> is a generalization of Dijkstra's algorithm that cuts down on the size of the subgraph that must be explored, if additional information is available that provides a lower-bound on the "distance" to the target.</p>
<p>

The process that underlies Dijkstra's algorithm is similar to the greedy process used in <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.  Prim's purpose is to find a <link xlink:type="simple" xlink:href="../795/41795.xml">
minimum spanning tree</link> for a graph.</p>
<p>

For the solution of nonconvex cost trees (typical for <it>real-world</it> costs exhibiting <link xlink:type="simple" xlink:href="../517/10517.xml">
economies of scale</link>) one solution allowing application of this algorithm is to successively divide the problem into convex subtrees (using bounding linear costs) and to pursue subsequent divisions using <link xlink:type="simple" xlink:href="../580/456580.xml">
branch and bound</link> methods. Such methods have been superseded by more efficient direct methods.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

 <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../632/159632.xml">
Link-state routing protocol</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</rule>
</direction>
</event>
</protocol>
</message>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../388/43388.xml">
OSPF</link></entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../219/39219.xml">
IS-IS</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D* search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>
<p>

<reflist>
<entry id="1">
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../018/10018.xml">
E. W. Dijkstra</link></scientist>
</person>
: <weblink xlink:type="simple" xlink:href="http://www-m3.ma.tum.de/twiki/pub/MN0506/WebHome/dijkstra.pdf">
<it>A note on two problems in connexion with graphs''</it></weblink>. In <it>Numerische Mathematik</it>, 1 (1959), S. 269–271.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 24.3: Dijkstra's algorithm, pp.595&ndash;601.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <link>
F. Benjamin Zhan</link>, and <link>
Charle E. Noon</link>.  1998.  Shortest Path Algorithms: An Evaluation Using Real Road Networks.  <it><link xlink:type="simple" xlink:href="../507/18096507.xml">
Transportation Science</link></it> 32(1): 65-73.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codeproject.com/KB/recipes/ShortestPathCalculation.aspx">
Dijkstra Algorithm implemented in C# by Michael Demeersseman</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.dgp.toronto.edu/people/JamesStewart/270/9798s/Laffra/DijkstraApplet.html">
Applet by Carla Laffra of Pace University</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.uweschmidt.org/dijkstravis">
Interactive visualization and animation of Dijkstra's algorithm suitable for people without prior knowledge of algorithms</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.boost.org/libs/graph/doc/dijkstra_shortest_paths.html">
The Boost Graph Library (BGL)'s implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://tide4javascript.com/?s=Dijkstra">
Analyze Dijkstra's algorithm in an online Javascript IDE</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.julianbrowne.com/article/viewer/shortest-path">
An interactive and visual calculator that lets you define your own nodes</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.sunysb.edu/~skiena/combinatorica/animations/dijkstra.html">
Animation of Dijkstra's algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://students.ceid.upatras.gr/~papagel/english/java_docs/minDijk.htm">
Interactive Implementation of Dijkstra's Algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-b2.is.tokushima-u.ac.jp/~ikeda/suuri/dijkstra/Dijkstra.shtml">
Shortest Path Problem: Dijkstra's Algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.unf.edu/~wkloster/foundations/DijkstraApplet/DijkstraApplet.htm">
Dijkstra's Algorithm Applet</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.lupinho.de/gishur/html/DijkstraApplet.html">
Another Dijkstra's Algorithm Applet</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.carto.net/papers/svg/dijkstra_shortest_path_demo/">
An interactive SVG/ECMAScript example demonstrating the Dijkstra Algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=77262">
T-SQL implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.codeproject.com/useritems/Shortest_Path_Problem.asp">
Another C# Dijkstra's algorithm implementation with full source code</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://algowiki.net/wiki/index.php/Dijkstra%27s_algorithm">
A Java implementation of Dijkstra's algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://plagiata.net.ru/?p=90">
Dijkstra Algorithm implemented in Delphi with full source code</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
