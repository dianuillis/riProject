<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:21:57[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<rule  confidence="0.8" wordnetid="105846932">
<language  confidence="0.8" wordnetid="106282651">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Longest increasing subsequence</title>
<id>4587078</id>
<revision>
<id>244500768</id>
<timestamp>2008-10-11T03:00:17Z</timestamp>
<contributor>
<username>Mathbot</username>
<id>234358</id>
</contributor>
</revision>
<categories>
<category>Combinatorics</category>
<category>Formal languages</category>
<category>Algorithms on strings</category>
<category>Dynamic programming</category>
</categories>
</header>
<bdy>

The <b>longest increasing subsequence</b> problem is to find the <link xlink:type="simple" xlink:href="../078/4587078.xml">
longest increasing subsequence</link> of a given sequence. Note that subsequence we are searching for is not necessarily contiguous. Searching for the longest contiguous increasing subsequence would be a simple matter of scanning the whole sequence to find the points where the values decrease, and taking the longest gap between two such points. <p>

A longest increasing subsequence of a <link xlink:type="simple" xlink:href="../572/23572.xml">
partially ordered</link> <link xlink:type="simple" xlink:href="../838/27838.xml">
sequence</link> is studied in the context of various disciplines related to <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematics</link>, including <link xlink:type="simple" xlink:href="../775/775.xml">
algorithmics</link>, <link xlink:type="simple" xlink:href="../765/1648765.xml">
random matrix theory</link>, <link xlink:type="simple" xlink:href="../200/19378200.xml">
representation theory</link>, and <link xlink:type="simple" xlink:href="../939/22939.xml">
physics</link>. The longest increasing subsequence problem has long been known to be solvable in time O(<it>n</it> log <it>n</it>).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

<sec>
<st>
 Relations to other algorithmic problems </st>

<p>

The longest increasing subsequence problem is closely related to the <link xlink:type="simple" xlink:href="../105/236105.xml">
longest common subsequence problem</link>, which has a quadratic time <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> solution: the longest increasing subsequence of a sequence <it>S</it> is the longest common subsequence of <it>S</it> and <it>T</it>, where <it>T</it> is the result of <link xlink:type="simple" xlink:href="../656/144656.xml">
sorting</link> <it>S</it>. However, for the special case in which the input is a permutation of the integers 1, 2, ..., <it>n</it>, this approach can be made much more efficient, leading to time bounds of the form O(<it>n</it> log log <it>n</it>).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

The longest increasing subsequence problem can also be related to finding the <link xlink:type="simple" xlink:href="../567/18757567.xml">
longest path</link> in a <link xlink:type="simple" xlink:href="../002/204002.xml">
directed acyclic graph</link> derived from the input sequence: we construct a vertex per sequence value and connect values <it>x</it> and <it>y</it> by an edge when <it>x</it> is both smaller than <it>y</it> and occurs earlier than it in the sequence. Longest paths in DAGs can be found in time linear in the size of the DAG, but in this case the size can be quadratic in the sequence length, so this algorithm is not asymptotically faster than the dynamic programming one.</p>

</sec>
<sec>
<st>
 Efficient algorithms </st>

<p>

We describe an efficient algorithm for the problem that utilizes only arrays and binary searching.
The algorithm processes the sequence elements in order, maintaining the longest increasing subsequence found so far. Denote the sequence values as X[1], X[2], etc. Then, after processing X[''i''], the algorithm will have stored values in two arrays, described below:
<indent level="1">

M[''j''] — stores the position <it>k</it> of the smallest value X[''k''] such that <it>k</it> ≤ <it>i</it> and there is an increasing subsequence of length <it>j</it> ending at X[''k'']
</indent>
:P[''k''] — stores the position of the predecessor of X[''k''] in the longest increasing subsequence ending at X[''k'']
In addition the algorithm stores a variable L representing the length of the longest increasing subsequence found so far.</p>
<p>

Note that, at any point in the algorithm, the sequence
<indent level="1">

X[M[1]], X[M[2]], ..., X[M[L]]
</indent>
is nondecreasing.  For, if there is an increasing subsequence of length <it>i</it> ending at X[M[''i'']], then there is also a subsequence of length <it>i</it>-1 ending at a smaller value: namely the one ending at P[M[[''i'']]. Thus, we may do binary searches in this sequence in logarithmic time.

The algorithm, then, proceeds as follows.

L = 0
M[0] = 0
for <it>i</it> = 1, 2, ... n:
binary search for the largest <it>j</it> ≤ L such that X[M[''j'']]  X[''i''] (or set <it>j</it> = 0 if no such value exists)
P[''i''] = M[''j'']
if <it>j</it> == L or X[''i'']  X[M[j+1]]:
M[''j''+1] = <it>i</it>
L = max(L, <it>j</it>+1)</p>
<p>

The result of this is the length of the longest sequence in L. The actual longest sequence can be found by backtracking through the P array:
<indent level="1">

..., X[P[P[M[L]]]], X[P[M[L]]], X[M[L]]
</indent>

</p>
</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

<link>
Erdős–Szekeres theorem</link></entry>
<entry level="1" type="bullet">

<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../256/1184256.xml">
Patience sorting</link></kind>
</psychological_feature>
</game>
</contest>
</social_event>
</event>
</category>
</concept>
</idea>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../441/9036441.xml">
Vershik</link></entry>
<entry level="1" type="bullet">

<link>
Tracy-Widom distribution</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Schensted, C.&#32;(1961).&#32;"Longest increasing and decreasing subsequences". <it>Canadian Journal of Mathematics</it>&#32;<b>13</b>: 179–191.</cite>&nbsp;</entry>
<entry id="2">
 <cite style="font-style:normal">Hunt, J.; Szymanski, T.&#32;(1977).&#32;"A fast algorithm for computing longest common subsequences". <it>Communications of the ACM</it>: 350–353. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F359581.359603">
10.1145/359581.359603</weblink>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>
 
<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.algorithmist.com/index.php/Longest_Increasing_Subsequence">
Algorithmist's Longest Increasing Subsequence</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www2.toki.or.id/book/AlgDesignManual/BOOK/BOOK2/NODE47.HTM#SECTION02314000000000000000">
Another explanation of the problem</weblink></entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</language>
</rule>
</entity>
</event>
</article>
