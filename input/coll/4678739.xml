<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:15:02[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Structure Mapping Engine</title>
<id>4678739</id>
<revision>
<id>225375038</id>
<timestamp>2008-07-13T10:22:31Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>All articles with unsourced statements</category>
<category>Wikipedia articles that are too technical</category>
<category>Machine learning</category>
<category>Articles with unsourced statements since July 2008</category>
<category>Pages needing expert attention</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-style" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_style.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 This article may be <b>too technical</b> for most readers to understand, and needs <b>attention from an expert</b> on its subject.  Please <weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Structure_Mapping_Engine&amp;action=edit">
expand</weblink> it to , without removing the technical details.</col>
</row>
</table>

<p>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_content.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>This article or section is missing  or needs .</b>
Using helps guard against copyright violations and factual inaccuracies. <it>(July 2008)''</it></col>
</row>
</table>

</p>
<p>

In <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link> and <link xlink:type="simple" xlink:href="../626/5626.xml">
cognitive science</link>, the <b>structure mapping engine</b> is an implementation in software of an algorithm for analogical matching based on the psychological theory of <link xlink:type="simple" xlink:href="../260/1940260.xml">
Dedre Gentner</link> [1983].  The basis of Gentner's structure-mapping idea is that an analogy is a mapping of knowledge from one domain (the base) into another (the target). The structure-mapping engine, or <b>SME,</b> is a <link xlink:type="simple" xlink:href="../416/375416.xml">
computer simulation</link> of the analogy and similarity comparisons. <weblink xlink:type="simple" xlink:href="http://www.ai.sri.com/software/sme">
Artificial Intelligence Center</weblink></p>
<p>

As of 1990, more than 40 projects had used it [Falkenhainer, 2005]. R.M. French said that structure mapping theory is "unquestionably the most influential work to date of the modeling of analogy-making" [2002]. </p>
<p>

The theory is useful because it ignores surface features and finds matches between potentially very different things if they have the same representational structure. For example, SME could determine that a pen is like a sponge because both are involved in dispensing liquid, even though they do this very differently.</p>

<sec>
<st>
 Structure mapping theory </st>

<p>

Structure mapping theory is based on the systematicity principle, which states that connected knowledge is preferred over independent facts. Therefore, the structure mapping engine should ignore isolated source-target mappings unless they are part of a bigger structure. The SME, the theory goes, should map objects that are related to knowledge that has already been mapped.</p>
<p>

The theory also requires that mappings be done <link xlink:type="simple" xlink:href="../196/45196.xml">
one-to-one</link>, which means that no part of the source description can map to more than one item in the target and no part of the target description can be mapped to more than one part of the source. The theory also requires that if a match maps subject to target then the arguments of subject and target must also be mapped. If both these conditions are met, the mapping is said to be "structurally consistent."</p>

</sec>
<sec>
<st>
 Concepts in SME </st>

<p>

SME maps knowledge from a <it>source</it> into a <it>target.</it> SME calls each description a <it>dgroup.</it> Dgroups contain a list of entities and <link xlink:type="simple" xlink:href="../280/203280.xml">
predicate</link>s. Entities represent the objects or concepts in a description — such as an input gear or a switch. Predicates are one of three types and are a general way to express knowledge for SME.</p>
<p>

<list>
<entry level="1" type="bullet">

 Relation predicates contain multiple arguments, which can be other predicates or entities. An example relation is: (transmit (what from to)). This relation has a functor <it>transmit</it> and takes three arguments: <it>what, from,</it> and <it>to.''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Attribute predicates are the properties of an entity. An example of an attribute is (red gear) which means that <it>gear</it> has the attribute <it>red.''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Function predicates map an entity into another entity or constant. An example of a function is (<link xlink:type="simple" xlink:href="../327/16327.xml">
joule</link>s power source) which maps the entity <it>power source</it> onto the numerical quantity <it>joules.</it> </entry>
</list>
</p>
<p>

Functions and attributes have different meanings, and consequently SME processes them differently. For example in SME’s true analogy rule set, attributes differ from functions because they cannot match unless there is a higher-order match between them. The difference between attributes and functions will be explained further in this section’s examples. </p>
<p>

All predicates have four parameters. They have (1) a functor, which identifies, it and (2) a type, which is either relation, attribute, or function. The other two parameters (3 and 4) are for determining how to process the arguments in the SME algorithm. If the arguments have to be matched in order, commutative is false. If the predicate can take any number of arguments, <link xlink:type="simple" xlink:href="../301/42301.xml">
N-ary</link> is false. An example of a predicate definition is: (sme:defPredicate behavior-set (predicate) relation :n-ary? t :commutative? t)
The predicate’s functor is “behavior-set,” its type is “relation,” and its n-ary and commutative parameters are both set to true. The “(predicate)” part of the definition specifies that there will be one or more predicates inside an instantiation of behavior-set.</p>

</sec>
<sec>
<st>
 Algorithm details </st>
<p>

The algorithm has several steps, as described in this <weblink xlink:type="simple" xlink:href="http://www.qrg.northwestern.edu/papers/Files/smeff2(searchable).pdf">
algorithm paper by Brian Falkenhainer, Kenneth D. Forbus, and Dedre Gentner</weblink>. Below are given examples to demonstrate how SME runs.</p>
<p>

The first step of the algorithm is to create a set of match hypotheses between source and target dgroups. A match hypothesis represents a possible mapping between any part of the source and the target. This mapping is controlled by a set of match rules. By changing the match rules, one can change the type of reasoning SME does. For example, one set of match rules may perform a kind of analogy called <it>literal similarity.</it> and another performs a kind of analogy called <it>true-analogy.</it> These rules are not the place where domain-dependent information is added, but rather where the <link xlink:type="simple" xlink:href="../533/103533.xml">
analogy</link> process is tweaked, depending on the type of <link xlink:type="simple" xlink:href="../238/106238.xml">
cognitive function</link> the user is trying to emulate. </p>
<p>

There are two types of match rules: filter rules and intern rules. Intern rules use only the arguments of the expressions in the match hypotheses that the filter rules identify. This limitation makes the processing more efficient by constraining the number of match hypotheses that are generated. At the same time, it also helps to build the structural consistencies that are needed later on in the algorithm. An example of a filter rule from the true-analogy rule set creates match hypotheses between predicates that have the same functor. The true-analogy rule set has an intern rule that iterates over the arguments of any match hypothesis, creating more match hypotheses if the arguments are entities or functions, or if the arguments are attributes and have the same functor.</p>
<p>

In order to illustrate how the match rules produce match hypotheses consider these two predicates:</p>
<p>

transmit torque inputgear secondgear  (p1)</p>
<p>

transmit signal switch div10          (p2)</p>
<p>

The filter match rule generates a match between p1 and p2 because they share the same functor, <it>transmit.</it> The intern rules then produce three more match hypotheses: torque to signal, inputgear to switch, and secondgear to div10. The intern rules created these match hypotheses because all the arguments were entities.</p>
<p>

If the arguments were functions or attributes instead of entities, the predicates would be expressed as:</p>
<p>

transmit torque (inputgear gear) (secondgear gear)  (p3)</p>
<p>

transmit signal (switch circuit) (div10 circuit)    (p4)</p>
<p>

These additional predicates make inputgear, secondgear, switch, and div10 functions or attributes depending on the value defined in the language input file. The representation also contains additional entities for gear and circuit.</p>
<p>

Depending on what type <it>inputgear, secondgear, switch,</it> and <it>div10</it> are, their meanings change. As attributes, each one is a property of the gear or circuit. For example, the gear has two attributes, inputgear and secondgear. The circuit has two attributes, switch and circuit. As functions inputgear, secondgear, switch, and div10 become quantities of the gear and circuit. In this example, the functions inputgear and secondgear now map to the numerical quantities “torque from inputgear” and “torque from secondgear,” For the circuit the quantities map to logical quantity “switch engaged” and the numerical quantity “current count on the divide by 10 counter.” </p>
<p>

SME processes these differently. It does not allow attributes to match unless they are part of a higher-order relation, but it does allow functions to match, even if they are not part of such a relation. It allows functions to match because they indirectly refer to entities and thus should be treated like relations that involve no entities. However, as next section shows, the intern rules assign lower weights to matches between functions than to matches between relations.</p>
<p>

The reason SME does not match attributes is because it is trying to create connected knowledge based on relationships and thus satisfy the systematicity principle. For example, if both a clock and a car have inputgear attributes, SME will not mark them as similar. If it did, it would be making a match between the clock and car based on their appearance — not on the relationships between them.</p>
<p>

When the additional predicates in p3 and p4 are functions, the results from matching p3 and p4 are similar to the results from p1 and p2 except there is an additional match between gear and circuit and the values for the match hypotheses between (inputgear gear) and (switch circuit), and (secondgear gear) and (div10 circuit), are lower. The next section describes the reason for this in more detail.</p>
<p>

If the inputgear, secondgear, switch, and div10 are attributes instead of entities, SME does not find matches between any of the attributes. It finds matches only between the transmit predicates and between torque and signal. Additionally, the structural-evaluation scores for the remaining two matches decrease. In order to get the two predicates to match, p3 would need to be replaced by p5, which is demonstrated below.</p>
<p>

transmit torque (inputgear gear) (div10 gear)		(p5)</p>
<p>

Since the true-analogy rule set identifies that the div10 attributes are the same between p5 and p4 and because the div10 attributes are both part of the higher-relation match between torque and signal, SME makes a match between (div10 gear) and (div10 circuit) — which leads to a match between gear and circuit. </p>
<p>

Being part of a higher-order match is a requirement only for attributes. For example, if (div10 gear) and (div10 circuit) are not part of a higher-order match, SME does not create a match hypothesis between them. However, if div10 is a function or relation, SME does create a match.</p>

</sec>
<sec>
<st>
 Structural evaluation score </st>
<p>

Once the match hypotheses are generated, SME needs to compute an evaluation score for each hypothesis. SME does so by using a set of intern match rules to calculate positive and negative evidence for each match. Multiple amounts of evidence are correlated using Dempster’s rule [Shafer, 1978] resulting in positive and negative belief values between 0 and 1. The match rules assign different values for matches involving functions and relations. These values are programmable, however, and some default values that can be used to enforce the systematicity principle are described in [Falkenhainer et. al., 1989].</p>
<p>

These rules are:</p>
<p>

<list>
<entry level="1" type="number">

If the source and target are not functions and have the same order, the match gets +0.3 evidence. If the orders are within 1 of each other, the match gets +0.2 evidence and  -0.05 evidence.</entry>
<entry level="1" type="number">

If the source and target have the same functor, the match gets 0.2 evidence if the source is a function and 0.5 if the source is a relation.</entry>
<entry level="1" type="number">

If the arguments match, the match gets +0.4 evidence. The arguments might match if all the pairs of arguments between the source and target are entities, if the arguments have the same functors, or it is never the case that the target is an entity but the source is not. </entry>
<entry level="1" type="number">

 If the predicate type matches, but the elements in the predicate do not match, then the match gets -0.8 evidence.</entry>
<entry level="1" type="number">

 If the source and target expressions are part of a matching higher-order match, add 0.8 of the evidence for the higher-order match. </entry>
</list>
</p>
<p>

In the example match between p1 and p2, SME gives the match between the transmit relations a positive evidence value of 0.7900, and the others get values of 0.6320. The transmit relation receives the evidence value of 0.7900 because it gains evidence from rules 1, 3, and 2. The other matches get a value of 0.6320 because 0.8 of the evidence from the transmit is propagated to these matches because of rule 5.</p>
<p>

For predicates p3 and p4, SME assigns less evidence because the arguments of the transmit relations are functions. The transmit relation gets positive evidence of 0.65 because rule 3 no longer adds evidence. The match between (input gear) and (switch circuit) becomes 0.7120. This match gets 0.4 evidence because of rule 3, and 0.52 evidence propagated from the transmit relation because of rule 5.</p>
<p>

When the predicates in p3 and p4 are attributes, rule 4 adds -0.8 evidence to the transmit match because — though the functors of the transmit relation match — the arguments do not have the potential to match and the arguments are not functions.</p>
<p>

To summarize, the intern match rules compute a structural evaluation score for each match hypothesis. These rules enforce the systematicity principle. Rule 5 provides trickle-down evidence in order to strengthen matches that are involved in higher-order relations. Rules 1, 3. and 4 add or subtract support for relations that could have matching arguments. Rule 2 adds support for the cases when the functors match. thereby adding support for matches that emphasize relationships.</p>
<p>

The rules also enforce the difference between attributes, functions, and relations. For example, they have checks which give less evidence for functions than relations. Attributes are not specifically dealt with by the intern match rules, but SME’s filter rules ensure that they will only be considered for these rules if they are part of a higher-order relation, and rule 2 ensures that attributes will only match if they have identical functors.</p>

</sec>
<sec>
<st>
 Gmap creation </st>
<p>

The rest of the SME algorithm is involved in creating maximally consistent sets of match hypotheses. These sets are called gmaps. SME must ensure that any gmaps that it creates are structurally consistent; in other words, that they are one-to-one — such that no source maps to multiple targets and no target is mapped to multiple sources. The gmaps must also have support, which means that if a match hypothesis is in the gmap, then so are the match hypothesis that involve the source and target items.</p>
<p>

The gmap creation process follows two steps. First, SME computes information about each match hypothesis — including entity mappings, any conflicts with other hypotheses, and what other match hypotheses with which it might be structurally inconsistent.</p>
<p>

SME then uses this information to merge match hypotheses — using a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link> and the structural evaluation score. It merges the match hypotheses into maximally structurally consistent connected graphs of match hypotheses. Then it combines gmaps that have overlapping structure if they are structurally consistent. Finally, it combines independent gmaps together while maintaining structural consistency.</p>
<p>

Comparing a source to a target dgroup may produce one or more gmaps. The weight for each gmap is the sum of all the positive evidence values for all the match hypotheses involved in the gmap. For example, if a source containing p1 and p6 below, is compared to a target containing p2, SME will generate two gmaps. Both gmaps have a weight of 2.9186. </p>
<p>

Source:</p>
<p>

transmit torque inputgear secondgear   (p1)</p>
<p>

transmit torque secondgear thirdgear   (p6)</p>
<p>

Target:
transmit signal switch div10           (p2)</p>
<p>

These are the gmaps which result from comparing a source containing a p1 and p6 and a target containing p2.</p>
<p>

<b>Gmap No. 1:</b>    
(TORQUE SIGNAL)
(INPUTGEAR SWITCH)
(SECONDGEAR DIV10)
(*TRANSMIT-TORQUE-INPUTGEAR-SECONDGEAR *TRANSMIT-SIGNAL-SWITCH-DIV10)</p>
<p>

<b>Gmap No. 2</b>:
(TORQUE SIGNAL)
(SECONDGEAR SWITCH)
(THIRDGEAR DIV10)
(*TRANSMIT-TORQUE-SECONDGEAR-THIRDGEAR *TRANSMIT-SIGNAL-SWITCH-DIV10)</p>
<p>

The gmaps show pairs of predicates or entities that match. For example, in gmap  No. 1, the entities <it>torque</it> and <it>signal</it> match and the behaviors transmit torque inputgear secondgear and transmit signal switch div10 match. Gmap No. 1 represents combining p1 and p2. Gmap No. 2 represents combining p1 and p6. Although p2 is compatible with both p1 and p6, the one-to-one mapping constraint enforces that both mappings cannot be in the same gmap. Therefore, SME produces two independent gmaps. In addition, combining the two gmaps together would make the entity mappings between thirdgear and div10 conflict with the entity mapping between secondgear and div10.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.qrg.northwestern.edu/papers/papers.html#Analogy">
Papers by the Qualitative Reasoning Group at Northwestern University</weblink></entry>
<entry level="1" type="bullet">

 Falkenhainer, B: 2005, Structure Mapping Engine Implementation. <weblink xlink:type="simple" xlink:href="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/analogy/sme/0.html">
sme implementation</weblink></entry>
<entry level="1" type="bullet">

 Falkenhainer, B, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../167/507167.xml">
Forbus, K</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 and Gentner, D: 1989, <weblink xlink:type="simple" xlink:href="http://www.qrg.northwestern.edu/papers/Files/smeff2(searchable).pdf">
"The structure-mapping engine: Algorithm and examples"</weblink>. Artificial Intelligence, 20(41): 1–63.</entry>
<entry level="1" type="bullet">

 French, RM: 2002. <weblink xlink:type="simple" xlink:href="http://www.u-bourgogne.fr/LEAD/people/french/analogy.tics.pdf">
"The Computational Modeling of Analogy-Making"</weblink>. Trends in Cognitive Science, 6(5), 200-205.</entry>
<entry level="1" type="bullet">

 Gentner, D: 1983, <weblink xlink:type="simple" xlink:href="http://www.cogsci.rpi.edu/CSJarchive/1983v07/i02/p0155p0170/MAIN.PDF">
"Structure-mapping: A Theoretical Framework for Analogy"</weblink>, Cognitive Science 7(2)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../660/226660.xml">
Shafer, G</link>: 1978, <it>A Mathematical Theory of Evidence</it>, Princeton University Press, Princeton, New Jersey. ISBN 0691081751.</entry>
</list>
</p>

</sec>
</bdy>
</article>
