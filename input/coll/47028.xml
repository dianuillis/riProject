<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:42:34[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Painter&apos;s algorithm</title>
<id>47028</id>
<revision>
<id>231982529</id>
<timestamp>2008-08-14T21:44:44Z</timestamp>
<contributor>
<username>Quasirandom</username>
<id>4141735</id>
</contributor>
</revision>
<categories>
<category>Computer graphics algorithms</category>
<category>3D computer graphics</category>
</categories>
</header>
<bdy>

The <b>painter's algorithm</b>, also known as a <b>priority fill</b>, is one of the simplest solutions to the <link xlink:type="simple" xlink:href="../665/9331665.xml">
visibility problem</link> in <process wordnetid="100029677" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<phenomenon wordnetid="100034213" confidence="0.8">
<consequence wordnetid="111410625" confidence="0.8">
<link xlink:type="simple" xlink:href="../073/10175073.xml">
3D computer graphics</link></consequence>
</phenomenon>
</physical_entity>
</process>
. When projecting a 3D scene onto a 2D plane, it is necessary at some point to decide which <link xlink:type="simple" xlink:href="../621/23621.xml">
polygon</link>s are visible, and which are <link xlink:type="simple" xlink:href="../796/469796.xml">
hidden</link>.<p>

The name "painter's algorithm" refers to the technique employed by many painters of painting distant parts of a scene before parts which are nearer thereby covering some areas of distant parts. The painter's algorithm sorts all the polygons in a scene by their depth and then paints them in this order, furthest to closest. It will paint over the parts that are normally not visible -- thus solving the visibility problem -- at the cost of having painted redundant areas of distant objects.</p>
<p>

<image location="center" width="600px" src="Painter's_algorithm.png" type="thumb">
<caption>

The distant mountains are painted first, followed by the closer meadows; finally, the closest objects in this scene, the trees, are painted.
</caption>
</image>
</p>
<p>

<image location="right" width="150px" src="Painters_problem.svg" type="frame">
<caption>

Overlapping polygons can cause the algorithm to fail
</caption>
</image>
</p>
<p>

The algorithm can fail in certain cases. In this example, Polygons A, B, and C overlap each other. It's not possible to decide which polygon is above the others. In this case, the offending polygons must be cut to allow sorting. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link>
Newell's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, proposed in 1972, provides a method for cutting such polygons. Numerous methods have also been proposed in the field of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link>
computational geometry</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>
<p>

In basic implementations, the painter's algorithm can be inefficient.  It forces the system to <link xlink:type="simple" xlink:href="../604/6604.xml">
render</link> each point on every polygon in the visible set, even if that polygon is occluded in the finished scene. This means that, for detailed scenes, the painter's algorithm can overly tax the computer hardware.</p>
<p>

A <b>reverse painter's algorithm</b> is sometimes used, in which objects nearest to the viewer are painted first -- with the rule that paint must never be applied to parts of the image that are already painted.  In a computer graphic system, this can be very efficient, since it is not necessary to calculate the colors (using lighting, texturing and such) for parts of the more distant scene that are hidden by nearby objects.  However, the reverse algorithm suffers from many of the same problems as the standard version.</p>
<p>

These and other flaws with the algorithm led to the development of <link xlink:type="simple" xlink:href="../904/146904.xml">
Z-buffer</link> techniques, which can be viewed as a development of the painter's algorithm, by resolving depth conflicts on a pixel-by-pixel basis, reducing the need for a depth-based rendering order. Even in such systems, a variant of the painter's algorithm is sometimes employed. As Z-buffer implementations generally rely on fixed-precision depth-buffer registers implemented in hardware, there is scope for visibility problems due to rounding error. These are overlaps or gaps at joins between polygons.  To avoid this, some graphics engine implementations "overrender", drawing the affected edges of both polygons in the order given by painter's algorithm.  This means that some pixels are actually drawn twice (as in the full painters algorithm) but this happens on only small parts of the image and has a negligible performance effect.</p>


</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
