<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:08:03[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Stemming</title>
<id>475964</id>
<revision>
<id>224256281</id>
<timestamp>2008-07-08T00:51:29Z</timestamp>
<contributor>
<username>ILikeThings</username>
<id>1025343</id>
</contributor>
</revision>
<categories>
<category>Information retrieval</category>
<category>Natural language processing</category>
<category>Linguistic morphology</category>
</categories>
</header>
<bdy>

<b>Stemming</b> is the process for reducing inflected (or sometimes derived) words to their <unit_of_measurement wordnetid="113583724" confidence="0.8">
<definite_quantity wordnetid="113576101" confidence="0.8">
<link xlink:type="simple" xlink:href="../017/1316017.xml">
stem</link></definite_quantity>
</unit_of_measurement>
, base or <link xlink:type="simple" xlink:href="../211/264211.xml">
root</link> form &ndash; generally a written word form. The stem need not be identical to the <link xlink:type="simple" xlink:href="../211/264211.xml">
morphological root</link> of the word; it is usually sufficient that related words map to the same stem, even if this stem is not in itself a valid root. The <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> has been a long-standing problem in <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>; the first paper on the subject was published in <link xlink:type="simple" xlink:href="../655/34655.xml">
1968</link>. The process of stemming, often called <b><link xlink:type="simple" xlink:href="../499/1220499.xml">
conflation</link></b>, is useful in <link xlink:type="simple" xlink:href="../023/4059023.xml">
search engine</link>s for <link xlink:type="simple" xlink:href="../152/7872152.xml">
query expansion</link> or <link xlink:type="simple" xlink:href="../386/7602386.xml">
indexing</link> and other <link xlink:type="simple" xlink:href="../652/21652.xml">
natural language processing</link> problems.<p>

Stemming programs are commonly referred to as <b>stemming algorithms</b> or <b>stemmers</b>.</p>

<sec>
<st>
Examples</st>
<p>

A stemmer for <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../916/8569916.xml">
English</link></language>
, for example, should identify the <link xlink:type="simple" xlink:href="../706/199706.xml">
string</link> "cats" (and possibly "catlike", "catty" etc.) as based on the root "cat", and "stemmer", "stemming", "stemmed" as based on "stem". A stemming algorithm reduces the words "fishing", "fished", "fish", and "fisher" to the root word, "fish".</p>

</sec>
<sec>
<st>
History</st>
<p>

The first ever published stemmer was written by Julie Beth Lovins in 1968.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> This paper was remarkable for its early date and had great influence on later work in this area.</p>
<p>

A later stemmer was written by <link xlink:type="simple" xlink:href="../202/2883202.xml">
Martin Porter</link> and was published in the <link>
July 1980</link> issue of the journal <it>Program</it>. This stemmer was very widely used and became the de-facto standard algorithm used for English stemming.  Dr. Porter received the <symbol wordnetid="106806469" confidence="0.8">
<award wordnetid="106696483" confidence="0.8">
<signal wordnetid="106791372" confidence="0.8">
<link xlink:type="simple" xlink:href="../195/504195.xml">
Tony Kent Strix award</link></signal>
</award>
</symbol>
 in 2000 for his work on stemming and information retrieval.</p>
<p>

Many implementations of the Porter stemming algorithm were written and freely distributed; however, many of these implementations contained subtle flaws. As a result, these stemmers did not match their potential. To eliminate this source of error, Martin Porter released an official <weblink xlink:type="simple" xlink:href="http://tartarus.org/~martin/PorterStemmer/">
free-software implementation</weblink>of the algorithm around the year <link xlink:type="simple" xlink:href="../548/34548.xml">
2000</link>. He extended this work over the next few years by building <link xlink:type="simple" xlink:href="../808/919808.xml">
Snowball</link>, a framework for writing stemming algorithms, and implemented an improved English stemmer together with stemmers for several other languages.</p>

</sec>
<sec>
<st>
Algorithms</st>
<p>

There are several types of stemming algorithms which differ in respect to performance and accuracy and how certain stemming obstacles are overcome.</p>

<ss1>
<st>
Brute Force Algorithms</st>


<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../127/103127.xml">
Brute force</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 stemmers employ a lookup table which contains relations between root forms and inflected forms. To stem a word, the table is queried to find a matching inflection. If a matching inflection is found, the associated root form is returned.</p>
<p>

Brute force approaches are criticized for their general lack of elegance in that no algorithm is applied that would more quickly converge on a solution. In other words, there are more operations performed during the search than should be necessary. Brute force searches consume immense amounts of storage to host the list of relations (relative to the task). The algorithm is only accurate to the extent that the inflected form already exists in the table. Given the number of words in a given language, like English, it is unrealistic to expect that all word forms can be captured and manually recorded by human action alone. Manual training of the algorithm is overly time-intensive and the ratio between the effort and the increase in accuracy is marginal at best.</p>
<p>

Brute force algorithms do overcome some of the challenges faced by the other approaches. Not all inflected word forms in a given language "follow the rules" appropriately. While "running" might be easy to stem to "run" in a suffix stripping approach, the alternate inflection, "ran", is not. Suffix stripping algorithms are somewhat powerless to overcome this problem, short of increasing the number and complexity of the rules, but brute force algorithms only require storing a single extra relation between "run" and "ran". While that is true, this assumes someone bothered to store the relation in the first place, and one of the major problems of improving brute force algorithms is the coverage of the language.</p>
<p>

Brute force algorithms are initially very difficult to design given the immense amount of relations that must be initially stored to produce an acceptable level of accuracy (the number can span well into the millions). However, brute force algorithms are easy to improve in that decreasing the stemming error is only a matter of adding more relations to the table. Someone with only a minor experience in linguistics is capable of improving the algorithm, unlike the suffix stripping approaches which require a solid background in linguistics.</p>
<p>

For technical accuracy, some programs may use suffix stripping to generate the lookup table given a text corpus, and then only consult the lookup table when stemming. This is not regarded as a brute force approach, although a lookup table is involved.</p>

</ss1>
<ss1>
<st>
Suffix Stripping Algorithms</st>

<p>

Suffix stripping algorithms do not rely on a lookup table that consists of inflected forms and root form relations. Instead, a typically smaller list of "rules" are stored which provide a path for the algorithm, given an input word form, to find its root form. Some examples of the rules include:</p>
<p>

<list>
<entry level="1" type="bullet">

 if the word ends in 'ed', remove the 'ed'</entry>
<entry level="1" type="bullet">

 if the word ends in 'ing', remove the 'ing'</entry>
<entry level="1" type="bullet">

 if the word ends in 'ly', remove the 'ly'</entry>
</list>
</p>
<p>

Suffix stripping approaches enjoy the benefit of being much simpler to maintain than brute force algorithms, assuming the maintainer is sufficiently knowledgeable in the challenges of linguistics and morphology and encoding suffix stripping rules. Suffix stripping algorithms are sometimes regarded as crude given the poor performance when dealing with exceptional relations (like 'ran' and 'run'). The solutions produced by suffix stripping algorithms are limited to those <link xlink:type="simple" xlink:href="../059/45059.xml">
lexical categories</link> which have well known suffices with few exceptions. This, however, is a problem, as not all parts of speech have such a well formulated set of rules. Lemmatisation attempts to improve upon this challenge.</p>

</ss1>
<ss1>
<st>
Lemmatisation Algorithms</st>

<p>

A more complex approach to the problem of determining a stem of a word is <link xlink:type="simple" xlink:href="../223/504223.xml">
lemmatisation</link>. This process involves first determining the <link xlink:type="simple" xlink:href="../059/45059.xml">
part of speech</link> of a word, and applying different normalization rules for each part of speech. The part of speech is first detected prior to attempting to find the root since for some languages, the stemming rules change depending on a word's part of speech.</p>
<p>

This approach is highly conditional upon obtaining the correct lexical category (part of speech). While there is overlap between the normalization rules for certain categories, identifying the wrong category or being unable to produce the right category limits the added benefit of this approach over suffix stripping algorithms. The basic idea is that, if we are able to grasp more information about the word to be stemmed, then we are able to more accurately apply normalization rules (which are, more or less, suffix stripping rules).</p>

</ss1>
<ss1>
<st>
Stochastic Algorithms</st>

<p>

Stochastic algorithms involve using probability to identify the root form of a word. Stochastic algorithms are trained (they "learn") on a table of root form to inflected form relations to develop a probabilistic model. This model is typically expressed in the form of complex linguistic rules, similar in nature to those in suffix stripping or lemmatisation. Stemming is performed by inputting an inflected form to the trained model and having the model produce the root form according to its internal ruleset, which again is similar to suffix stripping and lemmatisation, except that the decisions involved in applying the most appropriate rule, or whether or not to stem the word and just return the same word, or whether to apply two different rules sequentially, are applied on the grounds that the output word will have the highest probability of being correct (which is to say, the smallest probability of being incorrect, which is how it is typically measured).</p>
<p>

Some lemmatisation algorithms are stochastic in that, given a word which may belong to multiple parts of speech, a probability is assigned to each possible part. This may take into account the surrounding words, called the context, or not. Context-free grammars do not take into account any additional information. In either case, after assigning the probabilities to each possible part of speech, the most likely part of speech is chosen, and from there the appropriate normalization rules are applied to the input word to produce the normalized (root) form.</p>

</ss1>
<ss1>
<st>
Hybrid Approaches</st>

<p>

Hybrid approaches use two or more of the approaches described above in unison. A simple example is a <link>
 suffix tree</link> algorithm which first consults a lookup table using brute force. However, instead of trying to store the entire set of relations between words in a given language, the lookup table is kept small and is only used to store a minute amount of "frequent exceptions" like "ran =&amp;gt; run". If the word is not in the exception list, apply suffix stripping or lemmatisation and output the result.</p>

</ss1>
<ss1>
<st>
Affix Stemmers</st>
<p>

In <link xlink:type="simple" xlink:href="../526/17526.xml">
linguistics</link>, the term <link xlink:type="simple" xlink:href="../835/1835.xml">
affix</link> refers to either a <link xlink:type="simple" xlink:href="../564/24564.xml">
prefix</link> or a <link xlink:type="simple" xlink:href="../386/5564386.xml">
suffix</link>. In addition to dealing with suffixes, several approaches also attempt to remove common prefixes. For example, given the word <it>indefinitely</it>, identify that the leading "in" is a prefix that can be removed. Many of the same approaches mentioned earlier apply, but go by the name <b>affix stripping</b>.</p>

</ss1>
<ss1>
<st>
Matching Algorithms</st>
<p>

Such algorithms use a stem database (for example a set of documents that contain stem words). These stems, as mentioned above, are not necessarily valid words themselves (but rather common sub-strings, as the "brows" in "browse" and in "browsing"). In order to stem a word the algorithm tries to match it with stems from the database, applying various constraints, such as on the relative length of the candidate stem within the word (so that, for example, the short prefix "be", which is the stem of such words as "be", "been" and "being", would not be considered as the stem of the word "beside").</p>

</ss1>
</sec>
<sec>
<st>
Language Challenges</st>
<p>

While much of the early academic work in this area was focused on the English language (with significant use of the Porter Stemmer algorithm), many other languages have been investigated.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>
<p>

Hebrew and Arabic are still considered difficult research languages for stemming. English stemmers are fairly trivial (with only occasional problems, such as "dries" being the third-person singular present form of the verb "dry", "axes" being the plural of "axe" as well as "axis"); but stemmers become harder to design as the morphology, orthography, and character encoding of the target language becomes more complex. For example, an Italian stemmer is more complex than an English one (because of more possible verb inflections), a Russian one is more complex (more possible noun declensions), a Hebrew one is even more complex (due to non-catenative morphology and a writing system without vowels), and so on.. </p>

<ss1>
<st>
Multilingual Stemming</st>
<p>

Multilingual stemming applies morphological rules of two or more languages simultaneously instead of rules for only a single language when interpreting a search query. Commercial systems using multilingual stemming exist.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</ss1>
</sec>
<sec>
<st>
Error metrics</st>
<p>

There are two error measurements in stemming algorithms, <b>overstemming</b> and <b>understemming</b>. Overstemming is an error where two separate inflected words are stemmed to the same root, but should not have been - a <link>
false positive</link>. Understemming is an error where two separate inflected words should be stemmed to the same root, but are not - a <link>
false negative</link>. Stemming algorithms attempt to minimize each type of error, although reducing one type can lead to increasing the other.</p>

</sec>
<sec>
<st>
Applications</st>

<ss1>
<st>
Information Retrieval</st>
<p>

Stemmers are common elements in <link xlink:type="simple" xlink:href="../271/15271.xml">
query systems</link> such as <invention wordnetid="105633385" confidence="0.8">
<link xlink:type="simple" xlink:href="../139/33139.xml">
Web</link></invention>
 <link xlink:type="simple" xlink:href="../023/4059023.xml">
search engine</link>s, since a user who runs a query on "daffodils" would probably also be interested in documents that contain the word "daffodil" (without the s). The effectiveness of stemming for English query systems were soon found to be rather limited, however, and this has led early <link xlink:type="simple" xlink:href="../271/15271.xml">
Information retrieval</link> researchers to deem stemming irrelevant in general.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> An alternative approach, based on searching for <link xlink:type="simple" xlink:href="../182/986182.xml">
n-gram</link>s rather than stems, may be used instead. Also, recent research has shown greater benefits for retrieval in other languages.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></p>

</ss1>
<ss1>
<st>
 Usage in commercial products </st>
<p>

Many commercial companies have been using stemming since at least the 1980's and have produced algorithmic and lexical stemmers in many languages.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></p>
<p>

The Snowball stemmers have been compared with commercial lexical stemmers with varying results.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></p>
<p>

<web_site wordnetid="106359193" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../431/12431.xml">
Google search</link></web_site>
 adopted word stemming in <link xlink:type="simple" xlink:href="../163/36163.xml">
2003</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref> Previously a search for "fish" would not have returned "fishing".  Other software search algorithms vary in their use of word stemming.  Programs that simply search for substrings obviously will find "fish" in "fishing" but when searching for "fishes" will not find occurrences of the word "fish".</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <unit_of_measurement wordnetid="113583724" confidence="0.8">
<definite_quantity wordnetid="113576101" confidence="0.8">
<link xlink:type="simple" xlink:href="../211/264211.xml">
Root (linguistics)</link></definite_quantity>
</unit_of_measurement>
 - linguistic definition of the term "root"</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../017/1316017.xml">
Stem (linguistics)</link> - linguistic definition of the term "stem"</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../646/20646.xml">
Morphology (linguistics)</link></entry>
<entry level="1" type="bullet">

 <unit_of_measurement wordnetid="113583724" confidence="0.8">
<definite_quantity wordnetid="113576101" confidence="0.8">
<link xlink:type="simple" xlink:href="../048/2639048.xml">
Lemma (linguistics)</link></definite_quantity>
</unit_of_measurement>
 - linguistic definition</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../223/504223.xml">
Lemmatization</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../492/18492.xml">
Lexeme</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../224/71224.xml">
Inflection</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../258/99258.xml">
Derivation</link> - stemming is a form of reverse derivation</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../652/21652.xml">
Natural language processing</link> - stemming is generally regarded as a form of NLP</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.8">
<application wordnetid="106570110" confidence="0.8">
<program wordnetid="106568978" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106359877" confidence="0.8">
<code wordnetid="106355894" confidence="0.8">
<coding_system wordnetid="106353757" confidence="0.8">
<link xlink:type="simple" xlink:href="../439/318439.xml">
Text mining</link></coding_system>
</code>
</writing>
</written_communication>
</program>
</application>
</software>
 - stemming algorithms play a major role in commercial NLP software</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../561/5561.xml">
Computational linguistics</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Julie Beth Lovins (1968). Development of a stemming algorithm. Mechanical Translation and Computational Linguistics <b>11</b>:22–31.</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.clef-campaign.org/2007/working_notes/DolamicCLEF2007.pdf">
http://www.clef-campaign.org/2007/working_notes/DolamicCLEF2007.pdf</weblink> Dolamic, Savoy: Stemming Approaches for East European Languages (CLEF 2007)</entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=1141277.1141523"></weblink>  Savoy:  Light stemming approaches for the French, Portuguese, German and Hungarian languages (SAC 2006) ISBN 1-59593-108-2</entry>
<entry id="4">
<weblink xlink:type="simple" xlink:href="http://www3.interscience.wiley.com/cgi-bin/abstract/10049677/ABSTRACT?CRETRY=1&amp;SRETRY=0">
http://www3.interscience.wiley.com/cgi-bin/abstract/10049677/ABSTRACT?CRETRY=1&amp;SRETRY=0</weblink> Popovic &amp; Willett:  The Effectiveness of Stemming for Natural-Language Access to Slovene Textual Data (1992) Journal of the <link xlink:type="simple" xlink:href="../076/1464076.xml">
American Society for Information Science</link></entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://staff.science.uva.nl/~mdr/Publications/Files/clef2005-proc-adhoc.pdf">
http://staff.science.uva.nl/~mdr/Publications/Files/clef2005-proc-adhoc.pdf</weblink> Stemming in Hungarian at CLEF 2005</entry>
<entry id="6">
<weblink xlink:type="simple" xlink:href="http://InformationR.net/ir/12-3/paper315.html">
http://InformationR.net/ir/12-3/paper315.html</weblink> Viera, A.F.G. &amp; Virgil, J.: Uma revisão dos algoritmos de radicalização em língua portuguesa (2007) Information Research, 12(3) paper 315.</entry>
<entry id="7">
<weblink xlink:type="simple" xlink:href="http://www.coveo.com/en/Support/articles/Information%20-%20CES4-060330-3%20-%20Understanding%20Stemming.htm">
"Understanding Stemming"</weblink>. Coveo Knowledge Base (2006)</entry>
<entry id="8">
Ricardo Baeza-Yates and Berthier Ribeiro-Neto (1999). <it>Modern Information Retrieval</it>. ACM Press/Addison Wesley.</entry>
<entry id="9">
Jaap Kamps, Christof Monz, Maarten de Rijke and Börkur Sigurbjörnsson (2004). Language-dependent and Language-independent Approaches to Cross-Lingual Text Retrieval. In: C. Peters, J. Gonzalo, M. Braschler and M. Kluck, eds. <it>Comparative Evaluation of Multilingual Information Access Systems</it>. Springer Verlag, pp. 152–165.</entry>
<entry id="10">
Eija Airio (2006). Word normalization and decompounding in mono- and bilingual IR. Information Retrieval <b>9</b>:249–271.</entry>
<entry id="11">
<weblink xlink:type="simple" xlink:href="http://www.dtsearch.com/CS_DeveloperTools.html#languages">
http://www.dtsearch.com/CS_DeveloperTools.html#languages</weblink> International Developer Tools. dtSearch</entry>
<entry id="12">
<weblink xlink:type="simple" xlink:href="http://technet2.microsoft.com/Office/en-us/library/87065c9d-d39d-479d-909b-02160ec6d7791033.mspx?mfr=true">
http://technet2.microsoft.com/Office/en-us/library/87065c9d-d39d-479d-909b-02160ec6d7791033.mspx?mfr=true</weblink> Building Multilingual Solutions by using Sharepoint Products and Technologies. Microsoft Technet</entry>
<entry id="13">
<weblink xlink:type="simple" xlink:href="http://www.clef-campaign.org/2003/WN_web/19.pdf">
 CLEF 2003: Stephen Tomlinson compared the Snowball stemmers with the Hummingbird lexical stemming (lemmatization) system.</weblink></entry>
<entry id="14">
<weblink xlink:type="simple" xlink:href="http://www.clef-campaign.org/2004/working_notes/WorkingNotes2004/21.pdf">
CLEF 2004: Stephen Tomlison "Finnish, Portuguese and Russian Retrieval with Hummingbird SearchServer"</weblink></entry>
<entry id="15">
<weblink xlink:type="simple" xlink:href="http://www.google.com/support/bin/static.py?page=searchguides.html&amp;ctx=basics#stemming">
The Essentials of Google Search</weblink>. Web Search Help Center. <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../923/1092923.xml">
Google Inc.</link></company>
</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading </st>

<p>

<list>
<entry level="1" type="bullet">

 Dawson, J.L. (1974) <it>Suffix Removal for Word Conflation</it>, Bulletin of the Association for Literary and Linguistic Computing, 2(3): 33-46</entry>
<entry level="1" type="bullet">

 Frakes, W.B. (1984) <it>Term Conflation for Information Retrieval</it>, Cambridge University Press</entry>
<entry level="1" type="bullet">

 Frakes, W.B. &amp; Fox, C.J. (2003) <it>Strength and Similarity of Affix Removal Stemming Algorithms</it>, SIGIR Forum, 37: 26-30</entry>
<entry level="1" type="bullet">

 Frakes, W. B. (1992) <it>Stemming algorithms, Information retrieval: data structures and algorithms</it>, Prentice-Hall, Inc., Upper Saddle River, NJ</entry>
<entry level="1" type="bullet">

 Hafer, M.A. &amp; Weiss, S.F., (1974) <it>Word segmentation by letter successor varieties</it>, Information Processing &amp; Management 10 (11/12), 371-386.</entry>
<entry level="1" type="bullet">

 Harman, D., (1991) <it>How effective is suffixing?</it> Journal of the American Society for Information Science 42 (1), 7-15.</entry>
<entry level="1" type="bullet">

 Hull, D.A. (1996) <it>Stemming Algorithms – A Case Study for Detailed Evaluation</it>, JASIS, 47(1): 70-84</entry>
<entry level="1" type="bullet">

 Hull, D.A. &amp; Grefenstette, G. (1996) A<it> Detailed Analysis of English Stemming Algorithms</it>, Xerox Technical Report</entry>
<entry level="1" type="bullet">

 Kraaij, W. &amp; Pohlmann, R., 1996: <it>Viewing stemming as recall enhancement</it>, in H-P. Frei, D. Harman, P. Schauble &amp; R. Wilkinson (eds.), Proceedings of the 17th ACM SIGIR conference held at Zurich, August 18-22, pp.40-48.</entry>
<entry level="1" type="bullet">

 Krovetz, R. (1993) <it>Viewing Morphology as an Inference Process</it>, In Proceedings of ACM-SIGIR93, pp191-203</entry>
<entry level="1" type="bullet">

 Lennon, M., Pierce, D.S., Tarry, B.D. &amp; Willett, P. (1981) <it>An Evaluation of some Conflation Algorithms for Information Retrieval</it>, Journal of Information Science, 3: 177-183</entry>
<entry level="1" type="bullet">

 Lovins, J. (1971) <it><weblink xlink:type="simple" xlink:href="http://www.eric.ed.gov/sitemap/html_0900000b800c571a.html">
Error Evaluation for Stemming Algorithms as Clustering Algorithms</weblink></it>, JASIS, 22: 28-40</entry>
<entry level="1" type="bullet">

 Lovins, J. B. "Development of a Stemming Algorithm." Mechanical Translation and Computational Linguistics 11, 1968, 22--31. </entry>
<entry level="1" type="bullet">

 Marie-Claire, J. and Smith, D. (2005) <it>Conservative stemming for search and indexing''</it></entry>
<entry level="1" type="bullet">

 Paice, C.D. (1990) <it><weblink xlink:type="simple" xlink:href="http://www.comp.lancs.ac.uk/computing/research/stemming/paice/article.htm">
Another Stemmer</weblink></it>, SIGIR Forum, 24: 56-61</entry>
<entry level="1" type="bullet">

 Paice, C.D. (1996) <it><weblink xlink:type="simple" xlink:href="http://www3.interscience.wiley.com/cgi-bin/abstract/57804/ABSTRACT">
Method for Evaluation of Stemming Algorithms based on Error Counting</weblink></it>, JASIS, 47(8): 632-649</entry>
<entry level="1" type="bullet">

 Popovic, M. and Willett, P., (1992) <it><weblink xlink:type="simple" xlink:href="http://www3.interscience.wiley.com/cgi-bin/abstract/10049677/ABSTRACT">
The effectiveness of stemmng for natural language access to Slovene textual data</weblink></it>, Journal of the American Society for Information Science, 43(5), 384-390.</entry>
<entry level="1" type="bullet">

 Porter, M.F. (1980) <it><weblink xlink:type="simple" xlink:href="http://telemat.det.unifi.it/book/2001/wchange/download/stem_porter.html">
An Algorithm for Suffix Stripping</weblink></it>, Program, 14(3): 130-137</entry>
<entry level="1" type="bullet">

 Savoy, J., (1993) <it><weblink xlink:type="simple" xlink:href="http://www3.interscience.wiley.com/cgi-bin/abstract/10049824/ABSTRACT?CRETRY=1&amp;SRETRY=0">
Stemming of French words based on grammatical categories</weblink></it> Journal of the American Society for Information Science, 44(1), 1-9.</entry>
<entry level="1" type="bullet">

 Ulmschneider, J.E. &amp; Doszkocs, (1983) <it><weblink xlink:type="simple" xlink:href="http://www.eric.ed.gov/sitemap/html_0900000b8007ea83.html">
A practical stemming algorithm for online search assistance</weblink></it>, Online Review, 7(4), 301-318.</entry>
<entry level="1" type="bullet">

 Xu, J. &amp; Croft, W.B., (1998) <it><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=267954.267957">
Corpus-based stemming using coocurrence of word variants</weblink></it>, ACM Transactions on Information Systems, 16(1), 61-81.</entry>
</list>
</p>


</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://code.google.com/p/ir-themis/">
Themis</weblink> - open source IR framework, includes Porter stemmer implementation (PostgreSQL, Java API)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.utilitymill.com/utility/Porter_Stemming_Algorithm">
Web based Porter Stemming Algorithm implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://maya.cs.depaul.edu/~classes/ds575/porter.html">
Another web based Porter Stemming Algorithm implementation</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://snowball.tartarus.org">
Snowball</weblink> - free stemming algorithms for many languages, includes source code, including stemmers for five romance languages</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.locknet.ro/projects/ann-ruby-stemmer">
Ruby-Stemmer</weblink> - Ruby extension to Snowball API</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://pecl.php.net/package/stem/">
PECL</weblink> - PHP extension to the Snowball API</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.oleandersolutions.com/stemming.html">
Oleander Porter's algorithm</weblink> - stemming library in C++ released under BSD</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.waikato.ac.nz/~eibe/stemmers/index.html">
Unofficial home page of the Lovins stemming algorithm</weblink> - with source code in a couple of languages</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.tartarus.org/~martin/PorterStemmer/index.html">
Official home page of the Porter stemming algorithm</weblink> - including source code in several languages</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.comp.lancs.ac.uk/computing/research/stemming/index.htm">
Official home page of the Lancaster stemming algorithm</weblink> - Lancaster University, UK</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cmp.uea.ac.uk/Research/stemmer/">
Official home page of the UEA-Lite Stemmer </weblink> - University of East Anglia, UK</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.comp.lancs.ac.uk/computing/research/stemming/general/index.htm">
Overview of stemming algorithms</weblink></entry>
</list>
</p>
<p>

<it>This article was originally based on material from the <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<wordbook wordnetid="106418693" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<dictionary wordnetid="106418901" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../324/11324.xml">
Free On-line Dictionary of Computing</link></publication>
</reference_book>
</dictionary>
</book>
</wordbook>
</artifact>
</creation>
</product>
</work>
, which is  under the <link xlink:type="simple" xlink:href="../782/18938782.xml">
GFDL</link>.</it></p>


</sec>
</bdy>
</article>
