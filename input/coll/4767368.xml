<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:23:40[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Freivald&apos;s algorithm</title>
<id>4767368</id>
<revision>
<id>243690833</id>
<timestamp>2008-10-07T17:12:03Z</timestamp>
<contributor>
<username>Giftlite</username>
<id>37986</id>
</contributor>
</revision>
<categories>
<category>Articles containing proofs</category>
<category>Numerical linear algebra</category>
<category>Matrix theory</category>
</categories>
</header>
<bdy>

<b>Freivald's algorithm</b> is a <link xlink:type="simple" xlink:href="../383/495383.xml">
randomized algorithm</link> used to verify <link xlink:type="simple" xlink:href="../280/125280.xml">
matrix multiplication</link>. Given three <it>n</it> x <it>n</it> <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrices</link> <it>A</it>, <it>B</it>, and <it>C</it>, a general problem is to verify whether <it>A</it> x <it>B</it> = <it>C</it>. A naïve <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> would compute the product <it>A</it> x <it>B</it> explicitly and compare term by term whether this product equals <it>C</it>. However, this approach takes <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>3) time. To resolve this, Freivald's algorithm utilizes <link xlink:type="simple" xlink:href="../462/65462.xml">
randomization</link> in order to reduce this time bound to <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>2).
<sec>
<st>
The Algorithm</st>

<ss1>
<st>
Input</st>
<p>
 
Three <it>n</it> x <it>n</it> <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrices</link> <it>A</it>, <it>B</it>, <it>C</it>.
</p>
</ss1>
<ss1>
<st>
Output</st>
<p>
 
Yes, if <it>A</it> x <it>B</it> = <it>C</it>; No, otherwise.
</p>
</ss1>
<ss1>
<st>
Procedure</st>

<p>

Generate an <it>n</it> x 1 <link xlink:type="simple" xlink:href="../523/19196523.xml">
random</link> 0/1 <link xlink:type="simple" xlink:href="../533/32533.xml">
vector</link> <math>\vec{r}</math>.
Compute <math>\vec{P} = A \times (B \vec{r}) - C\vec{r}</math>.
Output "Yes" if <math>\vec{P} = (0,0,\ldots,0)^T</math>; "No," otherwise.</p>


</ss1>
</sec>
<sec>
<st>
Error Analysis</st>
<p>

Let <it>p</it> equal the <link xlink:type="simple" xlink:href="../934/22934.xml">
probability</link> of error. We claim that if <it>A</it> x <it>B</it> = <it>C</it>, then <it>p</it> = 0, and if <it>A</it> x <it>B</it> ≠ <it>C</it>, then <it>p</it> ≤ 1/2.</p>

<ss1>
<st>
<it>A</it> x <it>B</it> = <it>C'</it></st>
<p>
=
If <it>A</it> x <it>B</it> = <it>C</it>, then <it>A</it> x <it>B</it> &amp;minus; <it>C</it> = 0, and so <math>\vec{P} = A \times (B \vec{r}) - C \vec{r} = (A \times B)\vec{r} - C\vec{r} = (A \times B - C)\vec{r} = \vec{0}</math>, regardless of what our <link xlink:type="simple" xlink:href="../533/32533.xml">
vector</link> <math>\vec{r}</math> was.</p>

</ss1>
<ss1>
<st>
<it>A</it> x <it>B</it> ≠ <it>C''</it></st>
<p>

Let <math>D = A \times B - C = (d_{ij})</math>, so <math>\vec{P} = D \times \vec{r} = (p_1, p_2, ..., p_n)^T</math>.
Since <it>A</it> x <it>B</it> ≠ <it>C</it>, we have <it>A</it> x <it>B</it> &amp;minus; <it>C</it> ≠ 0, so some element of <it>D</it> is nonzero.</p>
<p>

Suppose that the element <math>d_{ij} \neq 0</math>. 
By the definition of <link xlink:type="simple" xlink:href="../280/125280.xml">
matrix multiplication</link>, we have <math>p_i = \sum_{k = 1}^n d_{ik}r_k =

d_{i1}r_1 + \ldots + d_{ij}r_j + \ldots + d_{in}r_n = d_{ij}r_j + y</math>.</p>
<p>

Using <link xlink:type="simple" xlink:href="../569/49569.xml">
Bayes' Theorem</link>, we have <math>Pr[p_i = 0] = Pr[p_i = 0 | y = 0]\cdot Pr[y = 0] + Pr[p_i = 0 | y \neq 0] \cdot Pr[y \neq 0]</math>.</p>
<p>

Also, note that:
<indent level="1">

<math>Pr[p_i = 0 | y = 0] = Pr[r_j = 0] = \frac{1}{2}</math>
</indent>
:<math>Pr[p_i = 0 | y \neq 0] \leq Pr[r_j = 1] = \frac{1}{2}</math></p>
<p>

Plugging these in the above equation, we have:</p>
<p>

<indent level="1">

<math>Pr[p_i = 0] \leq \frac{1}{2}\cdot Pr[y = 0] + \frac{1}{2}\cdot Pr[y \neq 0]</math>
</indent>
:<math>Pr[p_i = 0] \leq \frac{1}{2}\cdot Pr[y = 0] + \frac{1}{2}\cdot (1 - Pr[y = 0])</math>
<indent level="1">

<math>Pr[p_i = 0] \leq \frac{1}{2}</math>
</indent>

Therefore, 
<indent level="1">

<math>Pr[\vec{P} = 0] \leq Pr[p_i = 0] \leq \frac{1}{2}</math>.
</indent>
This completes the proof.</p>

</ss1>
</sec>
<sec>
<st>
Ramifications</st>
<p>

Simple algorithmic analysis shows that the running time of this <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>2), beating the classical <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic algorithm's</link> bound of <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>3). The error analysis also shows that if we run our <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> <it>k</it> times, we can achieve an error bound of less than <math>\frac{1}{2^k}</math>, an exponentially small quantity. Therefore, utilization of <link xlink:type="simple" xlink:href="../383/495383.xml">
randomized algorithms</link> can speed up a very slow <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic algorithm</link>. In fact, the best known deterministic matrix multiplication verification algorithm known at the current time is the <link xlink:type="simple" xlink:href="../509/2420509.xml">
Coppersmith-Winograd algorithm</link> with an asymptotic running time of <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>2.376).</p>

</sec>
</bdy>
</article>
