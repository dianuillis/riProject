<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:08:45[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Canny edge detector</title>
<id>476817</id>
<revision>
<id>239505188</id>
<timestamp>2008-09-19T08:50:55Z</timestamp>
<contributor>
<username>Charles Matthews</username>
<id>12978</id>
</contributor>
</revision>
<categories>
<category>Computer vision</category>
<category>Image processing</category>
</categories>
</header>
<bdy>

The <b>Canny</b> <link xlink:type="simple" xlink:href="../680/331680.xml">
edge detection</link> operator was developed by <link>
John F. Canny</link> in 1986 and uses a multi-stage <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> to detect a wide range of edges in images.  Most importantly, Canny also produced a <it>computational theory of edge detection</it> explaining why the technique works.<p>

<image location="right" width="300px" src="Valve_monochrome_canny_(6).PNG" type="thumb">
<caption>

The Canny edge detector applied to a colour photograph of a steam engine. (See the original image <weblink xlink:type="simple" xlink:href="http://en.wikipedia.org/wiki/Image:Valve_original_(1).PNG">
here</weblink>)
</caption>
</image>
</p>

<sec>
<st>
 Development of the Canny algorithm </st>

<p>

Canny's aim was to discover the optimal edge detection algorithm.  In this situation, an "optimal" edge detector means:
<list>
<entry level="1" type="bullet">

 <it>good <link xlink:type="simple" xlink:href="../935/42935.xml">
detection</link></it> - the algorithm should mark as many real edges in the image as possible.</entry>
<entry level="1" type="bullet">

 <it>good <link xlink:type="simple" xlink:href="../843/126843.xml">
localization</link></it> - edges marked should be as close as possible to the edge in the real image.</entry>
<entry level="1" type="bullet">

 <it>minimal response</it> - a given edge in the image should only be marked once, and where possible, image noise should not create false edges.</entry>
</list>
</p>
<p>

To satisfy these requirements Canny used the <link xlink:type="simple" xlink:href="../882/171882.xml">
calculus of variations</link> - a technique which finds the <link xlink:type="simple" xlink:href="../427/185427.xml">
function</link> which optimizes a given <link xlink:type="simple" xlink:href="../948/1374948.xml">
functional</link>.  The optimal function in Canny's detector is described by the sum of four <link xlink:type="simple" xlink:href="../678/9678.xml">
exponential</link> terms, but can be approximated by the first <link xlink:type="simple" xlink:href="../921/7921.xml">
derivative</link> of a <link xlink:type="simple" xlink:href="../552/245552.xml">
Gaussian</link>.</p>

</sec>
<sec>
<st>
 Stages of the Canny algorithm </st>


<ss1>
<st>
 <link xlink:type="simple" xlink:href="../836/476836.xml">
Noise reduction</link> </st>

<p>

<image location="right" width="200px" src="Valve_gaussian_(2).PNG" type="thumb">
<caption>

The image after a 5x5 Gaussian mask has been passed across each pixel.
</caption>
</image>
</p>
<p>

Because the Canny edge detector uses a filter based on the first derivative of a Gaussian, it is susceptible to noise present on raw unprocessed image data, so to begin with, the raw image is <link xlink:type="simple" xlink:href="../519/7519.xml">
convolved</link> with a Gaussian filter.  The result is as a slightly <link>
blurred</link> version of the original which is not affected by a single noisy pixel to any significant degree.</p>
<p>

Here is an example of a 5x5 Gaussian filter, used to create the image to the right, with <math>\sigma</math> = 0.4:</p>
<p>

<indent level="1">

<math>
\mathbf{B} = \frac{1}{159} \begin{bmatrix} 
2 &amp; 4 &amp; 5 &amp; 4 &amp; 2 \\
4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
5 &amp; 12 &amp; 15 &amp; 12 &amp; 5 \\
4 &amp; 9 &amp; 12 &amp; 9 &amp; 4 \\
2 &amp; 4 &amp; 5 &amp; 4 &amp; 2
\end{bmatrix} * \mathbf{A}
</math>
</indent>

</p>
</ss1>
<ss1>
<st>
 Finding the intensity gradient of the image </st>

<p>

<image location="left" width="200px" src="Valve_sobel_with_angle_colour_(4).PNG" type="thumb">
<caption>

A binary edge map, derived from the Sobel operator, with a threshold of  80. The edges are coloured to indicate the edge direction: yellow for zero degrees, green for 45 degrees, blue for 90 degrees and red for 135 degrees.
</caption>
</image>
</p>
<p>

An edge in an image may point in a variety of directions, so the Canny algorithm uses four filters to detect horizontal, vertical and diagonal edges in the blurred image.  The edge detection operator (Roberts, Prewitt, Sobel for example) returns a value for the first derivative in the horizontal direction (Gy) and the vertical direction (Gx). From this the edge gradient and direction can be determined: </p>
<p>

<math>\mathbf{G} = \sqrt{ {\mathbf{G}_x}^2 + {\mathbf{G}_y}^2 }</math></p>
<p>

<math>\mathbf{\Theta} = \operatorname{arctan}\left({ \mathbf{G}_y \over \mathbf{G}_x }\right)</math></p>
<p>

The edge direction angle is rounded to one of four angles representing vertical, horizontal and the two diagonals (0, 45, 90 and 135 degrees for example).</p>

</ss1>
<ss1>
<st>
 Non-maximum suppression </st>

<p>

<image location="right" width="200px" src="Valve_canny_with_angle_colour_(7).PNG" type="thumb">
<caption>

 The same binary map shown on the left after non-maxima suppression. The edges are still coloured to indicate direction.
</caption>
</image>
</p>
<p>

Given estimates of the image gradients, a search is then carried out to determine if the gradient magnitude assumes a local maximum in the gradient direction. So, for example,
<list>
<entry level="1" type="bullet">

 if the rounded angle is zero degrees the point will be considered to be on the edge if its intensity is greater than the intensities in the north and south directions,</entry>
<entry level="1" type="bullet">

 if the rounded angle is 90 degrees the point will be considered to be on the edge if its intensity is greater than the intensities in the east and west directions,</entry>
<entry level="1" type="bullet">

 if the rounded angle is 135 degrees the point will be considered to be on the edge if its intensity is greater than the intensities in the north east and south west directions,</entry>
<entry level="1" type="bullet">

 if the rounded angle is 45 degrees the point will be considered to be on the edge if its intensity is greater than the intensities in the south east and north west directions.</entry>
</list>

This is worked out by passing a 3x3 grid over the intensity map. </p>
<p>

From this stage referred to as non-maximum suppression, a set of edge points, in the form of a <link xlink:type="simple" xlink:href="../923/97923.xml">
binary image</link>, is obtained.  These are sometimes referred to as "thin edges".</p>

</ss1>
<ss1>
<st>
 Tracing edges through the image and hysteresis thresholding </st>

<p>

Intensity gradients which are large are more likely to correspond to edges than if they are small.  It is in most cases impossible to specify a threshold at which a given intensity gradient switches from corresponding to an edge into not doing so.  Therefore Canny uses thresholding with <link xlink:type="simple" xlink:href="../003/147003.xml">
hysteresis</link>.</p>
<p>

Thresholding with hysteresis requires two thresholds - high and low.  Making the assumption that important edges should be along continuous curves in the image allows us to follow a faint section of a given line and to discard a few noisy pixels that do not constitute a line but have produced large gradients.  Therefore we begin by applying a high threshold.  This marks out the edges we can be fairly sure are genuine.  Starting from these, using the directional information derived earlier, edges can be traced through the image.  While tracing an edge, we apply the lower threshold, allowing us to trace faint sections of edges as long as we find a starting point.</p>
<p>

Once this process is complete we have a binary image where each pixel is marked as either an edge pixel or a non-edge pixel. From complementary output from the edge tracing step, the binary edge map obtained in this way can also be treated as a set of edge curves, which after further processing can be represented as polygons in the image domain.</p>

</ss1>
<ss1>
<st>
 Differential geometric formulation of the Canny edge detector </st>

<p>

A more refined approach to obtain edges with sub-pixel accuracy is by using the approach of <link xlink:type="simple" xlink:href="../680/331680.xml#xpointer(//*[./st=%22Differential+edge+detection%22])">
differential edge detection</link>, where the requirement of non-maximum suppression is formulated in terms of second- and third-order derivatives computed from a <link xlink:type="simple" xlink:href="../661/1703661.xml">
scale-space</link> representation (Lindeberg 1998) -- see the article on <link xlink:type="simple" xlink:href="../680/331680.xml#xpointer(//*[./st=%22Differential+edge+detection%22])">
edge detection</link> for a detailed description.</p>

</ss1>
</sec>
<sec>
<st>
 Parameters </st>

<p>

The Canny algorithm contains a number of adjustable parameters, which can affect the computation time and effectiveness of the algorithm.</p>
<p>

<list>
<entry level="1" type="bullet">

 The size of the Gaussian filter: the smoothing filter used in the first stage directly affects the results of the Canny algorithm.  Smaller filters cause less blurring, and allow detection of small, sharp lines.  A larger filter causes more blurring, smearing out the value of a given pixel over a larger area of the image.  Larger blurring <link xlink:type="simple" xlink:href="../815/1780815.xml">
radii</link> are more useful for detecting larger, smoother edges - for instance, the edge of a rainbow.</entry>
<entry level="1" type="bullet">

 Thresholds: the use of two thresholds with hysteresis allows more flexibility than in a single-threshold approach, but general problems of thresholding approaches still apply.  A threshold set too high can miss important information.  On the other hand, a threshold set too low will falsely identify irrelevant information (such as noise) as important.  It is difficult to give a generic threshold that works well on all images.  No tried and tested approach to this problem yet exists.</entry>
</list>
</p>
<p>

To experiment with the parameters of the Canny algorithm, the on-line Canny application on http://matlabserver.cs.rug.nl can be useful.</p>

</sec>
<sec>
<st>
 Conclusion </st>

<p>

The Canny algorithm is adaptable to various environments.  Its parameters allow it to be tailored to recognition of edges of differing characteristics depending on the particular requirements of a given implementation. In Canny's original paper, the derivation of the optimal filter led to a <link xlink:type="simple" xlink:href="../101/443101.xml">
Finite Impulse Response</link> filter, which can be slow to compute in the spatial domain if the amount of smoothing required is important (the filter will have a large spatial support in that case). For this reason, it is often suggested to use <link>
Rachid Deriche</link>'s <link xlink:type="simple" xlink:href="../140/570140.xml">
Infinite Impulse Response</link>  form of Canny's filter (the Canny-Deriche detector), which is recursive, and which can be computed in a short, fixed amount of time for any desired amount of smoothing. The second form is suitable for real time implementations in <link xlink:type="simple" xlink:href="../814/592814.xml">
FPGA</link>s or <link xlink:type="simple" xlink:href="../020/44020.xml">
DSP</link>s, or very fast embedded PCs. In this context, however, the regular recursive implementation of the Canny operator does not give a good approximation of rotational symmetry and therefore gives a bias towards horizontal and vertical edges.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 Canny, J., <it>A Computational Approach To Edge Detection</it>, IEEE Trans. Pattern Analysis and Machine Intelligence, 8:679-714, 1986.</entry>
<entry level="1" type="bullet">

 R. Deriche, <it>Using Canny's criteria to derive an optimal edge detector recursively implemented</it>, Int. J. Computer Vision, Vol. 1, pp. 167-187, April 1987.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nada.kth.se/cvap/abstracts/cvap191.html">
Lindeberg, Tony "Edge detection and ridge detection with automatic scale selection", International Journal of Computer Vision, 30, 2, pp 117--154, 1998. (Includes the differential approach to non-maximum suppression.)</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../680/331680.xml">
Edge detection</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../224/1284224.xml">
Feature detection (computer vision)</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../190/242190.xml">
Feature extraction</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../661/1703661.xml">
Scale space</link></entry>
<entry level="1" type="bullet">

<mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../898/6185898.xml">
Ridge detection</link></function>
</mathematical_relation>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../596/6596.xml">
Computer vision</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../922/97922.xml">
Digital image processing</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.berkeley.edu/~jfc/">
John Canny's home page</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://matlabserver.cs.rug.nl/">
On-line Canny edge detector</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.tomgibara.com/computer-vision/canny-edge-detector">
Free Java implementation of Canny edge detector</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-sop.inria.fr/odyssee/team/Rachid.Deriche/Publications/RD.references.html">
Publication List of Rachid Deriche</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
