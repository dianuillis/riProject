<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:09:34[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<change_of_state  confidence="0.8" wordnetid="100199130">
<event  confidence="0.8" wordnetid="100029378">
<change  confidence="0.8" wordnetid="100191142">
<improvement  confidence="0.8" wordnetid="100248977">
<action  confidence="0.8" wordnetid="100037396">
<optimization  confidence="0.8" wordnetid="100260051">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<header>
<title>Register allocation</title>
<id>485122</id>
<revision>
<id>242490623</id>
<timestamp>2008-10-02T13:28:51Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Compiler optimizations</category>
</categories>
</header>
<bdy>
<p>

In <link xlink:type="simple" xlink:href="../355/40355.xml">
compiler optimization</link>, <b>register allocation</b> is the process of <link xlink:type="simple" xlink:href="../389/41389.xml">
multiplexing</link> a large number of target program <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s onto a small number of <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> <link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link>. The goal is to keep as many operands as possible in registers to maximise the execution speed of software programs. Register allocation can happen over a <link xlink:type="simple" xlink:href="../706/218706.xml">
basic block</link> (<it>local register allocation</it>), over a whole function/procedure (<it>global register allocation</it>), or in-between functions as a <link xlink:type="simple" xlink:href="../571/1795571.xml">
calling convention</link> (<it>interprocedural register allocation</it>).</p>
<p>

Most <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s need to process large numbers of different data items. However, most CPUs can only perform operations on a small fixed number of "slots" called registers. Even on machines that support memory operands, register access is considerably faster than memory access. Variables not allocated to registers must be loaded in and out of <link xlink:type="simple" xlink:href="../847/25847.xml">
RAM</link> whenever they are used.</p>
<p>

<it>Register spilling</it> occurs where there are more live variables than the machine has registers. When a <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> is generating <link xlink:type="simple" xlink:href="../683/20683.xml">
machine code</link> and there are more live variables than the machine has <register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link></written_record>
</evidence>
</indication>
</record>
</register>
, it has to transfer or "spill" some <link xlink:type="simple" xlink:href="../818/32818.xml">
variables</link> from <register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link></written_record>
</evidence>
</indication>
</record>
</register>
 to <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link>. This incurs a certain cost, as access from memory is typically slower than access from a register.</p>
<p>

In <link xlink:type="simple" xlink:href="../739/5739.xml">
compilers</link>, <it>register pressure</it> occurs when there are more variables to  allocate than there are <link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link> available. This typically results in register spilling.</p>

<sec>
<st>
Challenges </st>
<p>

Register allocation is an <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 problem.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> The number of variables in a typical program is much larger than the number of available registers in a processor, so the contents of some variables have to be <link xlink:type="simple" xlink:href="../122/485122.xml">
spilled</link> (saved) into memory locations. The cost of such spilling is minimised by spilling the least frequently used variables first, but it is not easy to know which variables will be used the least. In addition to this the hardware and <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> may impose restrictions on the usage of some registers.</p>

</sec>
<sec>
<st>
Global register allocation</st>
<p>

Like most other <link xlink:type="simple" xlink:href="../355/40355.xml">
compiler optimization</link>s, register allocation is based on the result of some <link>
compiler analysis</link>, typically one of <link xlink:type="simple" xlink:href="../356/4051356.xml">
live variable analysis</link>, a form of <link xlink:type="simple" xlink:href="../951/826951.xml">
data flow analysis</link>, or the construction
of <link xlink:type="simple" xlink:href="../371/373371.xml">
static single assignment form</link>, which encodes similar information into the name space of the code.</p>
<p>

<it>Global register allocators</it>, which consider an entire procedure, have been built using several 
paradigms, including bin packing (e.g., the DEC VAX compilers), priority-based <link xlink:type="simple" xlink:href="../743/426743.xml">
graph coloring</link> (e.g.,
Chow-style allocators), and bottom-up graph coloring (e.g., Chaitin-style allocators). 
Of these approaches, the Chaitin-style allocators appear to be most common.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../619/1778619.xml">
Chaitin's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 can be divided into two phases:
<list>
<entry level="1" type="number">

 Machine instructions are generated as if there are an infinite number of symbolic registers. So all variables suitable to being in registers will be assigned to numbered logical registers. The phase is sometimes called <it>register variable recognition</it>.</entry>
<entry level="1" type="number">

 symbolic registers are replaced by physical registers in a target machine, with the minimum cost of <link xlink:type="simple" xlink:href="../122/485122.xml">
spills</link>.</entry>
</list>
</p>
<p>

In phase two, an <it>interference graph</it> is constructed where nodes are symbolic registers (created in the previous phase) and an arc connects two nodes if they are alive at the same time. More precisely, if one variable is alive at the time the other is defined then they are said to interfere. If the graph can be colored with <it>R</it> colors then the variables can be stored in <it>R</it> registers. This insight was pointed out by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../915/301915.xml">
John Cocke</link></scientist>
</person>
, "father of the RISC architecture". The problem is that coloring a graph is an NP-hard problem. </p>
<p>

The key insight to Chaitin’s algorithm is called the <it>degree  R</it> rule which is as follows. Given a graph <it>G</it> which contains a node <it>N</it> with degree less than <it>R</it>, <it>G</it> is <it>R</it>-colorable <link xlink:type="simple" xlink:href="../922/14922.xml">
iff</link> the graph <it>G’</it>, where <it>G’</it> is <it>G</it> with node <it>N</it> removed, is <it>R</it>-colorable. The proof is obvious in one direction: if a graph <it>G</it> can be colored with <it>R</it> colors then the graph <it>G’</it> can be created without changing the coloring. In the other direction, suppose we have an <it>R</it>-coloring of <it>G’</it>. Since <it>N</it> has a degree of less than <it>R</it> there must be at least one color that is not in use for a node adjacent to <it>N</it>. We can color <it>N</it> with this color. </p>
<p>

While G cannot be R-colored
While graph G has a node N with degree less than R
Remove N and its associated edges from G and push N on a stack S
End While 
If the entire graph has been removed then the graph is R-colorable 
While stack S contains a node N
Add N to graph G and assign it a color from the R colors
End While
Else graph G cannot be colored with R colors
Simplify the graph G by choosing an object to spill and remove its node N from G
(spill nodes are chosen based on object’s number of definitions and references)
End While</p>
<p>

This algorithm is O(n^2). This algorithm can be improved through subsumption which is the act of coalescing nodes which are the source and target of copy operations into a single node before running the algorithm. This reduces the number of nodes to color but can increase the degree of any coalesced node. This can only be done when the nodes do not interfere with each other, however, and aggressive coalescing can lead to uncolorable graphs. (Preston Briggs’ thesis work introduces safer methods to determine which nodes to coalesce and spill. Based on his improvements this algorithm is often called the Chaitin-Briggs algorithm.) The subsumption step is slow and is not done in fast register allocators.</p>

</sec>
<sec>
<st>
Recent developments </st>
<p>

Graph coloring allocators produce efficient code, but their allocation time is high. In cases of static compilation, allocation time is not a significant concern. In cases of dynamic compilation, such as <link xlink:type="simple" xlink:href="../632/220632.xml">
just-in-time</link> (JIT) compilers, fast register allocation is important. An efficient technique proposed by Poletto and Sarkar is <weblink xlink:type="simple" xlink:href="http://www.research.ibm.com/jalapeno/papers/toplas99.pdf">
linear scan allocation</weblink>. This technique requires only a single pass over the list of variable live ranges. Ranges with short lifetimes are assigned to registers, whereas those with long lifetimes tend to be <link xlink:type="simple" xlink:href="../122/485122.xml">
spilled</link>, or reside in memory. The results are on average only 12% less efficient than graph coloring allocators.</p>
<p>

The linear scan algorithm follows:</p>
<p>

<list>
<entry level="1" type="number">

 Perform dataflow analysis to gather liveness information. Keep track of all variables’ live intervals, the interval when a variable is live, in a list sorted in order of increasing start point (note that this ordering is free if the list is built when computing liveness.) We consider variables and their intervals to be interchangeable in this algorithm.</entry>
<entry level="1" type="number">

 Iterate through liveness start points and allocate a register from the available register pool to each live variable.</entry>
<entry level="1" type="number">

 At each step maintain a list of active intervals sorted by the end point of the live intervals. (Note that insertion sort into a balanced binary tree can be used to maintain this list at linear cost.) Remove any expired intervals from the active list and free the expired interval’s register to the available register pool.</entry>
<entry level="1" type="number">

 In the case where the active list is size R we cannot allocate a register. In this case add the current interval to the active pool without allocating a register. Spill the interval from the active list with the furthest end point. Assign the register from the spilled interval to the current interval or, if the current interval is the one spilled, do not change register assignments.</entry>
</list>
</p>
<p>

Cooper and Dasgupta recently developed a "lossy" Chaitin-Briggs graph coloring algorithm suitable for use in a JIT <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. The "lossy" moniker refers to the imprecision the algorithm introduces into the interference graph. This optimization reduces the costly graph building step of Chaitin-Briggs making it suitable for runtime compilation. Experiments indicate that this lossy register allocator outperforms linear scan on the majority of tests used.</p>
<p>

"Optimal" register allocation algorithms based on Integer Programming have been developed by Goodwin and Wilken for regular architectures. These algorithms have been extended to irregular architectures by Kong and Wilken.</p>
<p>

While the worst case execution time is exponential, the experimental results show that the actual time is typically of order <math>O(n^{2.5})</math> of the number of constraints<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>.</p>

</sec>
<sec>
<st>
References </st>
<p>

<reflist>
<entry id="1">
Gregory J. Chaitin, Mark A. Auslander, Ashok K. Chandra, John Cocke, Martin E. Hopkins, and Peter W. Markstein. "Register allocation via coloring." Computer Languages, 6:47-57, 1981.</entry>
<entry id="2">
Cooper, Dasgupta, "Tailoring Graph-coloring Register Allocation For Runtime Compilation", http://llvm.org/pubs/2006-04-04-CGO-GraphColoring.html</entry>
<entry id="3">
Kong, Wilken, "Precise Register Allocation for Irregular Architectures", http://www.ece.ucdavis.edu/cerl/cerl_arch/irreg.pdf</entry>
</reflist>
</p>


</sec>
</bdy>
</psychological_feature>
</act>
</optimization>
</action>
</improvement>
</change>
</event>
</change_of_state>
</article>
