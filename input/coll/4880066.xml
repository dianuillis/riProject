<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:32:14[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>SQL Server Full Text Search</title>
<id>4880066</id>
<revision>
<id>241463814</id>
<timestamp>2008-09-28T04:01:20Z</timestamp>
<contributor>
<username>Sheehan</username>
<id>122289</id>
</contributor>
</revision>
<categories>
<category>SQL</category>
</categories>
</header>
<bdy>

<b>SQL Server Full Text Search</b> is an inexact <link xlink:type="simple" xlink:href="../648/28648.xml">
string matching</link> technology for <link xlink:type="simple" xlink:href="../245/28245.xml">
SQL Server</link>. It is a powerful and fast way of referencing the contents of almost any character-based column on <link xlink:type="simple" xlink:href="../994/13989994.xml">
SQL Server 2000</link>, <link xlink:type="simple" xlink:href="../994/13989994.xml">
SQL Server 2005</link>, and <link>
SQL Server 2008</link> . <p>

Full text indexes must be populated and are stored inside full-text catalogues.
Searching is installed as a separate service called MSSearch, an optional component of SQL Server 7.0/2000/2005.</p>

<sec>
<st>
 Types of Searches </st>

<p>

<list>
<entry level="1" type="bullet">

 Proximity based searches – cf. Section</entry>
<entry level="1" type="bullet">

 Inflectional based searches – cf. Section</entry>
<entry level="1" type="bullet">

 Weight based searches – cf. Section</entry>
<entry level="1" type="bullet">

 Prefix term searches – cf. Section</entry>
<entry level="1" type="bullet">

 Binary document search – cf. Section</entry>
</list>
</p>

</sec>
<sec>
<st>
 A Common Example </st>

<p>

The following article contains SQL code and simple worked examples. These examples refer to an imaginary table called "Athletes". This table contains information about various athletes their events and results in the Olympic Games. Inside this table you will find the following column names:</p>
<p>

<list>
<entry level="1" type="bullet">

 id</entry>
<entry level="1" type="bullet">

 name</entry>
<entry level="1" type="bullet">

 surname</entry>
<entry level="1" type="bullet">

 country</entry>
<entry level="1" type="bullet">

 notes</entry>
</list>
</p>
<p>

There exists a prior full-text index on the column "notes". The primary key of the table is on the column "id"</p>

</sec>
<sec>
<st>
 Full Text Query Syntax </st>

<p>

T-SQL supports two predicates and two functions that can be used to perform full-text searches: CONTAINS, CONTAINSTABLE, FREETEXT, and FREETEXTTABLE. The functionality of these predicates and functions are listed in the following table:</p>
<p>

<table cellpadding="5" border="1" cellspacing="0">
<row>
<col>
<b>Keyword</b></col>
<col>
<b>Meaning</b></col>
<col>
<b>Returns</b></col>
</row>
<row>
<col>
CONTAINS</col>
<col>
Supports complex syntax to search for a word or phrase using Boolean operators, prefix terms</col>
<col>
Simple Boolean predicate</col>
</row>
<row>
<col>
CONTAINSTABLE</col>
<col>
Supports CONTAINS syntax and returns document IDs and rank scores for matches</col>
<col>
Table containing document IDs and rank scores</col>
</row>
<row>
<col>
FREETEXT</col>
<col>
Automatically performs thesaurus expansions and replacements in a simplified syntax</col>
<col>
Simple Boolean predicate</col>
</row>
<row>
<col>
FREETEXTTABLE</col>
<col>
Supports FREETEXT syntax and returns document IDs and rank scores for matches</col>
<col>
Table containing document IDs and rank scores</col>
</row>
</table>
</p>
<p>

The rank is a number from 0 to 1000 that indicates the relevance of the search result. The higher the value the more relevant the match. Although rank is always calculated internally when a full-text search is performed, it is only exposed through the use of the full-text search functions. A variety of factors are considered in the various ranking algorithms used, including:</p>
<p>

<list>
<entry level="1" type="bullet">

 Document length - longer documents are generally considered more relevant</entry>
<entry level="1" type="bullet">

 Number of occurrences of search words/phrases - the more times the search words/phrases occur in the document, the higher the ranking</entry>
<entry level="1" type="bullet">

 Proximity of search words/phrases in proximity search - proximity is factored into rank when the NEAR proximity search operator is used</entry>
<entry level="1" type="bullet">

 User-defined weights - user-defined weights are factored into rank when the ISABOUT weighted search operator is used</entry>
</list>
</p>
<p>

The algorithms used to calculate rank include Jaccard for weighted searches and OKAPI BM25 for FREETEXT searches.</p>

</sec>
<sec>
<st>
 Proximity Searches </st>

<p>

Full-text searching has the ability to find words and phrases that are located in close proximity to one another. This is achieved by using the keyword "NEAR" (or the operator "~") between two given search words or phrases. </p>
<p>

In SQL Server 2008 words are considered to be "near" when they are within 50 words of one another; in prior versions of SQL Server search words or phrases were considered "near" one another with slightly over 1,100 intervening words.  Note that paragraph breaks and other non-space whitespace can affect the calculation of the number of intervening words, though the specifics have not been published by Microsoft.  The number of intervening words between phrases is factored into the rank of documents containing both of the search words or phrases.  The more intervening words between the two search terms, the lower the total rank.  There is currently no method for specifying a user-defined proximity (i.e., "10 words apart", "2 paragraphs apart", etc.)</p>
<p>

SQL Server uses a vector-space search algorithm to perform proximity searches.  The order in which the phrases appear within the search document are irrelevant to a proximity search.  In a SQL Server 2008 proximity search predicate (CONTAINS, FREETEXT), the NEAR operator is mapped internally to the AND operator.  The results are the same as if you simply used the AND operator.  To take advantage of the proximity search you have to use the CONTAINSTABLE or FREETEXTTABLE functions, both of which allow you to access the internally-generated RANK.</p>

<ss1>
<st>
 Proximity Search Simple Example #1 using the "NEAR" keyword </st>

<p>



SELECT e.name, e.surname
FROM CONTAINSTABLE(Athletes, *, '("Gold" NEAR "Finalists")') As ct
JOIN Athletes As e
ON ct.[KEY] = e.id
WHERE ct.[RANK] &amp;gt; 0
ORDER BY ct.[RANK];


</p>

</ss1>
<ss1>
<st>
 Proximity Search Simple Example #2 using the "~" operator </st>

<p>



SELECT e.name, e.surname
FROM CONTAINSTABLE(Athletes, *, '("Gold" ~ "First") OR ("Silver" ~ "Second") OR ("Bronze" ~ "Third")') As ct
JOIN Athletes As e
ON ct.[KEY] = e.id
WHERE ct.[RANK] &amp;gt; 0
ORDER BY ct.[RANK];

</p>

</ss1>
</sec>
<sec>
<st>
 Inflectional Searches </st>

<p>

Full-text searching has the ability to search for word inflections, that is, for different forms of the same word. Inflectional forms of words are generated by a language-specific components known as "stemmers" at query time. The U.S. English language stemmer (LCID 1033) is a different component from the Spanish language stemmer (LCID 3082), for instance.</p>
<p>

The stemmer relies on language-specific rules and dictionary lookups to generate inflectional word forms including gender and neutral verb conjugations, plural and singular nouns, adjective forms, and verb conjugations. As an example, when given the verb <it>swim</it>, SQL Server generates the inflectional forms <it>swim</it>, <it>swims</it>, <it>swimming</it>, <it>swam</it>, and <it>swum</it> when using the U.S. English stemmer.</p>
<p>

The FREETEXT predicate and FREETEXTTABLE function automatically generate inflectional forms for search words. The CONTAINS predicate and CONTAINSTABLE functions, however, require you to use the FORMSOF(INFLECTIONAL, ...) operator in your query string to generate inflectional forms.</p>

</sec>
<sec>
<st>
 Prefix Term Searches </st>

<p>

Full-text searching has the ability to search for word beginning with a certain term, or prefix. This is achieved by following your search term with a wild-card asterisk (*) symbol. In order to indicate to SQL Server that your search term is in fact a prefix search term, you must enclose it in double quotes. In a multi-word quoted prefix search phrase all of the words are treated as prefix terms, even if the wildcard * character follows only one word in the phrase. Note that when prefix searches are used SQL Server does not generate inflectional forms or perform thesaurus replacements and expansions of the words in the search phrase.</p>

<ss1>
<st>
 Prefix Term Simple Example #1 </st>

<p>


-- This sample matches all documents containing a word that begins with the prefix "al" 
SELECT name, surname
FROM Athletes a
WHERE CONTAINS(*, '"al*"')
</p>

</ss1>
<ss1>
<st>
 Prefix Term Simple Example #2 </st>

<p>


-- This sample matches all documents containing two words, one beginning with the prefix "al" 
-- and another beginning with the prefix "anon". Matches would include "al anon", 
-- "alcoholics anonymous", "alan anondez", etc. Notice that the trailing * is only needed
-- for one prefix in the search phrase.
SELECT name, surname
FROM Athletes a
WHERE CONTAINS(*, '"al* anon"')
</p>

</ss1>
</sec>
<sec>
<st>
 Non-Plain-Text Document Search </st>

<p>

Full-text searching has the ability to search through binary data. Some of the supported types are:</p>
<p>

<list>
<entry level="1" type="bullet">

 HTML (*.htm or *.html)</entry>
<entry level="1" type="bullet">

 XML (*.xml)</entry>
<entry level="1" type="bullet">

 MS Word (*.doc)</entry>
<entry level="1" type="bullet">

 MS Excel (*.xls)</entry>
<entry level="1" type="bullet">

 MS PowerPoint (*.ppt)</entry>
<entry level="1" type="bullet">

 Adobe Acrobat (*.pdf)</entry>
</list>
</p>
<p>

Some of these formats may require installing additional ifilter software on the machine and then issuing these commands to enable them to get loaded.</p>
<p>


sp_fulltext_service 'verify_signature', 0
sp_fulltext_service 'load_os_resources',1.
</p>
<p>

More formats can be added by installing additional ifilters and new ifilters can be developed to handle others.</p>

</sec>
<sec>
<st>
 Weighted Searches </st>

<p>

Full-text searching has the ability to associate a higher preference for certain terms over others.
This is achieved by using the function: “ISABOUT” and the “WEIGHT” keyword. The keyword is associated with any decimal value between 0.0 and 1.0. The higher the weight the greater preference the match will be given</p>

<ss1>
<st>
 Weighted Searches Simple Example #1 </st>



<p>

SELECT name, surname
FROM Athletes a
JOIN CONTAINSTABLE(Athletes, notes, 'ISABOUT(Bronze WEIGHT(.2), Silver WEIGHT(.4), Gold WEIGHT(.8))') ct
ON a.id = ct.[KEY]
ORDER BY Rank desc</p>



</ss1>
</sec>
<sec>
<st>
 Noise Words </st>

<p>

These are common words that MS Search feels should be ignored when considering matches. </p>
<p>

For example the article words like “the”, “an” and the <link xlink:type="simple" xlink:href="../234/1248234.xml">
conjunctions</link> like: “and”, “but” and “or” occur so frequently that to include them in a search would result in too many false positives.</p>

</sec>
<sec>
<st>
 Hardware Optimization Considerations </st>

<p>

By default, MS SQL Server reserves all the <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> in its process space, minus 1GB. This leaves little for MSSearch. Consider readjusting to a ratio of 8(SQL Server):2(MSSearch).
By default the Windows 2000/NT <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> is 1.5 times <link>
physical memory</link>. Consider increasing this to 3 times physical memory.</p>

</sec>
</bdy>
</article>
