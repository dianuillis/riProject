<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:43:48[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<kernel  confidence="0.9511911446218017" wordnetid="113137010">
<header>
<title>Kernel (computer science)</title>
<id>50394</id>
<revision>
<id>244266454</id>
<timestamp>2008-10-10T00:52:46Z</timestamp>
<contributor>
<username>Senator Palpatine</username>
<id>7357381</id>
</contributor>
</revision>
<categories>
<category>All pages needing cleanup</category>
<category>All pages needing factual verification</category>
<category>Articles with invalid date parameter in template</category>
<category>Wikipedia articles needing clarification</category>
<category>Operating system technology</category>
<category>Wikipedia articles needing factual verification since July 2007</category>
<category>Operating system kernels</category>
</categories>
</header>
<bdy>

<image width="200px" src="Kernel_Layout.svg" type="thumb">
<caption>

A kernel connects the application software to the hardware of a computer.
</caption>
</image>

<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>kernel</b> is the central component of most computer <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s (OS). Its responsibilities include managing the system's resources (the communication between <link xlink:type="simple" xlink:href="../310/5310.xml">
hardware</link> and <link xlink:type="simple" xlink:href="../309/5309.xml">
software</link> components). As a basic component of an operating system, a kernel provides the lowest-level <link xlink:type="simple" xlink:href="../775/574775.xml">
abstraction layer</link> for the resources (especially <link xlink:type="simple" xlink:href="../847/25847.xml">
memory</link>, <link xlink:type="simple" xlink:href="../218/5218.xml">
processors</link> and <link xlink:type="simple" xlink:href="../558/14558.xml">
I/O devices</link>) that application software must control to perform its function. It typically makes these facilities available to <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<furnishing wordnetid="103405265" confidence="0.8">
<table wordnetid="104379243" confidence="0.8">
<furniture wordnetid="103405725" confidence="0.8">
<console_table wordnetid="103092883" confidence="0.8">
<link xlink:type="simple" xlink:href="../746/454746.xml">
application</link></console_table>
</furniture>
</table>
</furnishing>
</instrumentality>
</artifact>
 <link xlink:type="simple" xlink:href="../178/45178.xml">
processes</link> through <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> mechanisms and <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link>s.</p>
<p>

These tasks are done differently by different kernels, depending on their design and implementation. While <link xlink:type="simple" xlink:href="../825/20825.xml">
monolithic kernel</link>s will try to achieve these goals by executing all the code in the same <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link> to increase the performance of the system, <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link>s run most of their services in <link xlink:type="simple" xlink:href="../467/93467.xml">
user space</link>, aiming to improve maintainability and modularity of the codebase.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> A range of possibilities exists between these two extremes.</p>

<sec>
<st>
Overview</st>
<p>

<image width="200px" src="Computer_abstraction_layers.svg" type="thumb">
<caption>

A typical vision of a <link xlink:type="simple" xlink:href="../509/6509.xml">
computer architecture</link> as a series of abstraction layers: <link xlink:type="simple" xlink:href="../615/13615.xml">
hardware</link>, <link xlink:type="simple" xlink:href="../155/41155.xml">
firmware</link>, <link xlink:type="simple" xlink:href="../368/1368.xml">
assembler</link>, kernel, <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> and <link xlink:type="simple" xlink:href="../178/45178.xml">
applications</link> (see also Tanenbaum 79).
</caption>
</image>

On the definition of 'kernel' <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
 said that the word is "traditionally used to denote the part of the operating system that is mandatory and common to all other software."<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

Most operating systems rely on the kernel concept. The existence of a kernel is a natural consequence of designing a computer system as a series of <link xlink:type="simple" xlink:href="../775/574775.xml">
abstraction layer</link>s,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> each relying on the functions of layers beneath itself. The kernel, from this viewpoint, is simply the name given to the lowest level of abstraction that is implemented in <link xlink:type="simple" xlink:href="../309/5309.xml">
software</link>. In order to avoid having a kernel, one would have to design all the software on the system not to use abstraction layers; this would increase the complexity of the design to such a point that only the simplest systems could feasibly be implemented.</p>
<p>

While it is today mostly called the <it>kernel</it>, originally the same part of the operating system was also called the <b><it>nucleus</it></b> or <b><it>core</it></b>,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> (Note, however, that the term <it>core</it> has also been used to refer to the primary memory of a computer system, because some early computers used a form of memory called <link>
core memory</link> ), and was originally conceived as containing only the essential support features of the operating system.</p>
<p>

In most cases, the <link xlink:type="simple" xlink:href="../909/40909.xml">
boot loader</link> starts executing the kernel in <link>
supervisor mode</link>,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> The kernel then initializes itself and starts the first process. After this, the kernel does not typically execute directly, only in response to external events (e.g. via system calls used by applications to request services from the kernel, or via <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>s used by the hardware to notify the kernel of events). Additionally, the kernel typically provides a loop that is executed whenever no processes are available to run; this is often called the <it>idle process</it>.</p>
<p>

Kernel development is considered one of the most complex and difficult tasks in programming.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> Its central position in an operating system implies the necessity for good performance, which defines the kernel as a critical piece of software and makes its correct design and implementation difficult. For various reasons, a kernel might not even be able to use the <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/60491.xml">
abstraction</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 mechanisms it provides to other software. Such reasons include <link xlink:type="simple" xlink:href="../924/66924.xml">
memory management</link> concerns (for example, a user-mode function might rely on memory being subject to <link xlink:type="simple" xlink:href="../997/1310997.xml">
demand paging</link>, but as the kernel itself provides that facility it cannot use it, because then it might not remain in memory to provide that facility) and lack of <link xlink:type="simple" xlink:href="../851/154851.xml">
reentrancy</link>, thus making its development even more difficult for software engineers.</p>
<p>

A kernel will usually provide features for low-level <link xlink:type="simple" xlink:href="../920/231920.xml">
scheduling</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> of processes (dispatching), <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link>, process <link xlink:type="simple" xlink:href="../017/4726017.xml">
synchronization</link>, <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>ing, manipulation of <link xlink:type="simple" xlink:href="../662/801662.xml">
process control block</link>s, <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link> handling, process creation and destruction, and process suspension and resumption (see <link xlink:type="simple" xlink:href="../260/4387260.xml">
process states</link>).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</sec>
<sec>
<st>
Kernel basic facilities</st>
<p>

The kernel's primary purpose is to manage the computer's resources and allow other programs to run and use these resources.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> Typically, the resources consist of:
<list>
<entry level="1" type="bullet">

 The <link>
Central Processing Unit</link> (CPU, the processor). This is the most central part of a computer system, responsible for <it>running</it> or <it>executing</it> programs on it. The kernel takes responsibility for deciding at any time which of the many running programs should be allocated to the processor or processors (each of which can usually run only one program at a time)</entry>
<entry level="1" type="bullet">

 The computer's <link xlink:type="simple" xlink:href="../847/25847.xml">
memory</link>. Memory is used to store both program instructions and data. Typically, both need to be present in memory in order for a program to execute. Often multiple programs will want access to memory, frequently demanding more memory than the computer has available. The kernel is responsible for deciding which memory each process can use, and determining what to do when not enough is available.</entry>
<entry level="1" type="bullet">

 Any <link xlink:type="simple" xlink:href="../558/14558.xml">
Input/Output (I/O)</link> devices present in the computer, such as keyboard, mouse, disk drives, printers, displays, etc. The kernel allocates requests from applications to perform I/O to an appropriate device (or subsection of a device, in the case of files on a disk or windows on a display) and provides convenient methods for using the device (typically abstracted to the point where the application does not need to know implementation details of the device).</entry>
</list>
</p>
<p>

Key aspects necessary in resource managements are the definition of an execution domain (<link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link>) and the protection mechanism used to mediate the accesses to the resources within a domain.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>
<p>

Kernels also usually provide methods for <link xlink:type="simple" xlink:href="../017/4726017.xml">
synchronization</link> and <link xlink:type="simple" xlink:href="../106/152106.xml">
communication</link> between processes (called <it>inter-process communication</it> or IPC).</p>
<p>

A kernel may implement these features itself, or rely on some of the processes it runs to provide the facilities to other processes, although in this case it must provide some means of IPC to allow processes to access the facilities provided by each other.</p>
<p>

Finally, a kernel must provide running programs with a method to make requests to access these facilities.</p>

<ss1>
<st>
Process management</st>
<p>

The main task of a kernel is to allow the execution of applications and support them with features such as hardware abstractions. A process defines which memory portions the application can access.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> (For this introduction, process, application and program are used as synonyms.)  Kernel <link xlink:type="simple" xlink:href="../249/203249.xml">
process management</link> must take into account the hardware built-in equipment for <link xlink:type="simple" xlink:href="../373/515373.xml">
memory protection</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></p>
<p>

To run an application, a kernel typically sets up an <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link> for the application, loads the file containing the application's code into memory (perhaps via <link xlink:type="simple" xlink:href="../997/1310997.xml">
demand paging</link>), sets up a <link xlink:type="simple" xlink:href="../105/1718105.xml">
stack</link> for the program and branches to a given location inside the program, thus starting its execution.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></p>
<p>

<link xlink:type="simple" xlink:href="../857/6857.xml">
Multi-tasking</link> kernels are able to give the user the illusion that the number of processes being run simultaneously on the computer is higher than the maximum number of processes the computer is physically able to run simultaneously. Typically, the number of processes a system may run simultaneously is equal to the number of CPUs installed (however this may not be the case if the processors support <link xlink:type="simple" xlink:href="../021/315021.xml">
simultaneous multithreading</link>).</p>
<p>

In a <link xlink:type="simple" xlink:href="../566/2204566.xml">
pre-emptive multitasking</link> system, the kernel will give every program a slice of time and switch from process to process so quickly that it will appear to the user as if these processes were being executed simultaneously. The kernel uses <link xlink:type="simple" xlink:href="../425/384425.xml">
scheduling algorithm</link>s to determine which process is running next and how much time it will be given. The algorithm chosen may allow for some processes to have higher priority than others. The kernel generally also provides these processes a way to communicate; this is known as <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link> (IPC) and the main approaches are <link xlink:type="simple" xlink:href="../653/825653.xml">
shared memory</link>, <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link> and <link xlink:type="simple" xlink:href="../346/26346.xml">
remote procedure call</link>s (see <link xlink:type="simple" xlink:href="../605/2581605.xml">
concurrent computing</link>).</p>
<p>

Other systems (particularly on smaller, less powerful computers) may provide <link>
co-operative multitasking</link>, where each process is allowed to run uninterrupted until it makes a special request that tells the kernel it may switch to another process. Such requests are known as "yielding", and typically occur in response to requests for interprocess communication, or for waiting for an event to occur. Older versions of <link xlink:type="simple" xlink:href="../890/18890.xml">
Windows</link> and <link xlink:type="simple" xlink:href="../043/20043.xml">
Mac OS</link> both used co-operative multitasking but switched to pre-emptive schemes as the power of the computers to which they were targeted grew.</p>
<p>

The operating system might also support <link xlink:type="simple" xlink:href="../020/64020.xml">
multiprocessing</link> (<link xlink:type="simple" xlink:href="../318/50318.xml">
SMP</link> or <link xlink:type="simple" xlink:href="../643/40643.xml">
Non-Uniform Memory Access</link>); in that case, different programs and threads may run on different processors. A kernel for such a system must be designed to be re-entrant, meaning that it may safely run two different parts of its code simultaneously. This typically means providing <link xlink:type="simple" xlink:href="../017/4726017.xml">
synchronization</link> mechanisms (such as <link xlink:type="simple" xlink:href="../603/244603.xml">
spinlock</link>s) to ensure that no two processors attempt to modify the same data at the same time.</p>

</ss1>
<ss1>
<st>
Memory management</st>
<p>

The kernel has full access to the system's memory and must allow processes to access safely this memory as they require it. Often the first step in doing this is <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual addressing</link>, usually achieved by <link xlink:type="simple" xlink:href="../193/311193.xml">
paging</link> and/or <link xlink:type="simple" xlink:href="../131/1323131.xml">
segmentation</link>. Virtual addressing allows the kernel to make a given physical address appear to be another address, the virtual address. Virtual address spaces may be different for different processes; the memory that one process accesses at a particular (virtual) address may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></p>
<p>

On many systems, a program's virtual address may refer to data which is not currently in memory. The layer of indirection provided by virtual addressing allows the operating system to use other data stores, like a <link xlink:type="simple" xlink:href="../777/13777.xml">
hard drive</link>, to store what would otherwise have to remain in main memory (RAM). As a result, operating systems can allow programs to use more memory than the system has physically available. When a program needs data which is not currently in RAM, the CPU signals to the kernel that this has happened, and the kernel responds by writing the contents of an inactive memory block to disk (if necessary) and replacing it with the data requested by the program. The program can then be resumed from the point where it was stopped. This scheme is generally known as <link xlink:type="simple" xlink:href="../997/1310997.xml">
demand paging</link>.</p>
<p>

Virtual addressing also allows creation of virtual partitions of memory in two disjointed areas, one being reserved for the kernel (<link xlink:type="simple" xlink:href="../467/93467.xml">
kernel space</link>) and the other for the applications (<link xlink:type="simple" xlink:href="../467/93467.xml">
user space</link>). The applications are not permitted by the processor to address kernel memory, thus preventing an application from damaging the running kernel. This fundamental partition of memory space has contributed much to current designs of actual general-purpose kernels and is almost universal in such systems, although some research kernels (e.g. <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../655/2049655.xml">
Singularity</link></O>
) take other approaches.</p>

</ss1>
<ss1>
<st>
Device management</st>
<p>

To perform useful functions, processes need access to the <link xlink:type="simple" xlink:href="../ago/Austin=2C_C$hicago.xml">
peripheral</link>s connected to the computer, which are controlled by the kernel through <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>s. For example, to show the user something on the screen, an application would make a request to the kernel, which would forward the request to its display driver, which is then responsible for actually plotting the character/pixel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></p>
<p>

A kernel must maintain a list of available devices. This list may be known in advance (e.g. on an embedded system where the kernel will be rewritten if the available hardware changes), configured by the user (typical on older PCs and on systems that are not designed for personal use) or detected by the operating system at run time (normally called <link xlink:type="simple" xlink:href="../859/158859.xml">
plug and play</link>).</p>
<p>

In a plug and play system, a device manager first performs a scan on different <link xlink:type="simple" xlink:href="../631/6631.xml">
hardware bus</link>es, such as <link xlink:type="simple" xlink:href="../075/24075.xml">
Peripheral Component Interconnect</link> (PCI) or <bus wordnetid="102924116" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../073/32073.xml">
Universal Serial Bus</link></bus>
 (USB), to detect installed devices, then searches for the appropriate drivers</p>
<p>

As device management is a very OS-specific topic, these drivers are handled differently by each kind of kernel design, but in every case, the kernel has to provide the <link xlink:type="simple" xlink:href="../558/14558.xml">
I/O</link> to allow drivers to physically access their devices through some port or memory location. Very important decisions have to be made when designing the device management system, as in some designs accesses may involve <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>es, making the operation very CPU-intensive and easily causing a significant performance overhead.</p>

</ss1>
<ss1>
<st>
System calls</st>

<p>

To actually perform useful work, a process must be able to access the services provided by the kernel. This is implemented differently by each kernel, but most provide a <link xlink:type="simple" xlink:href="../378/324378.xml">
C library</link> or an <link>
API</link>, which in turn invokes the related kernel functions.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></p>
<p>

The method of invoking the kernel function varies from kernel to kernel. If memory isolation is in use, it is impossible for a user process to call the kernel directly, because that would be a violation of the processor's access control rules. A few possibilities are:
<list>
<entry level="1" type="bullet">

 Using a software-simulated <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>. This method is available on most hardware, and is therefore very common.</entry>
<entry level="1" type="bullet">

 Using a <link xlink:type="simple" xlink:href="../844/6054844.xml">
call gate</link>. A call gate is a special address which the kernel has added to a list stored in kernel memory and which the processor knows the location of. When the processor detects a call to that location, it instead redirects to the target location without causing an access violation. Requires hardware support, but the hardware for it is quite common.</entry>
<entry level="1" type="bullet">

 Using a special system call instruction. This technique requires special hardware support, which common architectures (notably, <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>) may lack. System call instructions have been added to recent models of x86 processors, however, and some (but not all) operating systems for PCs make use of them when available.</entry>
<entry level="1" type="bullet">

 Using a memory-based queue. An application that makes large numbers of requests but does not need to wait for the result of each may add details of requests to an area of memory that the kernel periodically scans to find requests.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
Kernel design decisions</st>

<ss1>
<st>
Issues of kernel support for protection</st>
<p>

An important consideration in the design of a kernel is the support it provides for protection from faults (<link xlink:type="simple" xlink:href="../720/2573720.xml">
fault tolerance</link>) and from malicious behaviors (<link xlink:type="simple" xlink:href="../398/7398.xml">
security</link>). These two aspects are usually not clearly distinguished, and the <link xlink:type="simple" xlink:href="../990/12310990.xml">
adoption of this distinction</link> in the kernel design leads to the rejection of a <link xlink:type="simple" xlink:href="../185/3446185.xml">
hierarchical structure for protection</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>
<p>

The mechanisms or policies provided by the kernel can be classified according to several criteria, as: static (enforced at <link xlink:type="simple" xlink:href="../766/191766.xml">
compile time</link>) or dynamic (enforced at <link xlink:type="simple" xlink:href="../263/192263.xml">
runtime</link>); preemptive or post-detection; according to the protection principles they satisfy (i.e. <link xlink:type="simple" xlink:href="../257/1313257.xml">
Denning</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref>); whether they are hardware supported or language based;  whether they are more an open mechanism or a binding policy; and many more.</p>

<ss2>
<st>
Fault tolerance</st>
<p>

A useful measure of the level of fault tolerance of a system is how closely it adheres to the <link xlink:type="simple" xlink:href="../226/1695226.xml">
principle of least privilege</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref> In cases where multiple programs are running on a single computer, it is important to prevent a fault in one of the programs from negatively affecting the other. Extended to malicious design rather than a fault, this also applies to <link xlink:type="simple" xlink:href="../398/7398.xml">
security</link>, where it is necessary to prevent processes from accessing information without being granted permission.</p>
<p>

The two major hardware approaches<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref> for protection (of sensitive information) are <link xlink:type="simple" xlink:href="../185/3446185.xml">
Hierarchical protection domains</link> (also called <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/3446185.xml">
ring</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 architectures, segment architectures or <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/3446185.xml#xpointer(//*[./st=%22Supervisor+mode%22])">
supervisor mode</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
),<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref> and <link xlink:type="simple" xlink:href="../454/8803454.xml">
Capability-based addressing</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2220%22])">20</ref> </p>
<p>

<image location="right" width="250px" src="Priv_rings.svg" type="thumb">
</image>

Hierarchical protection domains are much less flexible, as is the case with every kernel with a hierarchical structure assumed as global design criterion.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> In the case of protection it is not possible to assign different privileges to processes that are at the same privileged level, and therefore is not possible to satisfy <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../772/974772.xml">
Denning's</link></scientist>
 four principles for fault tolerance<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref> (particularly the Principle of least privilege). Hierarchical protection domains also have a major performance drawback, since interaction between different levels of protection, when a process has to manipulate a data structure both in 'user mode' and 'supervisor mode', always requires message copying (transmission <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/2977119.xml#xpointer(//*[./st=%22Call+by+value%22])">
by value</link></subject>
</message>
).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref> A kernel based on capabilities, however, is more flexible in assigning privileges, can satisfy Denning's fault tolerance principles,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref> and typically doesn't suffer from the performance issues of copy by value.</p>
<p>

Both approaches typically require some hardware or firmware support to be operable and efficient. The hardware support for hierarchical protection domains<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref> is typically that of "<link xlink:type="simple" xlink:href="../954/3991954.xml">
CPU modes</link>." An efficient and simple way to provide hardware support of capabilities is to delegate the <link xlink:type="simple" xlink:href="../112/177112.xml">
MMU</link> the responsibility of checking access-rights for every memory access, a mechanism called <link xlink:type="simple" xlink:href="../454/8803454.xml">
capability-based addressing</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref> Most commercial computer architectures lack MMU support for capabilities.  
An alternative approach is to simulate capabilities using commonly-support hierarchical domains; in this approach, each protected object must reside in an address space that the application does not have access to; the kernel also maintains a list of capabilities in such memory.  When an application needs to access an object protected by a capability, it performs a system call and the kernel performs the access for it.  The performance cost of address space switching limits the practicality of this approach in systems with complex interactions between objects, but it is used in current operating systems for objects that are not accessed frequently or which are not expected to perform quickly.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2225%22])">25</ref>
Approaches where protection mechanism are not firmware supported but are instead simulated at higher levels (e.g. simulating capabilities by manipulating page tables on hardware that does not have direct support), are possible, but there are performance implications.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2226%22])">26</ref> Lack of hardware support may not be an issue, however, for systems that choose to use language-based protection.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2227%22])">27</ref></p>

</ss2>
<ss2>
<st>
Security</st>
<p>

An important kernel design decision is the choice of the abstraction levels where the security mechanisms and policies should be implemented. Kernel security mechanisms play a critical role in supporting security at higher levels.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2228%22])">28</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2229%22])">29</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2230%22])">30</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2231%22])">31</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref></p>
<p>

One approach is to use firmware and kernel support for fault tolerance (see above), and build the security policy for malicious behavior on top of that (adding features such as <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link> mechanisms where necessary), delegating some responsibility to the <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>. Approaches that delegate enforcement of security policy to the compiler and/or the application level are often called <it>language-based security</it>.</p>
<p>

The lack of many critical security mechanisms in current mainstream operating systems impedes the implementation of adequate security policies at the application <link xlink:type="simple" xlink:href="../775/574775.xml">
abstraction level</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2232%22])">32</ref> In fact, a common misconception in computer security is that any security policy can be implemented in an application regardless of kernel support.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2232%22])">32</ref></p>

</ss2>
<ss2>
<st>
Hardware-based protection or language-based protection</st>
<p>

Typical computer systems today use hardware-enforced rules about what programs are allowed to access what data. The processor monitors the execution and stops a program that violates a rule (e.g., a user process that is about to read or write to kernel memory, and so on). In systems that lack support for capabilities, processes are isolated from each other by using separate address spaces.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2233%22])">33</ref> Calls from user processes into the kernel are regulated by requiring them to use one of the above-described system call methods.</p>
<p>

An alternative approach is to use language-based protection. In a <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../420/12265420.xml">
language-based protection system</link></kernel>
</natural_object>
</plant_part>
, the kernel will only allow code to execute that has been produced by a trusted language <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>. The language may then be designed such that it is impossible for the programmer to instruct it to do something that will violate a security requirement.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2227%22])">27</ref></p>
<p>

Advantages of this approach include:
<list>
<entry level="1" type="bullet">

 Lack of need for separate address spaces. Switching between address spaces is a slow operation that causes a great deal of overhead, and a lot of optimization work is currently performed in order to prevent unnecessary switches in current operating systems. Switching is completely unnecessary in a language-based protection system, as all code can safely operate in the same address space.</entry>
<entry level="1" type="bullet">

 Flexibility. Any protection scheme that can be designed to be expressed via a programming language can be implemented using this method. Changes to the protection scheme (e.g. from a hierarchical system to a capability-based one) do not require new hardware.</entry>
</list>
</p>
<p>

Disadvantages include:
<list>
<entry level="1" type="bullet">

 Longer application start up time. Applications must be verified when they are started to ensure they have been compiled by the correct compiler, or may need recompiling either from source code or from <link xlink:type="simple" xlink:href="../997/89997.xml">
bytecode</link>.</entry>
<entry level="1" type="bullet">

 Inflexible type systems. On traditional systems, applications frequently perform operations that are not <link xlink:type="simple" xlink:href="../650/602650.xml">
type safe</link>. Such operations cannot be permitted in a language-based protection system, which means that applications may need to be rewritten and may, in some cases, lose performance.</entry>
</list>
</p>
<p>

Examples of systems with language-based protection include <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../211/10812211.xml">
JX</link></O>
 and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../001/19001.xml">
Microsoft</link></company>
's <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../655/2049655.xml">
Singularity</link></O>
.</p>

</ss2>
</ss1>
<ss1>
<st>
Process cooperation</st>
<p>

<link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> proved that from a logical point of view, <link xlink:type="simple" xlink:href="../074/4695074.xml">
atomic</link> <link xlink:type="simple" xlink:href="../593/244593.xml">
lock</link> and unlock operations operating on binary <link xlink:type="simple" xlink:href="../557/164557.xml">
semaphores</link> are sufficient primitives to express any functionality of process cooperation.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2234%22])">34</ref> However this approach is generally held to be lacking in terms of safety and efficiency, whereas a <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link> approach is more flexible.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</ss1>
<ss1>
<st>
I/O devices management</st>
<p>

The idea of a kernel where I/O devices are handled uniformly with other processes, as parallel co-operating processes, was first proposed and implemented by <link xlink:type="simple" xlink:href="../750/863750.xml">
Brinch Hansen</link> (although similar ideas were suggested in 1967<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2235%22])">35</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2236%22])">36</ref>). In Hansen's description of this, the "common" processes are called <it>internal processes</it>, while the I/O devices are called <it>external processes</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</ss1>
</sec>
<sec>
<st>
Kernel-wide design approaches</st>
<p>

Naturally, the above listed tasks and features can be provided in many ways that differ from each other in design and implementation. </p>
<p>

The principle of <it><link xlink:type="simple" xlink:href="../645/12155645.xml">
separation of mechanism and policy</link></it> is the substantial difference between the philosophy of micro and monolithic kernels.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2237%22])">37</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2238%22])">38</ref> Here a <it>mechanism</it> is the support that allows the implementation of many different policies, while a policy is a particular "mode of operation".&#91;&#93; In minimal microkernel just some very basic policies are included,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2238%22])">38</ref> and its mechanisms allows what is running on top of the kernel (the remaining part of the operating system and the other applications) to decide which policies to adopt (as memory management, high level process scheduling, file system management, etc.).<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> A monolithic kernel instead tends to include many policies, therefore restricting the rest of the system to rely on them.</p>
<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Per Brinch Hansen</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
 presented <link xlink:type="simple" xlink:href="../296/5296.xml">
cogent</link> arguments in favor of separation of mechanism and policy.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> The failure to properly fulfill this separation, is one of the major causes of the lack of substantial innovation in existing operating systems,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> a problem common in computer architecture.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2239%22])">39</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2240%22])">40</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2241%22])">41</ref> The monolithic design is induced by the "kernel mode"/"user mode" architectural approach to protection (technically called <link xlink:type="simple" xlink:href="../185/3446185.xml">
hierarchical protection domains</link>), which is common in conventional commercial system;<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2242%22])">42</ref> in fact, every module needing protection is therefore preferably included into the kernel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2242%22])">42</ref> This link between monolithic design and "privileged mode" can be reconducted to the key issue of mechanism-policy separation;<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> in fact the "privileged mode" architectural approach melts together the protection mechanism with the security policies, while the major alternative architectural approach, <link xlink:type="simple" xlink:href="../454/8803454.xml">
capability-based addressing</link>, clearly distinguishes between the two, leading naturally to a microkernel design<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> (see <link xlink:type="simple" xlink:href="../990/12310990.xml">
Separation of protection and security</link>).</p>
<p>

While <link xlink:type="simple" xlink:href="../825/20825.xml">
monolithic kernel</link>s execute all of their code in the same address space (<link xlink:type="simple" xlink:href="../467/93467.xml">
kernel space</link>) <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link>s try to run most of their services in user space, aiming to improve maintainability and modularity of the codebase.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Most kernels do not fit exactly into one of these categories, but are rather found in between these two designs. These are called <link xlink:type="simple" xlink:href="../041/4345041.xml">
hybrid kernel</link>s. More exotic designs such as <link>
nanokernel</link>s and <link xlink:type="simple" xlink:href="../757/95757.xml">
exokernel</link>s are available, but are seldom used for production systems. The <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../852/590852.xml">
Xen</link></software>
 hypervisor, for example, is an exokernel.</p>

<ss1>
<st>
Monolithic kernels</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../825/20825.xml">
Monolithic kernel</link></it>
</indent>
<image width="260px" src="kernel-simple.png" type="thumb">
<caption>

Diagram of Monolithic kernels
</caption>
</image>

In a monolithic kernel, all OS services run along with the main kernel thread, thus also residing in the same memory area. This approach provides rich and powerful hardware access. Some developers, such as UNIX developer Ken Thompson,  maintain that monolithic systems are easier to design and implement than other solutions. The main disadvantages of monolithic kernels are the dependencies between system components — a bug in a device driver might crash the entire system — and the fact that large kernels can become very difficult to maintain.</p>

</ss1>
<ss1>
<st>
Microkernels</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../023/20023.xml">
Microkernel</link></it>
</indent>
<image width="260px" src="Kernel-microkernel.svg" type="thumb">
<caption>

In the <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link> approach, the kernel itself only provides basic functionality that allows the execution of <link xlink:type="simple" xlink:href="../513/6513.xml">
servers</link>, separate programs that assume former kernel functions, such as device drivers, GUI servers, etc.
</caption>
</image>
</p>
<p>

The microkernel approach consists of defining a simple abstraction over the hardware, with a set of primitives or <link xlink:type="simple" xlink:href="../908/102908.xml">
system call</link>s to implement minimal OS services such as <link xlink:type="simple" xlink:href="../924/66924.xml">
memory management</link>, <link xlink:type="simple" xlink:href="../857/6857.xml">
multitasking</link>, and <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link>. Other services, including those normally provided by the kernel such as <link xlink:type="simple" xlink:href="../652/5652.xml">
networking</link>, are implemented in user-space programs, referred to as <it>servers</it>. Microkernels are easier to maintain than monolithic kernels, but the large number of system calls and <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>es might slow down the system because they typically generate more overhead than plain function calls.</p>
<p>

A microkernel allows the implementation of the remaining part of the operating system as a normal application program written in a <link xlink:type="simple" xlink:href="../842/189842.xml">
high-level language</link>, and the use of different operating systems on top of the same unchanged kernel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> It is also possible to dynamically switch among operating systems and to have more than one active simultaneously.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</ss1>
<ss1>
<st>
Monolithic kernels vs microkernels</st>
<p>

As the computer kernel grows, a number of problems become evident. One of the most obvious is that the <link xlink:type="simple" xlink:href="../559/10193559.xml">
memory footprint</link> increases. This is mitigated to some degree by perfecting the <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> system, but not all <link xlink:type="simple" xlink:href="../509/6509.xml">
computer architecture</link>s have virtual memory support.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2243%22])">43</ref> To reduce the kernel's footprint, extensive editing has to be performed to carefully remove unneeded code, which can be very difficult with non-obvious interdependencies between parts of a kernel with millions of lines of code.</p>
<p>

Due to the problems that monolithic kernels pose, they were considered obsolete by the early 1990s. As a result, the design of <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 as a monolithic kernel rather than a microkernel was the topic of a famous <link xlink:type="simple" xlink:href="../680/10680.xml">
flame war</link> between <celebrity wordnetid="109903153" confidence="0.9508927676800064">
<person wordnetid="100007846" confidence="0.9508927676800064">
<programmer wordnetid="110481268" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../618/17618.xml">
Linus Torvalds</link></programmer>
</person>
</celebrity>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Andrew Tanenbaum</link></professor>
</person>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2244%22])">44</ref> There is merit on both sides of the argument presented in the <link xlink:type="simple" xlink:href="../911/5087911.xml">
Tanenbaum/Torvalds debate</link>.</p>

<ss2>
<st>
Performances</st>
<p>

<link xlink:type="simple" xlink:href="../825/20825.xml">
Monolithic kernel</link>s are designed to have all of their code in the same address space (<link xlink:type="simple" xlink:href="../467/93467.xml">
kernel space</link>) to increase the performance of the system. Some developers maintain that monolithic systems are extremely efficient if well-written. The monolithic model tends to be more efficient through the use of shared kernel memory, rather than the slower IPC system of microkernel designs, which is typically based on <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link>.</p>
<p>

The performance of microkernels constructed in the 1980s and early 1990s was poor.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2245%22])">45</ref> Studies that empirically measured the performance of these microkernels did not analyze the reasons of such inefficiency.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> The explanations of this data were left to "folklore", with the assumption that they were due to the increased frequency of switches from "kernel-mode" to "user-mode"<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> , to the increased frequency of <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> and to the increased frequency of <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>es.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> </p>
<p>

In fact, as guessed in 1995, the  reasons for those poor performance might as well have been: (1) an actual inefficiency of the whole microkernel <it>approach</it>, (2) the particular <it>concepts</it> implemented in those microkernels, and (3) the particular <it>implementation</it> of those concepts.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> Therefore it remained to be studied if the solution to build an efficient microkernel was, unlike previous attempts, to apply the correct construction techniques.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

On the other end, the <link xlink:type="simple" xlink:href="../185/3446185.xml">
hierarchical protection domains</link> architecture that leads to the design of a monolithic kernel,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2242%22])">42</ref> has a significant performance drawback each time there's an interaction between different levels of protection (i.e. when a process has to manipulate a data structure both in 'user mode' and 'supervisor mode'), since this requires message copying <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/2977119.xml#xpointer(//*[./st=%22Call+by+value%22])">
by value</link></subject>
</message>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref></p>
<p>

By the mid-1990s, most researchers had abandoned the belief that careful tuning could reduce this overhead dramatically, but recently, newer microkernels, optimized for performance, such as <link xlink:type="simple" xlink:href="../763/95763.xml">
L4</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2246%22])">46</ref> and <link xlink:type="simple" xlink:href="../056/1157056.xml">
K42</link> have addressed these problems.&#91;&#93;
</p>

</ss2>
</ss1>
<ss1>
<st>
Hybrid kernels</st>

<p>

<indent level="1">

<it>Main article: <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/4345041.xml">
Hybrid kernel</link></kernel>
</natural_object>
</plant_part>
</it>
</indent>
<image width="260px" src="Kernel-hybrid.svg" type="thumb">
<caption>

The <link xlink:type="simple" xlink:href="../041/4345041.xml">
hybrid kernel</link> approach tries to combine the speed and simpler design of a monolithic kernel with the modularity and execution safety of a microkernel.
</caption>
</image>
</p>
<p>

Hybrid kernels are essentially a compromise between the monolithic kernel approach and the microkernel system. This implies running some services (such as the <link xlink:type="simple" xlink:href="../882/23882.xml">
network stack</link> or the <link xlink:type="simple" xlink:href="../280/1010280.xml">
filesystem</link>) in kernel space to reduce the performance overhead of a traditional microkernel, but still running kernel code (such as device drivers) as servers in user space.</p>

</ss1>
<ss1>
<st>
Nanokernels</st>

<p>

<indent level="1">

<it>Main article: <link>
Nanokernel</link></it>
</indent>

A nanokernel delegates virtually all services &mdash; including even the most basic ones like <link xlink:type="simple" xlink:href="../419/1805419.xml">
interrupt controllers</link> or the <link xlink:type="simple" xlink:href="../016/530016.xml">
timer</link> &mdash; to <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link>s to make the kernel memory requirement even smaller than a traditional microkernel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2247%22])">47</ref></p>

</ss1>
<ss1>
<st>
Exokernels</st>

<p>

<indent level="1">

<it>Main article: <plant_part wordnetid="113086908" confidence="0.8">
<natural_object wordnetid="100019128" confidence="0.8">
<kernel wordnetid="113137010" confidence="0.8">
<link xlink:type="simple" xlink:href="../757/95757.xml">
Exokernel</link></kernel>
</natural_object>
</plant_part>
</it>
</indent>

An exokernel is a type of kernel that does not abstract hardware into theoretical models. Instead it allocates physical hardware resources, such as processor time, memory pages, and disk blocks, to different programs. A program running on an exokernel can link to a <it>library operating system</it> that uses the exokernel to simulate the abstractions of a well-known OS, or it can develop application-specific abstractions for better performance.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2248%22])">48</ref></p>

</ss1>
</sec>
<sec>
<st>
History of kernel development</st>

<ss1>
<st>
Early operating system kernels</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../395/55395.xml">
History of operating systems</link></it>
</indent>

Strictly speaking, an operating system (and thus, a kernel) is not <it>required</it> to run a computer. Programs can be directly loaded and executed on the "bare metal" machine, provided that the authors of those programs are willing to work without any hardware abstraction or operating system support. Most early computers operated this way during the 1950s and early 1960s, which were reset and reloaded between the execution of different programs. Eventually, small ancillary programs such as <link xlink:type="simple" xlink:href="../773/483773.xml">
program loader</link>s and <link xlink:type="simple" xlink:href="../485/50485.xml">
debugger</link>s were left in memory between runs, or loaded from <link xlink:type="simple" xlink:href="../934/18934934.xml">
ROM</link>. As these were developed, they formed the basis of what became early operating system kernels. The <link>
"bare metal"</link> approach is still used today on some <link xlink:type="simple" xlink:href="../629/32629.xml">
video game console</link>s and <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded system</link>s, but in general, newer computers use modern operating systems and kernels.</p>
<p>

In 1969 the <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../452/2005452.xml">
RC 4000 Multiprogramming System</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 introduced the system design philosophy of a small nucleus "upon which operating systems for different purposes could be built in an orderly manner",<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2249%22])">49</ref> what would be called the microkernel approach.</p>

</ss1>
<ss1>
<st>
Time-sharing operating systems</st>

<p>

<indent level="1">

<it>Main article: <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../958/30958.xml">
Time-sharing</link></instrumentality>
</artifact>
</system>
</it>
</indent>

In the decade preceding <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
, computers had grown enormously in power — to the point where computer operators were looking for new ways to get people to use the spare time on their machines. One of the major developments during this era was <link xlink:type="simple" xlink:href="../958/30958.xml">
time-sharing</link>, whereby a number of users would get small slices of computer time, at a rate at which it appeared they were each connected to their own, slower, machine.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2250%22])">50</ref></p>
<p>

The development of time-sharing systems led to a number of problems. One was that users, particularly at universities where the systems were being developed, seemed to want to <link xlink:type="simple" xlink:href="../540/2471540.xml">
hack</link> the system to get more <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> time. For this reason, <link xlink:type="simple" xlink:href="../398/7398.xml">
security</link> and <link xlink:type="simple" xlink:href="../684/40684.xml">
access control</link> became a major focus of the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../847/18847.xml">
Multics</link></O>
 project in 1965.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2251%22])">51</ref> Another ongoing issue was properly handling computing resources: users spent most of their time staring at the screen and thinking instead of actually using the resources of the computer, and a time-sharing system should give the CPU time to an active user during these periods. Finally, the systems typically offered a <link xlink:type="simple" xlink:href="../146/137146.xml">
memory hierarchy</link> several layers deep, and partitioning this expensive resource led to major developments in <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> systems.</p>

</ss1>
<ss1>
<st>
Unix</st>

<p>

<indent level="1">

<it>Main article: <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
</it>
</indent>
<image width="300px" src="Unix-history.svg" type="thumb">
<caption>

A diagram of the predecessor/successor family relationship for <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../815/31815.xml">
Unix-like</link></family>
 systems.
</caption>
</image>
</p>
<p>

<family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 represented the culmination of decades of development towards a modern operating system. During the design phase, programmers decided to model every high-level <link xlink:type="simple" xlink:href="../986/18016986.xml">
device as a file</link>, because they believed the purpose of computation was data transformation.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2252%22])">52</ref> For instance, printers were represented as a "file" at a known location &mdash; when data was copied to the file, it printed out. Other systems, to provide a similar functionality, tended to virtualize devices at a lower level &mdash; that is, both devices <it>and</it> files would be instances of some lower level concept. Virtualizing the system at the file level allowed users to manipulate the entire system using their existing file management utilities and concepts, dramatically simplifying operation. As an extension of the same paradigm, Unix allows programmers to manipulate files using a series of small programs, using the concept of <link xlink:type="simple" xlink:href="../117/1236117.xml">
pipes</link>, which allowed users to complete operations in stages, feeding a file through a chain of single-purpose tools. Although the end result was the same, using smaller programs in this way dramatically increased flexibility as well as ease of development and use, allowing the user to modify their workflow by adding or removing a program from the chain.</p>
<p>

In the Unix model, the <it>Operating System</it> consists of two parts; one the huge collection of utility programs that drive most operations, the other the kernel that runs the programs.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2252%22])">52</ref> Under Unix, from a programming standpoint, the distinction between the two is fairly thin; the kernel is a program running in supervisor mode<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> that acts as a program loader and supervisor for the small utility programs making up the rest of the system, and to provide <link xlink:type="simple" xlink:href="../593/244593.xml">
locking</link> and <link xlink:type="simple" xlink:href="../558/14558.xml">
I/O</link> services for these programs; beyond that, the kernel didn't intervene at all in <link xlink:type="simple" xlink:href="../467/93467.xml">
user space</link>.</p>
<p>

Over the years the computing model changed, and Unix's treatment of everything as a file no longer seemed to be as universally applicable as it was before. Although a <link xlink:type="simple" xlink:href="../402/249402.xml">
terminal</link> could be treated as a file or a stream, which is printed to or read from, the same did not seem to be true for a <link xlink:type="simple" xlink:href="../293/12293.xml">
graphical user interface</link>. <link xlink:type="simple" xlink:href="../652/5652.xml">
Networking</link> posed another problem. Even if network communication can be compared to file access, the low-level packet-oriented architecture dealt with discrete chunks of data and not with whole files. As the capability of computers grew, Unix became increasingly cluttered with code. While kernels might have had 100,000 <link xlink:type="simple" xlink:href="../066/295066.xml">
lines of code</link> in the seventies and eighties, kernels of modern Unix successors like <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/18510.xml">
Linux</link></software>
 have more than 4.5 million lines.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2253%22])">53</ref> Thus, the biggest problem with monolithic kernels, or <it>monokernels</it>, was sheer size. The code was so extensive that working on such a large codebase was extremely tedious and time-consuming.</p>
<p>

Modern Unix-derivatives are generally based on module-loading monolithic kernels. Examples for this are <link xlink:type="simple" xlink:href="../212/18212.xml">
Linux distribution</link>s as well as <link xlink:type="simple" xlink:href="../622/18932622.xml">
Berkeley software distribution</link> variants such as <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/7580554.xml">
FreeBSD</link></horizontal_surface>
</surface>
</artifact>
</platform>
 and <link xlink:type="simple" xlink:href="../495/21495.xml">
NetBSD</link>. Apart from these alternatives, amateur developers maintain an active <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/229119.xml">
operating system development community</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
, populated by self-written hobby kernels which mostly end up sharing many features with Linux and/or being compatible with it.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2254%22])">54</ref></p>

</ss1>
<ss1>
<st>
Mac OS</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../046/20046.xml">
Mac OS history</link></it>
</indent>

<link xlink:type="simple" xlink:href="../856/856.xml">
Apple Computer</link> first launched <link xlink:type="simple" xlink:href="../043/20043.xml">
Mac OS</link> in 1984, bundled with its <link xlink:type="simple" xlink:href="../979/19006979.xml">
Apple Macintosh</link> <link xlink:type="simple" xlink:href="../137/18457137.xml">
personal computer</link>. For the first few releases, Mac OS (or System Software, as it was called) lacked many essential features, such as multitasking and a hierarchical filesystem. With time, the OS evolved and eventually became Mac OS 9 and had many new features added, but the kernel basically stayed the same. Against this, <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link> is based on <link xlink:type="simple" xlink:href="../076/53076.xml">
Darwin</link>, which uses a hybrid kernel called <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../754/617754.xml">
XNU</link></software>
, which was created combining the <link xlink:type="simple" xlink:href="../807/1223807.xml#xpointer(//*[./st=%224.3BSD%22])">
4.3BSD</link> kernel and the <link xlink:type="simple" xlink:href="../028/21028.xml">
Mach kernel</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2255%22])">55</ref></p>

</ss1>
<ss1>
<st>
Amiga</st>

<p>

<indent level="1">

<it>Main article: <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../304/18933304.xml">
AmigaOS</link></O>
</it>
</indent>
The <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../580/7580.xml">
Commodore</link></company>
 <link xlink:type="simple" xlink:href="../980/1980.xml">
Amiga</link> was released in 1985, and was among the first (and certainly most successful) home computers to feature a microkernel operating system.  The Amiga's kernel, <it>exec.library</it>, was small but capable, providing fast pre-emptive multitasking on similar hardware to the cooperatively-multitasked Apple Macintosh, and an advanced <link>
dynamic linking</link> system that allowed for easy expansion.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2256%22])">56</ref></p>

</ss1>
<ss1>
<st>
Windows</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../694/13694.xml">
History of Microsoft Windows</link></it>
</indent>

<link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> was first released in 1985 as an add-on to <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../027/20027.xml">
MS-DOS</link></O>
.  Because of its dependence on another operating system, some believed that this meant it could not be an operating system itself, although whether this is true depends entirely on the definition of operating system in use.  This product line would continue through the release of the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../486/454486.xml">
Windows 9x</link></O>
 series (upgrading the systems's capabilities to 32-bit addressing and pre-emptive multitasking) and end with <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../458/75458.xml">
Windows Me</link></version>
. Meanwhile, Microsoft had been developing <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/33438.xml">
Windows NT</link></family>
, an operating system intended for high-end and business users, since 1993. This line started with the release of <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../882/984882.xml">
Windows NT 3.1</link></version>
 and came to an end with the release of the <link xlink:type="simple" xlink:href="../438/33438.xml">
NT-based</link> <version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../941/33941.xml">
Windows 2000</link></version>
.</p>
<p>

<version wordnetid="107173585" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../879/33879.xml">
Windows XP</link></version>
 brought these two product lines together, attempting to combine the stability of the NT line with consumer features from the 9x series.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2257%22])">57</ref> It uses the <link xlink:type="simple" xlink:href="../523/1942523.xml">
NT kernel</link>, which is generally considered a hybrid kernel because the kernel itself contains tasks such as the Window Manager and the IPC Manager, but several subsystems run in user mode.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2258%22])">58</ref></p>

</ss1>
<ss1>
<st>
Development of microkernels</st>
<p>

Although <link xlink:type="simple" xlink:href="../028/21028.xml">
Mach</link>, developed at <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../093/48093.xml">
Carnegie Mellon University</link></university>
 from 1985 to 1994, is the best-known general-purpose microkernel, other microkernels have been developed with more specific aims. The <link xlink:type="simple" xlink:href="../763/95763.xml">
L4 microkernel family</link> (mainly the L3 and the L4 kernel) was created to demonstrate that microkernels are not necessarily slow.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2246%22])">46</ref> Newer implementations such as <link>
Fiasco</link> and <link>
Pistachio</link> are able to run <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 next to other L4 processes in separate address spaces.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2259%22])">59</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2260%22])">60</ref></p>
<p>

<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../184/65184.xml">
QNX</link></O>
 is a <link xlink:type="simple" xlink:href="../123/26123.xml">
real-time operating system</link> with a minimalistic microkernel design that has been developed since 1982, having been far more successful than Mach in achieving the goals of the microkernel paradigm.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2261%22])">61</ref> It is principally used in <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded system</link>s and in situations where software is not allowed to fail, such as the robotic arms on the <link>
space shuttle</link> and machines that control grinding of glass to extremely fine tolerances, where a tiny mistake may cost hundreds of thousands of dollars, as in the case of the mirror of the <telescope wordnetid="104403638" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../203/40203.xml">
Hubble Space Telescope</link></telescope>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2262%22])">62</ref></p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../391/3740391.xml">
Comparison of kernels</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../194/22194.xml">
Operating system</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../300/5300.xml">
Memory</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../847/25847.xml">
Random access memory</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../354/32354.xml">
Virtual memory</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../193/311193.xml">
Paging</link>, <link xlink:type="simple" xlink:href="../131/1323131.xml">
Segmentation</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../938/472938.xml">
Swap space</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../467/93467.xml">
User space</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../112/177112.xml">
Memory management unit</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../857/6857.xml">
Multitasking</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../178/45178.xml">
Process</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../303/45303.xml">
Thread</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../920/231920.xml">
Scheduling</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../958/30958.xml">
Time sharing</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../904/6904.xml">
Context switch</link></entry>
<entry level="2" type="bullet">

 <link xlink:type="simple" xlink:href="../106/152106.xml">
Inter-process communication</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../446/2532446.xml">
Interrupt request (IRQ)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../558/14558.xml">
Input/output (I/O)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../101/9101.xml">
Device Driver</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../739/5739.xml">
Compiler</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../447/7380447.xml">
Trap (computing)</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Footnotes</st>
<p>

For notes referring to sources, see bibliography below.</p>
<p>

<reflist>
<entry id="1">
Roch 2004</entry>
<entry id="2">
Liedtke 95</entry>
<entry id="3">
Tanenbaum 79, chapter 1</entry>
<entry id="4">
Deitel 82, p.65-66 cap. 3.9</entry>
<entry id="5">
Lorin 81 pp.161-186, Schroeder 77, Shaw 75 pp.245-267</entry>
<entry id="6">
Wulf 74 pp.337-345</entry>
<entry id="7">
Brinch Hansen 70 pp.238-241</entry>
<entry id="8">
The highest privilege level has various names throughout different architectures, such as supervisor mode, kernel mode, CPL0, DPL0, Ring 0, etc. See <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/3446185.xml">
Ring (computer security)</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 for more information.</entry>
<entry id="9">
<weblink xlink:type="simple" xlink:href="http://osdever.net/bkerndev/index.php?the_id=90">
Bona Fide OS Development - Bran's Kernel Development Tutorial</weblink>, by Brandon Friesen</entry>
<entry id="10">
For low-level scheduling see Deitel 82, ch. 10, pp. 249&ndash;268.</entry>
<entry id="11">
Levy 1984, p.5</entry>
<entry id="12">
Needham, R.M., Wilkes, M. V. <it><weblink xlink:type="simple" xlink:href="http://comjnl.oxfordjournals.org/cgi/content/abstract/17/2/117">
Domains of protection and the management of processes</weblink></it>, Computer Journal, vol. 17, no. 2, May 1974, pp 117-120.</entry>
<entry id="13">
Silberschatz 1990 </entry>
<entry id="14">
 <cite id="Reference-Tanenbaum-2008" style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Tanenbaum, Andrew S.</link></professor>
</person>
&#32;(2008). Modern Operating Systems, 3rd Edition,&#32;Prentice Hall,&#32;50-51. ISBN 0-13-600663-9.&nbsp;". . . nearly all system calls [are] invoked from C programs by calling a library procedure . . . The library procedure . . . executes a TRAP instruction to switch from user mode to kernel mode and start execution . . ."</cite>&nbsp;</entry>
<entry id="15">
Denning 1976</entry>
<entry id="17">
Cook, D.J. <it><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=803220">
Measuring memory protection</weblink></it>, accepted for 3rd International Conference on Software Engineering, Atlanta, Georgia, May 1978.</entry>
<entry id="16">
Swift 2005, p.29 quote: "isolation, resource control, decision verification (checking), and error recovery."</entry>
<entry id="19">
Intel Corporation 2002</entry>
<entry id="18">
Swift 2005 p.26</entry>
<entry id="21">
Hansen 73, section 7.3 p.233 "<it>interactions between different levels of protection require transmission of messages by value</it>"</entry>
<entry id="20">
Houdek et al. 1981</entry>
<entry id="23">
Schroeder 72</entry>
<entry id="22">
Linden 76</entry>
<entry id="25">
Silberschatz &amp; Galvin, Operating System Concepts, 4th ed, pp445 &amp; 446</entry>
<entry id="24">
Stephane Eranian &amp; David Mosberger, <weblink xlink:type="simple" xlink:href="http://www.informit.com/articles/article.aspx?p=29961">
Virtual Memory in the IA-64 Linux Kernel</weblink>, Prentice Hall PTR, 2002</entry>
<entry id="27">
<weblink xlink:type="simple" xlink:href="http://www.cs.cmu.edu/~rwh/papers/langsec/dagstuhl.pdf">
A Language-Based Approach to Security</weblink>, Schneider F., Morrissett G. (Cornell University) and Harper R. (Carnegie Mellon University)</entry>
<entry id="26">
 <cite style="font-style:normal">Hoch, Charles; J. C. Browne (University of Texas, Austin)&#32;(July 1980).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=850701&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
An implementation of capabilities on the PDP-11/45</weblink>"&#32;(pdf). <it>ACM SIGOPS Operating Systems Review</it>&#32;<b>14</b>&#32;(3): 22–32. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F850697.850701">
10.1145/850697.850701</weblink>. Retrieved on <link>
2007-01-07</link>.</cite>&nbsp;</entry>
<entry id="29">
M. Abrams et al, <it><weblink xlink:type="simple" xlink:href="http://www.acsac.org/secshelf/book001/book001.html">
Information Security: An Integrated Collection of Essays</weblink>, IEEE Comp. 1995.</it></entry>
<entry id="28">
J. Lepreau et al. <it><weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/504450.504477">
The Persistent Relevance of the Local Operating System to Global Applications</weblink></it>. Proceedings of the 7th ACM SIGOPS European Workshop, September 1996.</entry>
<entry id="31">
<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Jerry H. Saltzer, Mike D. Schroeder&#32;(September 1975).&#32;"<weblink xlink:type="simple" xlink:href="http://web.mit.edu/Saltzer/www/publications/protection/">
The protection of information in computer systems</weblink>". <it>Proceedings of the IEEE</it>&#32;<b>63</b>&#32;(9): 1278–1308. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109%2FPROC.1975.9939">
10.1109/PROC.1975.9939</weblink>.</cite>&nbsp;</entry>
</list>
</entry>
<entry id="30">
J. Anderson, <it><weblink xlink:type="simple" xlink:href="http://csrc.nist.gov/publications/history/ande72.pdf">
Computer Security Technology Planning Study</weblink>, Air Force Elect. Systems Div., ESD-TR-73-51, October 1972.</it></entry>
<entry id="34">
Dijkstra, E. W. <it>Cooperating Sequential Processes</it>. Math. Dep., Technological U., Eindhoven, Sept. 1965.</entry>
<entry id="35">
"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=363778&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">
SHARER, a time sharing system for the CDC 6600</weblink>".&#32;Retrieved on <link>
2007-01-07</link>.</entry>
<entry id="32">
P. A. Loscocco, S. D. Smalley, P. A. Muckelbauer, R. C. Taylor, S. J. Turner, and J. F. Farrell. <it><weblink xlink:type="simple" xlink:href="http://www.jya.com/paperF1.htm">
The Inevitability of Failure: The Flawed Assumption of Security in Modern Computing Environments</weblink></it>. In Proceedings of the 21st National Information Systems Security Conference, pages 303–314, Oct. 1998. <weblink xlink:type="simple" xlink:href="http://csrc.nist.gov/nissc/1998/proceedings/paperF1.pdf">
http://csrc.nist.gov/nissc/1998/proceedings/paperF1.pdf</weblink>.</entry>
<entry id="33">
 <cite style="font-style:normal">Jonathan S. Shapiro; Jonathan M. Smith; David J. Farber.&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=319151.319163">
EROS: a fast capability system</weblink>". <it>Proceedings of the seventeenth ACM symposium on Operating systems principles</it>.</cite>&nbsp;</entry>
<entry id="38">
Levin 75</entry>
<entry id="39">
Denning 1980</entry>
<entry id="36">
"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=811675&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">
Dynamic Supervisors - their design and construction</weblink>".&#32;Retrieved on <link>
2007-01-07</link>.</entry>
<entry id="37">
Baiardi 1988</entry>
<entry id="42">
Levy 84, p.1 quote: "Conventional architectures support a single privileged mode of
operation. This structure leads to monolithic design; any module needing protection must be part of the single operating system kernel. If, instead, any module could execute within a protected domain, systems could be built as a collection of independent modules extensible by any user."</entry>
<entry id="43">
Virtual addressing is most commonly achieved through a built-in <link xlink:type="simple" xlink:href="../112/177112.xml">
memory management unit</link>.</entry>
<entry id="40">
Jürgen Nehmer <it><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=723612">
The Immortality of Operating Systems, or: Is Research in Operating Systems still Justified?</weblink></it> Lecture Notes In Computer Science; Vol. 563. Proceedings of the International Workshop on Operating Systems of the 90s and Beyond. pp. 77 - 83 (1991) ISBN 3-540-54987-0 <weblink xlink:type="simple" xlink:href="http://www.sigmod.org/dblp/db/conf/dagstuhl/os1991.html">
http://www.sigmod.org/dblp/db/conf/dagstuhl/os1991.html</weblink> quote: "The past 25 years have shown that research on operating system architecture had a minor effect on existing main stream systems." <weblink xlink:type="simple" xlink:href="http://www.soe.ucsc.edu/~brucem/soft_ins/dissert.html">
http://www.soe.ucsc.edu/~brucem/soft_ins/dissert.html</weblink></entry>
<entry id="41">
Levy 84, p.1 quote: "Although the complexity of computer applications increases yearly, the underlying hardware architecture for applications has remained unchanged for decades."</entry>
<entry id="46">
<weblink xlink:type="simple" xlink:href="http://os.inf.tu-dresden.de/L4/overview.html">
The L4 microkernel family - Overview</weblink></entry>
<entry id="47">
<weblink xlink:type="simple" xlink:href="http://www.cis.upenn.edu/~KeyKOS/NanoKernel/NanoKernel.html">
KeyKOS Nanokernel Architecture</weblink></entry>
<entry id="44">
Recordings of the debate between Torvalds and Tanenbaum can be found at <weblink xlink:type="simple" xlink:href="http://www.dina.dk/~abraham/Linus_vs_Tanenbaum.html">
dina.dk</weblink>, <weblink xlink:type="simple" xlink:href="http://groups.google.com/group/comp.os.minix/browse_thread/thread/c25870d7a41696d2/f447530d082cd95d?tvc=2#f447530d082cd95d">
groups.google.com</weblink>, <weblink xlink:type="simple" xlink:href="http://www.oreilly.com/catalog/opensources/book/appa.html">
oreilly.com</weblink> and <weblink xlink:type="simple" xlink:href="http://www.cs.vu.nl/~ast/reliable-os/">
Andrew Tanenbaum's website</weblink></entry>
<entry id="45">
Härtig 97</entry>
<entry id="51">
<weblink xlink:type="simple" xlink:href="http://www.multicians.org/fjcc1.html">
Introduction and Overview of the Multics System</weblink>, by F. J. Corbató and V. A. Vissotsky.</entry>
<entry id="50">
<weblink xlink:type="simple" xlink:href="http://cm.bell-labs.com/cm/cs/who/dmr/cacm.html">
BSTJ version of C.ACM Unix paper</weblink></entry>
<entry id="49">
Hansen 2001 (os), pp.17-18</entry>
<entry id="48">
 <weblink xlink:type="simple" xlink:href="http://pdos.csail.mit.edu/exo.html">
MIT Exokernel Operating System</weblink></entry>
<entry id="55">
<weblink xlink:type="simple" xlink:href="http://www.kernelthread.com/mac/osx/arch_xnu.html">
XNU: The Kernel</weblink></entry>
<entry id="54">
This community mostly gathers at <weblink xlink:type="simple" xlink:href="http://www.osdever.net">
Bona Fide OS Development</weblink> and <weblink xlink:type="simple" xlink:href="http://www.mega-tokyo.com/forum">
The Mega-Tokyo Message Board</weblink>.</entry>
<entry id="53">
<weblink xlink:type="simple" xlink:href="http://www.dwheeler.com/essays/linux-kernel-cost.html">
Linux Kernel 2.6: It's Worth More!</weblink>, by David A. Wheeler, October 12, 2004</entry>
<entry id="52">
<weblink xlink:type="simple" xlink:href="http://www.unix.org/what_is_unix/single_unix_specification.html">
The UNIX System &mdash; The Single Unix Specification</weblink></entry>
<entry id="59">
<weblink xlink:type="simple" xlink:href="http://os.inf.tu-dresden.de/fiasco/overview.html">
The Fiasco microkernel - Overview</weblink></entry>
<entry id="58">
<weblink xlink:type="simple" xlink:href="http://www.microsoft.com/windows/WinHistoryDesktop.mspx">
Windows History: Windows Desktop Products History</weblink></entry>
<entry id="57">
<weblink xlink:type="simple" xlink:href="http://www.linuxworld.com.au/index.php/id;940707233;fp;2;fpid;1">
LinuxWorld IDC: Consolidation of Windows won't happen</weblink></entry>
<entry id="56">
Sheldon Leemon.&#32;"<weblink xlink:type="simple" xlink:href="http://www.atarimagazines.com/creative/v11n9/34_What_makes_it_so_great.php">
What makes it so great! (Commodore Amiga)</weblink>".&#32;  Creative Computing.&#32;Retrieved on <link>
2006-02-05</link>.</entry>
<entry id="62">
<weblink xlink:type="simple" xlink:href="http://hubble.nasa.gov/a_pdf/news/facts/overview.pdf">
Hubble Facts</weblink>, by <agency wordnetid="108337324" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../568/18426568.xml">
NASA</link></agency>
, January 1997</entry>
<entry id="61">
<weblink xlink:type="simple" xlink:href="http://www.qnx.com/products/rtos/microkernel.html">
QNX Realtime Operating System Overview</weblink></entry>
<entry id="60">
<weblink xlink:type="simple" xlink:href="http://www.l4ka.org">
L4Ka - The L4 microkernel family and friends</weblink></entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 Roch, Benjamin&#32;(2004).&#32;"<weblink xlink:type="simple" xlink:href="http://www.vmars.tuwien.ac.at/courses/akti12/journal/04ss/article_04ss_Roch.pdf">
Monolithic kernel vs. Microkernel</weblink>"&#32;(pdf).&#32;Retrieved on <link>
2006-10-12</link>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Silberschatz-1991" style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../106/4210106.xml">
Silberschatz, Abraham</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
;&#32;James L. Peterson, Peter B. Galvin&#32;(1991). <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=95329&amp;dl=acm&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
Operating system concepts</weblink>.&#32;<village wordnetid="108672738" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../309/4309.xml">
Boston, Massachusetts</link></village>
:&#32;Addison-Wesley,&#32;696. ISBN 0-201-51379-X.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Deitel-1984" style="font-style:normal" class="book">Deitel, Harvey M.&#32;[1982]&#32;(1984). <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=79046&amp;dl=GUIDE&amp;coll=GUIDE">
An introduction to operating systems</weblink>, revisited first edition,&#32;Addison-Wesley,&#32;673. ISBN 0-201-14502-2.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal"><link xlink:type="simple" xlink:href="../772/974772.xml">
Denning, Peter J.</link>&#32;(December 1976).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=356680&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
Fault tolerant operating systems</weblink>". <it>ACM Computing Surveys (CSUR)</it>&#32;<b>8</b>&#32;(4): 359–389. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F356678.356680">
10.1145/356678.356680</weblink>. <symbol wordnetid="106806469" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<signal wordnetid="106791372" confidence="0.8">
<identifier wordnetid="107270601" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../930/234930.xml">
ISSN</link></system_of_measurement>
</identifier>
</signal>
</standard>
</symbol>
 <weblink xlink:type="simple" xlink:href="http://worldcat.org/issn/0360-0300">
0360-0300</weblink>.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../772/974772.xml">
Denning, Peter J.</link></scientist>
&#32;(April 1980).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=859506&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">
Why not innovations in computer architecture?</weblink>". <it>ACM SIGARCH Computer Architecture News</it>&#32;<b>8</b>&#32;(2): 4–7. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F859504.859506">
10.1145/859504.859506</weblink>. ISSN 0163-5964.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Hansen, Per Brinch</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
&#32;(April 1970).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=362278&amp;dl=ACM&amp;coll=GUIDE&amp;CFID=11111111&amp;CFTOKEN=2222222">
The nucleus of a Multiprogramming System</weblink>". <it>Communications of the ACM</it>&#32;<b>13</b>&#32;(4): 238–241. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F362258.362278">
10.1145/362258.362278</weblink>. ISSN 0001-0782.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Hansen, Per Brinch</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
&#32;[1973]. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=540365">
Operating System Principles</weblink>.&#32;<link xlink:type="simple" xlink:href="../880/136880.xml">
Englewood Cliffs</link>:&#32;Prentice Hall,&#32;496. ISBN 0-13-637843-9.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/863750.xml">
Hansen, Per Brinch</link></associate>
</creator>
</research_worker>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
&#32;(2001).&#32;"<it><weblink xlink:type="simple" xlink:href="http://brinch-hansen.net/papers/2001b.pdf">
The evolution of operating systems</weblink></it>"&#32;(pdf). &#32;Retrieved on <link>
2006-10-24</link>. included in book:  <cite style="font-style:normal" class="book">&#32;[2001]&#32;"<weblink xlink:type="simple" xlink:href="http://brinch-hansen.net/papers/2001b.pdf">
1</weblink>",&#32;in Per Brinch Hansen: <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=360596&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
Classic operating systems: from batch processing to distributed systems</weblink>.&#32;New York,:&#32;Springer-Verlag,&#32;1-36. ISBN 0-387-95113-X.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<link>
Hermann Härtig</link>, Michael Hohmuth, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Jochen Liedtke</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
, Sebastian Schönberg, Jean Wolter <it><weblink xlink:type="simple" xlink:href="http://os.inf.tu-dresden.de/pubs/sosp97/#Karshmer:1991:OSA">
The performance of μ-kernel-based systems</weblink></it> <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/268998.266660">
http://doi.acm.org/10.1145/268998.266660</weblink> ACM SIGOPS Operating Systems Review, v.31 n.5, p.66-77, Dec. 1997</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Houdek, M. E., Soltis, F. G., and Hoffman, R. L. 1981. <it><weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=800052.801885">
IBM System/38 support for capability-based addressing</weblink></it>. In Proceedings of the 8th ACM International Symposium on Computer Architecture. ACM/IEEE, pp. 341–348.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../617/14617.xml">
Intel Corporation</link></company>
 (2002) <it><weblink xlink:type="simple" xlink:href="http://www.intel.com/design/pentium4/manuals/24547010.pdf">
The IA-32 Architecture Software Developer’s Manual, Volume 1: Basic Architecture</weblink>''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Levin, R.; E. Cohen, W. Corwin, F. Pollack, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../160/276160.xml">
William Wulf</link></associate>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
&#32;(1975).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=806531&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
Policy/mechanism separation in Hydra</weblink>". <it>ACM Symposium on Operating Systems Principles / Proceedings of the fifth ACM symposium on Operating systems principles</it>: 132–140.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book">Levy, Henry M.&#32;(1984). <weblink xlink:type="simple" xlink:href="http://www.cs.washington.edu/homes/levy/capabook/index.html">
Capability-based computer systems</weblink>.&#32;Maynard, Mass:&#32;Digital Press. ISBN 0-932376-22-3.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../112/1623112.xml">
Liedtke, Jochen</link></research_worker>
</scientist>
</causal_agent>
</engineer>
</programmer>
</computer_user>
</person>
</physical_entity>
. <it><weblink xlink:type="simple" xlink:href="http://i30www.ira.uka.de/research/publications/papers/index.php?lid=en&amp;docid=642">
On µ-Kernel Construction</weblink></it>, <it>Proc. 15th ACM Symposium on Operating System Principles (SOSP)</it>, December 1995</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Linden, Theodore A.&#32;(December 1976).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=356682&amp;coll=&amp;dl=ACM&amp;CFID=15151515&amp;CFTOKEN=6184618">
Operating System Structures to Support Security and Reliable Software</weblink>". <it>ACM Computing Surveys (CSUR)</it>&#32;<b>8</b>&#32;(4): 409–445. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F356678.356682">
10.1145/356678.356682</weblink>. ISSN 0360-0300.</cite>&nbsp; <weblink xlink:type="simple" xlink:href="http://csrc.nist.gov/publications/history/lind76.pdf">
http://csrc.nist.gov/publications/history/lind76.pdf</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Lorin-1981" style="font-style:normal" class="book">Lorin, Harold&#32;(1981). <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=578308&amp;coll=GUIDE&amp;dl=GUIDE&amp;CFID=2651732&amp;CFTOKEN=19681373">
Operating systems</weblink>.&#32;<village wordnetid="108672738" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../309/4309.xml">
Boston, Massachusetts</link></village>
:&#32;Addison-Wesley,&#32;pp.161-186. ISBN 0-201-14464-6.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../277/6521277.xml">
Schroeder, Michael D.</link></associate>
</scientist>
</causal_agent>
</colleague>
</specialist>
</person>
</expert>
</peer>
</physical_entity>
; Jerome H. Saltzer&#32;(March 1972).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=361275&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
A hardware architecture for implementing protection rings</weblink>". <it>Communications of the ACM</it>&#32;<b>15</b>&#32;(3): 157–170. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F361268.361275">
10.1145/361268.361275</weblink>. ISSN 0001-0782.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Shaw-1974" style="font-style:normal" class="book">Shaw, Alan C.&#32;(1974). <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=540329">
The logical design of Operating systems</weblink>.&#32;Prentice-Hall,&#32;304. ISBN 0-13-540112-7.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Tanenbaum-1979" style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Tanenbaum, Andrew S.</link></professor>
</person>
&#32;(1979). Structured Computer Organization.&#32;<village wordnetid="108672738" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../880/136880.xml">
Englewood Cliffs, New Jersey</link></village>
:&#32;Prentice-Hall. ISBN 0-13-148521-0.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../160/276160.xml">
Wulf, W.</link></associate>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
; E. Cohen, W. Corwin, A. Jones, R. Levin, C. Pierson, F. Pollack&#32;(June 1974).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=364017&amp;coll=portal&amp;dl=ACM">
HYDRA: the kernel of a multiprocessor operating system</weblink>". <it>Communications of the ACM</it>&#32;<b>17</b>&#32;(6): 337–345. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F355616.364017">
10.1145/355616.364017</weblink>. ISSN 0001-0782.</cite>&nbsp; <weblink xlink:type="simple" xlink:href="http://www.cs.virginia.edu/papers/p337-wulf.pdf">
http://www.cs.virginia.edu/papers/p337-wulf.pdf</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Baiardi-1988" style="font-style:normal" class="book">Baiardi, F.;&#32;A. Tomasi, <weblink xlink:type="simple" xlink:href="http://www.di.unipi.it/~vannesch/">
M. Vanneschi</weblink>&#32;(1988). <weblink xlink:type="simple" xlink:href="http://www.pangloss.it/libro.php?isbn=882042746X&amp;id=4357&amp;PHPSESSID=9da1895b18ed1cda115cf1c7ace9bdf0">
Architettura dei Sistemi di Elaborazione, volume 1</weblink>&#32;(in Italian).&#32;Franco Angeli. ISBN 88-204-2746-X.</cite>&nbsp;</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Swift, Michael M; Brian N. Bershad , Henry M. Levy, <it><weblink xlink:type="simple" xlink:href="http://nooks.cs.washington.edu/nooks-tocs.pdf">
Improving the reliability of commodity operating systems</weblink></it>, <weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/1047915.1047919">
http://doi.acm.org/10.1145/1047915.1047919</weblink> ACM Transactions on Computer Systems (TOCS), v.23 n.1, p.77-110, February 2005</entry>
</list>
</p>


</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../110/3110.xml">
Andrew Tanenbaum</link>, <it>Operating Systems - Design and Implementation (Third edition)</it>;</entry>
<entry level="1" type="bullet">

 Andrew Tanenbaum, <it>Modern Operating Systems (Second edition)</it>;</entry>
<entry level="1" type="bullet">

 <link>
Daniel P. Bovet</link>, <link>
Marco Cesati</link>, <it>The Linux Kernel</it>;</entry>
<entry level="1" type="bullet">

 <link>
David A. Peterson</link>, <link>
Nitin Indurkhya</link>, Patterson, <it>Computer Organization and Design</it>, <link>
Morgan Koffman</link> (ISBN 1-55860-428-6);</entry>
<entry level="1" type="bullet">

 <link>
B.S. Chalk</link>, <it>Computer Organisation and Architecture</it>, Macmillan P.(ISBN 0-333-64551-0).</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.kernel.org">
KERNEL.ORG, official Linux kernel home.</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sourceforge.net/softwaremap/trove_list.php?form_cat=144">
Operating System Kernels at SourceForge</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://freshmeat.net/browse/144/">
Operating System Kernels at Freshmeat</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.pdos.lcs.mit.edu/exo.html">
MIT Exokernel Operating System</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://wiki.debian.org/kernel_image">
Kernel image -  Debian Wiki</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cis.upenn.edu/~KeyKOS/NanoKernel/NanoKernel.html">
The KeyKOS Nanokernel Architecture</weblink>, a 1992 paper by <link>
Norman Hardy</link> <it>et al</it>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.usenix.org/publications/library/proceedings/sf94/full_papers/minshall.a">
An Overview of the NetWare Operating System</weblink>, a 1994 paper by Drew Major, Greg Minshall, and Kyle Powell (primary architects behind the NetWare OS).</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://kernelnewbies.org/">
Kernelnewbies</weblink>, a community for learning Linux kernel hacking.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://widefox.pbwiki.com/Kernel%20Comparison%20Linux%20vs%20Windows">
Detailed comparison between most popular operating system kernels</weblink>.</entry>
</list>
</p>



</sec>
</bdy>
</kernel>
</article>
