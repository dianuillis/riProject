<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:27:01[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<information  confidence="0.8" wordnetid="106634376">
<electronic_database  confidence="0.8" wordnetid="106588511">
<lexical_database  confidence="0.8" wordnetid="106638868">
<wordnet  confidence="0.8" wordnetid="106639428">
<database  confidence="0.8" wordnetid="106637824">
<header>
<title>NLTSS</title>
<id>5043345</id>
<revision>
<id>235092536</id>
<timestamp>2008-08-30T00:13:52Z</timestamp>
<contributor>
<username>The Anomebot2</username>
<id>1979668</id>
</contributor>
</revision>
<categories>
<category>Operating systems</category>
</categories>
</header>
<bdy>

<b>NLTSS</b>, the <b>Network Livermore Timesharing System</b>, also sometimes known as the <b>New Livermore Time Sharing System</b> was an <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> that was actively developed at Lawrence Livermore Laboratory (now <lab wordnetid="103629986" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../039/39039.xml">
Lawrence Livermore National Laboratory</link></lab>
) from <link xlink:type="simple" xlink:href="../754/34754.xml">
1979</link> until about <link xlink:type="simple" xlink:href="../670/34670.xml">
1988</link>, though it continued to run production applications until <link xlink:type="simple" xlink:href="../658/34658.xml">
1995</link>.  NLTSS ran initially on a <link xlink:type="simple" xlink:href="../742/655742.xml">
CDC 7600</link> computer, but only ran production from about <link xlink:type="simple" xlink:href="../846/34846.xml">
1985</link> until <link xlink:type="simple" xlink:href="../337/18948337.xml">
1994</link> on <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../315/217315.xml">
Cray</link></company>
 computers including the <link xlink:type="simple" xlink:href="../171/37171.xml">
Cray-1</link>, <link xlink:type="simple" xlink:href="../242/285242.xml">
Cray X-MP</link>, and <link xlink:type="simple" xlink:href="../164/855164.xml">
Cray Y-MP</link> models.
<sec>
<st>
 Characteristics </st>
<p>

The NLTSS operating system was unusual in many respects and unique in some.</p>

<ss1>
<st>
 Low-level architecture </st>
<p>

NLTSS was a <link xlink:type="simple" xlink:href="../023/20023.xml">
microkernel</link> <link xlink:type="simple" xlink:href="../867/1324867.xml">
message passing</link> system.  It was unique in that only a single system call was supported by the kernel of the system.  That system call, which might be called "communicate" (it didn't have a name because it didn't need to be distinguished from other system calls) accepted a list of "buffer tables" (e.g. see <weblink xlink:type="simple" xlink:href="http://www.webstart.com/jed/papers/Components/#s5">
The NLTSS Message System Interface</weblink>) that contained control information for message communication - either sends or receives.  Such communication, both locally within the system and across a network was all the kernel of the system supported directly for user <link xlink:type="simple" xlink:href="../178/45178.xml">
processes</link>.  The "message system" (supporting the one call and the <link xlink:type="simple" xlink:href="../652/5652.xml">
network protocols</link>) and drivers for the disks and processor composed the entire kernel of the system.</p>

</ss1>
<ss1>
<st>
 Mid-level architecture </st>
<p>

NLTSS was a <link xlink:type="simple" xlink:href="../717/539717.xml">
capability-based</link> <link xlink:type="simple" xlink:href="../513/6513.xml">
client-server</link> system.  The two primary servers were the file server and the process server.  The file server was a process privileged to be trusted by the drivers for local storage (disk storage,) and the process server was a process privileged to be trusted by the processor driver (software that switched <link xlink:type="simple" xlink:href="../958/30958.xml">
time sharing</link> control between processes in the "alternator", handled interrupts for processes besides the "communicate" call, provided access to memory and process state for the process server, etc.).</p>
<p>

NLTSS was a true <link xlink:type="simple" xlink:href="../411/41411.xml">
network operating system</link> in that its resource requests could come from local processes or remote processes anywhere on the network and the servers didn't distinguish them.  A server's only means to make such distinctions would be by network address and they had no reason to make such distinctions.  All requests to the servers appeared as network requests.</p>
<p>

Communication between processes in NLTSS by convention used the <b>LINCS</b> (<b>Livermore Interactive Network Communication System</b>) protocol suite, which defined a <link xlink:type="simple" xlink:href="../882/23882.xml">
protocol stack</link> along the lines of that defined by the <link xlink:type="simple" xlink:href="../747/22747.xml">
OSI reference model</link>.  The transport level protocol for NLTSS and LINCS was called <b>Delta-T</b>.  At the presentation level LINCS defined standards for communicating numbered parameters as tokens (e.g. integers, capabilities, etc.) that were stored in a session level record for processing in a <link xlink:type="simple" xlink:href="../346/26346.xml">
remote procedure call</link> sort of mechanism.</p>
<p>

The notion of a "<link xlink:type="simple" xlink:href="../990/16301990.xml">
user</link>" was only rather peripherally defined in NLTSS.  There was an "account server" that kept track of which users were using which resources (e.g. requests to create objects such as file or processes required such an account capability).  Access control was entirely managed with capabilities (communicable authority tokens).</p>

</ss1>
<ss1>
<st>
 File server </st>
<p>

Any process could make requests to the file server for the creation of files (returning a file <link xlink:type="simple" xlink:href="../717/539717.xml">
capability</link>), ask to read or write files (by presenting a file capability), etc.  For example, the act of reading a file generally required three buffer tables, one to send the request to the file server, one to receive the reply from the file server, and one to receive the data from the file.  These three requests were generally submitted at one time to the message system, sometimes bundled with other requests.  Control bits could be set in the buffer tables to awaken (unblock) a process whenever any of the buffer tables submitted were marked "Done".  A library call to read a file would typically block until the control reply was received from the file server, though <link xlink:type="simple" xlink:href="../953/1880953.xml">
asynchronous I/O</link> would of course not block and could check or block later.  Any such differences on the user side were invisible to the file server.</p>

</ss1>
<ss1>
<st>
 Process server </st>
<p>

In NLTSS the process server was quite similar to the file server in that user processes could ask for the creation of processes, the starting or stopping of processes, reading or writing process memory or registers, and to be notified of process faults.  The process server was an ordinary <link xlink:type="simple" xlink:href="../467/93467.xml">
user mode</link> process that was simply trusted to communicate with the <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> driver, just like the file server was trusted to communicate with the disk driver.  The process server stored process state in files provided by the file server and in that regard appeared like any other user process to the file server.</p>

</ss1>
<ss1>
<st>
 Directory server </st>
<p>

An example higher level server in NLTSS was the directory server.  This server's task was to essentially turn files (invisible to the user) into directories that could be used to store and retrieve capabilities by name.  Since capabilities were simply data this wasn't a particularly difficult task - consisting mostly of manipulating access permissions on the capabilities according to the conventions defined in the LINCS protocol suite.  One place where this got a bit interesting was regarding an access permission called "inheritance".  If this bit was on (allowed) then capabilities could be fetched with their full access from the directory.  If this bit was turned off (disallowed) then any permissions turned off in the directory capability were in turn turned off in the capability being feteched before it was returned to the requesting application.  This mechanism allowed people to store, for example, read/write files in a directory, but to give other users only permission to fetch read-only instances of them.</p>

</ss1>
</sec>
<sec>
<st>
 Development </st>
<p>

The bulk of the programming for NLTSS was done in a <link xlink:type="simple" xlink:href="../773/23773.xml">
Pascal</link> extension developed at <site wordnetid="108651247" confidence="0.8">
<region wordnetid="108630985" confidence="0.8">
<position wordnetid="108621598" confidence="0.8">
<center wordnetid="108523483" confidence="0.8">
<point wordnetid="108620061" confidence="0.8">
<landmark wordnetid="108624891" confidence="0.8">
<area wordnetid="108497294" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/38145.xml">
Los Alamos National Laboratory</link></geographical_area>
</tract>
</location>
</area>
</landmark>
</point>
</center>
</position>
</region>
</site>
 known as "Model".  Model extended Pascal to include an <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
abstract data type</link> (object) mechanism and some other features.</p>
<p>

NLTSS was saddled with a compatibility legacy.  NLTSS followed the development and deployment of the LTSS (Livermore Time Sharing System) in the Livermore Computer Center at LLNL (~1968-1988?).  NLTSS development started about the same time LTSS was ported to the <link xlink:type="simple" xlink:href="../171/37171.xml">
Cray-1</link> to become the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../451/1703451.xml">
Cray Time Sharing System</link></O>
.  To stay <link xlink:type="simple" xlink:href="../459/4459.xml">
backward compatible</link> with the many scientific applications at LLNL, NLTSS was forced to emulate the prior LTSS operating system's system calls.  This emulation was implemented in the form of a compatibility library called "baselib".  As one example, while the directory structure and thus the process structure for NLTSS was naturally a <link xlink:type="simple" xlink:href="../986/19721986.xml">
directed graph</link> (process capabilities could be stored in directories just like file capabilities or directory capabilities), the baselib library emulated a simple linear (controller - controllee) process structure (not even a <link xlink:type="simple" xlink:href="../821/41821.xml">
tree structure</link> as in <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
) to stay compatible with the previous LTSS.  Since scientific users never accessed NLTSS services outside the baselib library, NLTSS ended up looking nearly exactly like LTSS to its users.  Most users weren't aware of capabilities, didn't realize that they could access resources across the network, and generally weren't aware that NLTSS offered any services beyond those of LTSS.  NLTSS did support <link xlink:type="simple" xlink:href="../653/825653.xml">
shared memory</link> <link xlink:type="simple" xlink:href="../318/50318.xml">
symmetric multiprocessing</link>, a development that paralleled a similar development in the <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../451/1703451.xml">
Cray Time Sharing System</link></O>
.</p>
<p>

Even the name NLTSS was something of a legacy.  The "New Livermore Time Sharing System" name was initially considered a temporary name to use during development.  Once the system began to run some applications in a "dual system" mode (sort of a <link xlink:type="simple" xlink:href="../353/32353.xml">
virtual machine</link> sharing drivers with LTSS) a more permanent name, LINOS (LIncs Network Operating System), was chosen by the developers.  Unfortunately, the management at LLNL decided that the name couldn't be changed at that point (seemingly because the previous term had been used in budget requests) so the temporary development "NLTSS" name stayed with the system throughout its lifetime.</p>
<p>

A <link xlink:type="simple" xlink:href="../719/455719.xml">
mass storage</link> system was also developed in parallel with NLTSS that used the LINCS protocols (same file and directory protocols as NLTSS).  This system/software was later commercialized as the Unitree product.  Unitree was generally superseded by the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../733/15664733.xml">
High Performance Storage System</link></software>
 that could loosely be considered a legacy of LINCS and NLTSS.  For example, LINCS and NLTSS introduced a form of third party transfer (to copy file to file in NLTSS a process could send two requests to file servers, one to read and one to write and direct the file servers to transfer the data between themselves) that carried through in modified form to Unitree and HPSS.</p>

</sec>
<sec>
<st>
Implementation and design issues</st>

<p>

The biggest knock against NLTSS during its production lifetime was performance.  The one performance issue that affected users most was file access <link xlink:type="simple" xlink:href="../933/17933.xml">
latency</link>.  This generally wasn't a significant problem for disk I/O, but the systems that NLTSS ran on also supported a significant complement of very low latency <link xlink:type="simple" xlink:href="../298/7366298.xml">
solid state disk</link>s with access times under 10 microseconds.  The initial latencies for file operations under NLTSS were comparable to the latency for solid state disk access and significantly higher than the LTSS latency for such access.  To improve file access latency under NLTSS the implementation was changed significantly to put the most latency sensitive processes (in particular the file server) "in the kernel".  This effort wasn't as significant as it might at first sound as all NLTSS servers worked on a <link xlink:type="simple" xlink:href="../679/10520679.xml">
multithreading</link> model.  What this change really amounted to was to move the threads responsible for file server services from a separate file server process into the kernel "process".  Communication to users was unchanged (still through buffer tables, LINCS tokens, etc.), but file operations avoided some significant context changes that were the primary cause of the higher latencies over what the older LTSS and the competing <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../451/1703451.xml">
Cray Time Sharing System</link></O>
 provided.  This change did significantly (~3x) improve the latency of file I/O operations, but it also meant that the file server became a trusted part of the kernel (by implementation, not by design).</p>
<p>

A second implementation issue with NLTSS related to the security/integrity of its capability as data implementation.  This implementation used a password capability model (e.g. see <weblink xlink:type="simple" xlink:href="http://www.webstart.com/jed/papers/Managing-Domains/#s8">
Control by Password</weblink>).  With this model any person or process that could get access to the memory space of a process would have the authority to access the capability represented by the data found in that memory.  Some system architects (e.g. <person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Andrew S. Tanenbaum</link></professor>
</person>
, the architect of the <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../784/440784.xml">
Amoeba distributed operating system</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
) have suggested that this property of access to memory implying access to capabilities is not an inherent problem.  In the environment of NLTSS it sometimes happened that people took program <link xlink:type="simple" xlink:href="../721/49721.xml">
memory dump</link>s to others for analysis.  Because of this and other concerns, such password capabilities were considered a vulnerability in NLTSS.  A design was done to protect against this vulnerability, the <weblink xlink:type="simple" xlink:href="http://www.webstart.com/jed/papers/Managing-Domains/#s13">
Control by Public Key Encryption</weblink> mechanism.  This mechanism wasn't put into production in NLTSS both because of its significant performance cost and because users weren't aware of the vulnerability from password capabilities.  Modern advances in cryptography would make such protection for capabilities practical, especially for Internet/Web capabilities (e.g. see <weblink xlink:type="simple" xlink:href="http://www.waterken.com/dev/YURL/">
YURLs</weblink> or [https://wideword.net/ WideWORD]).</p>
<p>

A design issue with NLTSS that wasn't considered until years after it was removed from production was its open network architecture.  In NLTSS processes were considered as virtual processors in a network with no <link xlink:type="simple" xlink:href="../296/1362296.xml">
firewalls</link> or other restrictions.  Any process could communicate freely to any other.  This meant that it was not possible to do <link>
confinement</link> even in the sense of limiting direct communication (e.g. vs. limiting <link xlink:type="simple" xlink:href="../907/174907.xml">
covert channel</link>s such as "wall banging").  To correct this problem NLTSS would have to require capabilities to enable communication.  Late development work on NLTSS such as "stream numbers" was getting close to such a facility, but by the time active development stopped in <link xlink:type="simple" xlink:href="../670/34670.xml">
1988</link> communication in NLTSS was still unconfined.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <it><weblink xlink:type="simple" xlink:href="http://www.webstart.com/jed/">
Jed Donnelley</weblink></it>, project leader</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 J. E. Donnelley, <it><weblink xlink:type="simple" xlink:href="http://www.webstart.com/jed/papers/Components/">
 Components of a Network Operating System</weblink></it>, Fourth Conference on Local Networks, Minneapolis, 1979. Also in Computer Networks 3 (1979) 389-399.</entry>
<entry level="1" type="bullet">

 J. E. Donnelley, <it><weblink xlink:type="simple" xlink:href="http://www.webstart.com/jed/papers/Managing-Domains/">
  Managing Domains in a Network Operating System</weblink></it>, Proceedings of Local Networks and Distributed Office Systems Conference, London, May 1981, pp. 345-361.</entry>
<entry level="1" type="bullet">

 S. T. Brugger, M. Gandhi, and G. Streletz, <it><weblink xlink:type="simple" xlink:href="http://www.computer-history.info/Page4.dir/pages/LTSS.NLTSS.dir/pages/NLTSS.pdf">
Network Livermore Time Sharing System (NLTSS)</weblink></it>, 2001</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.computer-history.info/Page4.dir/pages/LTSS.NLTSS.dir/pages/cap-livermore.html">
Capability Computing at LLNL</weblink> A discussion of the history of the use of capabilities in computing at LLNL, including a brief mention of the <weblink xlink:type="simple" xlink:href="http://www.computer-history.info/Page4.dir/pages/RATS.html">
RATS system</weblink> and how the development lead to NLTSS</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.computer-history.info/">
Stories of the Development of Large Scale Scientific Computing at Lawrence Livermore National Laboratory</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.computer-history.info/Page5.dir/pages/Chronicles.dir/">
The NLTSS Chronicles</weblink> Cartoons from the development of NLTSS and LINCS</entry>
</list>
</p>

</sec>
</bdy>
</database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
</article>
