<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:11:41[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Point in polygon</title>
<id>504484</id>
<revision>
<id>234957589</id>
<timestamp>2008-08-29T09:40:26Z</timestamp>
<contributor>
<username>Михајло Анђелковић</username>
<id>1597947</id>
</contributor>
</revision>
<categories>
<category>Geometric algorithms</category>
</categories>
</header>
<bdy>

<image location="right" width="150px" src="Simple_polygon.svg" type="thumb">
<caption>

An example of a simple polygon
</caption>
</image>
<p>

In <link xlink:type="simple" xlink:href="../927/176927.xml">
computational geometry</link>, the <b>point-in-polygon</b> (<b>PIP</b>) problem asks whether a given point in the plane lies inside, outside, or on the boundary of a <link xlink:type="simple" xlink:href="../621/23621.xml">
polygon</link>. It is a special case of <link xlink:type="simple" xlink:href="../494/504494.xml">
point location</link> problems and finds applications in areas that deal with processing geometrical data, such as <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, <link xlink:type="simple" xlink:href="../398/12398.xml">
geographical information system</link>s (GIS), <link xlink:type="simple" xlink:href="../875/4562875.xml">
motion planning</link>, and <link xlink:type="simple" xlink:href="../315/37315.xml">
CAD</link>.</p>
<p>

An early description of the problem in computer graphics shows two common approaches (ray casting and angle summation) in use as early as 1974.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

An attempt of computer graphics veterans to trace the history of the problem and some tricks for its solution can be found in an issue of the <it>Ray Tracing News</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

<sec>
<st>
 Ray casting algorithm </st>
<p>

<image location="right" width="300px" src="RecursiveEvenPolygon.svg">
</image>

One simple way of finding whether the point is inside or outside a <link xlink:type="simple" xlink:href="../530/1059530.xml">
simple polygon</link> is to test how many times a <link>
ray</link>  starting from the point intersects the edges of the polygon. If the point in question is not on the boundary of the polygon, the number of intersections is an <link xlink:type="simple" xlink:href="../135/143135.xml">
even number</link> if the point is outside, and it is <link xlink:type="simple" xlink:href="../135/143135.xml">
odd</link> if inside. This algorithm is sometimes also known as the <b>crossing number algorithm</b> or the <b><link xlink:type="simple" xlink:href="../388/8033388.xml">
even-odd rule</link> algorithm</b>. The algorithm is based on a simple observation that if a point moves along a ray from infinity to the probe point and if it crosses the boundary of a polygon, possibly several times, then it alternately goes from the outside to inside, then from the inside to the outside, etc. As a result, after every two "border crossings" the moving point goes outside. This observation may be mathematically proved basing on the <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../444/267444.xml">
Jordan curve theorem</link></proposition>
</theorem>
</message>
</statement>
.</p>
<p>

If implemented on a computer with <link>
finite precision arithmetics</link>, the results may be incorrect if the point lies very close to that boundary, because of rounding errors. This is not normally a concern, as speed is much more important than complete accuracy in most applications of computer graphics. However, for a formally correct <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>, one would have to introduce a <link xlink:type="simple" xlink:href="../506/21506.xml">
numerical</link> <link xlink:type="simple" xlink:href="../062/522062.xml">
tolerance</link> ε and test in line whether <it>P</it> lies within ε of <it>L</it>, in which case the algorithm should stop and report "<it>P</it> lies very close to the boundary."</p>
<p>

Most implementations of the ray casting algorithm consecutively check intersections of a, say, horizontal ray with all sides of the polygon in turn. In this case the following problem must be addressed. If the ray passes exactly through a <link xlink:type="simple" xlink:href="../417/11308417.xml">
vertex</link> of a polygon, then it will intersect 2 segments at their endpoints. While it is OK for the case of, say, the topmost vertex in the example, the case of, say, the rightmost vertex (in the example) requires that we count one intersection for the algorithm to work correctly. A similar problem arises with horizontal segments that happen to fall on the ray. The issue is solved as follows. If the intersection point is a vertex of a tested polygon side, then the intersection counts only if the second vertex of the side lies below the ray. </p>
<p>

Once again, the case of the ray passing through a vertex may pose numerical problems in <link>
finite precision</link> arithmetics: for two sides adjacent to the same vertex the straightforward computation of the intersection with a ray may not give the vertex in both cases. If the polygon is specified by its vertices, then this problem is eliminated by checking the y-coordinates of the ray and the ends of the tested polygon side before actual computation of the intersection. In other cases, when polygon sides are computed from other types of data, other tricks must be applied for the <link>
numerical robustness</link> of the algorithm.</p>

</sec>
<sec>
<st>
 Winding number algorithm </st>
<p>

Another algorithm is to compute the given point's <link xlink:type="simple" xlink:href="../113/86113.xml">
winding number</link> with respect to the polygon. If the winding number is non-zero, the point lies inside the polygon. One way to compute the winding number is to sum up the angles subtended by each side of the polygon. However, this involves costly <link xlink:type="simple" xlink:href="../220/374220.xml">
inverse trigonometric functions</link>, which generally makes this algorithm slower than the ray casting algorithm. Luckily, these inverse trigonometric functions do not need to be computed. Since the result, the sum of all angles, can add up to 0 or 2*PI (or multiples of 2*PI) only, it is sufficient to track through which quadrants the polygon winds, as it turns around the test point, which makes the winding number algorithm comparable in speed to counting the boundary crossings.</p>
<p>

For simple polygons, both algorithms will always give the same results for all points. However, for <link xlink:type="simple" xlink:href="../538/1081538.xml">
complex polygons</link>, the algorithms may give different results for points in the regions where the polygon intersects itself, where the polygon does not have a clearly defined inside and outside. In this case, the former algorithm is called the <link xlink:type="simple" xlink:href="../388/8033388.xml">
even-odd rule</link>.</p>

</sec>
<sec>
<st>
Point in polygon queries</st>
<p>

The point in polygon problem may be considered in the general repeated <link>
geometric query</link> setting: given a single polygon and a sequence of query points, quickly find the answers for each query point. Clearly, any of the general approaches for planar <link xlink:type="simple" xlink:href="../494/504494.xml">
point location</link> may be used. Simpler solutions are available for some special polygons.</p>

<ss1>
<st>
Special cases</st>

<p>

Simpler algorithms are possible for <link xlink:type="simple" xlink:href="../237/12003237.xml">
monotone polygon</link>s, <link xlink:type="simple" xlink:href="../655/12002655.xml">
star-shaped polygon</link>s and <link xlink:type="simple" xlink:href="../019/660019.xml">
convex polygon</link>s.</p>

</ss1>
</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../122/78122.xml">
Ivan Sutherland</link></scientist>
</person>
 et al,"A Characterization of Ten Hidden-Surface Algorithms"  1974, <it><link>
ACM Computing Surveys</link></it> vol. 6 no. 1.</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://jedi.ks.uiuc.edu/~johns/raytracer/rtn/rtnv3n4.html">
"Point in Polygon, One More Time..."</weblink>,  <it><link>
Ray Tracing News</link></it>, vol. 3 no. 4, <link xlink:type="simple" xlink:href="../340/22340.xml">
October 1</link>, <link xlink:type="simple" xlink:href="../635/34635.xml">
1990</link>. </entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.acm.org/pubs/tog/editors/erich/ptinpoly/">
Point in polygon strategies</weblink>, by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../882/15248882.xml">
Eric Haines</link></scholar>
</professional>
</adult>
</causal_agent>
</alumnus>
</engineer>
</intellectual>
</programmer>
</computer_user>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ecse.rpi.edu/Homepages/wrf/research/geom/pnpoly.html">
C code to determine if a point is in a polygon</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.visibone.com/inpoly/">
C code for an algorithm using integers and no divides</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.geometryalgorithms.com/Archive/algorithm_0103/algorithm_0103.htm">
Crossing number and winding number algorithms with illustrations and example code</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
