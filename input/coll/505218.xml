<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:11:54[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Register machine</title>
<id>505218</id>
<revision>
<id>237466587</id>
<timestamp>2008-09-10T09:38:21Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Computational models</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../636/19636.xml">
mathematical logic</link> and <link xlink:type="simple" xlink:href="../392/323392.xml">
theoretical computer science</link> a <b>register machine</b> is a generic class of <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link>s used in a manner similar to a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
. All the models are <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link>.
<sec>
<st>
Overview</st>
<p>

The register machine gets its name from its one or more "registers" -- in place of a Turing machine's tape and head (or tapes and heads) the model uses <b>multiple, uniquely-addressed registers</b>, each of which holds a single positive <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>. </p>
<p>

There are at least 4 sub-classes found in the literature, here listed from most primitive to the most like a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> -- the most primitive and reduced model. Lacks indirect addressing. Instructions are in the finite state machine in the manner of the <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../616/6144616.xml">
Pointer machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
  -- a blend of counter machine and RAM models. Less common and more abstract than either model. Instructions are in the finite state machine in the manner of the <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>. </entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../227/544227.xml">
Random access machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 (RAM) -- a counter machine with indirect addressing and, usually, an augmented instruction set. Instructions are in the finite state machine in the manner of the <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>. </entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 model (RASP) -- a RAM with instructions in its registers analogous to the <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../435/71435.xml">
Universal Turing machine</link></machine>
</causal_agent>
</worker>
</device>
</assistant>
</instrumentality>
</artifact>
</model>
</person>
</physical_entity>
; thus it is an example of the <link xlink:type="simple" xlink:href="../091/478091.xml">
von Neumann architecture</link>. But unlike a computer the model is <it>idealized</it> with effectively-infinite registers (and if used, effectively-infinite special registers such as an accumulator). Unlike a computer or even a <link xlink:type="simple" xlink:href="../672/3963672.xml">
RISC</link>, the instruction set is much reduced in the number of instructions.</entry>
</list>
</p>
<p>

Any properly-defined register machine model is <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link>. Computational speed is very dependent on the model specifics.</p>
<p>

In practical computer science, a similar concept known as a <link xlink:type="simple" xlink:href="../353/32353.xml">
virtual machine</link> is sometimes used to minimise dependencies on underlying machine architectures.  Such machines are also used for teaching.  The term "register machine" is sometimes used to refer to a virtual machine in textbooks. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
 Formal definition </st>
<p>

<indent level="1">

<it>No standard terminology exists; each author is responsible for defining in prose the meanings of their mnemonics or symbols. Many authors use a "register-transfer"-like symbolism to explain the actions of their models, but again they are responsible for defining its syntax.</it>
</indent>

A register machine consists of:</p>
<p>

<list>
<entry level="1" type="number">

<b>An unbounded number of labeled, discrete, unbounded registers unbounded in extent (capacity)</b>: a finite (or infinite in some models) set of registers <math>r_0 \ldots r_n</math> each considered to be of infinite extent and each of which holds a single non-negative integer (0, 1, 2, ...). The registers may do their own arithmetic, or there may or may not be one or more special registers that do the arithmetic e.g. an "accumulator" and/or "address register". <it>See also <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../227/544227.xml">
Random access machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
.''</it></entry>
<entry level="1" type="number">

<b>Tally counters or marks</b>: discrete, indistinguishable objects or marks of only one sort suitable for the model. In the most-reduced <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> model, per each arithmetic operation only one object/mark is either added to or removed from its location/tape. In some <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> models (e.g. Melzak (1961), Minsky (1961)) and most RAM and RASP models more than one object/mark can be added or removed in one operation with "addition" and usually "subtraction"; sometimes with "multiplication" and/or "division". Some models have control operations such as "copy" (variously: "move", "load", "store") that move "clumps" of objects/marks from register to register in one action.</entry>
<entry level="1" type="number">

<b>A (very) limited set of instructions</b>: the instructions tend to divide into two classes: arithmetic and control. The instructions are drawn from the two classes to form "instruction-sets", such that an instruction set must allow the model to be <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> (it must be able to compute any <link xlink:type="simple" xlink:href="../338/1139338.xml">
partial recursive function</link>).</entry>
<entry level="2" type="number">

<b>Arithmetic</b>: arithmetic instructions may operate on all registers or on just a special register (e.g. accumulator). They are <it>usually</it> chosen from the following sets (but exceptions abound): </entry>
<entry level="3" type="bullet">

Counter machine: { Increment (r), Decrement (r), Clear-to-zero (r) }</entry>
<entry level="3" type="bullet">

Reduced RAM, RASP: { Increment (r), Decrement (r), Clear-to-zero (r), Load-immediate-constant k, Add (r1,r2), proper-Subtract (r1,r2), Increment accumulator, Decrement accumulator, Clear accumulator, Add to accumulator contents of register r, proper-Subtract from accumulator contents of register r, }</entry>
<entry level="3" type="bullet">

Augmented RAM, RASP: All of the reduced instructions plus: { Multiply, Divide, various Boolean bit-wise (left-shift, bit test, etc.)}</entry>
<entry level="2" type="number">

<b>Control</b>:</entry>
<entry level="3" type="bullet">

Counter machine models: optional { Copy (r1,r2) }</entry>
<entry level="3" type="bullet">

RAM and RASP models: most have { Copy (r1,r2) }, or { Load Accumulator from r, Store accumulator into r, Load Accumulator with immediate constant }</entry>
<entry level="3" type="bullet">

All models: at least one <it>conditional "jump"</it> (branch, goto) following test of a register e.g. { Jump-if-zero, Jump-if-not-zero (i.e. Jump-if-positive), Jump-if-equal, Jump-if-not equal  }</entry>
<entry level="3" type="bullet">

All models optional: { unconditional program jump (goto) }</entry>
<entry level="2" type="number">

<b>Register-addressing method</b>:</entry>
<entry level="3" type="bullet">

Counter machine: no indirect addressing, immediate operands possible in highly atomized models</entry>
<entry level="3" type="bullet">

RAM and RASP: indirect addressing available, immediate operands typical</entry>
<entry level="2" type="number">

<b>Input-output</b>: optional in all models</entry>
<entry level="1" type="number">

<b>State register</b>: A special Instruction Register "IR", finite and separate from the registers above, stores the current instruction to be executed and its address in the TABLE of instructions; this register and its TABLE is located in the finite state machine.</entry>
<entry level="2" type="bullet">

The IR is off-limits to all models. In the case of the RAM and RASP, for purposes of determining the "address" of a register, the model can select either (i) in the case of direct addressing -- the address specified by the TABLE and temporarily located in the IR or (ii) in the case of indirect addressing -- the contents of the register specified by the IR's instruction.</entry>
<entry level="2" type="bullet">

The IR is <it>not</it> the "program counter" (PC) of the RASP (or conventional <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>). The PC is just another register similar to an accumulator, but dedicated to holding the number of the RASP's current register-based instruction. Thus a RASP has <it>two</it> "instruction/program" registers -- (i) the IR (finite state machine's Instruction Register), and (ii) a PC (Program Counter) for the program located in the registers. (As well as a register dedicated to "the PC", a RASP may dedicate another register to "the Program-Instruction Register" (going by any number of names such as "PIR, "IR", "PR", etc.) </entry>
<entry level="1" type="number">

<b>List of labeled instructions, usually in sequential order</b>: A finite list of instructions <math>I_1 \ldots I_m</math>. In the case of the counter machine, random access machine (RAM) and pointer machine the instruction store is in the "TABLE" of the finite state machine; thus these models are example of the <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>. In the case of the RASP the program store is in the registers; thus this is an example of the <link xlink:type="simple" xlink:href="../091/478091.xml">
von Neumann architecture</link>. <it>See also <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../227/544227.xml">
Random access machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
.</it>Usually, like <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s, the instructions are listed in sequential order; unless a jump is successful the default sequence continues in numerical order. An exception to this is the abacus (Lambek (1961), Minsky (1961)) counter machine models -- every instruction has at least one "next" instruction identifier "z", and the conditional branch has two.</entry>
<entry level="2" type="bullet">

Observe also that the abacus model combines two instructions, JZ then DEC: e.g. { INC ( r, z ), JZDEC ( r, ztrue, zfalse ) }.See <link xlink:type="simple" xlink:href="../818/7667818.xml">
McCarthy Formalism</link> for more about the <it>conditional expression</it> "IF r=0 THEN ztrue ELSE  zfalse" (cf McCarthy (1960)).</entry>
</list>
</p>

</sec>
<sec>
<st>
 Historical development of the register machine model </st>

<p>

Two trends appeared in the early 1950s -- the first to characterize the <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> as a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
, the second to define computer-like models -- models with sequential instruction sequences and conditional jumps -- with the power of a Turing machine, i.e. a so-called <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalence</link>.  Need for this work was carried out in context of two "hard" problems: the unsolvable word problem posed by <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link> -- his problem of "tag" -- and the very "hard" problem of <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../584/154584.xml">
Hilbert's problems</link></difficulty>
</problem>
</state>
</condition>
 -- the 10th question around <link xlink:type="simple" xlink:href="../109/9109.xml">
Diophantine equation</link>s. Researchers were questing for Turing-equivalent models that were less "logical" in nature and more "arithmetic" (cf Melzak (1961) p. 281, Shepherdson-Sturgis (1963) p. 218). </p>
<p>

The first trend -- toward characterizing computers -- seems to have originated with <link>
Hans Hermes</link> (1954) and <link>
Heinz Kaphengst</link> (1959), the second trend with <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../047/1056047.xml">
Hao Wang</link></scientist>
 (1954, 1957) and, as noted above, furthered along by <link>
Z. A.Melzak</link> (1961), <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../498/1250498.xml">
Joachim Lambek</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 (1961), <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
 (1961, 1967), and <link>
John Shepherdson</link> and <link>
H. E. Sturgis</link> (1963).</p>
<p>

The last five names are listed explicitly in that order by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../712/2627712.xml">
Yuri Matiyasevich</link></scientist>
. He follows up with:
<indent level="1">

"Register machines [some authors use "register machine" synonymous with "counter-machine"] are particularly suitable for constructing Diophantine equations. Like Turing machines, they have very primitive instructions and, in addition, they deal with numbers" (Yuri Matiyasevich (1993), <it>Hilbert's Tenth Problem</it>, commentary to Chapter 5 of the book, at http://logic.pdmi.ras.ru/yumat/H10Pbook/commch_5htm. )    
</indent>

It appears, remarkably, that Lambek, Melzak, Minsky and Shepherdson and Sturgis independently anticipated the same idea at the same time. See Note On Precedence below.</p>
<p>

The history begins with Wang's model. </p>

<ss1>
<st>
 (1954, 1957) Wang's model: Post-Turing machine </st>
<p>

Wang's work followed from <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link>'s (1936) paper and led Wang to his definition of his <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../489/6640489.xml">
Wang B-machine</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
—a two-symbol <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link> computation model with only four atomic instructions:
<indent level="1">

{ LEFT, RIGHT, PRINT, JUMP_if_marked_to_instruction_z }
</indent>

To these four both Wang (1954, 1957) and then C.Y. Lee (1961) added another other instruction from the Post set { ERASE }, and then a Post's unconditional jump { JUMP_to_ instruction_z } (or to make things easier, the conditional jump JUMP_IF_blank_to_instruction_z, or both. Lee named this a "W-machine" model:
<indent level="1">

{ LEFT, RIGHT, PRINT, ERASE, JUMP_if_marked, [maybe JUMP or JUMP_IF_blank] } 
</indent>

Wang expressed hope that his model would be "a rapprochement" (p. 63) between the theory of Turing machines and the practical world of the computer.</p>
<p>

Wang's work was highly influential. We find him referenced by Minsky (1961) and (1967), Melzak (1961), Shepherdson and Sturgis (1963). Indeed, Shepherdson and Sturgis (1963) remark that: 
<indent level="1">

"...we have tried to carry a step further the 'rapprochement' between the practical and theoretical aspects of computation suggested by Wang" (p. 218)
</indent>

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 eventually evolved this model into the (2-symbol) <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link>.</p>
<p>

<b>Difficulties with the Wang/Post-Turing model</b>:</p>
<p>

Except there was a problem: the Wang model (the six instructions of the 7-instruction <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link>) was still a single-tape Turing-like device, however nice its <it>sequential program instruction-flow</it> might be. Both Melzak (1961) and Shepherdson and Sturgis (1963) observed this (in the context of certain proofs and investigations):</p>
<p>

<indent level="1">

"...a Turing machine has a certain opacity... a Turing machine is slow in (hypothetical) operation and, usually, complicated. This makes it rather hard to design it, and even harder to investigate such matters as time or storage optimization or a comparison between efficiency of two algorithms. (Melzak (1961) p. 281)
</indent>

<indent level="1">

"...although not difficult ... proofs are complicated and tedious to follow for two reasons: (1) A Turing machine has only head so that one is obliged to break down the computation into very small steps of operations on a single digit. (2) It has only one tape so that one has to go to some trouble to find the under one wishing to work on and keep it separate from other numbers" (Shepherdson and Sturgis (1963) p. 218).
</indent>

Indeed as examples at <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../511/6246511.xml">
Turing machine examples</link></method>
</know-how>
</invention>
, <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link> and <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link> show, the work can be "complicated".</p>

</ss1>
<ss1>
<st>
 Minsky, Melzak-Lambek and Shepherdson-Sturgis models "cut the tape" into many  </st>
<p>

So why not 'cut the tape' so each is infinitely long (to accommodate any size integer) but left-ended, and call these three tapes "Post-Turing (ie. Wang-like) tapes"? The individual heads will move left (for decrement) and right (for increment). In one sense the heads indicate "the tops of the stack" of concatenated marks. Or in Minsky (1961) and Hopcroft and Ullman (1979, p. 171ff) the tape is always blank except for a mark at the left end -- at no time does a head ever print or erase.</p>
<p>

We just have to be careful to write our instructions so that a test-for-zero and jump occurs <it>before</it> we decrement otherwise our machine will "fall off the end" or "bump against the end" -- we will have an instance of a <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link>. Before a decrement our machine must always ask the question: "Is the tape/counter empty? If so then I can't decrement, otherwise I can."</p>
<p>

<indent level="1">

<it>For example of the addition algorithm written for a counter machine see <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/7585920.xml">
Algorithm examples</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
, and for an example of (im-) proper subtraction see <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../577/23577.xml">
Partial function</link></function>
</mathematical_relation>
.</it>
</indent>

Minsky (1961) and Shepherdson-Sturgis (1963) prove that only a few tapes -- as few as one -- still allow the machine to be Turing equivalent <it>IF</it> the data on the tape is represented as a <link>
Gödel number</link> (or some other uniquely encodable-decodable number); this number will evolve as the computation proceeds. In the one tape version with Gödel number encoding the counter machine must be able to (i) multiply the Gödel number by a constant (numbers "2" or "3"), and (ii) divide by a constant (numbers "2" or "3") and jump if the remainder is zero. Minsky (1967) shows that the need for this bizarre instruction set can be relaxed to { INC (r), JZDEC (r, z) } and the convenience instructions { CLR (r), J (r) } if two tapes are available. A simple Gödelization is still required, however. A similar result appears in Elgot-Robinson (1964) with respect to their RASP model.       </p>


</ss1>
<ss1>
<st>
 (1961) Melzak's model is different: clumps of pebbles go into and out of holes </st>
<p>
 
Melzak's (1961) model is significantly different. He took his own model, flipped the tapes vertically, called them "holes in the ground" to be filled with "pebble counters". Unlike Minsky's "increment" and "decrement", Melzak allowed for proper subtraction of any count of pebbles and "adds" of any count of pebbles.</p>
<p>

He defines indirect addressing for his model (p. 288) and provides two examples of its use (p. 89); his "proof" (p. 290-292) that his model is <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> is so sketchy that the reader cannot tell whether or not he intended the indirect addressing to be a required for the proof.</p>
<p>

Legacy of Melzak's model is Lambek's simplification and the reappearance of his mnemonic conventions in Cook and Reckhow 1973.</p>

</ss1>
<ss1>
<st>
 Lambek (1961) atomizes Melzak's model into the Minsky (1961) model: INC and DEC-with-test </st>
<p>

Lambek (1961) took Melzak's ternary model and atomized it down to the two unary instructions -- X+, X- if possible else jump -- the exact same two that Minsky (1961) had come up with.</p>
<p>

However, like the Minsky (1961) model, the Lambek model does execute its instructions in a default-sequential manner-- both X+ and X- carry the identifier of the next instruction, and X- also carries the jump-to instruction of the zero-test is successful.</p>

</ss1>
<ss1>
<st>
 Elgot-Robinson (1964) and the problem of the RASP without indirect addressing </st>
<p>

A RASP or <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 begins as a counter machine with its "program of instruction" placed in its "registers<it>. Analogous to, but independent of, the finite state machine's "Instruction Register", at least one of the registers (nicknamed the "program counter" (PC)) and one or more "temporary" registers maintain a record of, and operate on, the current instruction's number. The finite state machine's TABLE of instructions is responsible for (i) fetching the current </it>program<it> instruction from the proper register, (ii) parsing the </it>program<it> instruction, (ii) fetching operands specified by the </it>program <it> instruction, and (iv) executing the </it>program<it> instruction.</it></p>
<p>

Except there is a problem: If based on <it>counter machine</it> chassis this computer-like, <link xlink:type="simple" xlink:href="../942/15942.xml">
von Neumann</link> machine will not be Turing equivalent. It cannot compute everything that is computable. Intrinsically the model is bounded by the size of its (very-) <it>finite</it> state machine's instructions. The counter machine based RASP can compute any <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link> (e.g. multiplication) but not all <link xlink:type="simple" xlink:href="../469/26469.xml">
mu recursive function</link>s (e.g. the <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
 ). </p>
<p>

Elgot-Robinson investigate the possibility of allowing their RASP model to "self modify" its program instructions. The idea was an old one, proposed by Burks-Goldstine-von Neumann (1946-7), and sometimes called "the computed goto." Melzak (1961) specifically mentions the "computed goto" by name but instead provides his model with indirect addressing.</p>
<p>

<b>Computed goto:</b> A RASP <it>program</it> of instructions that modifies the "goto address" in a conditional- or unconditional-jump <it>program</it> instruction.</p>
<p>

But this does not solve the problem (unless one resorts to <link>
Gödel number</link>s). What is necessary is a method to fetch the address of a program instruction that lies (far) "beyond/above" the upper bound of the <it>finite</it> state machine's instruction register and TABLE.</p>
<p>

<indent level="1">

Example: A counter machine equipped with only four unbounded registers can e.g. multiply any two numbers ( m, n ) together to yield p -- and thus be a primitive recursive function -- no matter how large the numbers m and n; moreover, less than 20 instructions are required to do this! e.g. { 1: CLR ( p ), 2: JZ ( m, done ), 3 outer_loop: JZ ( n, done ), 4: CPY ( m, temp ), 5: inner_loop: JZ ( m, outer_loop ), 6: DEC ( m ), 7: INC ( p ), 8: J ( inner_loop ), 9: outer_loop: DEC ( n ), 10 J ( outer_loop ), HALT }
</indent>

<indent level="1">

However, with only 4 registers, this machine has not nearly big enough to build a RASP that can execute the multiply algorithm as a <it>program</it>. No matter how big we build our finite state machine there will always be a <it>program</it> (including its parameters) which is larger. So by definition the bounded program machine that does not use unbounded encoding tricks such as <link>
Gödel number</link>s cannot not <it>universal</it>. 
</indent>

Minsky (1967) hints at the issue in his investigation of a counter machine (he calls them "program computer models") equipped with the instructions { CLR (r), INC (r), and RPT ("a" times the instrcutions m to n) }. He doesn't tell us how to fix the problem, but he does observe that:
<indent level="1">

 "... the program computer has to have some way to keep track of how many RPT's remain to be done, and this might exhaust any particular amount of storage allowed in the finite part of the computer. RPT operatons require infinite registers of their own, in general, and they must be treated differently from the other kinds of operations we have considered." (p. 214)
</indent>

But Elgot and Robinson solve the problem: They augment their P0 RASP with an indexed set of instructions -- a somewhat more complicated (but more flexible) form of indirect addressing. Their P'0 model addresses the registers by adding the contents of the "base" register (specified in the instruction) to the "index" specified explicitly in the instruction (or vice versa, swapping "base" and "index"). Thus the indexing P'0 instructions have one more parameter than the non-indexing P0 instructions:  
<indent level="1">

 Example: INC ( rbase, index ) ; effective address will be [rbase] + index, where the natural number "index" is derived from the finite-state machine instruction itself.
</indent>

</p>
</ss1>
<ss1>
<st>
 Hartmanis (1971) </st>
<p>

By 1971 Hartmanis has simplified the indexing to indirection for use in his RASP model.</p>
<p>

<b>Indirect addressing:</b> A pointer-register supplies the finite state machine with the address of the target register required for the instruction. Said another way: The <it>contents</it> of the pointer-register is the <it>address</it> of the "target" register to be used by the instruction. If the pointer-register is unbounded, the RAM, and a suitable RASP built on its chassis, will be Turing equivalent. The target register can serve either as a source or destination register, as specified by the instruction.</p>
<p>

Note that the finite state machine does not have to explicitly specify this target register's address. It just says to the rest of the machine: Get me the contents of the register pointed to by my pointer-register and then do xyz with it. It must specify explicitly by name, via its instruction, this pointer-register (e.g. "N", or "72" or "PC", etc) but it doesn't have to know what number the pointer-register actually contains (perhaps 279,431).</p>

</ss1>
<ss1>
<st>
 Cook and Reckhow (1973) describe the RAM </st>
<p>

Cook and Reckhow (1973) cite Hartmanis (1971) and simplify his model to what they call a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../227/544227.xml">
Random access machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 ( RAM -- i.e. a machine with indirection and the <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>). In a sense we are back to Melzak (1961) but with a much simpler model than Melzak's.</p>

</ss1>
</sec>
<sec>
<st>
 Precedence </st>

<p>

Minsky was working at the <link xlink:type="simple" xlink:href="../536/637536.xml">
M.I.T. Lincoln Labs</link> and published his work there; his paper was received for publishing in the <it>Annals of Mathematics</it> on August 15, 1960 but not published until November 1961. While receipt occurred a full year before the work of Melzak and Lambek was received and published (received, respectively, May and June 15, 1961 and published side-by-side September 1961). That (i) both were Canadians and published in the Canadian Mathematical Bulletin, (ii) neither would have had reference to Minsky's work because it was not yet published in a peer-reviewed journal, but (iii) Melzak references Wang, and Lambek references Melzak, leads one to hypothesize that their work occurred simultaneously and independently.</p>
<p>

Almost exactly the same thing happened to Shepherdson and Sturgis. Their paper was received in December 1961 -- just a few months after Melzak and Lambek's work was received. Again, they had little (at most 1 month) or no benefit of reviewing the work of Minsky. They were careful to observe in footnotes that papers by Ershov, Kaphengst and Peter had "recently appeared" (p. 219). These were published much earlier but appeared in the German language in German journals so issues of accessibility present themselves. </p>
<p>

The final paper of Shepherdson and Sturgis did not appear in a peer-reviewed journal until 1963. And as they fairly and honestly note in their Appendix A, the 'systems' of Kaphengst (1959), Ershov (1958), Peter (1958) are all so similar to what results were obtained later as to be indistinguishable to a set of the following:
<indent level="1">

 produce 0 i.e. 0 --&amp;gt; n
</indent>
: increment a number i.e. n+1 --&amp;gt; n
<indent level="2">

"i.e. of performing the operations which generate the natural numbers" (p. 246)
</indent>
: copy a number i.e. n --&amp;gt; m
<indent level="1">

 to "change the course of a computation", either comparing two numbers or decrementing until 0
</indent>

Indeed, Shepherson and Sturgis conclude
<indent level="2">

"The various minimal systems are very similar"( p. 246)
</indent>

By order of <it>publishing</it> date the work of Kaphengst (1959), Ershov (1958), Peter (1958) were first. Does context matter? An answer would require close examination of the papers. Conclusions and opinions about this will be left to the reader.</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

 <link>
Unlimited Register Machine</link></entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="2" type="bullet">

 </entry>
<entry level="2" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../249/7599249.xml">
Counter machine models</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../616/6144616.xml">
Pointer machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../227/544227.xml">
Random access machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
</entry>
<entry level="2" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../435/71435.xml">
Universal Turing machine</link></machine>
</causal_agent>
</worker>
</device>
</assistant>
</instrumentality>
</artifact>
</model>
</person>
</physical_entity>
</entry>
<entry level="2" type="bullet">

 <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../952/6477952.xml">
Turing machine gallery</link></method>
</know-how>
</invention>
</entry>
<entry level="2" type="bullet">

 <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../511/6246511.xml">
Turing machine examples</link></method>
</know-how>
</invention>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../489/6640489.xml">
Wang B-machine</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link> -- description plus examples</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../775/775.xml">
Algorithm</link></entry>
<entry level="2" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../703/6901703.xml">
Algorithm characterizations</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="2" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/7585920.xml">
Algorithm examples</link></causal_agent>
</method>
</worker>
</know-how>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../668/13668.xml">
Halting problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../911/67911.xml">
Busy beaver</link></entry>
</list>
</p>


</sec>
<sec>
<st>
 Bibliography </st>
<p>

<b>Background texts:</b> The following bibliography of source papers includes a number of texts to be used as background. The mathematics that led to the flurry of papers about abstact machines in the 1950s and 1960's can be found in van Heijenoort (1967) -- an assemblage of original papers spanning the 50 years from Frege (1879) to Gödel (1931). Davis (ed.) <it>The Undecidable</it> (1965) carries the torch onward beginning with Gödel (1931) through Gödel's (1964) postscriptum (p. 71); the original papers of <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../208/1208.xml">
Alan Turing</link></scientist>
</person>
 (1936-7) and <link xlink:type="simple" xlink:href="../382/362382.xml">
Emil Post</link> (1936) are included in <it>The Undecidable</it>. The mathematics of Church, Rosser and Kleene that appear as reprints of original papers in <it>The Undecidable</it> is carried further in Kleene (1952), a mandatory text for anyone pursuing a deeper understanding of the mathematics behind the machines. Both Kleene (1952) and Davis (1958) are referenced by a number of the papers.</p>
<p>

For a good treatment of the counter machine see Minsky (1967) Chapter 11 "Models similar to Digital Computers" -- he calls the counter machine a "program computer". A recent overview is found at van Emde Boas (1990). A recent treatment of the Minsky (1961)/Lambek (1961) model can be found Boolos-Burgess-Jeffrey (2002); they reincarnate Lambek's "abacus model" to demonstrate equivalence of Turing machines and partial recursive functions, and they provide a graduate-level introduction to both abstract machine models (counter- and Turing-) and the mathematics of recursion theory. Beginiing with the first edition Boolos-Burgess (1970) this model appeared with virtually the same treatment.</p>
<p>

<b>The papers</b>: The papers begin with Wang (1957) and his dramatic simplification of the Turing machine.  Turing (1936), Kleene (1952), Davis (1958) and in particular Post (1936) are cited in Wang (1957); in turn, Wang is referenced by Melzak (1961), Minsky (1961) and Shepherdson-Sturgis (1961-3) as they independently reduce the Turing tapes to "counters". Melzak (1961) provides his pebble-in-holes counter machine model with indirection but doesn't carry the treatment further. The work of Elgot-Robinson (1964) define the RASP -- the computer-like <link xlink:type="simple" xlink:href="../421/7179421.xml">
random access stored program machine</link>s -- and appear to be the first to investigate the failure of the bounded <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> to calculate the mu-recursive functions. This failure -- except with the draconian use of <link xlink:type="simple" xlink:href="../790/207790.xml">
Godel number</link>s in the manner of Minsky (1961)) -- leads to their definition of "indexed" instructions (i.e. indirect addressing) for their RASP model. Elgot-Robinson (1964) and more so Hartmanis (1971) investigate RASPs with self-modifying programs. Hartmanis (1971) specifies an instruction set with indirection, citing lecture notes of Cook (1970). For use in investigations of computational complexity Cook and his graduate student Reckhow (1973) provide the definition of a RAM (their model and mnemonic convention are similar to Melzak's, but offer him no reference in the paper). The pointer machines are an offshoot of Knuth (1968, 1973) and independently Schönhage (1980). </p>
<p>

For the most part the papers contain mathematics beyond the undergraduate level -- in particular the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s and <link xlink:type="simple" xlink:href="../469/26469.xml">
mu recursive function</link>s presented elegantly in Kleene (1952) and less in depth, but useful nonetheless, in Boolos-Burgess-Jeffrey (2002).</p>
<p>

All texts and papers excepting the four starred have been witnessed. These four are written in German and appear as references in Shepherdson-Sturgis (1963) and Elgot-Robinson (1964); Shepherdson-Sturgis (1963) offer a brief discussion of their results in Shepherdson-Sturgis' Appendix A. The terminology of at least one paper (Kaphengst (1959) seems hark back to the Burke-Goldstine-von Neumann (1946-7) analysis of computer architecture. </p>
<p>

<table class="wikitable">
<row style="font-size:9pt" align="center" valign="bottom">
<col width="114.6" Height="49.2">
Author</col>
<col width="43.2">
year</col>
<col width="46.8">
reference</col>
<col width="41.4">
Turing machine</col>
<col width="43.2">
Counter machine</col>
<col width="27.6">
RAM</col>
<col width="28.2">
RASP</col>
<col width="38.4">
Pointer machine</col>
<col width="54">
Indirect addressing</col>
<col width="43.8">
Self modifying program</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Goldstine &amp; von Neumann</col>
<col align="center" valign="bottom">
1947</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Kleene</col>
<col align="center" valign="bottom">
1952</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
<list>
<entry level="1" type="bullet">

Hermes</entry>
</list>
</col>
<col align="center" valign="bottom">
1954, 5</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
?</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Wang</col>
<col align="center" valign="bottom">
1957</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
hints</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
hints</col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
<list>
<entry level="1" type="bullet">

Peter</entry>
</list>
</col>
<col align="center" valign="bottom">
1958</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
?</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
Davis</col>
<col align="center" valign="bottom">
1958</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
<list>
<entry level="1" type="bullet">

Ershov</entry>
</list>
</col>
<col align="center" valign="bottom">
1959</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
?</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
<list>
<entry level="1" type="bullet">

Kaphengst</entry>
</list>
</col>
<col align="center" valign="bottom">
1959</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
?</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Melzak</col>
<col align="center" valign="bottom">
1961</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
hints</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Lambek</col>
<col align="center" valign="bottom">
1961</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Minsky</col>
<col align="center" valign="bottom">
1961</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Shepherdson &amp; Sturgis</col>
<col align="center" valign="bottom">
1963</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
hints</col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
Elgot &amp; Robinson</col>
<col align="center" valign="bottom">
1964</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
Davis- Undecidable</col>
<col align="center" valign="bottom">
1965</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
van Heijenoort</col>
<col align="center" valign="bottom">
1967</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
Minsky</col>
<col align="center" valign="bottom">
1967</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
hints</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
hints</col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Knuth</col>
<col align="center" valign="bottom">
1968, 73</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
Hartmanis</col>
<col align="center" valign="bottom">
1971</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
</row>
<row style="font-size:9pt">
<col Height="12" valign="bottom">
Cook &amp; Reckhow</col>
<col align="center" valign="bottom">
1973</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Schonhage</col>
<col align="center" valign="bottom">
1980</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
van Emde Boas</col>
<col align="center" valign="bottom">
1990</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="12.6" valign="bottom">
Boolos &amp; Burgess; Boolos, Burgess &amp; Jeffrey</col>
<col align="center" valign="bottom">
1970-2002</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom">
X</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
</table>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
<link xlink:type="simple" xlink:href="../535/382535.xml">
Harold Abelson</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<programmer wordnetid="110481268" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<computer_user wordnetid="109951274" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/96431.xml">
Gerald Jay Sussman</link></research_worker>
</mathematician>
</causal_agent>
</academician>
</computer_user>
</associate>
</educator>
</professional>
</adult>
</scientist>
</engineer>
</colleague>
</programmer>
</specialist>
</interior_designer>
</person>
</peer>
</expert>
</physical_entity>
 with Julie Sussman, <link xlink:type="simple" xlink:href="../368/82368.xml">
Structure and Interpretation of Computer Programs</link>, <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../601/719601.xml">
MIT Press</link></company>
, <village wordnetid="108672738" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../685/5685.xml">
Cambridge, Massachusetts</link></village>
, 2nd Ed, 1996</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../621/340621.xml">
George Boolos</link></person>
, <link>
John P. Burgess</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../354/4294354.xml">
Richard Jeffrey</link></logician>
</causal_agent>
</person>
</expert>
</physical_entity>
 (2002), <it>Computability and Logic: Fourth Edition</it>, Cambridge University Press, Cambridge, England. The original Boolos-Jeffrey text has been extensively revised by Burgess: more advanced than an introductory textbook. "Abacus machine" model is extensively developed in Chapter 5 <it>Abacus Computability</it>; it is one of three models extensively treated and compared -- the Turing machine (still in Boolos' original 4-tuple form) and recursion the other two.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../641/6479641.xml">
Arthur Burks</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../708/763708.xml">
Herman Goldstine</link></associate>
</creator>
</mathematician>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../942/15942.xml">
John von Neumann</link></scientist>
</person>
 (1946), <it>Preliminary discussion of the logical design of an electronic computing instrument</it>, reprinted pp. 92ff in <expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<link xlink:type="simple" xlink:href="../136/349136.xml">
Gordon Bell</link></originator>
</employee>
</causal_agent>
</worker>
</creator>
</associate>
</engineer>
</colleague>
</specialist>
</pioneer>
</interior_designer>
</person>
</physical_entity>
</peer>
</expert>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../300/287300.xml">
Allen Newell</link></scientist>
</person>
 (1971), <it>Computer Structures: Readings and Examples</it>, mcGraw-Hill Book Company, New York. ISBN 0070043574  .</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../432/39432.xml">
Stephen A. Cook</link></scientist>
</person>
 and Robert A. Reckhow (1972), <it>Time-bounded random access machines</it>, Journal of Computer Systems Science 7 (1973), 354-375.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 (1958), <it>Computability &amp; Unsolvability</it>, McGraw-Hill Book Company, Inc. New York.</entry>
<entry level="1" type="bullet">

 <link>
Calvin Elgot</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<immigrant wordnetid="110199489" confidence="0.8">
<migrant wordnetid="110314952" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/46024.xml">
Abraham Robinson</link></mathematician>
</scientist>
</causal_agent>
</traveler>
</migrant>
</immigrant>
</person>
</physical_entity>
 (1964), <it>Random-Access Stored-Program Machines, an Approach to Programming Languages</it>, Journal of the Association for Computing Machinery, Vol. 11, No. 4 (October, 1964), pp. 365-399.</entry>
<entry level="1" type="bullet">

 <link>
J. Hartmanis</link> (1971), "Computational Complexity of Random Access Stored Program Machines," Mathematical Systems Theory 5, 3 (1971) pp. 232-245. </entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../443/299443.xml">
John Hopcroft</link></scientist>
</person>
, <peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/1702318.xml">
Jeffrey Ullman</link></scholar>
</causal_agent>
</alumnus>
</laureate>
</associate>
</recipient>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</physical_entity>
</peer>
 (1979). <it>Introduction to Automata Theory, Languages and Computation</it>, 1st ed., Reading Mass: Addison-Wesley. ISBN 0-201-02988-X.  A difficult book centered around the issues of machine-interpretation of "languages", NP-Completeness, etc. </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link> (1952), <it>Introduction to Metamathematics</it>, North-Holland Publishing Company, Amsterdam, Netherlands. ISBN 0-7204-2103-9.</entry>
<entry level="1" type="bullet">

<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
 (1968), <it>The Art of Computer Programming</it>, Second Edition 1973, Addison-Wesley, Reading, Massachusetts. Cf pages 462-463 where he defines "a new kind of abstract machine or 'automaton' which deals with linked structures."</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../498/1250498.xml">
Joachim Lambek</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 (1961, received 15 June 1961), <it>How to Program an Infinite Abacus</it>, Mathematical Bulletin, vol. 4, no. 3. September 1961 pages 295-302. In his Appendix II, Lambek proposes a "formal definition of 'program'. He references Melzak (1961) and Kleene (1952) <it>Introduction to Metamathematics</it>.</entry>
<entry level="1" type="bullet">

<link>
Z. A. Melzak</link> (1961, received 15 May 1961), <it>An informal Arthmetical Approach to Computability and Computation</it>, Canadian Mathematical Bulletin, vol. 4, no. 3. September 1961 pages 279-293. Melzak offers no references but acknowledges "the benefit of conversations with Drs. R. Hamming, D. McIlroy and V. Vyssots of the Bell telephone Laborators and with Dr. H. Wang of Oxford University."</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
&#32;(1961, received August 15, 1960).&#32;"Recursive Unsolvability of Post's Problem of 'Tag' and Other Topics in Theory of Turing Machines". <it>Annals of Math</it>&#32;<b>74</b>: 437&ndash;455. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.2307%2F1970290">
10.2307/1970290</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
&#32;(1967). Computation: Finite and Infinite Machines, 1st ed.,&#32;Englewood Cliffs, N. J.:&#32;Prentice-Hall, Inc..</cite>&nbsp; In particular see chapter 11: <it>Models Similar to Digital Computers</it> and chapter 14: <it>Very Simple Bases for Computability</it>. In the former chapter he defines "Program machines" and in the later chapter he discusses "Universal Program machines with Two Registers" and "...with one register", etc.</entry>
<entry level="1" type="bullet">

<link>
John C. Shepherdson</link> and <link>
H. E. Sturgis</link> (1961) received December 1961 <it>Computability of Recursive Functions</it>, Journal of the Association of Computing Machinery (JACM) 10:217-255, 1963. An extremely valuable reference paper. In their Appendix A the authors cite 4 others with reference to "Minimality of Instructions Used in 4.1: Comparison with Similar Systems".</entry>
<entry level="2" type="bullet">

Kaphengst, Heinz, <it>Eine Abstrakte programmgesteuerte Rechenmaschine</it>', Zeitschrift fur mathematische Logik und Grundlagen der Mathematik:<it>5</it> (1959), 366-379. </entry>
<entry level="2" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<inventor wordnetid="110214637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../952/146952.xml">
Ershov, A. P.</link></associate>
</creator>
</research_worker>
</inventor>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 <it>On operator algorithms</it>, (Russian) Dok. Akad. Nauk 122 (1958), 967-970. English translation, Automat. Express 1 (1959), 20-23.</entry>
<entry level="2" type="bullet">

<link>
Péter, Rózsa</link> <it>Graphschemata und rekursive Funktionen</it>, Dialectica 12 (1958), 373.</entry>
<entry level="2" type="bullet">

Hermes, Hans <it>Die Universalität programmgesteuerter Rechenmaschinen. Math.-Phys. Semesterberichte (Göttingen) 4 (1954), 42-53.</it></entry>
<entry level="1" type="bullet">

 <link>
Arnold Schönhage</link> (1980), <it>Storage Modification Machines</it>, Society for Industrial and Applied Mathematics, SIAM J. Comput. Vol. 9, No. 3, August 1980. Wherein Schōnhage shows the equivalence of his SMM with the "successor RAM" (Random Access Machine), etc. resp. <it>Storage Modification Machines</it>, in <it>Theoretical Computer Science</it> (1979), pp. 36-37</entry>
<entry level="1" type="bullet">

<link>
Peter van Emde Boas</link>, <it>Machine Models and Simulations</it> pp.3-66, appearing in:</entry>
<entry level="2" type="indent">

<link>
Jan Van Leeuwen</link>, ed. "Handbbook of Theoretical Computer Science. Volumne A: Algorithms and Complexity<it>, The MIT PRESS/Elsevier, 1990. ISBN 0-444-88071-2 (volume A). QA 76.H279 1990. </it></entry>
<entry level="1" type="indent">

van Emde Boas' treatment of SMMs appears on pp. 32-35. This treatment clarifies Schōnhage 1980 -- it closely follows but expands slightly the Schōnhage treatment. Both references may be needed for effective understanding.</entry>
<entry level="1" type="bullet">

<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../047/1056047.xml">
Hao Wang</link></scientist>
 (1957), <it>A Variant to Turing's Theory of Computing Machines</it>, JACM (Journal of the Association for Computing Machinery) 4; 63-92. Presented at the meeting of the Association, June 23-25, 1954.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

  <cite id="Reference-Mathworld-Register machine"><physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<encyclopedist wordnetid="110055566" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../189/836189.xml">
Eric W. Weisstein</link></scholar>
</mathematician>
</writer>
</scientist>
</causal_agent>
</alumnus>
</compiler>
</encyclopedist>
</intellectual>
</person>
</communicator>
</physical_entity>
, <it><weblink xlink:type="simple" xlink:href="http://mathworld.wolfram.com/RegisterMachine.html">
Register machine</weblink></it> at <computer wordnetid="103082979" confidence="0.8">
<work wordnetid="104599396" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<reference_book wordnetid="106417598" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<encyclopedia wordnetid="106427387" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../235/374235.xml">
MathWorld</link></web_site>
</device>
</book>
</instrumentality>
</artifact>
</product>
</encyclopedia>
</publication>
</reference_book>
</machine>
</creation>
</work>
</computer>
.</cite></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.igblan.free-online.co.uk/igblan/ca/minsky.html">
Igblan - Minsky Register Machines</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mathworld.wolfram.com/RegisterMachine.html">
Visual Register Machine</weblink> (like a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<link xlink:type="simple" xlink:href="../035/37035.xml">
life game</link></rule>
</concept>
</idea>
)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://svn.oriontransfer.org/RegisterMachine/index.rhtml">
Samuel Williams' Online Register Machine Computer</weblink></entry>
</list>
</p>


</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
