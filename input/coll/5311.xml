<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:22:45[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Computer programming</title>
<id>5311</id>
<revision>
<id>244268737</id>
<timestamp>2008-10-10T01:06:24Z</timestamp>
<contributor>
<username>Mdd</username>
<id>113850</id>
</contributor>
</revision>
<categories>
<category>Software development process</category>
<category>Computer programming</category>
</categories>
</header>
<bdy>

"Programming" redirects here. For other uses, see <link xlink:type="simple" xlink:href="../327/6271327.xml">
Programming (disambiguation)</link>.<p>

<b>Computer programming</b> (often shortened to <b>programming</b> or <b>coding</b>) is the process of writing, testing, debugging/troubleshooting, and maintaining the <link xlink:type="simple" xlink:href="../661/27661.xml">
source code</link> of <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s. This source code is written in a <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>. The code may be a modification of an existing source or something completely new. The purpose of programming is to create a program that exhibits a certain desired behavior (customization). The process of writing source code requires expertise in many different subjects, including knowledge of the application domain, specialized <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s and <link xlink:type="simple" xlink:href="../225/3729225.xml">
formal logic</link>.</p>
<p>

<table style="width: 22em; text-align: left; font-size: 88%; line-height: 1.5em; width:18em; text-align:center; font-size:95%;" class="infobox " cellspacing="5">
<row>
<col colspan="2" style="text-align:center; font-size: 125%; font-weight: bold; padding-bottom:0.3em; background:transparent; line-height:1.0em; font-size:125%; font-weight:bold;" class="">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../565/27565.xml">
Software development process</link></method>
</know-how>
</col>
</row>
<row>
<header colspan="2" style="text-align:center; background:#E7C6A5;">
Activities and steps</header>
</row>
<row>
<col colspan="2" style="text-align:center; line-height:1.4em;" class="">
<link xlink:type="simple" xlink:href="../449/522449.xml">
Requirements</link>
&nbsp;·  <link xlink:type="simple" xlink:href="../231/9053231.xml">
Specification</link> <link xlink:type="simple" xlink:href="../364/48364.xml">
Architecture</link>&nbsp;·  <link xlink:type="simple" xlink:href="../325/223325.xml">
Design</link> <link xlink:type="simple" xlink:href="../311/5311.xml">
Implementation</link>&nbsp;·  <link xlink:type="simple" xlink:href="../090/29090.xml">
Testing</link> <link xlink:type="simple" xlink:href="../759/1688759.xml">
Deployment</link>&nbsp;·  <link xlink:type="simple" xlink:href="../960/780960.xml">
Maintenance</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; background:#E7C6A5;">
Models</header>
</row>
<row>
<col colspan="2" style="text-align:center; line-height:1.4em;" class="">
<belief wordnetid="105941423" confidence="0.8">
<doctrine wordnetid="105943300" confidence="0.8">
<link xlink:type="simple" xlink:href="../009/639009.xml">
Agile</link></doctrine>
</belief>

&nbsp;·  <link xlink:type="simple" xlink:href="../116/3348116.xml">
Cleanroom</link>&nbsp;·  <link xlink:type="simple" xlink:href="../878/163878.xml">
Iterative</link>&nbsp;·  <link xlink:type="simple" xlink:href="../993/239993.xml">
RAD</link> <link xlink:type="simple" xlink:href="../624/233624.xml">
RUP</link>&nbsp;·  <link xlink:type="simple" xlink:href="../504/149504.xml">
Spiral</link>&nbsp;·  <link xlink:type="simple" xlink:href="../980/33980.xml">
Waterfall</link>&nbsp;·  <belief wordnetid="105941423" confidence="0.8">
<doctrine wordnetid="105943300" confidence="0.8">
<link xlink:type="simple" xlink:href="../352/10352.xml">
XP</link></doctrine>
</belief>
&nbsp;·  <belief wordnetid="105941423" confidence="0.8">
<doctrine wordnetid="105943300" confidence="0.8">
<link xlink:type="simple" xlink:href="../665/4743665.xml">
Scrum</link></doctrine>
</belief>
</col>
</row>
<row>
<header colspan="2" style="text-align:center; background:#E7C6A5;">
Supporting disciplines</header>
</row>
<row>
<col colspan="2" style="text-align:center; line-height:1.4em;" class="">
<link xlink:type="simple" xlink:href="../180/165180.xml">
Configuration management</link>
<link xlink:type="simple" xlink:href="../488/27488.xml">
Documentation</link> <link xlink:type="simple" xlink:href="../409/1843409.xml">
Quality assurance (SQA)</link> <link xlink:type="simple" xlink:href="../010/27010.xml">
Software engineering</link>  <link xlink:type="simple" xlink:href="../710/4016710.xml">
Project management</link> <link xlink:type="simple" xlink:href="../684/7945684.xml">
User experience design</link></col>
</row>
<row>
<header colspan="2" style="text-align:center; background:#E7C6A5;">
<link xlink:type="simple" xlink:href="../882/370882.xml">
Tools</link></header>
</row>
<row>
<col colspan="2" style="text-align:center; line-height:1.4em;" class="">
<link xlink:type="simple" xlink:href="../080/2310080.xml">
Performance analysis</link>
<link xlink:type="simple" xlink:href="../485/50485.xml">
Debugger</link></col>
</row>
<row>
<col colspan="2" style="text-align:right;"></col>
</row>
</table>

</p>

<sec>
<st>
 Overview </st>
<p>

Within <link xlink:type="simple" xlink:href="../010/27010.xml">
software engineering</link>, programming (the <it>implementation</it>) is regarded as one phase in a <link xlink:type="simple" xlink:href="../565/27565.xml">
software development process</link>.</p>
<p>

There is an ongoing debate on the extent to which the writing of programs is an art, a craft or an engineering discipline.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Good programming is generally considered to be the measured application of all three, with the goal of producing an efficient and maintainable software solution (the criteria for "efficient" and "maintainable" vary considerably). The discipline differs from many other technical professions in that programmers generally do not need to be licensed or pass any standardized (or governmentally regulated) certification tests in order to call themselves "programmers" or even "software engineers".</p>
<p>

Another ongoing debate is the extent to which the programming language used in writing programs affects the form that the final program takes.  This debate is analogous to that surrounding the <link xlink:type="simple" xlink:href="../915/26915.xml">
Sapir-Whorf hypothesis</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> in <link xlink:type="simple" xlink:href="../526/17526.xml">
linguistics</link>, that postulates that a particular language's nature influences the habitual thought of its speakers. Different language patterns yield different patterns of thought. This idea challenges the possibility of representing the world perfectly with language, because it acknowledges that the mechanisms of any language condition the thoughts of its speaker community.</p>
<p>

Said another way, programming is the craft of transforming requirements into something that a computer can execute.</p>

</sec>
<sec>
<st>
 History of programming </st>

<p>

<indent level="1">

<it>See also: <link xlink:type="simple" xlink:href="../120/896120.xml">
History of programming languages</link></it> 
</indent>
<image width="150px" src="IBM402plugboard.Shrigley.wireside.jpg" type="thumb">
<caption>

Wired plug board for an <link xlink:type="simple" xlink:href="../751/1145751.xml">
IBM 402 Accounting Machine</link>.
</caption>
</image>

The earliest programmable <link xlink:type="simple" xlink:href="../462/51462.xml">
machine</link> (that is a machine whose behavior can be controlled by changes to a "program") was <link xlink:type="simple" xlink:href="../981/271981.xml">
Al-Jazari</link>'s programmable <link xlink:type="simple" xlink:href="../180/48180.xml">
humanoid robot</link> in 1206. Al-Jazari's <link xlink:type="simple" xlink:href="../781/25781.xml">
robot</link> was originally a boat with four automatic musicians that floated on a lake to entertain guests at royal drinking parties. His <link xlink:type="simple" xlink:href="../331/382331.xml">
mechanism</link> had a programmable drum machine with <link xlink:type="simple" xlink:href="../486/905486.xml">
peg</link>s (<link xlink:type="simple" xlink:href="../284/40284.xml">
cam</link>s) that bump into little <link xlink:type="simple" xlink:href="../857/38857.xml">
lever</link>s that operate the <link xlink:type="simple" xlink:href="../638/24638.xml">
percussion</link>. The drummer could be made to play different rhythms and different drum patterns by moving the pegs to different locations.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>  Another sophisticated programmable machine by Al-Jazari was the <link xlink:type="simple" xlink:href="../051/19313051.xml">
castle clock</link>.</p>
<p>

The <link xlink:type="simple" xlink:href="../225/16225.xml">
Jacquard Loom</link>, developed in 1801, is often quoted as a source of <link xlink:type="simple" xlink:href="../906/572906.xml">
prior art</link>.  The machine used a series of <link xlink:type="simple" xlink:href="../447/7513447.xml">
pasteboard</link> cards with holes punched in them.  The hole pattern represented the pattern that the loom had to follow in weaving cloth.  The loom could produce entirely different weaves using different sets of cards. The use of <link xlink:type="simple" xlink:href="../420/24420.xml">
punched cards</link> was also adopted by <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../698/5698.xml">
Charles Babbage</link></scientist>
 around 1830, to control his <link xlink:type="simple" xlink:href="../271/1271.xml">
Analytical Engine</link>.</p>
<p>

This innovation was later refined by <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../969/13969.xml">
Herman Hollerith</link></person>
 who, in 1896 founded the <it><link xlink:type="simple" xlink:href="../969/13969.xml">
Tabulating Machine Company</link></it> (which became <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
).  He invented the Hollerith punched card, the <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<calculator wordnetid="109887034" confidence="0.8">
<link xlink:type="simple" xlink:href="../751/1145751.xml">
card reader</link></calculator>
</causal_agent>
</person>
</expert>
</physical_entity>
, and the <link xlink:type="simple" xlink:href="../718/856718.xml">
key punch</link> machine. These inventions were the foundation of the modern information processing industry. The addition of a <link xlink:type="simple" xlink:href="../087/3308087.xml">
plug-board</link> to his 1906 Type I Tabulator allowed it to do different jobs without having to be rebuilt (the first step toward programming). By the late 1940s there were a variety of plug-board programmable machines, called <link xlink:type="simple" xlink:href="../269/851269.xml">
unit record equipment</link>, to perform data processing tasks (card reading). The early computers were also programmed using plug-boards.</p>
<p>

<image location="left" width="150px" src="PunchCardDecks.agr.jpg" type="thumb">
<caption>

A box of <link xlink:type="simple" xlink:href="../420/24420.xml">
punch cards</link> with several program decks.
</caption>
</image>
</p>
<p>

The invention of the <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../091/478091.xml">
Von Neumann architecture</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 allowed computer programs to be stored in <link xlink:type="simple" xlink:href="../847/25847.xml">
computer memory</link>. Early programs had to be painstakingly crafted using the instructions of the particular machine, often in <link xlink:type="simple" xlink:href="../686/238686.xml">
binary</link> notation. Every model of computer would be likely to need different instructions to do the same task. Later <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly language</link>s were developed that let the programmer specify each instruction in a text format, entering abbreviations for each operation code instead of a number and specifying addresses in symbolic form (e.g. ADD X, TOTAL). In 1954 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
, the first higher level programming language, was invented. This allowed programmers to specify calculations by entering a formula directly (e.g. Y &#0061; X*2 + 5*X + 9). The program text, or <it>source</it>, was converted into machine instructions using a special program called a <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>.  Many other languages were developed, including ones for commercial programming, such as <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link>. Programs were mostly still entered using punch cards or <link xlink:type="simple" xlink:href="../761/49761.xml">
paper tape</link>. (See <link xlink:type="simple" xlink:href="../371/7380371.xml">
computer programming in the punch card era</link>). By the late 1960s, <link xlink:type="simple" xlink:href="../174/28174.xml">
data storage device</link>s and <link xlink:type="simple" xlink:href="../402/249402.xml">
computer terminal</link>s became inexpensive enough so programs could be created by typing directly into the computers. <link xlink:type="simple" xlink:href="../310/30310.xml">
Text editor</link>s were developed that allowed changes and corrections to be made much more easily than with punch cards. </p>
<p>

As time has progressed, computers have made giant leaps in the area of processing power. This has brought about newer programming languages that are more <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/60491.xml">
abstracted</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
 from the underlying hardware. Although these more abstracted languages require additional <link xlink:type="simple" xlink:href="../671/2554671.xml">
overhead</link>, in most cases the huge increase in speed of modern computers has brought about little performance decrease compared to earlier counterparts. The benefits of these more abstracted languages is that they allow both an easier learning curve for people less familiar with the older lower-level programming languages, and they also allow a more experienced programmer to develop simple applications quickly. Despite these benefits, large complicated programs, and programs that are more dependent on speed still require the faster and relatively lower-level languages with today's hardware. (The same concerns were raised about the original Fortran language.)</p>
<p>

Throughout the second half of the twentieth century, programming was an attractive career in most developed countries. Some forms of programming have been increasingly subject to <link xlink:type="simple" xlink:href="../916/537916.xml">
offshore outsourcing</link> (importing software and services from other countries, usually at a lower wage), making programming career decisions in developed countries more complicated, while increasing economic opportunities in less developed areas. It is unclear how far this trend will continue and how deeply it will impact programmer wages and opportunities.</p>

</sec>
<sec>
<st>
 Modern programming </st>

<ss1>
<st>
Quality requirements</st>
<p>

Whatever the approach to software development may be, the final program must satisfy some fundamental properties. The following five properties are among the most relevant:</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Efficiency</b>: the amount of system resources a program consumes (processor time, memory space, slow devices, network bandwidth and to some extent even user interaction), the less the better.</entry>
<entry level="1" type="bullet">

<b>Reliability</b>: how often the results of a program are correct. This depends on prevention of <link xlink:type="simple" xlink:href="../908/593908.xml">
error propagation</link> resulting from data conversion and prevention of errors resulting from buffer overflows, underflows and zero division.</entry>
<entry level="1" type="bullet">

<b>Robustness</b>: how well a program anticipates situations of data type conflict and other incompatibilities that result in run time errors and program halts. The focus is mainly on user interaction and the handling of <abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../231/59231.xml">
exceptions</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
.</entry>
<entry level="1" type="bullet">

<b>Usability</b>: the clarity and intuitiveness of a programs output can make or break its success. This involves a wide range of textual and graphical elements that makes a program easy and comfortable to use.</entry>
<entry level="1" type="bullet">

<b>Portability</b>: the range of hardware and OS platforms on which the source code of a program can be compiled and run. This depends mainly on the range of platform specific compilers for the language of the source code rather than anything having to do with the program directly.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Algorithmic complexity</st>
<p>

The academic field and the engineering practice of computer programming are both largely concerned with discovering and implementing the most efficient <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s for a given class of problem. For this purpose, algorithms are classified into <it>orders</it> using so-called <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link>, <it>O(n)</it>, which expresses resource use, such as execution time or memory consumption, in terms of the size of an input. Expert programmers are familiar with a variety of well-established algorithms and their respective complexities and use this knowledge to choose algorithms that are best suited to the circumstances.</p>

</ss1>
<ss1>
<st>
Methodologies</st>
<p>

The first step in most formal software development projects is requirements analysis, followed by testing to determine value 
modeling, implementation, and failure elimination (<link xlink:type="simple" xlink:href="../395/323395.xml">
debugging</link>).
There exist a lot of differing approaches for each of those tasks. One approach popular for <link xlink:type="simple" xlink:href="../449/522449.xml">
requirements analysis</link> is <link>
Use Case</link> analysis.</p>
<p>

Popular modeling techniques include Object-Oriented Analysis and Design (<link xlink:type="simple" xlink:href="../984/2613984.xml">
OOAD</link>) and Model-Driven Architecture (<link xlink:type="simple" xlink:href="../169/401169.xml">
MDA</link>). The Unified Modeling Language (<link xlink:type="simple" xlink:href="../169/32169.xml">
UML</link>) is a notation used for both OOAD and MDA.</p>
<p>

A similar technique used for database design is Entity-Relationship Modeling (<link xlink:type="simple" xlink:href="../991/752991.xml">
ER Modeling</link>). </p>
<p>

Implementation techniques include imperative languages (<link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented</link> or <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../801/23801.xml">
procedural</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
), <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
functional languages</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
, and <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic languages</link>.</p>

</ss1>
<ss1>
<st>
Measuring language usage</st>
<p>

It is very difficult to determine what are the most popular of modern programming languages.  Some languages are very popular for particular kinds of applications (e.g., <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link> is still strong in the corporate data center, often on large <link xlink:type="simple" xlink:href="../266/20266.xml">
mainframes</link>, <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link> in engineering applications, and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 in <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../447/638447.xml">
embedded applications</link></instrumentality>
</artifact>
</system>
), while some languages are regularly used to write many different kinds of applications.</p>
<p>

Methods of measuring language popularity include: counting the number of job advertisements that mention the language<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>, the number of books teaching the language that are sold (this overestimates the importance of newer languages), and estimates of the number of existing lines of code written in the language (this underestimates the number of users of business languages such as COBOL).</p>

</ss1>
<ss1>
<st>
Debugging</st>
<p>

<image width="250px" src="H96566k.jpg" type="thumbnail">
<caption>

A bug which was debugged in <link xlink:type="simple" xlink:href="../584/34584.xml">
1947</link>.
</caption>
</image>

<link xlink:type="simple" xlink:href="../395/323395.xml">
Debugging</link> is a very important task in the software development process, because an erroneous program can have significant consequences for its users.  Some languages are more prone to some kinds of faults because their specification does not require <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>s to perform as much checking as other languages.  Use of a <link xlink:type="simple" xlink:href="../573/575573.xml">
static analysis</link> tool can help detect some possible problems.</p>
<p>

Debugging is often done with <link xlink:type="simple" xlink:href="../305/15305.xml">
IDE</link>s like <link xlink:type="simple" xlink:href="../768/13980768.xml">
Visual Studio</link>, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../178/214178.xml">
NetBeans</link></software>
, and <environment wordnetid="113934596" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<situation wordnetid="113927383" confidence="0.8">
<link xlink:type="simple" xlink:href="../958/216958.xml">
Eclipse</link></situation>
</state>
</environment>
. Standalone debuggers like <link xlink:type="simple" xlink:href="../052/13052.xml">
gdb</link> are also used, and these often provide less of a visual environment, usually using a <link xlink:type="simple" xlink:href="../707/6707.xml">
command line</link>.</p>

</ss1>
</sec>
<sec>
<st>
 Programming languages </st>

<p>

<indent level="1">

<it>Main articles: <link xlink:type="simple" xlink:href="../015/23015.xml">
Programming language</link>&#32;and&#32;<link xlink:type="simple" xlink:href="../146/144146.xml">
List of programming languages</link></it>
</indent>

Different programming languages support different styles of programming (called <it><link xlink:type="simple" xlink:href="../897/189897.xml">
programming paradigm</link>s</it>). The choice of language used is subject to many considerations, such as company policy, suitability to task, availability of third-party packages, or individual preference. Ideally, the programming language best suited for the task at hand will be selected. Trade-offs from this ideal involve finding enough programmers who know the language to build a team, the availability of <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>s for that language, and the efficiency with which programs written in a given language execute.  </p>
<p>

Allen Downey, in his book <it><weblink xlink:type="simple" xlink:href="http://www.greenteapress.com/thinkapjava/">
How To Think Like A Computer Scientist</weblink></it>, writes:</p>

<p>

The details look different in different languages, but a few basic instructions
appear in just about every language:</p>
<p>

<b>input</b>: Get data from the keyboard, a file, or some other device.</p>
<p>

<b>output</b>: Display data on the screen or send data to a file or other device.</p>
<p>

<b>math</b>: Perform basic mathematical operations like addition and multiplication.</p>
<p>

<b>conditional execution</b>: Check for certain conditions and execute the appropriate
sequence of statements.</p>
<p>

<b>repetition</b>: Perform some action repeatedly, usually with some variation.</p>

<p>

Many computer languages provide a mechanism to call functions provided by libraries.  Provided the functions in a library follow the appropriate runtime conventions (eg, method of passing arguments), then these functions may be written in any other language.</p>

</sec>
<sec>
<st>
 Programmers </st>
<p>

For more about the process of computer programming, see <link xlink:type="simple" xlink:href="../716/23716.xml">
Programmer</link>.</p>
<p>

<link xlink:type="simple" xlink:href="../716/23716.xml">
Computer programmer</link>s are those who write computer software. Their job usually involves:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../449/522449.xml">
Requirements analysis</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../448/14171448.xml">
Specification</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../364/48364.xml">
Software architecture</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../661/27661.xml">
Coding</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../739/5739.xml">
Compilation</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../090/29090.xml">
Software testing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../430/164430.xml">
Documentation</link></entry>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../953/3743953.xml">
Integration</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../960/780960.xml">
Maintenance</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../802/6301802.xml">
List of basic computer programming topics</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../858/6303858.xml">
List of computer programming topics</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../371/7380371.xml">
Computer programming in the punch card era</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../834/13834.xml">
Hello world program</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../010/27010.xml">
Software engineering</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../316/18949316.xml">
ACCU (organisation)</link></entry>
<entry level="1" type="bullet">

<organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Association for Computing Machinery</link></organization>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
Paul Graham&#32;(2003).&#32;"<it><weblink xlink:type="simple" xlink:href="http://www.paulgraham.com/hp.html">
Hackers and Painters</weblink></it>". &#32;Retrieved on <link>
2006-08-22</link>.</entry>
<entry id="2">
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../163/259163.xml">
Kenneth E. Iverson</link></scientist>
</person>
, the originator of the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../451/1451.xml">
APL programming language</link></programming_language>
, believed that the Sapir&ndash;Whorf hypothesis applied to computer languages (without actually mentioning the hypothesis by name).  His <link xlink:type="simple" xlink:href="../093/31093.xml">
Turing award</link> lecture, "Notation as a tool of thought", was devoted to this theme, arguing that more powerful notations aided thinking about computer algorithms. Iverson K.E.,"<weblink xlink:type="simple" xlink:href="http://elliscave.com/APL_J/tool.pdf">
Notation as a tool of thought</weblink>", <it>Communications of the ACM</it>, 23: 444-465 (August 1980).</entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://www.shef.ac.uk/marcoms/eview/articles58/robot.html">
A 13th Century Programmable Robot</weblink>, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../417/310417.xml">
University of Sheffield</link></university>
</entry>
<entry id="4">
 <cite id="CITEREFFowler1970" style="font-style:normal">Fowler, Charles B.&#32;(October 1967),&#32;"The Museum of Music: A History of Mechanical Instruments",&#32;<it>Music Educators Journal</it>&#32;<b>54</b>(2):  45-49</cite>&nbsp;</entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://www.computerweekly.com/Articles/2007/09/11/226631/sslcomputer-weekly-it-salary-survey-finance-boom-drives-it-job.htm">
Survey of Job advertisements mentioning a given language</weblink>&amp;gt;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>




<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://programming.wikia.com/wiki/Main_Page">
Programmming Wikia</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
