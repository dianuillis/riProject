<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:15:23[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Kademlia</title>
<id>532895</id>
<revision>
<id>238564244</id>
<timestamp>2008-09-15T11:59:24Z</timestamp>
<contributor>
<username>SimonP</username>
<id>1591</id>
</contributor>
</revision>
<categories>
<category>Distributed data sharing</category>
<category>Distributed computing</category>
</categories>
</header>
<bdy>

<b>Kademlia</b> is a <link xlink:type="simple" xlink:href="../141/192141.xml">
distributed hash table</link> for decentralized <link xlink:type="simple" xlink:href="../107/24107.xml">
peer to peer</link> <link xlink:type="simple" xlink:href="../592/4122592.xml">
computer network</link>s designed by <link>
Petar Maymounkov</link> and <link>
David Mazières</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. It specifies the structure of the network and the exchange of information through <link xlink:type="simple" xlink:href="../116/998116.xml">
node</link> lookups. Kademlia nodes communicate among themselves using <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/31929.xml">
UDP</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
. A virtual or <link xlink:type="simple" xlink:href="../669/1014669.xml">
overlay network</link> is formed by the participant nodes. Each node is identified by a number or <it>node ID</it>. The <it>node ID</it> serves not only as identification, but the Kademlia algorithm uses the <it>node ID</it> to locate values (usually file <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../790/13790.xml">
hashes</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 or keywords).  In fact, the <it>node ID</it> provides a direct map to file hashes and that node stores information on where to obtain the file or resource.    <p>

When searching for some value, the algorithm needs to know the associated key and explores the network in several steps. Each step will find nodes that are closer to the key until the contacted node returns the value or no more closer nodes are found. This is very efficient: Like many other <link xlink:type="simple" xlink:href="../141/192141.xml">
DHT</link>s, Kademlia contacts only <math>O(\log (n))</math> (see <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link>) nodes during the search out of a total of <math>n</math> nodes in the system.</p>
<p>

Further advantages are found particularly in the decentralized structure, which clearly increases the resistance against a <link xlink:type="simple" xlink:href="../776/39776.xml">
denial of service attack</link>. Even if a whole set of nodes is flooded, this will have limited effect on network availability, which will recover itself by knitting the network around these "holes".</p>



<sec>
<st>
 System details </st>
<p>

First generation peer-to-peer file sharing networks, such as Napster, relied on a central database to co-ordinate look ups on the network.  Second generation peer-to-peer networks, such as Gnutella, used flooding to locate files, searching every node on the network.  Third generation peer-to-peer networks use <it>Distributed hash tables</it> to look up files in the network.  <it>Distributed hash tables</it> store resource <b>locations</b> throughout the network.  A major criterion for these protocols is locating the desired nodes quickly.</p>
<p>

The Kademlia algorithm is based on the calculation of the "distance" between two nodes. This distance is computed as the <link xlink:type="simple" xlink:href="../979/105979.xml">
exclusive or</link> of the two node IDs, taking the result as an <link xlink:type="simple" xlink:href="../563/14563.xml">
integer number</link>. Keys and Node ID's have the same format and length, so distance can be calculated among them in exactly the same way.</p>
<p>

This "distance" does not have anything to do with geographical conditions, but designates the distance within the ID range. Thus it can and does happen that, for example, a node from Germany and one from Australia are "neighbours". </p>
<p>

Each Kademlia search iteration comes one bit closer to the target.  A <b>basic</b> Kademlia network with 2n nodes will only take <it>n</it> steps to find that node.</p>

<ss1>
<st>
 Routing tables </st>

<p>

Kademlia routing tables consist of a <it>list</it> for each bit of the node id. (e.g. if a node ID consists of 128 bits, a node will keep 128 such <it>lists</it>.) A list has many entries. Every entry in a <it>list</it> holds the necessary data to locate another node.  The data in each <it>list</it> entry is typically the <it>ip address</it>, <it>port</it>, and <it>node id</it> of another node.  Every <it>list</it> corresponds to a specific distance from the node. Nodes that can go in the nth <it>list</it> must have a differing nth bit from the node's id; the first n-1 bits of the candidate id must match those of the node's id.  This means that it is very easy to fill the first <it>list</it> as 1/2 of the nodes in the network are far away candidates.  The next <it>list</it> can use only 1/4 of the nodes in the network (one bit closer than the first), etc.</p>
<p>

With an ID of 128 bits, every node in the network will classify other nodes in one of 128 different distances, one specific distance per bit.</p>
<p>

As nodes are encountered on the network, they are added to the <it>lists</it>.  This includes store and retrieval operations and even when helping other nodes to find a key.  Every node encountered will be considered for inclusion in the <it>lists</it>. Therefore the knowledge that a node has of the network is very dynamic. This keeps the network constantly updated and adds resilience to accidents or attacks.</p>
<p>

In the Kademlia literature, the <it>lists</it> are referred to as <it>k-buckets</it>.  <it>k</it> is a system wide number, like 20. Every k-bucket is a <it>list</it> having up to <it>k</it> entries inside. i.e. all nodes on the network will have <it>lists</it> containing up to 20 nodes for a particular bit (a particular distance from himself). </p>
<p>

Since the possible nodes for each <it>k-bucket</it> decreases quickly (because there will be very few nodes that are that close), the lower bit <it>k-buckets</it> will fully map all nodes in that section of the network.  Since the quantity of possible ID's is much larger than any node population can ever be, some of the k-buckets corresponding to very short distances will remain empty.</p>
<p>

<image width="420px" src="Dht_example.png" type="thumb">
<caption>

An example network partition
</caption>
</image>
</p>
<p>

Consider the simple network to the right.  There are seven nodes; the small circles at the bottom.  The node under consideration is node six (binary 110) in black.  There are three <it>k-buckets</it> in this network.  Nodes zero, one and two (binary 000, 001, and 010) are candidates for the first <it>k-bucket</it>.  Node three (binary 011) is not participating in the network.  In the second <it>k-bucket</it>, nodes four and five (binary 100 and 101) are placed.  Finally, the third <it>k-bucket</it> can only contain node seven (binary 111).  Each of the three <it>k-buckets</it> is enclosed in a gray circle.  If the size of the <it>k-bucket</it> was two, then the first <it>2-bucket</it> could only contain two of the three nodes.</p>
<p>

It is known that nodes that have been connected for a long time in a network will probably remain connected for a long time in the future. Because of this statistical distribution, Kademlia selects long connected nodes to remain stored in the k-buckets. This increases the number of known valid nodes at some time in the future and provides for a more stable network.</p>
<p>

When a <it>k-bucket</it> is full and a new node is discovered for that <it>k-bucket</it>, the least recently seen node in the <it>k-bucket</it> is PINGed.  If the node is found to be still alive, the new node is place in a secondary list; a replacement cache.  The replacement cache is used only if a node in the <it>k-bucket</it> stops responding. In other words: new nodes are used only when older nodes disappear.</p>

</ss1>
<ss1>
<st>
 Protocol messages </st>

<p>

Kademlia has four messages.  </p>
<p>

<list>
<entry level="1" type="bullet">

 PING       - used to verify that a node is still alive.</entry>
<entry level="1" type="bullet">

 STORE      - Stores a (key, value) pair in one node.</entry>
<entry level="1" type="bullet">

 FIND_NODE  - The recipient of the request will return the k nodes in his own buckets that are the closest ones to the requested key.</entry>
<entry level="1" type="bullet">

 FIND_VALUE - as FIND_NODE, but if the recipient of the request has the requested key in its store, it will return the corresponding value.</entry>
</list>
</p>
<p>

Each <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../346/26346.xml">
RPC</link></rule>
</direction>
</protocol>
</message>
 message includes a random value from the initiator.  This ensures that when the response is received it corresponds to the request previously sent.</p>

</ss1>
<ss1>
<st>
 Locating nodes </st>

<p>

Node lookups can proceed asynchronously.  The quantity of simultaneous lookups is denoted by α and is typically three. A node initiates a FIND_NODE request by querying to the k nodes in its own <it>k-buckets</it> that are the closest ones to the desired key.  When these recipient nodes receive the request, they will look in their <it>k-buckets</it> and return the <it>k</it> closest nodes to the desired key that they know. The requestor will update a results list with the results (node ID's) he receives, keeping the k best ones (the k nodes that are closer to the searched key) that respond to queries. Then the requestor will select these k best results and issue the request to them, and iterate this process again and again. Because every node has a better knowledge of his own surroundings than any other node has, the received results will be other nodes that are every time closer and closer to the searched key. The iterations continue until no nodes are returned that are closer than the best previous results. When the iterations stop, the best k nodes in the results list are the ones in the whole network that are the closest to the desired key.</p>
<p>

The node information can be augmented with <link xlink:type="simple" xlink:href="../672/41672.xml">
round trip times</link>, or <link xlink:type="simple" xlink:href="../672/41672.xml">
RTT</link>.  This information will be used to choose a time-out specific for every consulted node. When a query times out, another query can be initiated, never surpassing α queries at the same time.</p>

</ss1>
<ss1>
<st>
 Locating resources </st>

<p>

Information is located by mapping it to a key.  A <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../790/13790.xml">
hash</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is typically used for the map.  The storer nodes will have information due to a previous STORE message.  Locating a value follows the same procedure as locating the closest nodes to a key, except the search terminates when a node has the requested value in his store and returns this value.</p>
<p>

The values are stored at several nodes (k of them) to allow for nodes to come and go and still have the value available in some node. i.e. to provide redundancy.  
Every certain time, a node that stores a value will explore the network to find the k nodes that are close to the key value and replicate the value onto them. This compensates for disappeared nodes.
Also, for popular values that might have many requests, the load in the storer nodes is diminished by having a retriever store this value in some node near, but outside of, the k closest ones. This new storing is called a cache. In this way the value is stored farther and farther away from the key, depending on the quantity of requests.  This allows popular searches to find a storer quicker. Because the value is returned from nodes farther away from the key, this alleviates possible "hot spots". Caching nodes will drop the value after a certain time depending on their distance from the key.
Some implementations (eg. Kad) do not have replication nor caching. The purpose of this is to remove old information quickly from the system. The node that is providing the file will periodically refresh the information onto the network (perform NODE-LOOKUP and STORE messages).  When all of the nodes having the file go offline, nobody will be refreshing its values (sources and keywords) and the information will eventually disappear from the network.</p>

</ss1>
<ss1>
<st>
 Joining the network </st>

<p>

A node that would like to join the net must first go through a <link xlink:type="simple" xlink:href="../679/6885679.xml">
bootstrap</link> process.  In this phase, the node needs to know the <link xlink:type="simple" xlink:href="../921/14921.xml">
IP address</link> and port of another node (obtained from the user, or from a stored list) that is already participating in the Kademlia network. If the bootstrapping node has not yet participated in the network, it computes a <link xlink:type="simple" xlink:href="../523/19196523.xml">
random</link> ID number that is supposed not to be already assigned to any other node. It uses this ID until leaving the network.</p>
<p>

The joining node inserts the bootstrap node into one of its <it>k-buckets</it>.  The new node then does a NODE_LOOKUP of his own ID against the only other node he knows.  The "self-lookup" will populate other nodes' <it>k-buckets</it> with the new node id, and will populate the new node k-buckets with the nodes in the path between him and the bootstrap node.  After this, the new node refreshes all <it>k-buckets</it> further away than the k-bucket where the bootstrap node falls in.  This refresh is just a lookup of a random key that is within that <it>k-bucket</it> range. </p>
<p>

Initially, nodes have one <it>k-bucket</it>.  When the <it>k-bucket</it> becomes full, it can be split.  The split occurs if the range of nodes in the <it>k-bucket</it> spans the nodes own id (values to the left and right in a binary tree).  Kademlia relaxes even this rule for the one "closest nodes" <it>k-bucket</it>, because typically one single bucket will correspond to the distance where  all the nodes that are the closest to this node are, they may be more than k, and we want it to know them all. It may turn out that a highly unbalanced binary sub-tree exists near the node.  If <it>k</it> is 20, and there are 21+ nodes with a prefix "xxx0011....." and the new node is "xxx0000<it>11001</it>", the new node can contain multiple <it>k-buckets</it> for the other 21+ nodes.  This is to guarantee that the network knows about all nodes in the closest region.</p>

</ss1>
<ss1>
<st>
 Accelerated lookups </st>

<p>

Kademlia uses a <it><link xlink:type="simple" xlink:href="../979/105979.xml">
XOR</link> <link xlink:type="simple" xlink:href="../467/1561467.xml">
metric</link></it> to define distance. Two node ID's or a node ID and a key are XORed and the result is the distance between them. For each bit, the XOR function returns zero if the two bits are equal and one if the two bits are different. XOR metric distances hold the <link xlink:type="simple" xlink:href="../941/53941.xml">
triangle inequality</link>: The distance from "A" to "B" is shorter than (or equal to) the distance from "A" to "C" plus the distance from "C" to "B".</p>
<p>

The <it>XOR metric</it> allows Kademlia to extend routing tables beyond single bits.  Groups of bits can be place in <it>k-buckets</it>.  The group of bits are termed a prefix.  For an <it>m-bit</it> prefix, there will be 2m-1 <it>k-buckets</it>.  The missing <it>k-bucket</it> is a further extension of the routing tree that contains the node ID.  An <it>m-bit</it> prefix reduces the maximum number of lookups from <it>log2 n</it> to <it>log2b n</it>.  These are <b>maximum</b> values and the average value will be far less, increasing the chance of finding a node in an own <it>k-bucket</it> that share more bits than just the prefix with the target key.</p>
<p>

Nodes can use mixtures of prefixes in their routing table, such as the <link xlink:type="simple" xlink:href="../564/1756564.xml">
Kad Network</link> used by <link xlink:type="simple" xlink:href="../202/5464202.xml">
eMule</link>.  The Kademlia network could even be heterogeneous in routing table implementations.  This would just complicate the analysis of lookups.</p>

</ss1>
</sec>
<sec>
<st>
 Academic significance </st>

<p>

While the XOR metric is not needed to understand Kademlia, it is critical in the analysis of the protocol.  The XOR arithmetic forms a <link xlink:type="simple" xlink:href="../447/19447.xml">
group</link> and <link xlink:type="simple" xlink:href="../384/19616384.xml">
abstract algebra</link> allows closed analysis.  Other DHT protocols and algorithms required <link xlink:type="simple" xlink:href="../416/375416.xml">
simulation</link> or complicated formal analysis in order to predict network behavior and correctness.  Using groups of bits as routing information also simplifies the algorithms.</p>

</sec>
<sec>
<st>
 Use in file sharing networks </st>

<p>

Kademlia is used in <link xlink:type="simple" xlink:href="../797/18949797.xml">
file sharing</link> networks. By making Kademlia keyword searches, one can find information in the file-sharing network so it can be downloaded. 
Since there is no central instance to store an index of existing files, this task is divided evenly among all clients: If a node wants to share a file, it processes the contents of the file, calculating from it a number (<link xlink:type="simple" xlink:href="../790/13790.xml">
hash</link>) that will identify this file within the file-sharing network. The hashes and the node IDs must be of the same length. It then searches for several nodes whose ID is close to the hash, and has his own IP address stored at those nodes. i.e. it publishes itself as a source for this file. A searching client will use Kademlia to search the network for the node whose ID has the smallest distance to the file hash, then will retrieve the sources list that is stored in that node.</p>
<p>

Since a key can correspond to many values, e.g. many sources of the same file, every storing node may have different information. Then, the sources are requested from all k nodes close to the key. </p>
<p>

The file hash is usually obtained from a specially formed Internet <link xlink:type="simple" xlink:href="../921/1427921.xml">
link</link> found elsewhere, or included within an indexing file obtained from other sources.</p>
<p>

Filename searches are implemented using <link xlink:type="simple" xlink:href="../138/17138.xml">
keyword</link>s. The filename is divided into its constituent words. Each of these keywords is hashed and stored in the network, together with the corresponding filename and file hash. A search involves choosing one of the keywords, contacting the node with an ID closest to that keyword hash, and retrieving the list of filenames that contain the keyword. Since every filename in the list has its hash attached, the chosen file can then be obtained in the normal way.</p>

</sec>
<sec>
<st>
Implementations</st>
<p>

Public clients using the Kademlia algorithm (these networks are incompatible with one another): 
<list>
<entry level="1" type="bullet">

Overnet network: <link xlink:type="simple" xlink:href="../135/336135.xml">
Overnet</link> (integrated in <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../787/144787.xml">
eDonkey</link></software>
 (no longer available) and <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../350/242350.xml">
MLDonkey</link></software>
). With <weblink xlink:type="simple" xlink:href="http://kadc.sourceforge.net/">
KadC</weblink> a C library for handling its Kademlia is available.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../564/1756564.xml">
Kad Network</link>: <link xlink:type="simple" xlink:href="../202/5464202.xml">
eMule</link> v0.40+, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../350/242350.xml">
MLDonkey</link></software>
 v2.5-28+. <link>
Lphant</link> v.3.50 beta 2+ and <link xlink:type="simple" xlink:href="../737/612737.xml">
aMule</link> v2.1.0+.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.revconnect.com/">
RevConnect</weblink> - v0.403+.</entry>
<entry level="1" type="bullet">

 BitTorrent Mainline DHT: <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../497/1845497.xml">
BitTorrent</link></software>
 v4.1.0+, <link>
µTorrent</link> v1.2+, <link>
BitSpirit</link> v3.0+, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../521/887521.xml">
BitComet</link></software>
 v0.59+, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<client wordnetid="109985075" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<case wordnetid="109898892" confidence="0.8">
<link xlink:type="simple" xlink:href="../384/2208384.xml">
KTorrent</link></case>
</causal_agent>
</client>
</person>
</physical_entity>
, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../945/8293945.xml">
Azureus 3.0+</link></software>
 (via a Plugin) and many <link xlink:type="simple" xlink:href="../385/6814385.xml">
libtorrent</link>-based: They all share a DHT based on an implementation of the Kademlia algorithm, for trackerless torrents.</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../945/8293945.xml#xpointer(//*[./st=%22DHT%22])">
Azureus DHT</link></software>
 v2.3.0.0+: used for decentralized <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../098/239098.xml">
BitTorrent</link></format>
</rule>
</direction>
</protocol>
</information>
</message>
 tracking and various <weblink xlink:type="simple" xlink:href="http://azureus.aelitis.com/wiki/index.php/Distributed_hash_table">
other features</weblink>; <it>differing</it> from the BitTorrent Mainline DHT.</entry>
<entry level="1" type="bullet">

 Mojito - a Java Kademlia library written for the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../956/17956.xml">
LimeWire</link></software>
 project. Mojito is used in LimeWire to provide DHT support for BitTorrent as well as to augment the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../856/11856.xml">
Gnutella</link></rule>
</direction>
</protocol>
</message>
 protocol. See the <weblink xlink:type="simple" xlink:href="http://www.limewire.org/nightly/modules/mojito/api/org/limewire/mojito/class-use/MojitoDHT.html">
Class interface  documentation</weblink> for more information. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://khashmir.sourceforge.net/">
Khashmir</weblink> - Python implementation of Kademlia. Used in the mainline Bittorrent, with some modifications.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.thomas.ambus.dk/plan-x/routing/">
Plan-x</weblink> - Java implementation.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.heim-d.uni-sb.de/~heikowu/SharkyPy/">
SharkyPy</weblink> - another python implementation of a Kademlia Distributed Hash Table. LGPL licenced.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://entangled.sourceforge.net/">
Entangled</weblink> - Python implementation of Kademlia, also providing a distributed <link xlink:type="simple" xlink:href="../238/1966238.xml">
tuple space</link>. LGPL licenced</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://retroshare.sf.net/">
RetroShare</weblink> - Kademlia implementation for secure Peer-to-Peer messaging and File Sharing</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../471/1963471.xml">
Content addressable network</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../132/322132.xml">
Chord (DHT)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../684/5440684.xml">
Tapestry (DHT)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../273/5200273.xml">
Pastry (DHT)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../011/14947011.xml">
Koorde</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://pdos.csail.mit.edu/~petar">
Petar Maymounkov's Academic Home Page</weblink></entry>
<entry level="1" type="bullet">

 Kademlia Specification : http://xlattice.sourceforge.net/components/protocol/kademlia/specs.html</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.northwestern.edu/~yqiao">
Yi Qiao</weblink> and <weblink xlink:type="simple" xlink:href="http://www.cs.northwestern.edu/~fabianb">
Fabian E. Bustamante</weblink> <weblink xlink:type="simple" xlink:href="http://www.aqualab.cs.northwestern.edu/publications/YQiao06SUO.pdf">
 USENIX 2006 paper that characterizes Overnet and Gnutella</weblink></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Stutzbach, Daniel&#32;(2006).&#32;"<weblink xlink:type="simple" xlink:href="http://www.barsoom.org/~agthorr/papers/infocom-2006-kad.pdf">
Improving Lookup Performance over a Widely-Deployed DHT</weblink>".&#32;  University of Oregon.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.kademlia.ru/">
Russian site about Kad Network</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://boykin.acis.ufl.edu/?p=142">
Brunet</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">
Kademlia: A Peer to peer information system Based on the XOR Metric</weblink></entry>
</list>
</entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.slyck.com/story1235.html">
Mojito and LimeWire</weblink></entry>
</reflist>
</p>


</sec>
</bdy>
</article>
