<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:48:18[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Banker&apos;s algorithm</title>
<id>5348805</id>
<revision>
<id>237017499</id>
<timestamp>2008-09-08T06:30:26Z</timestamp>
<contributor>
<username>Benjicharlton</username>
<id>3023242</id>
</contributor>
</revision>
<categories>
<category>Concurrent algorithms</category>
</categories>
</header>
<bdy>

This page deals with deadlock avoidance. For rounding to nearest even, see <b><link>
Banker's rounding</link></b><p>

The <b>Banker's algorithm</b> is a <link xlink:type="simple" xlink:href="../428/267428.xml">
resource allocation</link> &amp; <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link> avoidance <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> developed by <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> that tests for safety by simulating the allocation of pre-determined maximum possible amounts of all <link xlink:type="simple" xlink:href="../365/1728365.xml">
resources</link>, and then makes a "safe-state" check to test for possible deadlock conditions for all other pending activities, before deciding whether allocation should be allowed to continue.</p>
<p>

The algorithm was developed in the design process for the <link xlink:type="simple" xlink:href="../837/1525837.xml">
THE</link> <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> and originally described (in <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../433/8433.xml">
Dutch</link></language>
) in EWD108<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>. The name is by analogy with the way that bankers account for <link xlink:type="simple" xlink:href="../121/56121.xml">
liquidity</link> constraints.</p>

<sec>
<st>
 Algorithm </st>
<p>

The Banker's algorithm is run by the operating system whenever a <link xlink:type="simple" xlink:href="../178/45178.xml">
process</link> requests resources.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>
The algorithm prevents deadlock by denying or postponing the request if it determines that accepting the request could put the system in an unsafe state (one where deadlock could occur).</p>

<ss1>
<st>
 Resources </st>
<p>

For the Banker's algorithm to work, it needs to know three things:
<list>
<entry level="1" type="bullet">

How much of each resource each process could possibly request</entry>
<entry level="1" type="bullet">

How much of each resource each process is currently holding</entry>
<entry level="1" type="bullet">

How much of each resource the system has available</entry>
</list>
</p>
<p>

Some of the resources that are tracked in real systems are <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link>, <link xlink:type="simple" xlink:href="../557/164557.xml">
semaphores</link> and <link xlink:type="simple" xlink:href="../746/620746.xml">
interface</link> access.</p>

<ss2>
<st>
 Example </st>
<p>

Assuming that the system distinguishes between four types of resources, (A, B, C and D), the following is an example of how those resources could be distributed.  <it>Note that this example shows the system at an instant before a new request for resources arrives.  Also, the types and number of resources are abstracted.  Real systems, for example, would deal with much larger quantities of each resource.</it></p>

</ss2>
</ss1>
<ss1>
<st>
 Safe and Unsafe States </st>
<p>

A state (as in the above example) is considered safe if it is possible for all processes to finish executing (terminate).  Since the system cannot know when a process will terminate, or how many resources it will have requested by then, the system assumes that all processes will eventually attempt to acquire their stated maximum resources and terminate soon afterward.  This is a reasonable assumption in most cases since the system is not particularly concerned with how long each process runs (at least not from a deadlock avoidance perspective).  Also, if a process terminates without acquiring its maximum resources, it only makes it easier on the system.</p>
<p>

Given that assumption, the algorithm determines if a state is safe by trying to find a hypothetical set of requests by the processes that would allow each to acquire its maximum resources and then terminate (returning its resources to the system).  Any state where no such set exists is an unsafe state.</p>

<ss2>
<st>
 Pseudo-Code<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> </st>

<p>

P - set of processes</p>
<p>

Mp - maximal requirement of resources for process p</p>
<p>

Cp - current resources allocation process p</p>
<p>

A - currently available resources</p>
<p>

while (P != ∅) {
found = FALSE;
foreach (p ∈ P) {
if (Mp − Cp ≤ A) {
/* p can obtain all it needs.         */
/* assume it does so, terminates, and */
/* releases what it already has.      */
A = A + Cp ;
P = P − {p};
found = TRUE;
}
}
if (! found) return FAIL;
}
return OK;</p>

</ss2>
<ss2>
<st>
 Example C Program To Implement Banker's Algorithm </st>

<p>

The following Link Contains a C Program to implement the above pseudocode. It is written under GNU/Linux environment.
<weblink xlink:type="simple" xlink:href="http://thamirabarani.org/Resources/bankers.c">
Download: 'C Program for Bankers algorithm'</weblink></p>

</ss2>
<ss2>
<st>
 Example </st>
<p>

We can show that the state given in the previous example is a safe state by showing that it is possible for each process to acquire its maximum resources and then terminate.
<list>
<entry level="1" type="number">

P1 acquires 2 A, 1 B and 1 D more resources, achieving its maximum</entry>
<entry level="2" type="bullet">

The system now still has 1 A, no B, 1 C and 1 D resource available</entry>
<entry level="1" type="number">

P1 terminates, returning 3 A, 3 B, 2 C and 2 D resources to the system</entry>
<entry level="2" type="bullet">

The system now has 4 A, 3 B, 3 C and 3 D resources available</entry>
<entry level="1" type="number">

P2 acquires 2 B and 1 D extra resources, then terminates, returning all its resources</entry>
<entry level="2" type="bullet">

The system now has 5 A, 3 B, 6 C and 6 D resources</entry>
<entry level="1" type="number">

P3 acquires 4 C resources and terminates</entry>
<entry level="2" type="bullet">

The system now has all resources: 6 A, 4 B, 7 C and 6 D</entry>
<entry level="1" type="number">

Because all processes were able to terminate, this state is safe</entry>
</list>

Note that these requests and acquisitions are <it>hypothetical</it>.  The algorithm generates them to check the safety of the state, but no resources are actually given and no processes actually terminate.  Also note that the order in which these requests are generated – if several can be fulfilled – doesn't matter, because all hypothetical requests let a process terminate, thereby increasing the system's free resources.</p>
<p>

For an example of an unsafe state, consider what would happen if process 2 were holding 1 more unit of resource B at the beginning.</p>

</ss2>
</ss1>
<ss1>
<st>
 Requests </st>
<p>

When the system receives a request for resources, it runs the Banker's algorithm to determine if it is safe to grant the request.  The algorithm is fairly straight forward once the distinction between safe and unsafe states is understood.
<list>
<entry level="1" type="number">

Can the request be granted?</entry>
<entry level="2" type="bullet">

If not, the request is impossible and must either be denied or put on a waiting list</entry>
<entry level="1" type="number">

Assume that the request is granted</entry>
<entry level="1" type="number">

Is the new state safe?</entry>
<entry level="2" type="bullet">

If so grant the request</entry>
<entry level="2" type="bullet">

If not, either deny the request or put it on a waiting list</entry>
</list>

<it>Whether the system denies or postpones an impossible or unsafe request is a decision specific to the operating system.</it></p>

<ss2>
<st>
 Example </st>
<p>

Continuing the previous examples, assume process 3 requests 2 units of resource C.
<list>
<entry level="1" type="number">

There is not enough of resource C available to grant the request</entry>
<entry level="1" type="number">

The request is denied</entry>
</list>
</p>
<p>

On the other hand, assume process 3 requests 1 unit of resource C.
<list>
<entry level="1" type="number">

There are enough resources to grant the request</entry>
<entry level="1" type="number">

Assume the request is granted</entry>
<entry level="2" type="bullet">

The new state of the system would be:</entry>
</list>

Available system resources
A B C D
Free 3 1 0 2</p>
<p>

Processes (currently allocated resources):
A B C D
P1   1 2 2 1
P2   1 0 3 3
P3   1 1 2 0</p>
<p>

Processes (maximum resources):
A B C D
P1   3 3 2 2
P2   1 2 3 4
P3   1 1 5 0</p>
<p>

<list>
<entry level="1" type="number">

Determine if this new state is safe</entry>
<entry level="2" type="number">

P1 can acquire 2 A, 1 B and 1 D resources and terminate</entry>
<entry level="2" type="number">

Then, P2 can acquire 2 B and 1 D resources and terminate</entry>
<entry level="2" type="number">

Finally, P3 can acquire 3 C resources and terminate</entry>
<entry level="2" type="number">

Therefore, this new state is safe</entry>
<entry level="1" type="number">

Since the new state is safe, grant the request</entry>
</list>
</p>
<p>

Finally, assume that process 2 requests 1 unit of resource B.
<list>
<entry level="1" type="number">

There are enough resources</entry>
<entry level="1" type="number">

Assuming the request is granted, the new state would be:</entry>
</list>

Available system resources:
A B C D
Free 3 0 1 2</p>
<p>

Processes (currently allocated resources):
A B C D
P1   1 2 2 1
P2   1 1 3 3
P3   1 1 1 0</p>
<p>

Processes (maximum resources):
A B C D
P1   3 3 2 2
P2   1 2 3 4
P3   1 1 5 0</p>
<p>

<list>
<entry level="1" type="number">

Is this state safe?  Assuming P1, P2, and P3 request more of resource B and C.</entry>
<entry level="2" type="bullet">

P1 is unable to acquire enough B resources</entry>
<entry level="2" type="bullet">

P2 is unable to acquire enough B resources</entry>
<entry level="2" type="bullet">

P3 is unable to acquire enough C resources</entry>
<entry level="2" type="bullet">

No process can acquire enough resources to terminate, so this state is not safe</entry>
<entry level="1" type="number">

Since the state is unsafe, deny the request</entry>
</list>

<it>Note that in this example, no process was able to terminate.  It is possible that some processes will be able to terminate, but not all of them.  That would still be an unsafe state.</it></p>

</ss2>
</ss1>
</sec>
<sec>
<st>
 Trade-offs </st>
<p>

Like most algorithms, the Banker's algorithm involves some trade-offs.  Specifically, it needs to know how much of each resource a process could possibly request.  In most systems, this information is unavailable, making the Banker's algorithm useless. Besides, it is unrealistic
to assume that the number of processes is static. In most systems the number of processes varies dynamically. 
Moreover, the requirement that a process will eventually release all its resources (when the process terminates) is 
sufficient for the correctness of the algorithm, however it is not sufficient for a practical system. Waiting for hours (or even
days) for resources to be released is usually not acceptable.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
E. W. Dijkstra "<weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/users/EWD/ewd01xx/EWD108.PDF">
EWD108: Een algorithme ter voorkoming van de dodelijke omarming</weblink>" (in Dutch; <it>An algorithm for the prevention of the deadly embrace</it>)</entry>
<entry id="2">
 <cite style="font-style:normal" class="book">Lubomir, F. Bic&#32;(2003). <weblink xlink:type="simple" xlink:href="http://vig.prenhall.com/catalog/academic/product/0,1144,0130266116,00.html">
Operating System Principles</weblink>.&#32;Prentice Hall.</cite>&nbsp;</entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://www.cs.huji.ac.il/course/2006/os/notes/notes4.pdf">
Concurrency</weblink></entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading </st>
<p>

<list>
<entry level="1" type="bullet">

 "<weblink xlink:type="simple" xlink:href="http://codex.cs.yale.edu/avi/os-book/os7">
Operating System Concepts</weblink>" by Silberschatz, Galvin, and Gagne (pages 259-261 of the 7th edition)</entry>
<entry level="1" type="bullet">

 "<weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD623.PDF">
EWD623: The mathematics behind the Banker’s Algorithm</weblink>" (1977) by E. W. Dijkstra, published as pages 308–312 of Edsger W. Dijkstra, <it>Selected Writings on Computing: A Personal Perspective</it>, Springer-Verlag, 1982. ISBN 0-387-90652-5</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.isi.edu/~faber/cs402/notes/lecture9.html">
Deadlock Recovery, Avoidance and Prevention</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://algoritmo-del-banquero.veer.com.ar">
Algoritmo del Banquero</weblink> (In <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../825/26825.xml">
Spanish</link></language>
)</entry>
</list>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
