<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:43:53[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Kruskal&apos;s algorithm</title>
<id>53776</id>
<revision>
<id>240635683</id>
<timestamp>2008-09-24T07:53:33Z</timestamp>
<contributor>
<username>Jamelan</username>
<id>3529454</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Graph algorithms</category>
<category>Spanning tree</category>
</categories>
</header>
<bdy>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>

<b>Kruskal's algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> in <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link> that finds a <link xlink:type="simple" xlink:href="../795/41795.xml">
minimum spanning tree</link> for a connected weighted graph.  This means it finds a subset of the <link>
edge</link>s that forms a tree that includes every <link xlink:type="simple" xlink:href="../899/638899.xml">
vertex</link>, where the total weight of all the edges in the tree is minimized.  If the graph is not connected, then it finds a <it>minimum spanning forest</it> (a minimum spanning tree for each <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../223/246223.xml">
connected component</link></part>
</component>
</concept>
</idea>
). Kruskal's algorithm is an example of a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link>.<p>

It works as follows:
<list>
<entry level="1" type="bullet">

 create a forest <it>F</it> (a set of trees), where each vertex in the graph is a separate <graph wordnetid="107000195" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../560/48560.xml">
tree</link></graph>
</entry>
<entry level="1" type="bullet">

 create a set <it>S</it> containing all the edges in the graph</entry>
<entry level="1" type="bullet">

 while <it>S</it> is <link xlink:type="simple" xlink:href="../566/9566.xml">
nonempty</link></entry>
<entry level="2" type="bullet">

 remove an edge with minimum weight from <it>S''</it></entry>
<entry level="2" type="bullet">

 if that edge connects two different trees, then add it to the forest, combining two trees into a single tree</entry>
<entry level="2" type="bullet">

 otherwise discard that edge</entry>
</list>

At the termination of the <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>, the forest has only one component and forms a minimum spanning tree of the graph.</p>
<p>

This algorithm first appeared in <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../374/4977374.xml">
Proceedings of the American Mathematical Society</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
</it>, pp. 48&ndash;50 in <link xlink:type="simple" xlink:href="../672/34672.xml">
1956</link>, and was written by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<statistician wordnetid="110653238" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../807/1432807.xml">
Joseph Kruskal</link></associate>
</mathematician>
</scientist>
</causal_agent>
</colleague>
</statistician>
</person>
</peer>
</physical_entity>
.</p>
<p>

Other algorithms for this problem include <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, <link xlink:type="simple" xlink:href="../059/9516059.xml">
Reverse-Delete algorithm</link>, and <link>
Borůvka's algorithm</link>.</p>

<sec>
<st>
 Performance </st>
<p>

Where <it>E</it> is the number of edges in the graph and <it>V</it> is the number of vertices, Kruskal's algorithm can be shown to run in <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link></it>(<it>E</it> <link xlink:type="simple" xlink:href="../992/249992.xml">
log</link> <it>E</it>) time, or equivalently, <it>O</it>(<it>E</it> log <it>V</it>) time, all with simple data structures. These running times are equivalent because:
<list>
<entry level="1" type="bullet">

 <it>E</it> is at most <it>V</it>2 and <math>\log V^2 = 2 \log V</math> is <it>O</it>(log <it>V</it>).</entry>
<entry level="1" type="bullet">

 If we ignore isolated vertices, which will each be their own component of the minimum spanning tree anyway, <it>V</it> ≤ <it>E</it>+1, so log <it>V</it> is <it>O</it>(log <it>E</it>).</entry>
</list>
</p>
<p>

We can achieve this bound as follows: first sort the edges by weight using a <link xlink:type="simple" xlink:href="../304/3189304.xml">
comparison sort</link> in <it>O</it>(<it>E</it> log <it>E</it>) time; this allows the step "remove an edge with minimum weight from <it>S</it>" to operate in constant time. Next, we use a <link xlink:type="simple" xlink:href="../551/1037551.xml">
disjoint-set data structure</link> to keep track of which vertices are in which components. We need to perform O(<it>E</it>) operations, two 'find' operations and possibly one union for each edge. Even a simple disjoint-set data structure such as disjoint-set forests with union by rank can perform O(<it>E</it>) operations in <it>O</it>(<it>E</it> log <it>V</it>) time. Thus the total time is <it>O</it>(<it>E</it> log <it>E</it>) = <it>O</it>(<it>E</it> log <it>V</it>).</p>
<p>

Provided that the edges are either already sorted or can be sorted in linear time (for example with <link xlink:type="simple" xlink:href="../864/99864.xml">
counting sort</link> or <link xlink:type="simple" xlink:href="../980/25980.xml">
radix sort</link>), the algorithm can use more sophisticated disjoint-set data structures to run in <it>O</it>(<it>E</it> α(<it>V</it>)) time, where α is the extremely slowly-growing inverse of the single-valued <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Ackermann function</link></function>
</mathematical_relation>
.</p>

</sec>
<sec>
<st>
 Example </st>

<p>

<table cellpadding="5" border="1" cellspacing="0">
<row>
<col>
<image width="200px" src="Prim_Algorithm_0.svg">
</image>
</col>
<col>
This is our original graph. The numbers near the arcs indicate their weight. None of the arcs are highlighted.</col>
</row>
<row>
<col>
<image width="200px" src="Kruskal_Algorithm_1.svg">
</image>
</col>
<col>
<b>AD</b> and <b>CE</b> are the shortest arcs, with length 5, and <b>AD</b> has been <link xlink:type="simple" xlink:href="../808/3019808.xml">
arbitrarily</link>chosen, so it is highlighted.</col>
</row>
<row>
<col>
<image width="200px" src="Kruskal_Algorithm_2.svg">
</image>
</col>
<col>
<b>CE</b> is now the shortest arc that does not form a cycle, with length 5, so it is highlighted as the second arc.</col>
</row>
<row>
<col>
<image width="200px" src="Kruskal_Algorithm_3.svg">
</image>
</col>
<col>
The next arc, <b>DF</b> with length 6, is highlighted using much the same method.</col>
</row>
<row>
<col>
<image width="200px" src="Kruskal_Algorithm_4.svg">
</image>
</col>
<col>
The next-shortest arcs are <b>AB</b> and <b>BE</b>, both with length 7. <b>AB</b> is chosen arbitrarily, and is highlighted. The arc <b>BD</b> has been highlighted in red, because there already exists a path (in green) between <b>B</b> and <b>D</b>, so it would form a cycle (<b>ABD</b>) if it were chosen.</col>
</row>
<row>
<col>
<image width="200px" src="Kruskal_Algorithm_5.svg">
</image>
</col>
<col>
The process continues to highlight the next-smallest arc, <b>BE</b> with length 7. Many more arcs are highlighted in red at this stage: <b>BC</b> because it would form the loop <b>BCE</b>,  <b>DE</b> because it would form the loop <b>DEBA</b>, and <b>FE</b> because it would form <b>FEBAD</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Kruskal_Algorithm_6.svg">
</image>
</col>
<col>
Finally, the process finishes with the arc <b>EG</b> of length 9, and the minimum spanning tree is found.</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Proof of correctness </st>

<p>

The proof consists of two parts. First, it is proved that the algorithm produces a spanning tree. Second, it is proved that the constructed spanning tree is of minimal weight.</p>

<ss1>
<st>
Spanning tree</st>
<p>

Let <math>P</math> be a connected, weighted graph and let <math>Y</math> be the subgraph of <math>P</math> produced by the algorithm. <math>Y</math> cannot have a cycle, since the last edge added to that cycle would have been within one subtree and not between two different trees. <math>Y</math> cannot be disconnected, since the first encountered edge that joins two components of <math>Y</math> would have been added by the algorithm. Thus, <math>Y</math> is a spanning tree of <math>P</math>.</p>

</ss1>
<ss1>
<st>
Minimality</st>

<p>

The proof is by <it><link xlink:type="simple" xlink:href="../418/25418.xml">
reductio ad absurdum</link></it>. Assume that <math>Y</math> is not a minimal spanning tree and among all minimum weight spanning trees pick <math>Y_1</math> which has the smallest number of edges  which are not in <math>Y</math>. Consider the edge <math>e</math> which  was first to  be added by the algorithm to <math>Y</math> of those which are not in <math>Y_1</math>.</p>
<p>

<math>Y_1 \cup {e}</math> <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../770/455770.xml#xpointer(//*[./st=%22Properties+of+spanning+trees%22])">
has a cycle</link></difficulty>
</problem>
</state>
</condition>
. Being a tree, <math>Y</math> cannot contain all edges of this cycle. Therefore this cycle contains an edge  <math>f</math> which is not in <math>Y</math>. The graph <math>Y_2=Y_1 \cup {e} \setminus {f}</math> is also a spanning tree and therefore its weight cannot be less than the weight of <math>Y_1</math> and hence the weight of <it>e</it> cannot be less than the weight of <it>f</it>. 
<math>Y_2</math>
By  another application of the <it>reductio ad absurdum</it> we shall prove that the weight of <it>f</it> cannot be less than that of <it>e</it>.  Assume the contrary and remember that the edges are considered for addition to <math>Y</math> in the order of non-decreasing weight. Therefore <it>f</it> would have been considered in the main loop before <it>e</it>, i.e., it would be tested for the addition to a subforest <math>Y_3 \subset Y\cap Y_1</math> (recall that <it>e</it> is the first edge of <math>Y</math> which is not in <math>Y_1</math>). But <it>f</it> does not create a cycle in <math>Y_1</math>, therefore it cannot create a cycle in <math>Y_3</math>, and it would have been added to the growing tree. </p>
<p>

The above implies that the weights of <it>e</it> and <it>f</it> are equal, and hence <math>Y_2</math> is also a minimal spanning tree. But <math>Y_2</math> has one more edge in common with <math>Y</math> than <math>Y_1</math>, which contradicts to the choice of <math>Y_1</math>, <it><link xlink:type="simple" xlink:href="../228/25228.xml">
Q.E.D</link></it>.</p>

</ss1>
</sec>
<sec>
<st>
 Pseudocode </st>
<p>

1  <b>function</b> Kruskal(<it>G</it>)
2    <b>for each</b> vertex <it>v</it> in <it>G</it> do
3      Define an elementary cluster <it>C</it>(<it>v</it>) ← {<it>v</it>}.
4    Initialize a priority queue <it>Q</it> to contain all edges in <it>G</it>, using the weights as keys.
5    Define a tree <it>T</it> ← Ø       //<it>T</it> will ultimately contain the edges of the MST
6     // n is total number of vertices
7    <b>while</b> <it>T</it> has fewer than <it>n</it>-1 edges <b>do</b>
8      // edge u,v is the minimum weighted route from/to v
9      (<it>u</it>,<it>v</it>) ← <it>Q</it>.removeMin()
10      // prevent cycles in T. add u,v only if T does not already contain an edge consisting of u and v. 
11      // Note that the cluster contains more than one vertex only if an edge containing a pair of
12      // the vertices has been added to the tree.
13      Let <it>C</it>(<it>v</it>) be the cluster containing <it>v</it>, and let <it>C</it>(<it>u</it>) be the cluster containing <it>u</it>.
14      <b>if</b> <it>C</it>(<it>v</it>) ≠ <it>C</it>(<it>u</it>) <b>then</b>
15        Add edge (<it>v</it>,<it>u</it>) to <it>T</it>.
16        Merge <it>C</it>(<it>v</it>) and <it>C</it>(<it>u</it>) into one cluster, that is, union <it>C</it>(<it>v</it>) and <it>C</it>(<it>u</it>).
17    <b>return</b> tree <it>T</it></p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 Joseph. B. Kruskal: <it><weblink xlink:type="simple" xlink:href="http://links.jstor.org/sici?sici=0002-9939(195602)7%3A1%3C48%3AOTSSSO%3E2.0.CO%3B2-M">
On the Shortest Spanning Subtree of a Graph and the Traveling Salesman Problem</weblink></it>. In: <it>Proceedings of the American Mathematical Society</it>, Vol 7, No. 1 (Feb, 1956), pp. 48–50</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 23.2: The algorithms of Kruskal and Prim, pp.567&ndash;574.</entry>
<entry level="1" type="bullet">

 Michael T. Goodrich and Roberto Tamassia. <it>Data Structures and Algorithms in Java</it>, Fourth Edition. John Wiley &amp; Sons, Inc., 2006. ISBN 0-471-73884-0. Section 13.7.1: Kruskal's Algorithm, pp.632.</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../059/9516059.xml">
Reverse-Delete algorithm</link></entry>
<entry level="1" type="bullet">

 <link>
Borůvka's algorithm</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://students.ceid.upatras.gr/~papagel/project/kruskal.htm">
Animation of Kruskal's algorithm (Requires Java plugin)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cut-the-knot.org/Curriculum/Games/Mazes.shtml">
Create and Solve Mazes by Kruskal's and Prim's algorithms</weblink> at <link xlink:type="simple" xlink:href="../167/3259167.xml">
cut-the-knot</link></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-b2.is.tokushima-u.ac.jp/~ikeda/suuri/kruskal/Kruskal.shtml">
Minimum Spanning Tree Problem: Kruskal's Algorithm</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
