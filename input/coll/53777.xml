<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:45:28[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Ford-Fulkerson algorithm</title>
<id>53777</id>
<revision>
<id>239461720</id>
<timestamp>2008-09-19T03:50:24Z</timestamp>
<contributor>
<username>Jamelan</username>
<id>3529454</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Network flow</category>
</categories>
</header>
<bdy>

The <b>Ford-Fulkerson algorithm</b> (named for <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/7183185.xml">
L. R. Ford, Jr.</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../238/239238.xml">
D. R. Fulkerson</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
) computes the <link xlink:type="simple" xlink:href="../165/403165.xml">
maximum flow</link> in a <link xlink:type="simple" xlink:href="../676/645676.xml">
flow network</link>. It was published in 1956. The name "Ford-Fulkerson" is often also used for the <link xlink:type="simple" xlink:href="../230/239230.xml">
Edmonds-Karp algorithm</link>, which is a specialization of Ford-Fulkerson.<p>

The idea behind the <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is very simple: As long as there is a path from the source (start node) to the sink (end node), with available capacity on all edges in the path, we send flow along one of these paths. Then we find another path, and so on. A path with available capacity is called an <link>
augmenting path</link>.</p>

<sec>
<st>
Algorithm</st>
<p>

Given is a graph <math>G(V,E)</math>, with capacity <math>c(u,v)</math> and flow <math>f(u,v)=0</math> for the edge from <math>u</math> to <math>v</math>. We want to find the maximum flow from the source <math>s</math> to the sink <math>t</math>. After every step in the algorithm the following is maintained:</p>
<p>

<list>
<entry level="1" type="bullet">

 <math>\ f(u,v) \leq c(u,v)</math>. The flow from <math>u</math> to <math>v</math> does not exceed the capacity.</entry>
<entry level="1" type="bullet">

 <math>\ f(u,v) = - f(v,u)</math>. Maintain the net flow between <math>u</math> and <math>v</math>. If in reality <math>a</math> units are going from <math>u</math> to <math>v</math>, and <math>b</math> units from <math>v</math> to <math>u</math>, maintain <math>f(u,v)=a-b</math> and <math>f(v,u)=b-a</math>.</entry>
<entry level="1" type="bullet">

 <math>\ \sum_v f(u,v) = 0 \Longleftrightarrow f_{in}(u) = f_{out}(u)</math> for all nodes <math>u</math>, except <math>s</math> and <math>t</math>. The amount of flow into a node equals the flow out of the node.</entry>
</list>
</p>
<p>

This means that the flow through the network is a <it>legal flow</it> after each round in the algorithm. We define the <b>residual network</b> <math>G_f(V,E_f)</math> to be the network with capacity <math>c_f(u,v) = c(u,v) - f(u,v)</math> and no flow. Notice that it can happen that a flow from <math>v</math> to <math>u</math> is allowed in the residual
network, though disallowed in the original network: if <math>f(u,v)&amp;gt;0</math> and <math>c(v,u)=0</math> then
<math>c_f(v,u)&amp;gt;0</math>.</p>
<p>

<b>Algorithm</b> Ford-Fulkerson
<indent level="1">

<b>Inputs</b> Graph <math>\,G</math> with flow capacity <math>\,c</math>, a source node <math>\,s</math>, and a sink node <math>\,t</math>
</indent>
:<b>Output</b> A flow <math>\,f</math> from <math>\,s</math> to <math>\,t</math> which is a maximum
<list>
<entry level="2" type="number">

 <math>f(u,v) \leftarrow 0</math> for all edges <math>\,(u,v)</math></entry>
<entry level="2" type="number">

 While there is a path <math>\,p</math> from <math>\,s</math> to <math>\,t</math> in <math>\,G_f</math>, such that <math>\,c_f(u,v) &amp;gt; 0</math> for all edges <math>(u,v) \in p</math>:</entry>
<entry level="3" type="number">

 Find <math>\,c_f(p) = \min\{c_f(u,v) \;|\; (u,v) \in p\}</math></entry>
<entry level="3" type="number">

 For each edge <math>(u,v) \in p</math></entry>
<entry level="4" type="number">

 <math>f(u,v) \leftarrow f(u,v) + c_f(p)</math> (<it>Send flow along the path</it>)</entry>
<entry level="4" type="number">

 <math>f(v,u) \leftarrow f(v,u) - c_f(p)</math> (<it>The flow might be "returned" later</it>)</entry>
</list>
</p>
<p>

The path in step 2 can be found with for example a <link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link> or a <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link> in <math>G_f(V,E_f)</math>. If you use the former, the algorithm is called <link xlink:type="simple" xlink:href="../230/239230.xml">
Edmonds-Karp</link>.</p>
<p>

When no more paths in step 2 can be found, <math>s</math> will not be able to reach <math>t</math> in the residual
network. If <math>S</math> is the set of nodes reachable by <math>s</math> in the residual network, then the total
capacity in the original network of edges from <math>S</math> to the remainder of <math>V</math> is on the one hand
equal to the total flow we found from <math>s</math> to <math>t</math>,
and on the other hand serves as an upper bound for all such flows.
This proves that the flow we found is maximal. See also <link xlink:type="simple" xlink:href="../130/78130.xml">
Max-flow Min-cut theorem</link>.</p>

</sec>
<sec>
<st>
Complexity</st>
<p>

By adding the flow augmenting path to the flow already established in the graph, the maximum flow will be reached when no more flow augmenting paths can be found in the graph.  However, there is no certainty that this situation will ever be reached, so the best that can be guaranteed is that the answer will be correct if the algorithm terminates.  In the case that the algorithm runs forever, the flow might not even converge towards the maximum flow.  However, this situation only occurs with irrational flow values.  When the capacities are integers, the runtime of Ford-Fulkerson is bounded by <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>E*f</it>), where <it>E</it> is the number of edges in the graph and <it>f</it> is the maximum flow in the graph.  This is because each augmenting path can be found in <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>E</it>) time and increases the flow by an integer amount which is at least 1.</p>
<p>

A variation of the Ford-Fulkerson algorithm with guaranteed termination and a runtime independent of the maximum flow value is the <link xlink:type="simple" xlink:href="../230/239230.xml">
Edmonds-Karp algorithm</link>, which runs in <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>VE</it>2) time.</p>

</sec>
<sec>
<st>
Example</st>

<p>

The following example shows the first steps of Ford-Fulkerson in a flow network with 4 nodes, source <it>A</it> and sink <it>D</it>. This example shows the worst-case behaviour of the algorithm. In each step, only a flow of 1 is sent across the network. If you used breadth-first-search instead, you would only need two steps.</p>

<p>

<table width="100%">
<row>
<header>
Path</header>
<header>
Capacity</header>
<header>
Resulting flow network</header>
</row>
<row>

<col>
Initial flow network</col>
<col>
<image width="300px" src="Ford-Fulkerson_example_0.svg">
</image>
</col>
</row>
<row>
<col>
<math>A,B,C,D</math></col>
<col>
<math>\min(c_f(A,B), c_f(B,C), c_f(C,D))=</math><p>

<math>\min(c(A,B)-f(A,B) ,c(B,C)-f(B,C), c(C,D)-f(C,D))=</math>
<math>\min(1000-0, 1-0, 1000-0)=1</math></p>
</col>
<col>
<image width="300px" src="Ford-Fulkerson_example_1.svg">
</image>
</col>
</row>
<row>
<col>
<math>A,C,B,D</math></col>
<col>
<math>\min(c_f(A,C), c_f(C,B), c_f(B,D))=</math><p>

<math>\min(c(A,C)-f(A,C), c(C,B)-f(C,B), c(B,D)-f(B,D))=</math>
<math>\min(1000-0, 0-(-1), 1000-0)=1</math></p>
</col>
<col>
<image width="300px" src="Ford-Fulkerson_example_2.svg">
</image>
</col>
</row>
<row>

<col>
After 1998 more steps â€¦</col>

</row>
<row>

<col>
Final flow network</col>
<col>
<image width="300px" src="Ford-Fulkerson_example_final.svg">
</image>
</col>
</row>
</table>
</p>

<p>

Notice how flow is "pushed back" from <it>C</it> to <it>B</it> when finding the path <it>A,C,B,D</it>.</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.lix.polytechnique.fr/~durr/MaxFlow/">
Animation of Ford-Fulkerson algorithm</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 26.2: The Ford-Fulkerson method, pp.651&ndash;664.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../185/7183185.xml">
L. R. Ford</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
; D. R. Fulkerson&#32;(1956).&#32;"Maximal flow through a network". <it>Canadian Journal of Mathematics</it>&#32;<b>8</b>: 399--404.</cite>&nbsp;</entry>
</list>
</p>


</sec>
</bdy>
</article>
