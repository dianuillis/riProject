<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:45:40[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Prim&apos;s algorithm</title>
<id>53783</id>
<revision>
<id>243444411</id>
<timestamp>2008-10-06T15:10:37Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Articles containing proofs</category>
<category>Graph algorithms</category>
<category>Spanning tree</category>
</categories>
</header>
<bdy>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>

<b>Prim's algorithm</b> is an algorithm in <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link> that finds a <link xlink:type="simple" xlink:href="../795/41795.xml">
minimum spanning tree</link> for a connected weighted graph.  This means it finds a subset of the <link>
edge</link>s that forms a <graph wordnetid="107000195" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../560/48560.xml">
tree</link></graph>
 that includes every <link xlink:type="simple" xlink:href="../899/638899.xml">
vertex</link>, where the total weight of all the <link xlink:type="simple" xlink:href="../401/12401.xml">
edges</link> in the tree is minimized.   The algorithm was discovered in 1930 by mathematician <link>
Vojtěch Jarník</link> and later independently by <link xlink:type="simple" xlink:href="../784/328784.xml">
computer scientist</link> <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<link xlink:type="simple" xlink:href="../129/3162129.xml">
Robert C. Prim</link></creator>
</scholar>
</mathematician>
</originator>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</pioneer>
</person>
</physical_entity>
 in 1957 and rediscovered by <link xlink:type="simple" xlink:href="../018/10018.xml">
Edsger Dijkstra</link> in 1959. Therefore it is sometimes called the <b>DJP algorithm</b>, the <b>Jarník algorithm</b>, or the <b>Prim-Jarník algorithm</b>.
<sec>
<st>
 Description </st>

<p>

The algorithm continuously increases the size of a tree starting with a single vertex until it spans all the vertices. </p>
<p>

<list>
<entry level="1" type="bullet">

 Input: A connected weighted graph with vertices V and edges E.</entry>
<entry level="1" type="bullet">

 Initialize: Vnew = {x}, where x is an arbitrary node (starting point) from V, Enew= {}</entry>
<entry level="1" type="bullet">

 repeat until Vnew=V:</entry>
<entry level="2" type="bullet">

 Choose edge (u,v) from E with minimal weight such that u is in Vnew and v is not (if there are multiple edges with the same weight, choose arbitrarily)</entry>
<entry level="2" type="bullet">

 Add v to Vnew, add (u,v) to Enew</entry>
<entry level="1" type="bullet">

 Output: Vnew and Enew describe the minimal spanning tree</entry>
</list>
</p>

</sec>
<sec>
<st>
 Time complexity </st>

<p>

<table class="wikitable">
<header>
Minimum edge weight data structure</header>
<header>
Time complexity (total)</header>
<row>
<col>
 <link xlink:type="simple" xlink:href="../463/244463.xml">
adjacency matrix</link>, searching</col>
<col>
O(V2)</col>
</row>
<row>
<col>
 <link xlink:type="simple" xlink:href="../890/69890.xml">
binary heap</link> (as in pseudocode below) and <link xlink:type="simple" xlink:href="../431/392431.xml">
adjacency list</link></col>
<col>
O((V + E) log(V)) = O(E log(V))</col>
</row>
<row>
<col>
 <amount wordnetid="105107765" confidence="0.8">
<magnitude wordnetid="105090441" confidence="0.8">
<property wordnetid="104916342" confidence="0.8">
<number wordnetid="105121418" confidence="0.8">
<link xlink:type="simple" xlink:href="../142/254142.xml">
Fibonacci heap</link></number>
</property>
</magnitude>
</amount>
 and <link xlink:type="simple" xlink:href="../431/392431.xml">
adjacency list</link></col>
<col>
O(E + V log(V))</col>
</row>
</table>
</p>
<p>

A simple implementation using an <link xlink:type="simple" xlink:href="../463/244463.xml">
adjacency matrix</link> graph representation and searching an array of weights to find the minimum weight edge to add requires <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>V2</it>) running time. Using a simple <link xlink:type="simple" xlink:href="../890/69890.xml">
binary heap</link> data structure and an <link xlink:type="simple" xlink:href="../431/392431.xml">
adjacency list</link> representation, Prim's algorithm can be shown to run in time which is <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>E</it> log <it>V</it>) where E is the number of edges and V is the number of vertices. Using a more sophisticated <amount wordnetid="105107765" confidence="0.8">
<magnitude wordnetid="105090441" confidence="0.8">
<property wordnetid="104916342" confidence="0.8">
<number wordnetid="105121418" confidence="0.8">
<link xlink:type="simple" xlink:href="../142/254142.xml">
Fibonacci heap</link></number>
</property>
</magnitude>
</amount>
, this can be brought down to O(<it>E</it> + <it>V</it> log <it>V</it>), which is significantly faster when the graph is dense enough that <it>E</it> is <math>\Omega</math>(<it>V</it> log <it>V</it>).</p>

</sec>
<sec>
<st>
 Example </st>

<p>

<table cellpadding="5" border="1" cellspacing="2">
<header>
Image</header>
<header>
Description</header>
<row>
<col>
<image width="200px" src="Prim_Algorithm_0.svg">
</image>
</col>
<col>
This is our original weighted graph. The numbers near the arcs indicate their weight.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_1.svg">
</image>
</col>
<col>
Vertex <b>D</b> has been arbitrarily chosen as a starting point. Vertices <b>A</b>, <b>B</b>, <b>E</b> and <b>F</b> are connected to <b>D</b> through a single edge. <b>A</b> is the vertex nearest to <b>D</b> and will be chosen as the second vertex along with the edge <b>AD</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_2.svg">
</image>
</col>
<col>
The next vertex chosen is the vertex nearest to <it>either</it> <b>D</b> or <b>A</b>. <b>B</b> is 9 away from <b>D</b> and 7 away from <b>A</b>, <b>E</b> is 15, and <b>F</b> is 6. <b>F</b> is the smallest distance away, so we highlight the vertex <b>F</b> and the arc <b>DF</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_3.svg">
</image>
</col>
<col>
The algorithm carries on as above. Vertex <b>B</b>, which is 7 away from <b>A</b>, is highlighted.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_4.svg">
</image>
</col>
<col>
In this case, we can choose between <b>C</b>, <b>E</b>, and <b>G</b>. <b>C</b> is 8 away from <b>B</b>, <b>E</b> is 7 away from <b>B</b>, and <b>G</b> is 11 away from <b>F</b>. <b>E</b> is nearest, so we highlight the vertex <b>E</b> and the arc <b>EB</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_5.svg">
</image>
</col>
<col>
Here, the only vertices available are <b>C</b> and <b>G</b>. <b>C</b> is 5 away from <b>E</b>, and <b>G</b> is 9 away from <b>E</b>. <b>C</b> is chosen, so it is highlighted along with the arc <b>EC</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_6.svg">
</image>
</col>
<col>
Vertex <b>G</b> is the only remaining vertex. It is 11 away from <b>F</b>, and 9 away from <b>E</b>. <b>E</b> is nearer, so we highlight it and the arc <b>EG</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Prim_Algorithm_7.svg">
</image>
</col>
<col>
Now all the vertices have been selected and the <link xlink:type="simple" xlink:href="../795/41795.xml">
minimum spanning tree</link>is shown in green. In this case, it has weight 39.</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Pseudocode </st>


<ss1>
<st>
 Min-heap </st>


<p>

<list>
<entry level="1" type="definition">

 Initialization</entry>
<entry level="1" type="indent">

 <it>inputs: A graph, a function returning edge weights weight-function, and an initial vertex''</it></entry>
</list>

initial placement of all vertices in the 'not yet seen' set, set initial vertex to be added to the tree, and place all vertices in a min-heap to allow for removal of the min distance from the minimum graph.
<b>for each</b> <it>vertex</it> <b>in</b> <it>graph</it>
<b>set</b> min_distance <b>of</b> <it>vertex</it> <b>to</b> ∞
<b>set</b> parent <b>of</b> <it>vertex</it> <b>to</b> <it>null</it>
<b>set</b> minimum_adjacency_list <b>of</b> <it>vertex</it> <b>to</b> empty list
<b>set</b> is_in_Q <b>of</b> <it>vertex</it> <b>to</b> true
<b>set</b> distance <b>of</b> initial vertex <b>to</b> <it>zero</it>
add to minimum-heap <b>Q</b> all vertices in graph.</p>
<p>

<list>
<entry level="1" type="definition">

 Algorithm</entry>
</list>

In the algorithm description above,
<indent level="1">

 <it>nearest vertex</it> is Q[0], now latest addition
</indent>
: <it>fringe</it> is v in Q where distance of v  ∞ after nearest vertex is removed
<indent level="1">

 <it>not seen</it> is v in Q where distance of v = ∞ after nearest vertex is removed
</indent>
The while loop will fail when remove minimum returns <link xlink:type="simple" xlink:href="../712/21712.xml">
null</link>. The adjacency list is set to allow a directional graph to be returned.
<indent level="1">

 <it>time complexity: V for loop, log(V) for the remove function</it>
</indent>
<b>while</b> <it>latest_addition</it> = remove minimum in <b>Q</b>
<b>set</b> is_in_Q <b>of</b> <it>latest_addition</it> to false
add <it>latest_addition</it> to (minimum_adjacency_list of (parent of <it>latest_addition</it>))
add (parent of <it>latest_addition</it>) to (minimum_adjacency_list of <it>latest_addition</it>)
<indent level="1">

 <it>time complexity: E/V, the average number of vertices</it>
</indent>
<b>for each</b> <it>adjacent</it> <b>of</b> <it>latest_addition</it>
<b>if</b> (is_in_Q of <it>adjacent</it>) and (weight-function(<it>latest_addition</it>, <it>adjacent</it>)  min_distance of <it>adjacent</it>)
<b>set</b> parent <b>of</b> <it>adjacent</it> <b>to</b> <it>latest_addition</it>
<b>set</b> min_distance <b>of</b> <it>adjacent</it> <b>to</b> weight-function(<it>latest_addition</it>, <it>adjacent</it>)
<indent level="1">

 <it>time complexity: log(V), the height of the heap</it>
</indent>
update <it>adjacent</it> in <b>Q</b>, order by min_distance</p>

</ss1>
</sec>
<sec>
<st>
 Proof of correctness </st>

<p>

Let <it>P</it> be a connected, weighted <link xlink:type="simple" xlink:href="../401/12401.xml">
graph</link>.  At every iteration of Prim's algorithm, an edge must be found that connects a vertex in a subgraph to a vertex outside the subgraph.  Since <it>P</it> is connected, there will always be a path to every vertex.  The output <it>Y</it> of Prim's algorithm is a <graph wordnetid="107000195" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../560/48560.xml">
tree</link></graph>
, because the edge and vertex added to <it>Y</it> are connected. Let <it>Y1</it> be a minimum spanning tree of P. If <it>Y1</it>=<it>Y</it> then <it>Y</it> is a minimum spanning tree. Otherwise, let <it>e</it> be the first edge added during the construction of <it>Y</it> that is not in <it>Y1</it>, and <it>V</it> be the set of vertices connected by the edges added before <it>e</it>.  Then one endpoint of <it>e</it> is in <it>V</it> and the other is not.  Since <it>Y1</it> is a spanning tree of <it>P</it>, there is a path in <it>Y1</it> joining the two endpoints.  As one travels along the path, one must encounter an edge <it>f</it> joining a vertex in <it>V</it> to one that is not in <it>V</it>.  Now, at the iteration when <it>e</it> was added to <it>Y</it>, <it>f</it> could also have been added and it would be added instead of <it>e</it> if its weight was less than <it>e</it>.  Since <it>f</it> was not added, we conclude that </p>
<p>

<indent level="1">

<it>w</it>(<it>f</it>) ≥ <it>w</it>(<it>e</it>).
</indent>

Let <it>Y2</it> be the graph obtained by removing <it>f</it> and adding <it>e</it> from <it>Y1</it>.  It is easy to show that <it>Y2</it> is connected, has the same number of edges as <it>Y1</it>, and the total weights of its edges is not larger than that of <it>Y1</it>, therefore it is also a minimum spanning tree of <it>P</it> and it contains <it>e</it> and all the edges added before it during the construction of <it>V</it>.  Repeat the steps above and we will eventually obtain a minimum spanning tree of <it>P</it> that is identical to <it>Y</it>.  This shows <it>Y</it> is a minimum spanning tree.</p>
<p>

Other algorithms for this problem include <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and <link>
Borůvka's algorithm</link>.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 V. Jarník: <it>O jistém problému minimálním</it> [About a certain minimal problem], Práce Moravské Přírodovědecké Společnosti, 6, 1930, pp. 57-63. (in Czech)</entry>
<entry level="1" type="bullet">

 R. C. Prim: <it>Shortest connection networks and some generalisations</it>. In: <it>Bell System Technical Journal</it>, 36 (1957), pp. 1389–1401</entry>
<entry level="1" type="bullet">

 D. Cherition and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../127/46127.xml">
R. E. Tarjan</link></scientist>
</person>
: <it>Finding minimum spanning trees</it>. In: <it>SIAM Journal of Computing</it>, 5 (Dec. 1976), pp. 724–741</entry>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 23.2: The algorithms of Kruskal and Prim, pp.567&ndash;574.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://tide4javascript.com/?s=Prim">
Analyze Prim's algorithm in an online Javascript IDE</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www-b2.is.tokushima-u.ac.jp/~ikeda/suuri/dijkstra/Prim.shtml">
Minimum Spanning Tree Problem: Prim's Algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cut-the-knot.org/Curriculum/Games/Mazes.shtml">
Create and Solve Mazes by Kruskal's and Prim's algorithms</weblink> at <link xlink:type="simple" xlink:href="../167/3259167.xml">
cut-the-knot</link></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://students.ceid.upatras.gr/~papagel/project/prim.htm">
Animated example of Prim's algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mincel.com/java/prim.html">
Prim's Algorithm (Java Applet)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://codebase.dbp-site.com/code/prims-algorithm-grid-map-generator-24">
Variation on Prims Algorithm to generate a shortest-route grid between a random set of points</weblink> - written for <link xlink:type="simple" xlink:href="../729/860729.xml">
Dark Basic Pro</link></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
