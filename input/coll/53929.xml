<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:45:41[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>CYK algorithm</title>
<id>53929</id>
<revision>
<id>218575064</id>
<timestamp>2008-06-11T07:15:33Z</timestamp>
<contributor>
<username>Senu</username>
<id>2464896</id>
</contributor>
</revision>
<categories>
<category>Dynamic programming</category>
<category>Parsing algorithms</category>
</categories>
</header>
<bdy>

The <b>Cocke-Younger-Kasami (CYK) algorithm</b> (alternatively called CKY) determines whether a 
<link xlink:type="simple" xlink:href="../701/27701.xml">
string</link> can be generated by a given <link xlink:type="simple" xlink:href="../759/6759.xml">
context-free grammar</link> and, if so, how it can be generated. This is known as <link xlink:type="simple" xlink:href="../015/310015.xml">
parsing</link> the string. The algorithm is an example of <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>.<p>

The standard version of CYK recognizes languages defined by context-free grammars written in <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../850/7850.xml">
Chomsky normal form</link></language>
 (CNF).  Since any context-free grammar can be converted to CNF without too much difficulty, CYK can be used to recognize any context-free language. It is also possible to extend the CYK algorithm to handle some context-free grammars which are not written in CNF; this may be done to improve performance, although at the cost of making the algorithm harder to understand.</p>
<p>

The worst case <link xlink:type="simple" xlink:href="../503/3469503.xml">
asymptotic</link> time complexity of CYK is <link xlink:type="simple" xlink:href="../578/44578.xml">
Θ</link>(n3), where <it>n</it> is the length of the parsed string. This makes it one of the most efficient (in those terms) algorithms for recognizing any context-free language. However, there are other algorithms that will perform better for certain subsets of the context-free languages.</p>

<sec>
<st>
The algorithm</st>

<p>

The CYK algorithm is a <link xlink:type="simple" xlink:href="../521/679521.xml">
bottom up</link> algorithm and is important theoretically, since it can be used to constructively prove that the <link>
membership problem</link> for context-free languages is <link xlink:type="simple" xlink:href="../336/8336.xml">
decidable</link>. </p>
<p>

The CYK algorithm for the membership problem is as follows:
<b>Let</b> the input string consist of <it>n</it> letters, <it>a</it>1 ... <it>an</it>.
<b>Let</b> the grammar contain <it>r</it> terminal and nonterminal symbols <it>R</it>1 ... <it>Rr</it>. 
This grammar contains the subset Rs which is the set of start symbols.
<b>Let</b> P[n,n,r] be an array of booleans. Initialize all elements of P to false.
<b>For each</b> i = 1 to n
<b>For each</b> unit production Rj -&amp;gt; ai, <b>set</b> P[i,1,j] = true.
<b>For each</b> i = 2 to n -- Length of span
<b>For each</b> j = 1 to n-i+1 -- Start of span
<b>For each</b> k = 1 to i-1 -- Partition of span
<b>For each</b> production RA -&amp;gt; RB RC
<b>If</b> P[j,k,B] and P[j+k,i-k,C] <b>then</b> set P[j,i,A] = true
<b>If</b> any of P[1,n,x] is true (x is iterated over the set s, where s are all the indices for Rs)
<b>Then</b> string is member of language
<b>Else</b> string is not member of language</p>

<ss1>
<st>
Informally</st>

<p>

In informal terms, this algorithm considers every possible subsequence of the sequence of words and sets P[i,j,k] to be true if the subsequence of words starting from i of length j can be generated from Rk. Once it has considered subsequences of length 1, it goes on to subsequences of length 2, and so on. For subsequences of length 2 and greater, it considers every possible partition of the subsequence into two parts, and checks to see if there is some production P → Q R such that Q matches the first part and R matches the second part. If so, it records P as matching the whole subsequence. Once this process is completed, the sentence is recognized by the grammar if the subsequence containing the entire sentence is matched by the start symbol.</p>
<p>

<table class="wikitable">
<caption>
CYK table</caption>
<row>
<col>
<b>S</b></col>
</row>
<row>

<col>
VP</col>
</row>
<row>

<col>
&nbsp;</col>

</row>
<row>
<col>
<b>S</b></col>



</row>
<row>

<col>
VP</col>


<col>
PP</col>
</row>
<row>
<col>
<b>S</b></col>

<col>
NP</col>


<col>
NP</col>
</row>
<row>
<col>
NP</col>
<col>
V, VP</col>
<col>
Det.</col>
<col>
N</col>
<col>
P</col>
<col>
Det</col>
<col>
N</col>
</row>
<row style="border-top:3px solid grey;">
<col>
she</col>
<col>
eats</col>
<col>
a</col>
<col>
fish</col>
<col>
with</col>
<col>
a</col>
<col>
fork</col>
</row>
</table>
</p>

</ss1>
<ss1>
<st>
Algorithm extension</st>

<p>

It is simple to extend the above algorithm to not only determine if a sentence is in a language, but to also construct a <link xlink:type="simple" xlink:href="../404/118404.xml">
parse tree</link>, by storing parse tree nodes as elements of the array, instead of booleans. Since the grammars being recognized can be ambiguous, it is necessary to store a list of nodes (unless one wishes to only pick one possible parse tree); the end result is then a forest of possible parse trees.
An alternative formulation employs a second table B[n,n,r] of so-called <it>backpointers</it>.</p>
<p>

It is also possible to extend the CYK algorithm to parse strings using <link xlink:type="simple" xlink:href="../803/1819803.xml">
weighted</link> and <link xlink:type="simple" xlink:href="../329/299329.xml">
stochastic context-free grammar</link>s. Weights (probabilities) are then stored in the table P instead of booleans, so P[i,j,A] will contain the minimum weight (maximum probability) that the substring from i to j can be derived from A. Further extensions of the algorithm allow all parses of a string to be enumerated from lowest to highest weight (highest to lowest probability).</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../685/9685.xml">
Earley parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../899/892899.xml">
Packrat parser</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../915/301915.xml">
John Cocke</link></scientist>
</person>
 and Jacob T. Schwartz (1970). Programming languages and their compilers: Preliminary notes. Technical report, Courant Institute of Mathematical Sciences, New York University.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<theorist wordnetid="110706812" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../790/14133790.xml">
T. Kasami</link></causal_agent>
</intellectual>
</theorist>
</person>
</physical_entity>
 (1965). An efficient recognition and syntax-analysis algorithm for context-free languages.  Scientific report AFCRL-65-758, Air Force Cambridge Research Lab, Bedford, MA.</entry>
<entry level="1" type="bullet">

 Daniel H. Younger (1967). Recognition and parsing of context-free languages in time <it>n</it>3. <it>Information and Control</it> 10(2): 189&ndash;208.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
