<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:16:24[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Random access machine</title>
<id>544227</id>
<revision>
<id>243517643</id>
<timestamp>2008-10-06T21:23:35Z</timestamp>
<contributor>
<username>Scarecroe</username>
<id>129667</id>
</contributor>
</revision>
<categories>
<category>Computational models</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>random access machine</b> (RAM) is an <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link> in the general class of <link xlink:type="simple" xlink:href="../218/505218.xml">
register machine</link>s. The RAM is very similar to the <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> but with the added capability of 'indirect addressing' of its registers. Like the counter machine the RAM has its instructions in the finite-state portion of the machine (the so-called <link xlink:type="simple" xlink:href="../019/58019.xml">
Harvard architecture</link>).<p>

The RAM's equivalent of the <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../435/71435.xml">
Universal Turing machine</link></machine>
</causal_agent>
</worker>
</device>
</assistant>
</instrumentality>
</artifact>
</model>
</person>
</physical_entity>
 -- with its <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link> in the registers as well as its data -- is called the <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 or RASP. It is an example of the so-called <link xlink:type="simple" xlink:href="../091/478091.xml">
von Neumann architecture</link> and is closest to the common notion of <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>.</p>
<p>

Together with the <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 and <link xlink:type="simple" xlink:href="../249/7599249.xml">
counter machine models</link>, the RAM and RASP models are used for <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity analysis</link>. Van Emde Boas (1990) calls these three plus the <link xlink:type="simple" xlink:href="../616/6144616.xml">
pointer machine</link> "sequential machine" models, to distinguish them from "<link xlink:type="simple" xlink:href="../675/956675.xml">
parallel random access machine</link>" models.</p>

<sec>
<st>
Introduction to the Random Access Machine Model (RAM) </st>
<p>

The concept of a random access machine (RAM) starts with the simplest model of all, the so-called <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> model. Two additions move it away from the counter machine, however. The first enhances the machine with the convenience of indirect addressing; the second moves the model toward the more conventional accumulator-based <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> with the addition of one or more auxiliary (dedicated) registers, the most common of which is called "the accumulator".   </p>

<ss1>
<st>
 Formal Definition: Random Access Machine </st>
<p>

A <it>Random Access Machine</it> (RAM) is an abstract computational-machine model identical to a multiple-register <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> with the addition of indirect addressing. At the discretion of an instruction from its finite state machine's TABLE, the machine derives a "target" register's address either (i) directly from the instruction itself, or (ii) indirectly from the <it>contents</it> (e.g. number, label) of the "pointer" register specified in the instruction.</p>
<p>

By definition: A <it>register</it> is a location with both an <it>address</it> (a unique, distinguishable designation/locator equivalent to a natural number) and a <it>content</it> -- a single natural number. For precision we will use the quasi-formal symbolism from Boolos-Burgess-Jeffrey (2002) to specify a register, its contents, and an operation on a register: 
<list>
<entry level="1" type="bullet">

 [r] means "the contents of register with address r". The label "r" here is a "variable" that can be filled with a natural number or a letter (e.g. "A") or a name.</entry>
<entry level="1" type="bullet">

 → means "copy/deposit into", or "replaces", but without destruction of the source</entry>
<entry level="2" type="indent">

 Example: [3] +1 → 3; means "The contents of source register with address "3", plus 1, is put into destination register with address "3" (here source and destination are the same place). If [3]=37, that is, the contents of register 3 is the number "37", then 37+1 = 38 will be put into register 3.</entry>
</list>
</p>
<p>

<indent level="2">

 Example: [3] → 5; means "The contents of source register with address "3" is put into destination register with address "5". If [3]=38, that is, the contents of register 3 is the number 38, then this number will be put into register 5.  
</indent>
:::<it>NOTE: As it stands this second example is ambiguous. Unless otherwise specified our usage hereafter will be "the contents of source register 3 remains in register 3, i.e. [3] → 3 (the alternative would be that the contents of register 3 is </it>removed<it> from register 3 and placed into register 5, thereby leaving register 3 empty.)</it>      </p>
<p>

Definition: A <it>direct</it> instruction is one that specifies <it>in the instruction itself</it> the address of the source or destination register whose contents will be the subject of the instruction.
Definition: An <it>indirect instruction</it> is one that specifies an "pointer register", the contents of which is the address of a "target" register. The target register can be either a source or a destination (the various COPY instructions provide examples of this). A register can address itself indirectly.
<indent level="1">

<it>For want of a standard/convention this article will specify "direct/indirect", abbreviated as "d/i", as a parameter (or parameters) in the instruction:
</it></indent>
::<it>Example: COPY ( </it>'d<b>, A, </b>i<b>, N ) means directly </b>d<b> get the source register's address (register "A") from the instruction itself but indirectly </b>i<b> get the destination address from pointer-register N. Suppose [N]=3, then register 3 is the destination and the instruction will do the following: [A] → 3.</b></p>
<p>

Definition: The contents of <it>source register</it> is used by the instruction. The source register's address can be specified either (i) directly by the instruction, or (ii) indirectly by the pointer register specified by the instruction. </p>
<p>

Definition: The contents of the <it>pointer register</it> is the <it>address</it> of the "target" register.</p>
<p>

Definition: The contents of the <it>pointer register</it> points to the <it>target register</it> -- the "target" may be either a source or a destination register.</p>
<p>

Definition: The <it>destination register</it> is where the instruction deposits its result. The source register's address can be specified either (i) directly by the instruction, or (ii) indirectly by the pointer register specified by the instruction. The source and destination registers can be one</p>

</ss1>
<ss1>
<st>
 Refresher: The counter machine model </st>
<p>

<indent level="1">

<it>Melzak (1961) provides an easy visualization of a counter machine: its "registers" are holes in the ground, and these holes hold pebbles. Per an instruction, into and out of these holes "the computer" (person or machine) adds (INCrements) or removes (DECrements) a single pebble. As needed, additional pebbles come from, and excess pebbles go back into, an infinite supply; if the hole is too small to accommodate the pebbles the "computer" digs the hole bigger.</it>
</indent>

<indent level="1">

<it>Minsky (1961) and Hopcroft-Ullman 1979 (p. 171) offer the visualization of a multi-tape <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 with as many left-ended tapes as "registers". Each tape's length is unbounded to the right, and every square is blank except for the left end, which is marked. The </it>distance<it> of a tape's "head" from its left end, measured in numbers of tape-squares, represents the natural number in "the register". To DECrement the count of squares the tape head moves left; INCrement it moves right. There is no need to print or erase marks on the tape; the only conditional instructions are to check to see if the head is at the left end, by testing a left-end mark with a "Jump-if-marked instruction".</it>  
</indent>

<indent level="1">

<it>The following instruction "mnemonics" e.g. "CLR (r)" are arbitrary; no standard exists.</it>
</indent>

The <link xlink:type="simple" xlink:href="../218/505218.xml">
register machine</link> has, for a memory external to its finite-state machine -- an unbounded (cf: footnote|countable and unbounded) collection of discrete and uniquely-labelled locations with <it>unbounded</it> capacity, called "registers". These registers hold only natural numbers (zero and the positive integers). Per a list of sequential instructions in the finite state machine's TABLE, a few (e.g. 2) types of primitive operations operate on the contents of these "registers". Finally, a <it>conditional-expression</it> in the form of an <it>IF-THEN-ELSE</it> is available to test the contents of one or two registers and "branch/jump" the finite state machine out of the default instruction-sequence.  </p>
<p>

<b>Base model 1</b>: The model closest to Minsky's (1961) visualization and to Lambek (1961):
<list>
<entry level="1" type="bullet">

{ INCrement contents of register r, DECrement contents of register r, <it>IF</it> contents of register r is Zero <it>THEN</it> Jump to instruction Iz <it>ELSE</it> continue to next instruction }:</entry>
</list>
</p>
<p>

<table class="wikitable">
<row style="font-size:9pt;font-weight:bold" align="center" valign="bottom">
<col width="63.6" Height="12">
Instruction</col>
<col width="67.8">
Mnemonic</col>
<col width="130.2">
Action on register(s) "r"</col>
<col width="240.6">
Action on finite state machine's Instruction Register, IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
INCrement</col>
<col valign="bottom">
INC ( r )</col>
<col align="center" valign="bottom">
 [r]+1 → r</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
DECrement</col>
<col valign="bottom">
DEC ( r )</col>
<col align="center" valign="bottom">
 [r]-1 → r</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Jump if Zero</col>
<col valign="bottom">
JZ ( r, z )</col>
<col align="center" valign="bottom">
none</col>
<col align="center" valign="bottom">
 IF [r1] = 0 THEN z → IR  ELSE [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Halt</col>
<col valign="bottom">
H</col>
<col align="center" valign="bottom">
none</col>
<col align="center" valign="bottom">
 [IR]→ IR</col>
</row>
</table>
</p>
<p>

<b>Base model 2</b>: The "successor" model (named after the successor function of the <process wordnetid="105701363" confidence="0.8">
<maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/25005.xml">
Peano axioms</link></higher_cognitive_process>
</theory>
</explanation>
</auditory_communication>
</thinking>
</saying>
</speech>
</maxim>
</process>
): 
<list>
<entry level="1" type="bullet">

{ INCrement the contents of register r, CLeaR the contents of register r, <it>IF</it> contents of register rj Equals the contents of register rk <it>THEN</it> Jump to instruction Iz <it>ELSE</it> goto to next instruction }</entry>
</list>
</p>
<p>

<table class="wikitable">
<row style="font-size:9pt;font-weight:bold" align="center" valign="bottom">
<col width="63.6" Height="12">
Instruction</col>
<col width="67.8">
Mnemonic</col>
<col width="130.2">
Action on register(s) "r"</col>
<col width="240.6">
Action on finite state machine's Instruction Register, IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
CLeaR</col>
<col valign="bottom">
CLR ( r )</col>
<col align="center" valign="bottom">
0 → r</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
INCrement</col>
<col valign="bottom">
INC ( r )</col>
<col align="center" valign="bottom">
 [r]+1 → r</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Jump if Equal</col>
<col valign="bottom">
JE (r1, r2, z)</col>
<col align="center" valign="bottom">
none</col>
<col align="center" valign="bottom">
 IF [r1] = [r2] THEN z → IR  ELSE [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
Halt</col>
<col valign="bottom">
H</col>
<col align="center" valign="bottom">
none</col>
<col align="center" valign="bottom">
 [IR]→ IR</col>
</row>
</table>
</p>
<p>

<b>Base model 3</b>: Used by Elgot-Robinson (1964) in their investigation of bounded and unbounded RASPs -- the "successor" model with COPY in the place of CLEAR: 
<list>
<entry level="1" type="bullet">

{ INCrement the contents of register r, COPY the contents of register rj to register rk, <it>IF</it> contents of register rj Equals the contents of register rk <it>then</it> Jump to instruction Iz <it>ELSE</it> goto to next instruction }</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Creating "convenience instructions" from the base sets</st>
<p>

The three base sets 1, 2, or 3 above are equivalent in the sense that one can create the instructions of one set using the instructions of another set (an interesting exercise: a hint from Minsky (1967) -- declare a reserved register e.g. call it "0" (or Z for "zero" or E for "erase") to contain the number 0). The choice of model will depend on which an author finds easiest to use in a demonstration, or a proof, etc.</p>
<p>

Moreover, from base sets 1, 2, or 3 we can create <it>any</it> of the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s ( cf Minsky (1967), Boolos-Burgess-Jeffrey (2002) ). (How to cast the net wider to capture the <it>total</it> and <it>partial</it> <link xlink:type="simple" xlink:href="../469/26469.xml">
mu recursive function</link>s will be discussed in context of indirect addressing). However, building the primitive recursive functions is difficult because the instruction sets are so ... primitive (tiny). One solution is to expand a particular set with "convenience instructions" from another set:    
<indent level="1">

<it>These will not be subroutines in the conventional sense but rather </it>blocks<it> of instructions created from the base set and given a mnemonic. In a formal sense, to use these blocks we need to either (i) "expand" them into their base-instruction equivalents -- they will require the use of temporary or "auxiliary" registers so the model must take this into account, or (ii) design our machines/models with the instructions 'built in'.</it>
</indent>
:Example: Base set 1. To create CLR (r) use the block of instructions to count down register r to zero. Observe the use of the hint mentioned above:
<list>
<entry level="2" type="bullet">

 CLR (r) =equiv</entry>
<entry level="2" type="bullet">

 <it>loop</it>: JZ (r, <it>exit</it>)</entry>
<entry level="3" type="bullet">

 DEC (r)</entry>
<entry level="3" type="bullet">

 JZ (0, <it>loop</it>)</entry>
<entry level="2" type="bullet">

 <it>exit</it>: etc.    </entry>
</list>
</p>
<p>

Again, all of this is for convenience only; none of this increases the model's intrinsic power.</p>

<p>

For example: the most expanded set would include each unique instruction from the three sets, plus unconditional jump J (z) i.e.:
<list>
<entry level="1" type="bullet">

 { CLR (r), DEC (r), INC (r), CPY ( rs, rd ), JZ (r, z), JE ( rj, rk, z ), J(z) }</entry>
</list>
</p>
<p>

Most authors pick one or the other of the conditional jumps, e.g. Shepherdson-Sturgis (1963) use the above set minus JE (to be perfectly accurate they use JNZ -- Jump if <it>Not</it> Zero in place of JZ; yet another possible convenience instruction).  </p>


</ss1>
</sec>
<sec>
<st>
 The "indirect" operation </st>

<ss1>
<st>
 Example of indirect addressing </st>
<p>
 
In our daily lives the notion of an "indirect operation" is not unusual.
<indent level="1">

Example: A treasure hunt -- 
</indent>
:At location "Tom_&amp;_Becky's_cave_in_pirate_chest" will be where we can find a map directing us to "the treasure":
<indent level="2">

(1) We go to location "Tom_&amp;_Becky's_cave..." and dig around until we find a wooden box 
</indent>
::(2) Inside the box is a map to the location of the treasure: "under_Thatcher's_front_porch"
<indent level="2">

(3) We go to location "under_Thatcher's_front_porch", jackhammer away the concrete, and discover "the treasure": a sack of rusty door-knobs. 
</indent>

Indirection specifies a location identified as the pirate chest in "Tom_&amp;_Becky's_cave..." that acts as a <it>pointer</it> to any other location (including itself): its contents (the treasure map) provides the "address" of the <it>target</it> location 
"under_Thatcher's_front_porch" where the real action is occur. </p>


</ss1>
<ss1>
<st>
 Why the need for an indirect operation: Two major problems with the counter machine model</st>
<p>
  
In the following one must remember that these models are abstract models with two fundamental differences from anything physically real: unbounded numbers of registers each with unbounded capacities. The problem appears most dramatically when one tries to use a counter machine model to build a RASP ( <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 ) that is <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> and thus compute any partial <link xlink:type="simple" xlink:href="../469/26469.xml">
mu recursive function</link>:</p>
<p>

<list>
<entry level="1" type="bullet">

<it>Melzak (1961) added indirection to his "hole-and-pebble" model so that his model could modify itself with a "computed goto" and provides two examples of its use ("Decimal representation in the scale of d" and "Sorting by magnitude", whether these are used in his proof that the model is Turing equivalent is unclear since "the program iteself is left to the reader as an exercise" (p. 292)). Minsky (1961, 1967) was able to demonstrate that, with suitable (but difficult-to-use) <link>
Gödel number</link> encoding, the register model did not need indirection to be Turing equivalent; but it did need at least one unbounded register. As noted below, Minsky (1967) hints at the problem for a RASP but doesn't offer a solution. Elgot and Robinson (1964) proved that their RASP model P0 -- it has no indirection capability -- cannot compute all "recursive sequential functions" (ones that have parameters of arbitrary length) if it does not have the capability of modifying its own instructions, but it can via Gödel numbers if it does (p. 395-397; in particular figure 2 and footnote p. 395). On the other hand their RASP model P'0 equipped with an "index register" (indirect addressing) can compute all the "partial recursive sequential functions" ( the mu recursive functions ) ( p. 397-398).</it> </entry>
<entry level="1" type="indent">

<it>Cook and Reckhow (1973) say it most succinctly: </it></entry>
<entry level="2" type="indent">

<it>The indirect instructions are necessary in order for a fixed progam to access an unbounded number of registers as the inputs vary." (p. 73)</it> </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Unbounded <it>capacities</it></b><b> of registers versus bounded capacities of state-machine instructions</b>: The so-called <it>finite</it> state part of the machine is supposed to be -- by the normal definition of algorithm -- <it>very</it> finite both in the number of "states" (instructions) and the instructions' sizes (their capacity to hold symbols/signs). So how does a state machine move an arbitrarily-large constant directly into a register, e.g. MOVE (k, r) (Move constant k to register r)? If huge constants are necessary they must either start out in the registers themselves or be created by the state machine using a finite number of instructions e.g. multiply- and add- subroutines using INC and DEC (but not a quasi-infinite number of these!).</entry>
<entry level="2" type="indent">

<it>Sometimes the constant k will be created by use of CLR ( r ) followed by INC ( r ) repeated k times -- e.g. to put the constant k=3 into register r, i.e. 3 → r, so at the end of the instruction [r]=3: CLR (r), INC (r), INC (r), INC (r). This trick is mentioned by Kleene (1952) p. 223. The problem arises when the number to be created exhausts the number of instructions available to the </it>finite<it> state machine; there is always a bigger constant than the number of instructions available to the </it>finite<it> state machine.''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Unbounded <it>numbers</it></b><b> of registers versus bounded state-machine instructions</b>: This is more severe than the first problem. In particular, this problem arises when we attempt to build a so-called Random Access Stored Program machine (RASP), a "Universal Machine" ( see more at <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../435/71435.xml">
Universal Turing machine</link></machine>
</causal_agent>
</worker>
</device>
</assistant>
</instrumentality>
</artifact>
</model>
</person>
</physical_entity>
 ) that uses its finite state machine to interpret a "program of instructions" located in its registers -- i.e. we are building what is nowadays called a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link> with the <link xlink:type="simple" xlink:href="../091/478091.xml">
von Neumann architecture</link>.''</entry>
</list>
</p>
<p>

<indent level="1">

Observe that the counter machine's finite state machine must call out a register <it>explicitly</it> (directly) by its name/number: INC (65,356) calls out register number "65,365" <it>explicitly</it>. If the number of registers exceeds the capability of the <it>finite</it> state machine to address them, then registers outside the bounds will be unreachable. For example, if the finite state machine can only reach 65,536 = 216 registers then how can it reach the 65,537th? 
</indent>

So how <it>do</it> we address a register beyond the bounds of the finite state machine? One approach would be to modify the <it>program</it>-instructions (the ones stored in the registers) so that they contain more than one command. But this too can be exhausted unless an instruction is of (potentially) unbounded size. So why not use just one "über-instruction" -- one really really big number -- that contains <it>all</it> the program instructions encoded into it! This is how Minsky solves the problem, but the <link>
Gödel number</link>ing he uses represents a great inconvenience to the model, and the result is nothing at all like our intuitive notion of a "stored program computer". </p>
<p>

Elgot and Robinson (1964) come to a similar conclusion with respect to a RASP that is "finitely determined". Indeed it can access an unbounded number of registers (e.g. to fetch instructions from them) but only if the RASP allows "self modification" of its <it>program</it> instructions, and has encoded its "data" in a Gödel number (Fig. 2 p. 396).</p>
<p>

In the context of a more computer-like model using his RPT (repeat) instruction Minsky (1967) tantalizes us with a solution to the problem (cf p. 214, p. 259) but offers no firm resolution. He asserts:
<indent level="1">

"In general a RPT operation could not be an instruction in the finite-state part of the machine ... this might exhaust any particular amount of storage allowed in the finite part of the computer [sic, his name for his RAM models]. RPT operations require infinite registers of their own." (p. 214).
</indent>

He offers us a <it>bounded</it> RPT that together with CLR (r) and INC (r) can compute any <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>, and he offers the unbounded RPT quoted above that as playing the role of μ operator; it together with CLR (r) and INC (r) can compute the <link xlink:type="simple" xlink:href="../469/26469.xml">
mu recursive function</link>s. But he does not discuss "indirection" or the RAM model per se.</p>
<p>

From the references in Hartmanis (1971) it appears that Cook (in his lecture notes while at UC Berkeley, 1970) has firmed up the notion of indirect addressing. This becomes clearer in the paper of Cook and Reckhow (1973) -- Cook is Reckhow's Master's thesis advisor. Hartmanis' model -- quite similar to Melzak's (1961) model -- uses two and three-register adds and subtracts and two parameter copies; Cook and Reckhow's model reduce the number of parameters (registers called out in the program instructions) to one call-out by use of an accumulator "AC". </p>
<p>

<b>The solution in a nutshell:</b> Design our machine/model with unbounded <b>indirection</b> -- provide an <it>unbounded</it> "address" register that can potentially name (call out) any register no matter how many there are. For this to work, in general, the <it>unbounded</it> register requires an ability to be cleared and then incremented (and, possibly, decremented) by a potentially infinite loop. In this sense the solution represents the unbounded <link>
μ operator</link> that can, if necessary, hunt ad infinitim along the unbounded string of registers until it finds what it is looking for. The pointer register is exactly like any other register with one exception: under the circumstances called "indirect addressing" it provides <it>its</it> contents, rather than the address-operand in the state machine's TABLE, to be the address of the target register (including possibly itself!)</p>

</ss1>
<ss1>
<st>
 Bounded indirection and the primitive recursive functions </st>
<p>

If we eschew the Minsky approach of one monster number in one register, and specify that our machine model will be "like a computer" we have to confront this problem of indirection if we are to compute the <link xlink:type="simple" xlink:href="../264/5987264.xml">
recursive function</link>s (also called the <link>
μ-recursive function</link>s ) -- both total and partial varieties. </p>
<p>

Our simpler counter machine model can do a "bounded" form of indirection -- and thereby compute the sub-class of <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s -- by using a primitive recursive "operator" called "definition by cases" (defined in Kleene (1952) p. 229 and Boolos-Burgess-Jeffrey p. 74). Such a "bounded indirection" is a laborious, tedious affair. "Definition by cases" requires the machine to determine/distinguish the contents of the pointer register by attempting, time after time until success, to match this contents against a number/name that the case operator <it>explicitly</it> declares. Thus the definition by cases starts from e.g. the lower bound address and continues ad nauseam toward the upper bound address attempting to make a match:
<indent level="1">

 <it>Is the number in register N equal to 0? If not then is it equal to 1? 2? 3? ... 65364? If not then we're at the last number 65365 and this had better be the one, else we have a problem!</it>   
</indent>

"Bounded" indirection will not allow us to compute the partial recursive functions -- for those we need <it>unbounded</it> indirection aka the <link>
μ operator</link>. 
<indent level="1">

<it>Suppose we had been able to continue on to number 65367, and in fact that register had what we were looking for. Then we could have completed our calculation successfully! But suppose 65367 didn't have what we needed. How far should we continue to go?</it>
</indent>

To be <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> the counter machine needs to either use the unfortunate single-register Minsky <link>
Gödel number</link> method, or be augmented with an ability to explore the ends of its register string, ad infinitum if necessary. (A failure to find something "out there" defines what it means for an algorithm to fail to terminate; cf Kleene (1952) pp. 316ff <it>Chapter XII Partial Recursive Functions</it>, in particular p. 323-325.) See more on this in the example below.</p>

</ss1>
<ss1>
<st>
 Unbounded indirection and the partial recursive functions </st>
<p>

For <it>unbounded</it> indirection we require a "hardware" change in our machine model. Once we make this change the model is no longer a counter machine, but rather a random access machine. </p>
<p>

Now when e.g. INC  is specified, the finite state machine's instruction will have to specify <it>where</it> the address of the register of interest will come from. This <it>where</it> can be either (i) the state machine's instruction that provides an <it>explicit label</it>, or (ii) the <it>pointer-register</it> whose <it>contents</it> is the address of interest. Whenever an instruction specifies a register address it now will <it>also</it> need to specify an additional parameter "i/d" -- "indirect/direct". In a sense this new "i/d" parameter is a "switch" that flips one way to get the direct address as specified in the instruction or the other way to get the indirect address from the pointer register (which pointer register  -- in some models every register can be a pointer register -- is specified by the instruction). This "mutually exclusive but exhaustive choice" is yet another example of "definition by cases", and the arithmetic equivalent shown in the example below is derived from the definition in Kleene (1952) p. 229. </p>
<p>

<indent level="1">

Example: CPY ( indirectsource, rsource, directdestination, rdestination )
</indent>

<indent level="1">

Assign a code to specify direct addressing as d="0" and indirect addressing as i="1". Then our machine can determine the source address as follows:
</indent>
:: i*[rs] + (1-i)*rs
<indent level="1">

For example, suppose the contents of register 3 is "5" (i.e. [3]=5 ) and the contents of register 4 is "2" (i.e. [4]=2 ):
</indent>

<indent level="2">

 Example: CPY ( 1, 3, 0, 4 ) = CPY ( indirect, reg 3, direct, reg 4 ) 
</indent>
::: 1*[3] + 0*3 = [3] = source-register address 5
<indent level="3">

 0*[4] + 1*4 = 4 = destination-register address 4
</indent>

<indent level="2">

 Example: CPY ( 0, 3, 0, 4 )
</indent>
::: 0*[3] + 1*3 = 3 = source-register address 3
<indent level="3">

 0*[4] + 1*4 = 4 = destination-register address 4
</indent>

<indent level="2">

 Example: CPY ( 0, 3, 1, 4 )
</indent>
::: 0*[3] + 1*4 = 3 = source-register address 3
<indent level="3">

 1*[4] + 0*4 = [4] = destination-register address 2
</indent>

</p>
</ss1>
<ss1>
<st>
 The indirect COPY instruction </st>
<p>
 
Probably the most useful of the added instructions is COPY. Indeed Elgot-Robinson (1964) provide their models P0 and P'0 with the COPY instructions, and Cook-Reckhow (1973) provide their accumulator-based model with only two indirect instructions -- COPY to accumulator indirectly, COPY from accumulator indirectly.</p>
<p>

<b>A plethora of instructions</b>: Because any instruction acting on a single register can be augmented with its indirect "dual" (including conditional and unconditional jumps, cf the Elgot-Robinson model), the inclusion of indirect instructions will double the number of single parameter/register instructions (e.g. INC (d, r), INC (i, r)). Worse, every two parameter/register instruction will have 4 possible varieties, e.g.:</p>
<p>

<indent level="1">

 CPY (d, rs, d, rd ) = COPY directly from source-register directly to destination-register
</indent>
: CPY (i, rsp, d, rd ) = COPY to destination-register indirectly using the source address to be found in the source-pointer register rsp.
<indent level="1">

 CPY (d, rs, i, rdp ) = COPY contents of source-register indirectly into register using destination address to be found in the destination-pointer register rdp.
</indent>
: CPY (i, rsp, i, rdp ) = COPY indirectly the contents of the source register with address to be found in source-pointer register rsp, into the destination register with address to be found in the destination-pointer register rdp)</p>
<p>

In a similar manner every three-register instruction that involves two source registers rs1 rs2 and a destination register rd will result in 8 varieties, for example the addition:
<indent level="2">

 [rs1] + [rs2] → rd
</indent>

will yield:
<list>
<entry level="1" type="bullet">

 ADD ( d, rs1 , d, rs2 , d, rd )</entry>
<entry level="1" type="bullet">

 ADD ( i, rsp1 , d, rs2 , d, rd )</entry>
<entry level="1" type="bullet">

 ADD ( d, rs1 , i, rsp2 , d, rd )</entry>
<entry level="1" type="bullet">

 ADD ( i, rsp1 , i, rsp2 , d, rd )  </entry>
<entry level="1" type="bullet">

 ADD ( d, rs1 , d, rs2 , i, rdp )   </entry>
<entry level="1" type="bullet">

 ADD ( i, rsp1 , d, rs2 , i, rdp )   </entry>
<entry level="1" type="bullet">

 ADD ( d, rs1 , i, rsp2 , i, rdp )   </entry>
<entry level="1" type="bullet">

 ADD ( i, rs1 , i, rs2 , i, rdp )   </entry>
</list>
</p>
<p>

If we designate one register to be the "accumulator" (see below) and place strong restrictions on the various instructions allowed then we can greatly reduce the plethora of direct and indirect operations. However, one must be sure that the resulting reduced instruction-set is sufficient, and we must be aware that the reduction will come at the expense of more instructions per "significant" operation.</p>

</ss1>
</sec>
<sec>
<st>
 The notion of "accumulator A" </st>
<p>

Historical convention dedicates a register to the accumulator,  an "arithmetic organ" that literally accumulates its number during a sequence of arithmetic operations: 
<indent level="1">

"The first part of our arithmetic organ ... should be a parallel storage organ which can receive a number and add it to the one already in it, which is also able to clear its contents and which can store what it contains. We will call such an organ an <it>Accumulator</it>. It is quite conventional in principle in past and present computing machines of the most varied types, e.g. desk multipliers, standard IBM counters, more modern relay machines, the ENIAC" (boldface in original: Goldstine and von Neumann, 1946; p. 98 in Bell and Newell 1971).
</indent>

However, the accumulator comes at the expense of more instructions per arithmetic "operation", in particular with respect to what are called 'read-modify-write' instructions such as "Increment indirectly the contents of the register pointed to by register r2 ". "A" designates the "accumulator" register A:</p>
<p>

<table class="wikitable">
<row style="font-size:9pt" align="center" valign="bottom">
<col style="font-weight:bold" width="49.2" Height="12">
Label</col>
<col style="font-weight:bold" width="70.2">
Instruction</col>
<col width="4.8"></col>
<col style="font-weight:bold" width="24">
A</col>
<col style="font-weight:bold" width="47.4">
r2</col>
<col style="font-weight:bold" width="64.2">
r378,426</col>
<col style="font-weight:bold" width="267">
Description</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="12"></col>


<col>
. . .</col>
<col>
378,426</col>
<col>
17</col>

</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col style="font-style:Italic" Height="12">
INCi ( r2 ):</col>
<col>
CPY ( i, r2, d, A )</col>

<col style="font-weight:bold">
17</col>
<col>
378,426</col>
<col>
17</col>
<col>
Contents of r2 points to r378,426 with contents "17": copy this to A</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="12"></col>
<col>
INC ( A )</col>

<col style="font-weight:bold">
18</col>
<col>
378,426</col>
<col>
17</col>
<col>
Incement contents of A</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="12"></col>
<col>
CPY ( d, A, i, r2 )</col>

<col>
18</col>
<col>
378,426</col>
<col style="font-weight:bold">
18</col>
<col>
Contents of r2 points to r378,426: copy contents of A into r378,426</col>
</row>
</table>
</p>
<p>

If we stick with a specific name for the accumulator, e.g. "A", we can imply the accumulator in the instructions, for example, 
<indent level="1">

 INC ( A ) = INCA
</indent>
However, when we write the CPY instructions without the accumulator called out the instructions are ambiguous or they must have empty parameters:
<indent level="1">

 CPY ( d, r2, d, A ) = CPY (d, r2, , )
</indent>
: CPY ( d, A, d, r2 ) = CPY ( , , d, r2)</p>
<p>

Historically what has happened is these two CPY instructions have received distinctive names; however, no convention exists. Tradition (e.g. <link xlink:type="simple" xlink:href="../211/17211.xml">
Knuth</link>'s (1973) imaginary <link xlink:type="simple" xlink:href="../236/173236.xml">
MIX</link> computer) uses two names called LOAD and STORE. Here we are adding the "i/d" parameter:
<indent level="1">

 LDA ( d/i, rs ) =def  CPY ( d/i, rs, d, A ) 
</indent>
: STA ( d/i, rd ) =def  CPY ( d, A, d/i, rd ) </p>
<p>

The typical accumulator-based model will have all its two-variable arithmetic and constant operations (e.g. ADD (A, r), SUB (A, r) ) use (i) the accumulator's contents, together with (ii) a specified register's contents.  The one-variable operations (e.g. INC (A), DEC (A) and CLR (A) ) require only the accumulator. Both instruction-types deposit the result (e.g. sum, difference, product, quotient or remainder) in the accumulator.
<indent level="1">

 Example: INCA = [A] +1 → A
</indent>
: Example: ADDA (rs) = [A] + [rs] → A
<indent level="1">

 Example: MULA (rs) = [A] * [rs] → A
</indent>

If we so choose, we can abbreviate the mnemonics because at least one source-register and the destination register is always the accumulator A. Thus we have :
<indent level="1">

{ LDA (i/d, rs), STA (i/d, rd), CLRA, INCA, DECA, ADDA (rs), SUBA (rs), MULA (rs), DIVA (rs), etc.)
</indent>

</p>
</sec>
<sec>
<st>
 The notion of indirect address register "N" </st>
<p>

If our model has an <it>unbounded accumulator</it> can we <it>bound</it> all the other registers? Not until we provide for at least one unbounded register from which we derive our indirect addresses. </p>
<p>

The minimimalist approach is to use the accumulator itself (Schönhage does this). </p>
<p>

Another approach (Schönhage does this too) is to declare a specific register the "indirect address register" and confine indirection relative to this register (Schonhage's RAM0 model uses both A and N registers for indirect as well as direct instructions). Again our new register has no conventional name -- perhaps "N" from "iNdex", or "iNdirect" or "address Number".</p>
<p>

For maximum flexibility, as we have done for the accumulator A --  we will consider N just another register subject to increment, decrement, clear, test, direct copy, etc. Again we can shrink the instruction to a single-parameter that provides for direction and indirection, for example.
<indent level="1">

 LDAN (i/d) = CPY (i/d, N, d, A); LoaD Accumulator via iNdirection register 
</indent>
: STAN (i/d) = CPY (d, A, i/d, N). STore Accumlator via iNdirection register</p>
<p>

Why is this such an interesting approach? At least two reasons:</p>
<p>

<b>(1) An instruction set with no parameters:</b></p>
<p>

Schönhage does this to produce his RAM0 instruction set. See section below. </p>
<p>

<b>(2) Reduce a RAM to a Post-Turing machine:</b></p>
<p>

Posing as minimalists, we reduce all the registers excepting the accumulator A and indirection register N e.g. <b>r</b> = { r0, r1, r2, ... } to an unbounded string of (very-) bounded-capacity pigeon-holes. These will do nothing but hold (very-) bounded numbers e.g. a lone bit with value { 0, 1 }. Likewise we shrink the accumulator to a single bit. We restrict any arithmetic to the registers { A, N }, use indirect operations to pull the contents of registers into the accumulator and write 0 or 1 from the accumulator to a register:  
<indent level="1">

{ LDA (i, N), STA (i, N), CLR (A/N), INC (A/N), DEC(N), JZ (A/N, Iz), JZ (Iz), H }
</indent>

We push further and eliminate A altogether by the use of two "constant" registers called "ERASE" and "PRINT": [ERASE]=0, [PRINT]=1. 
<indent level="1">

{ CPY (d, ERASE, i, N), CPY (d, PRINT, i, N), CLR (N), INC (N), DEC (N), JZ (i, N, Iz), JZ (Iz), H }
</indent>

Rename the COPY instructions and call INC (N) = RIGHT, DEC (N) = LEFT and we have the same instructions as the Post-Turing machine, plus an extra CLRN :
<indent level="1">

{ ERASE, PRINT, CLRN, RIGHT, LEFT, JZ (i, N, Iz), JZ (Iz), H }
</indent>
</p>

</sec>
<sec>
<st>
 Turing equivalence of the RAM with indirection </st>
<p>

In the section above we informally showed that a RAM with an unbounded indirection capability produces a <link xlink:type="simple" xlink:href="../147/3688147.xml">
Post-Turing machine</link>. The Post-Turing machine is Turing equivalent, so we have shown that the RAM with indirection is Turing equivalent. </p>
<p>

We give here a slightly more formal demonstration. Begin by designing our model with three reserved registers "E", "P", and "N", plus an unbounded set of registers 1, 2, ..., n to the right. The registers 1, 2, ..., n will be considered "the squares of the tape". Register "N" points to "the scanned square" that "the head" is currently observing. The "head" can be thought of as being in the conditional jump  -- observe that it uses indirect addressing ( cf Elgot-Robinson p. 398). As we decrement or increment "N" the (apparent) head will "move left" or "right" along the squares. We will move the contents of "E"=0 or "P"=1 to the "scanned square" as pointed to by N, using the indirect CPY. </p>
<p>

The fact that our tape is left-ended presents us with a minor problem: Whenever LEFT occurs our instructions will have to test to determine whether or not the contents of "N" is zero; if so we should leave its count at "0" (this is our choice as designers -- for example we might have the machine/model "trigger an event" of our choosing). </p>
<p>

<indent level="1">

Instruction set 1 (augmented): { INC (N), DEC (N), CLR (N), CPY (d, rs,i, N), JZ ( i, r, z ), HALT }
</indent>

The following table both defines the Post-Turing instructions in terms of their RAM equivalent instructions and gives an example of their functioning. The (apparent)location of the head along the tape of registers r0-r5 . . . is shown shaded:
<table class="wikitable">
<row style="font-size:9pt" align="center" valign="bottom">
<col style="font-weight:bold" width="51.6" Height="12">
Mnemonic</col>
<col style="font-weight:bold" width="60">
label:</col>
<col width="81"></col>
<col width="4.8"></col>
<col style="font-weight:bold" width="16.2">
E</col>
<col style="font-weight:bold" width="16.2">
P</col>
<col style="font-weight:bold" width="16.2">
N</col>
<col style="font-weight:bold" width="4.8"></col>
<col style="font-weight:bold" width="14.4">
r0</col>
<col style="font-weight:bold" width="14.4">
r1</col>
<col style="font-weight:bold" width="14.4">
r2</col>
<col style="font-weight:bold" width="14.4">
r3</col>
<col style="font-weight:bold" width="14.4">
r4</col>
<col style="font-weight:bold" width="14.4">
r5</col>
<col style="font-weight:bold" width="22.8">
etc</col>
<col style="font-weight:bold" width="84">
Action on registers</col>
<col style="font-weight:bold" width="229.2">
Action on finite state machine Instruction Register IR</col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="3.6"></col>
















</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="9.6"></col>
<col style="font-style:Italic">
start:</col>


<col>
0</col>
<col>
1</col>
<col>
3</col>




<col style="background-color:#C0C0C0">
1</col>
<col>
0</col>




</row>
<row style="font-size:9pt">
<col align="center" Height="3.6" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom">
R</col>
<col style="font-style:Italic" align="center" valign="bottom">
right:</col>
<col valign="bottom">
INC ( N )</col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom">
0</col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="font-weight:bold" align="center" valign="bottom">
4</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="background-color:#C0C0C0" align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
 [N]+1 → N</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="3.6" valign="bottom"></col>
<col style="font-style:Italic" align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom">
P</col>
<col style="font-style:Italic" align="center" valign="bottom">
print:</col>
<col valign="bottom">
CPY ( d, P , i, N )</col>
<col align="center" valign="bottom"></col>
<col style="font-weight:bold;color:#969696" align="center" valign="bottom">
0</col>
<col style="font-weight:bold" align="center" valign="bottom">
1</col>
<col style="color:#969696" align="center" valign="bottom">
4</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="background-color:#C0C0C0;font-weight:bold" align="center" valign="bottom">
1</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
 [P]=1 → [N]=r4</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="3" valign="bottom"></col>
<col style="font-style:Italic" align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom">
E</col>
<col style="font-style:Italic" align="center" valign="bottom">
erase:</col>
<col valign="bottom">
CPY ( d, E , i, N )</col>
<col align="center" valign="bottom"></col>
<col style="font-weight:bold" align="center" valign="bottom">
0</col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="font-weight:bold" align="center" valign="bottom">
4</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="background-color:#C0C0C0;font-weight:bold" align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
 [E]=0 → [N]=r4</col>
<col align="center" valign="bottom">
 [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="3" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom">
L</col>
<col style="font-style:Italic" align="center" valign="bottom">
left:</col>
<col valign="bottom">
JZ ( i, N, end )</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
0</col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="font-weight:bold" align="center" valign="bottom">
4</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="background-color:#C0C0C0" align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
none</col>
<col align="center" valign="bottom">
 IF <link xlink:type="simple" xlink:href="../290/21290.xml">
N</link> =r4] =0 THEN "end" → IR else [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom"></col>
<col style="font-style:Italic" align="center" valign="bottom"></col>
<col valign="bottom">
DEC ( N )</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
0</col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="font-weight:bold" align="center" valign="bottom">
3</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="background-color:#C0C0C0" align="center" valign="bottom">
1</col>
<col style="color:#969696" align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
 [N]-1 → N</col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="3" valign="bottom"></col>
<col style="font-style:Italic" align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom">
J0 ( halt )</col>
<col style="font-style:Italic" align="center" valign="bottom">
jump_if_blank:</col>
<col valign="bottom">
JZ ( i, N, end )</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
0</col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="font-weight:bold" align="center" valign="bottom">
3</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="background-color:#C0C0C0" align="center" valign="bottom">
1</col>
<col style="color:#969696" align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
none</col>
<col align="center" valign="bottom">
 IF <link xlink:type="simple" xlink:href="../290/21290.xml">
N</link> =r3] =0 THEN "end" → IR else [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="3" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom">
J1 ( halt )</col>
<col style="font-style:Italic" align="center" valign="bottom">
jump_if_mark:</col>
<col valign="bottom">
JZ ( i, N, halt )</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
0</col>
<col style="color:#969696" align="center" valign="bottom">
1</col>
<col style="font-weight:bold" align="center" valign="bottom">
3</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="background-color:#C0C0C0" align="center" valign="bottom">
1</col>
<col style="color:#969696" align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
 <link xlink:type="simple" xlink:href="../290/21290.xml">
N</link> =r3]→ A</col>
<col align="center" valign="bottom">
 IF <link xlink:type="simple" xlink:href="../290/21290.xml">
N</link> =r3] =0 THEN "end" → IR else [IR]+1 → IR</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom"></col>
<col style="font-style:Italic" align="center" valign="bottom">
end</col>
<col valign="bottom">
. . . etc</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
0</col>
<col align="center" valign="bottom">
1</col>
<col align="center" valign="bottom">
3</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="background-color:#C0C0C0" align="center" valign="bottom">
1</col>
<col align="center" valign="bottom">
0</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="3" valign="bottom"></col>
<col style="font-style:Italic" align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col style="color:#969696" align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt" align="center" valign="bottom">
<col Height="9.6"></col>
<col style="font-style:Italic">
halt:</col>
<col>
H</col>

<col>
0</col>
<col style="color:#969696">
1</col>
<col style="color:#969696">
3</col>




<col style="background-color:#C0C0C0">
1</col>
<col style="color:#969696">
0</col>


<col>
none</col>
<col>
 [IR]+1 → IR</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Example: Bounded indirection yields a machine that is not Turing equivalent </st>
<p>

Throughout this demonstration we have to keep in mind that the instructions in the finite state machine's TABLE is <it>bounded</it>, i.e. <it>finite</it>:
<indent level="1">

"Besides a merely being a <it>finite set of rules</it> which gives a seqeunce of operations for solving a specific type of problem, an algorithm has five important features [Finiteness, Definiteness, Input, Output, Effectiveness]" (italics added, Knuth p. 4-7).
</indent>

<indent level="1">

<it>The difficulty arises because the registers have explicit "names" (numbers) and our machine must call each out by name in order to "access" it.</it> 
</indent>

We will build the indirect CPY ( i, q, d, φ ) with the CASE operator. The address of the target register will be specified by the contents of register "q"; once the CASE operator has determined what this number is, CPY will directly deposit the contents of the register with that number into register "φ". We will need an additional register that we will call "y" -- it serves as an up-counter. </p>
<p>

<indent level="1">

<it>So the following is actually a constructive demonstration or proof that we can indeed simulate the indirect CPY ( i, q, d, φ ) without a "hardware" design change to our counter machine/model. However, note that because this indirect CPY is "bounded" by the size/extent of the finite state machine, a RASP using this indirect CPY can only calculate the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive functions</link>, not the full suite of <link>
mu recursive functions</link>.</it>  
</indent>

The CASE "operator" is described in Kleene (1952) (p. 229) and in Boolos-Burgess-Jeffrey (2002) (p. 74); the latter authors emphasize its utility. The following definition is per Kleene but modified to reflect the familiar "IF-THEN-ELSE" construction. </p>
<p>

The CASE operator "returns" a natural number into φ depending on which "case" is satisfied, starting with "case_0" and going successively through "case_last"; if no case is satisfied then the number called "default" (aka "woops") is returned into φ (here <b>x</b> designates some selection of parameters, e.g. register q and the string r0, ... rlast )): </p>
<p>

<it>Definition by cases</it> φ (<b>x</b>, y):
<list>
<entry level="2" type="bullet">

 case_0: IF Q0(<b>x</b>, y) is true THEN φ0(<b>x</b>, y) ELSE </entry>
<entry level="2" type="bullet">

 case_1: IF Q1(<b>x</b>, y) is true THEN φ1(<b>x</b>, y) ELSE</entry>
<entry level="2" type="bullet">

 cases_2 through case_next_to_last: etc. . . . . . . . . ELSE</entry>
<entry level="2" type="bullet">

 case_last: IF Qlast(<b>x</b>, y) is true THEN φlast(<b>x</b>, y) ELSE</entry>
<entry level="2" type="bullet">

 default: do φdefault(<b>x</b>, y)</entry>
</list>
</p>
<p>

Kleene require that the "predicates" Qn that doing the testing are all mutually-exclusive -- "predicates" are functions that produce only { true, false } for output; Boolos-Burgess-Jeffrey add the requirement that the cases are "exhaustive". </p>
<p>

We begin with a number in register q that represents the address of the target register. But what is this number? The "predicates" will test it to find out, one trial after another: JE (q, y, z) followed by INC (y). Once the number is identified explicitly, the CASE operator directly/explicitly copies the contents of this register to φ: </p>
<p>

<indent level="1">

<it>Definition by cases</it> CPY (i, q, d, φ) =def φ (q, r0, ..., rlast, y) = 
</indent>
:* case_0: IF CLR (y), [q] - [y]=0  THEN CPY ( r0, φ ), J (exit) ELSE 
<list>
<entry level="2" type="bullet">

 case_1: IF  INC (y), [q] = [y]=1 THEN CPY ( r1, φ ), J (exit) ELSE</entry>
<entry level="2" type="bullet">

 case_2 through case n: IF . . . THEN . . . ELSE</entry>
<entry level="2" type="bullet">

 case_n: IF  INC (y), [q] = [y]=n THEN CPY ( rn, φ ), J (exit) ELSE</entry>
<entry level="2" type="bullet">

 case_n+1 to case_last: IF . . . THEN . . . ELSE</entry>
<entry level="2" type="bullet">

 case_last: IF INC (y), [q] = [y]="last" THEN CPY ( rlast, φ ), J (exit) ELSE</entry>
<entry level="2" type="bullet">

 default: woops</entry>
</list>
</p>
<p>

Case_0 ( the base step of the recursion on y) looks like this:
<list>
<entry level="2" type="bullet">

 <it>case_0</it>:</entry>
<entry level="3" type="bullet">

 CLR ( y ) ; set register y = 0</entry>
<entry level="3" type="bullet">

 JE ( q, y, <it>_φ0</it> )</entry>
<entry level="3" type="bullet">

 J ( <it>case_1</it> )</entry>
<entry level="4" type="bullet">

 <it>_φ0:</it> CPY ( r0, φ )</entry>
<entry level="4" type="bullet">

 J ( <it>exit</it> )</entry>
<entry level="2" type="bullet">

 <it>case_1:</it> etc.</entry>
</list>
</p>
<p>

Case_n (the induction step) looks like this; remember, each instance of "n", "n+1", ..., "last" must be an explicit natural number:
<list>
<entry level="2" type="bullet">

 <it>case_n</it>:</entry>
<entry level="3" type="bullet">

 INC ( y ) </entry>
<entry level="3" type="bullet">

 JE ( q, y, <it>_φn</it> )</entry>
<entry level="3" type="bullet">

 J ( <it>case_n+1</it>)</entry>
<entry level="4" type="bullet">

 <it>_φn:</it> CPY ( rn, φ )</entry>
<entry level="4" type="bullet">

 J ( <it>exit</it> )</entry>
<entry level="2" type="bullet">

<it>case__n+1:</it> etc.</entry>
</list>
</p>
<p>

Case_last stops the induction and bounds the CASE operator (and thereby bounds the "indirect copy" operator): 
<list>
<entry level="2" type="bullet">

 <it>case_last</it>:</entry>
<entry level="3" type="bullet">

 INC ( y )</entry>
<entry level="3" type="bullet">

 JE ( q, y, <it>_φlast</it> )</entry>
<entry level="3" type="bullet">

 J ( <it>woops</it> )</entry>
<entry level="4" type="bullet">

 <it>_φlast</it>: CPY ( rlast, φ )</entry>
<entry level="4" type="bullet">

 J ( <it>exit</it> )</entry>
<entry level="2" type="bullet">

<it>woops:</it> how do we handle an out-of-bounds attempt?</entry>
<entry level="2" type="bullet">

<it>exit:</it> etc.</entry>
</list>
</p>
<p>

If the CASE could continue ad infinitum it would be the <link xlink:type="simple" xlink:href="../197/693197.xml">
mu operator</link>. But it can't --its finite state machine's "state register" has reached its maximum count (e.g. 65365 = 11111111,111111112 ) or its table has run out of instructions; it is a <it>finite</it> machine, after all.</p>

</sec>
<sec>
<st>
 Examples of Models </st>

<ss1>
<st>
 Register-to-register ("read-modify-write") model of Cook and Reckhow (1973) </st>
<p>

The commonly-encountered Cook and Rechkow model is a bit like the ternary-register Malzek model (written with Knuth mnemonics -- the original instructions had no mnemonics excepting TRA, Read, Print).</p>
<p>

<list>
<entry level="2" type="bullet">

 LOAD ( C, rd ) ; C → rd, C is any integer</entry>
<entry level="2" type="indent">

 Example: LOAD ( 0, 5 ) will clear register 5.</entry>
<entry level="2" type="bullet">

 ADD ( rs1, rs2, rd  ) ; [rs1] + [rs2] → rd , the registers can be the same or different;</entry>
<entry level="2" type="indent">

Example: ADD ( A, A, A ) will double the contents of register A.</entry>
<entry level="2" type="bullet">

 SUB ( rs1, rs2, rd ) ; [rs1] - [rs2] → rd, the registers can be the same or different:</entry>
<entry level="2" type="indent">

Example: SUB ( 3, 3, 3 ) will clear register 3. </entry>
<entry level="2" type="bullet">

 COPY ( i, rp, d, rd ) ; <link>
rp]</link> →  rd, Indirectly copy the contents of the source-register pointed to by pointer-register rp into the destination register. </entry>
<entry level="2" type="bullet">

 COPY ( d, rs, i, rp ) ; [rs] → [rp]. Copy the contents of source register rs into the destination-register pointed to by the pointer-register rp.</entry>
<entry level="2" type="bullet">

 JNZ ( r, Iz ) ; Conditional jump if [r] is positive; i.e. IF [r] &amp;gt; 0 THEN jump to instruction z else continue in sequence (Cook and Reckhow call this: "TRAnsfer control to line m if Xj &amp;gt; 0")</entry>
<entry level="2" type="bullet">

 READ ( rd ) ; copy "the input" into destination register rd  </entry>
<entry level="2" type="bullet">

 PRINT ( rs ) ; copy the contents of source register rs to "the output."</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Schönhage's RAM0 and RAM1 (1980) </st>
<p>

Schönhage (1980) describes a very primitive, atomized model chosen for his proof of the equivalence of his SMM <link xlink:type="simple" xlink:href="../616/6144616.xml">
pointer machine</link> model:
<indent level="1">

"In order to avoid any explicit addressing the RAM0 has the accumulator with contents <it>z</it> and an additional address register with current contents <it>n</it> (initially 0)" (p. 494)
</indent>

<b>RAM1 model</b>: Schönhage demonstrates how his construction can be used to form the more common, usable form of "successor"-like RAM (using this article's mnemonics):
<list>
<entry level="3" type="bullet">

 LDA k ; k --&amp;gt; A , k is a constant, an explicit number such as "47"</entry>
<entry level="3" type="bullet">

 LDA ( d, r ) ; [r] → A ; directly load A </entry>
<entry level="3" type="bullet">

 LDA ( i, r ) ; <link>
r]</link> → A ; indirectly load A </entry>
<entry level="3" type="bullet">

 STA ( d, r ) ; [A] → r ; directly store A</entry>
<entry level="3" type="bullet">

 STA ( i, r ) ; [A] → [r] ; indirectly store A</entry>
<entry level="3" type="bullet">

 JEA ( r, z ) ; IF [A] = [r] then Iz else continue</entry>
<entry level="3" type="bullet">

 INCA ; [A] + 1 --&amp;gt; A </entry>
</list>
</p>
<p>

<b>RAM0 model</b>: Schönhage's RAM0 machine has 6 instructions indicated by a single letter (the 6th "C xxx" seems to involve 'skip over next parameter'. Schönhage designated the accumulator with "z", "N" with "n", etc. Rather than Schönage's mnemonics we will use the mnemonics developed above. 
<list>
<entry level="3" type="bullet">

(Z), CLRA:  0 → A</entry>
<entry level="3" type="bullet">

(A), INCA:  [A] +1 → A</entry>
<entry level="3" type="bullet">

(N), CPYAN:  [A] → N</entry>
<entry level="3" type="bullet">

(A), LDAA: <link>
A]</link> → A ; contents of A points to register address; put register's contents into A</entry>
<entry level="3" type="bullet">

(S), STAN: [A] → [N] ; contents of N points to register address; put contents of A into register pointed to by N</entry>
<entry level="3" type="bullet">

(C), JAZ ( z ): [A] = 0 then go to Iz ; ambiguous in his treatment     </entry>
</list>
</p>
<p>

Indirection comes (i) from CPYAN (copy/transfer contents A to N) working with store_A_via_N STAN, and from (ii) the peculiar indirection instruction LDAA ( <link xlink:type="simple" xlink:href="../290/290.xml">
A</link> →  A &amp;gt; ).</p>

</ss1>
</sec>
<sec>
<st>
Footnotes</st>

<ss1>
<st>
 Countable vs unbounded </st>
<p>

The definitional fact that any sort of counter machine without an unbounded register-"address" register must specify a register "r" by name indicates that the model requires "r" to be <it>finite</it>, although it is "unbounded" in the sense that the model implies no upper limit to the number of registers necessary to do its job(s). For example we do not require r  83,617,563,821,029,283,746 nor r  2^1,000,001, etc. </p>
<p>

<indent level="1">

Thus our model can "expand" the number of registers, if necessary to perform a certain computation. However this <it>does</it> mean that whatever number the model expands to must be <it>countable</it> -- it must be indexable with a counting-number: <it>ω is not an option</it>.
</indent>

We can escape this restriction by providing an unbounded register to provide the address of the register that specifies an indirect address.</p>



</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../218/505218.xml">
Register machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 -- generic register-based machines as opposed to Turing-like tape-based machines</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 -- simplest model without indirection</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access stored program machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 - RASP: a RAM on steroids</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../616/6144616.xml">
Pointer machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 -- a restricted type of RAM </entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../675/956675.xml">
PRAM</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 - Parallel Random Access Machine</entry>
<entry level="1" type="bullet">

<link>
real RAM</link>, the infinite precision floating point arithmetics RAM, an abstract <link xlink:type="simple" xlink:href="../278/1773278.xml">
model of computation</link> used in <link xlink:type="simple" xlink:href="../927/176927.xml">
computational geometry</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://savannah.nongnu.org/projects/ramemu/">
Random Access Machine Emulator</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.szkup.com/?pid=msthesis&amp;lang=en">
Random Access Machine Emulator</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

With a few exceptions, these references are the same as those at <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../218/505218.xml">
Register machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
.</p>
<p>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../621/340621.xml">
George Boolos</link></person>
, <link>
John P. Burgess</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../354/4294354.xml">
Richard Jeffrey</link></logician>
</causal_agent>
</person>
</expert>
</physical_entity>
 (2002), <it>Computability and Logic: Fourth Edition</it>, Cambridge University Press, Cambridge, England. The original Boolos-Jeffrey text has been extensively revised by Burgess: more advanced than an introductory textbook. "Abacus machine" model is extensively developed in Chapter 5 <it>Abacus Computability</it>; it is one of three models extensively treated and compared -- the Turing machine (still in Boolos' original 4-tuple form) and recursion the other two.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../641/6479641.xml">
Arthur Burks</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../708/763708.xml">
Herman Goldstine</link></associate>
</creator>
</mathematician>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../942/15942.xml">
John von Neumann</link></scientist>
</person>
 (1946), <it>Preliminary discussion of the logical design of an electronic computing instrument</it>, reprinted pp. 92ff in <expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<link xlink:type="simple" xlink:href="../136/349136.xml">
Gordon Bell</link></originator>
</employee>
</causal_agent>
</worker>
</creator>
</associate>
</engineer>
</colleague>
</specialist>
</pioneer>
</interior_designer>
</person>
</physical_entity>
</peer>
</expert>
 and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../300/287300.xml">
Allen Newell</link></scientist>
</person>
 (1971), <it>Computer Structures: Readings and Examples</it>, mcGraw-Hill Book Company, New York. ISBN 0070043574  .</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../432/39432.xml">
Stephen A. Cook</link></scientist>
</person>
 and Robert A. Reckhow (1972), <it>Time-bounded random access machines</it>, Journal of Computer Systems Science 7 (1973), 354-375.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/953041.xml">
Martin Davis</link></scholar>
</mathematician>
</scientist>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
 (1958), <it>Computability &amp; Unsolvability</it>, McGraw-Hill Book Company, Inc. New York.</entry>
<entry level="1" type="bullet">

 <link>
Calvin Elgot</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<immigrant wordnetid="110199489" confidence="0.8">
<migrant wordnetid="110314952" confidence="0.8">
<traveler wordnetid="109629752" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/46024.xml">
Abraham Robinson</link></mathematician>
</scientist>
</causal_agent>
</traveler>
</migrant>
</immigrant>
</person>
</physical_entity>
 (1964), <it>Random-Access Stored-Program Machines, an Approach to Programming Languages</it>, Journal of the Association for Computing Machinery, Vol. 11, No. 4 (October, 1964), pp. 365-399.</entry>
<entry level="1" type="bullet">

 <link>
J. Hartmanis</link> (1971), "Computational Complexity of Random Access Stored Program Machines," Mathematical Systems Theory 5, 3 (1971) pp. 232-245.</entry>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../443/299443.xml">
John Hopcroft</link></scientist>
</person>
, <peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/1702318.xml">
Jeffrey Ullman</link></scholar>
</causal_agent>
</alumnus>
</laureate>
</associate>
</recipient>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</physical_entity>
</peer>
 (1979). <it>Introduction to Automata Theory, Languages and Computation</it>, 1st ed., Reading Mass: Addison-Wesley. ISBN 0-201-02988-X.  A difficult book centered around the issues of machine-interpretation of "languages", NP-Completeness, etc. </entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link> (1952), <it>Introduction to Metamathematics</it>, North-Holland Publishing Company, Amsterdam, Netherlands. ISBN 0-7204-2103-9.</entry>
<entry level="1" type="bullet">

<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
 (1968), <it>The Art of Computer Programming</it>, Second Edition 1973, Addison-Wesley, Reading, Massachusetts. Cf pages 462-463 where he defines "a new kind of abstract machine or 'automaton' which deals with linked structures."</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../498/1250498.xml">
Joachim Lambek</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 (1961, received 15 June 1961), <it>How to Program an Infinite Abacus</it>, Mathematical Bulletin, vol. 4, no. 3. September 1961 pages 295-302. In his Appendix II, Lambek proposes a "formal definition of 'program'. He references Melzak (1961) and Kleene (1952) <it>Introduction to Metamathematics</it>.</entry>
<entry level="1" type="bullet">

<link>
Z. A. Melzak</link> (1961, received 15 May 1961), <it>An informal Arthmetical Approach to Computability and Computation</it>, Canadian Mathematical Bulletin, vol. 4, no. 3. September 1961 pages 279-293. Melzak offers no references but acknowledges "the benefit of conversations with Drs. R. Hamming, D. McIlroy and V. Vyssots of the Bell telephone Laborators and with Dr. H. Wang of Oxford University."</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
&#32;(1961, received August 15, 1960).&#32;"Recursive Unsolvability of Post's Problem of 'Tag' and Other Topics in Theory of Turing Machines". <it>Annals of Math</it>&#32;<b>74</b>: 437&ndash;455. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.2307%2F1970290">
10.2307/1970290</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin Minsky</link></scientist>
</person>
&#32;(1967). Computation: Finite and Infinite Machines, 1st ed.,&#32;Englewood Cliffs, N. J.:&#32;Prentice-Hall, Inc..</cite>&nbsp; In particular see chapter 11: <it>Models Similar to Digital Computers</it> and chapter 14: <it>Very Simple Bases for Computability</it>. In the former chapter he defines "Program machines" and in the later chapter he discusses "Universal Program machines with Two Registers" and "...with one register", etc.</entry>
<entry level="1" type="bullet">

<link>
John C. Shepherdson</link> and <link>
H. E. Sturgis</link> (1961) received December 1961 <it>Computability of Recursive Functions</it>, Journal of the Association of Computing Machinery (JACM) 10:217-255, 1963. An extremely valuable reference paper. In their Appendix A the authors cite 4 others with reference to "Minimality of Instructions Used in 4.1: Comparison with Similar Systems".</entry>
<entry level="2" type="bullet">

Kaphengst, Heinz, <it>Eine Abstrakte programmgesteuerte Rechenmaschine</it>', Zeitschrift fur mathematische Logik und Grundlagen der Mathematik:<it>5</it> (1959), 366-379. </entry>
<entry level="2" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<inventor wordnetid="110214637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../952/146952.xml">
Ershov, A. P.</link></associate>
</creator>
</research_worker>
</inventor>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 <it>On operator algorithms</it>, (Russian) Dok. Akad. Nauk 122 (1958), 967-970. English translation, Automat. Express 1 (1959), 20-23.</entry>
<entry level="2" type="bullet">

<link>
Péter, Rózsa</link> <it>Graphschemata und rekursive Funktionen</it>, Dialectica 12 (1958), 373.</entry>
<entry level="2" type="bullet">

Hermes, Hans <it>Die Universalität programmgesteuerter Rechenmaschinen. Math.-Phys. Semsterberichte (Göttingen) 4 (1954), 42-53.</it></entry>
<entry level="1" type="bullet">

 <link>
Arnold Schönhage</link> (1980), <it>Storage Modification Machines</it>, Society for Industrial and Applied Mathematics, SIAM J. Comput. Vol. 9, No. 3, August 1980. Wherein Schōnhage shows the equivalence of his SMM with the "successor RAM" (Random Access Machine), etc. resp. <it>Storage Modification Machines</it>, in <it>Theoretical Computer Science</it> (1979), pp. 36-37</entry>
<entry level="1" type="bullet">

<link>
Peter van Emde Boas</link>, <it>Machine Models and Simulations</it> pp.3-66, appearing in:</entry>
<entry level="2" type="indent">

<link>
Jan Van Leeuwen</link>, ed. "Handbbook of Theoretical Computer Science. Volumne A: Algorithms and Complexity<it>, The MIT PRESS/Elsevier, 1990. ISBN 0-444-88071-2 (volume A). QA 76.H279 1990. </it></entry>
<entry level="1" type="indent">

van Emde Boas' treatment of SMMs appears on pp. 32-35. This treatment clarifies Schōnhage 1980 -- it closely follows but expands slightly the Schōnhage treatment. Both references may be needed for effective understanding.</entry>
<entry level="1" type="bullet">

<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../047/1056047.xml">
Hao Wang</link></scientist>
 (1957), <it>A Variant to Turing's Theory of Computing Machines</it>, JACM (Journal of the Association for Computing Machinery) 4; 63-92. Presented at the meeting of the Association, June 23-25, 1954.</entry>
</list>
</p>


</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
