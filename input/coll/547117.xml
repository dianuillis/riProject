<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:16:39[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Dynamic memory allocation</title>
<id>547117</id>
<revision>
<id>236441075</id>
<timestamp>2008-09-05T13:08:31Z</timestamp>
<contributor>
<username>Berks105</username>
<id>864270</id>
</contributor>
</revision>
<categories>
<category>Memory management</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, <b>dynamic memory allocation</b> is the allocation of <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> storage for use in a <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link> during the <link xlink:type="simple" xlink:href="../263/192263.xml">
runtime</link> of that program. It can be seen also as a way of distributing ownership of limited memory resources among many pieces of data and code.  <p>

Dynamically allocated memory exists until it is released either explicitly by the programmer, exiting a <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link>
block</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
, or by the <link xlink:type="simple" xlink:href="../734/6734.xml">
garbage collector</link>. This is in contrast to  <link xlink:type="simple" xlink:href="../391/2783391.xml">
static memory allocation</link>, which has a fixed duration. It is said that an object so allocated has a <it>dynamic lifetime</it>.</p>

<sec>
<st>
 Details </st>
<p>

<list>
<entry level="1" type="bullet">

 The task of fulfilling allocation request</entry>
<entry level="2" type="bullet">

 Finding a block of unused memory of sufficient size</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Problems during fulfilling allocation request</entry>
<entry level="2" type="bullet">

 Internal and external <link xlink:type="simple" xlink:href="../369/3909369.xml">
fragmentation</link>. </entry>
<entry level="3" type="bullet">

 Reduction needs special care, thus making implementation more complex (see <link>
algorithm efficiency</link>).</entry>
<entry level="2" type="bullet">

 Allocator's <link xlink:type="simple" xlink:href="../632/18933632.xml">
metadata</link> can inflate the size of (individually) small allocations; </entry>
<entry level="3" type="bullet">

 <link xlink:type="simple" xlink:href="../057/1136057.xml">
Chunking</link> attempts to reduce this effect.</entry>
</list>
</p>
<p>

Usually, memory is allocated from a large pool of unused memory area called <b>the heap</b> (also called the <b>free store</b>).  Since the precise location of the allocation is not known in advance, the memory is accessed indirectly, usually via a <link xlink:type="simple" xlink:href="../292/229292.xml">
reference</link>. The precise algorithm used to organize the memory area and allocate and deallocate chunks is hidden behind an abstract interface and may use any of the methods described below.</p>

</sec>
<sec>
<st>
 Implementations </st>


<ss1>
<st>
 Fixed-size-blocks allocation </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../313/1815313.xml">
memory pool</link></it>
</indent>

Fixed-size-blocks allocation, also called memory pool allocation, uses a <link xlink:type="simple" xlink:href="../047/2932047.xml">
free list</link> of fixed-size blocks of memory (often all of the same size).  This works well for simple <link xlink:type="simple" xlink:href="../630/46630.xml">
embedded system</link>s.</p>

</ss1>
<ss1>
<st>
 Buddy blocks </st>

<p>

<indent level="1">

<it>For more details on this topic, see <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../180/364180.xml">
Buddy memory allocation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</it>
</indent>
In this system, memory is allocated from a large block in a memory that is a <link xlink:type="simple" xlink:href="../948/376948.xml">
power of two</link> in size. If the block is more than twice as large as desired, it is broken in two. One of the halves is selected, and the process repeats (checking the size again and splitting if needed) until the block is just large enough.</p>
<p>

All the blocks of a particular size are kept in a sorted <link>
linked list</link> or <link xlink:type="simple" xlink:href="../806/30806.xml">
tree</link>. When a block is freed, it is compared to its buddy. If they are both free, they are combined and placed in the next-largest size buddy-block list. (When a block is allocated, the allocator will start with the smallest sufficiently large block avoiding needlessly breaking blocks)</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../082/2098082.xml">
Hazard pointer</link></concept>
</idea>
</entry>
<entry level="1" type="bullet">

 <accomplishment wordnetid="100035189" confidence="0.8">
<abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<feat wordnetid="100036762" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../328/219328.xml">
Heap overflow</link></anomaly>
</feat>
</psychological_feature>
</act>
</physical_condition>
</action>
</state>
</event>
</condition>
</abnormality>
</accomplishment>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../351/1836351.xml">
Hoard memory allocator</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../289/384289.xml">
malloc</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../313/1815313.xml">
Memory pool</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../709/608709.xml">
mmap</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../954/3254954.xml">
obstack</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/3926881.xml">
Slab allocation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../265/1836265.xml">
Stack-based memory allocation</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
. <it>Fundamental Algorithms</it>, Third Edition. Addison-Wesley, 1997. ISBN 0-201-89683-4. Section 2.5: Dynamic Storage Allocation, pp.435&ndash;456.</entry>
<entry level="1" type="bullet">

 Herbert Glarner's visualized <weblink xlink:type="simple" xlink:href="http://herbert.gandraxa.com/herbert/dsa.asp">
Dynamic Storage Allocation</weblink>, describing efficient techniques</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.osdcom.info/content/view/31/39/">
Simple Memory Allocation Algorithms</weblink> on OSDEV Community</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Wilson, P.R.; Johnstone, M.S.; Neely, M.; Boles, D.&#32;(1995).&#32;"<weblink xlink:type="simple" xlink:href="http://books.google.com/books?hl=en&amp;lr=&amp;ie=UTF-8&amp;id=m0yZN2bA3TcC&amp;oi=fnd&amp;pg=PA1&amp;dq=paul+wilson&amp;ots=H28axwHr6U&amp;sig=cCCwN72PZFqLtnjRWhIvpbXbc0c">
Dynamic Storage Allocation: A Survey and Critical Review</weblink>". <it>Memory Management: International Workshop, Iwmm'95, Kinross, Uk, September 27-29, 1995: Proceedings</it>. Retrieved on <link>
2008-01-06</link>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Berger, E.D.; Zorn, B.G.; McKinley, K.S.&#32;(2001).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=381694.378821">
Composing high-performance memory allocators</weblink>". <it>ACM SIGPLAN Notices</it>&#32;<b>36</b>&#32;(5): 114â€“124. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F381694">
10.1145/381694</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">Berger, E.D.;&#32;Zorn, B.G.; McKinley, K.S.&#32;(2002). "<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=582419.582421">
Reconsidering custom memory allocation</weblink>".&#32;<it>Proceedings of the 17th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications</it>: 1-12, ACM Press New York, NY, USA.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://geocities.com/malbrain/arena2_c.html">
Sample bit-mapped arena memory allocator in C</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://rtportal.upv.es/rtmalloc">
TLSF: a constant time allocator for real-time systems</weblink></entry>
<entry level="1" type="bullet">

 [https://users.cs.jmu.edu/bernstdh/web/common/lectures/slides_cpp_dynamic-memory.php Slides for knowing about Dynamic memory allocation]</entry>
</list>
</p>


</sec>
</bdy>
</article>
