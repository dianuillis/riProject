<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:20:19[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Baby-step giant-step</title>
<id>563928</id>
<revision>
<id>232498293</id>
<timestamp>2008-08-17T14:35:48Z</timestamp>
<contributor>
<username>Serprex</username>
<id>3916631</id>
</contributor>
</revision>
<categories>
<category>Number theoretic algorithms</category>
<category>group theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../890/41890.xml">
group theory</link>, a branch of mathematics, the <b>baby-step giant-step</b> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is a series of well-defined steps to compute the <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete logarithm</link>. The discrete log problem is of fundamental importance to the area of <link>
public key cryptography</link>. Many of the most commonly used cryptography systems are based on the assumption that the discrete log is extremely difficult to compute; the more difficult it is, the more security it provides a data transfer. One way to increase the difficulty of the discrete log problem is to base the cryptosystem on a larger group.
<sec>
<st>
Theory</st>
<p>

The algorithm is based on a <link xlink:type="simple" xlink:href="../481/773481.xml">
space-time tradeoff</link>. It is a fairly simple modification of <link>
trial multiplication</link>, the naive method of finding discrete logarithms.</p>
<p>

Given a <link xlink:type="simple" xlink:href="../327/52327.xml">
cyclic group</link> <math>G</math> of order <math>n</math>, a <link xlink:type="simple" xlink:href="../945/99945.xml">
generator</link> <math>\alpha</math> of the group and a group element <math>\beta</math>, the problem is to find an integer <math>x</math> such that
<indent level="1">

 <math>\alpha^x = \beta\,.</math>
</indent>
The baby-step giant-step algorithm is based on rewriting <math>x</math> as <math>x = im + j</math>, with <math>m = \lceil \sqrt{n} \rceil</math> and <math>0 \leq i &amp;lt; m</math> and <math>0 \leq j &amp;lt; m</math>. Therefore, we have:
<indent level="1">

<math>\beta(\alpha^{-m})^i=\alpha^j\,.</math>
</indent>

The algorithm precomputes <math>\alpha^j</math> for several values of <math>j</math>. Then it fixes an <math>m</math> and tries values of <math>i</math> in the left-hand side of the congruence above, in the manner of trial multiplication. It tests to see if the congruence is satisfied for any value of <math>j</math>, using the precomputed values of <math>\alpha^j</math>.</p>

</sec>
<sec>
<st>
The algorithm</st>
<p>

<b>Input</b>: A cyclic group <it>G</it> of order <it>n</it>, having a generator α and an element β.</p>
<p>

<b>Output</b>: A value <it>x</it> satisfying <math>\alpha^{x}=\beta</math>.</p>
<p>

<list>
<entry level="1" type="number">

 <it>m</it> ← Ceiling(√<it>n</it>)</entry>
<entry level="1" type="number">

 For all <it>j</it> where 0 ≤ <it>j</it> &amp;lt; <it>m</it>:</entry>
<entry level="2" type="number">

 Compute α<it>j</it> and store the pair (<it>j</it>, α<it>j</it>) in a table. (See section "In practice")</entry>
<entry level="1" type="number">

 Compute α&amp;minus;<it>m</it>.</entry>
<entry level="1" type="number">

 γ ← β.</entry>
<entry level="1" type="number">

 For <it>i</it> = 0 to (<it>m</it> &amp;minus; 1):</entry>
<entry level="2" type="number">

 Check to see if γ is the second component (α<it>j</it>) of any pair in the table.</entry>
<entry level="2" type="number">

 If so, return <it>im</it> + <it>j</it>.</entry>
<entry level="2" type="number">

 If not, γ ← γ • α&amp;minus;<it>m</it>.</entry>
</list>
</p>

</sec>
<sec>
<st>
In practice</st>
<p>

The best way to speed up the baby-step giant-step algorithm is to use an efficient table lookup scheme. The best in this case is a <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link>. The hashing is done on the second component, and to perform the check in step 1 of the main loop, γ is hashed and the resulting memory address checked. Since hash tables can retrieve and add elements in <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(1) time (constant time), this does not slow down the overall baby-step giant-step algorithm.</p>
<p>

The running time of the algorithm and the space complexity is O(√<it>n</it>).</p>

</sec>
<sec>
<st>
 Notes </st>
<p>

<list>
<entry level="1" type="bullet">

 The baby-step giant-step algorithm is a generic algorithm. It works for every finite cyclic group.</entry>
<entry level="1" type="bullet">

 It is not necessary to know the order of the group <it>G</it> in advance. The algorithm still works if <it>n</it> is merely an upper bound on the group order.</entry>
<entry level="1" type="bullet">

 Usually the baby-step giant-step algorithm is used for groups whose order is prime. If the order of the group is composite then the <link xlink:type="simple" xlink:href="../624/1995624.xml">
Pohlig-Hellman algorithm</link> is more efficient.</entry>
<entry level="1" type="bullet">

 The algorithm requires <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>m</it>) memory. It is possible to use less memory by choosing a smaller <it>m</it> in the first step of the algorithm. Doing so increases the running time, which then is <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n</it>/<it>m</it>). Alternatively one can use <link xlink:type="simple" xlink:href="../817/1630817.xml">
Pollard's rho algorithm for logarithms</link>, which has about the same running time as the baby-step giant-step algorithm, but only a small memory requirement.</entry>
<entry level="1" type="bullet">

 The algorithm was originally developed by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../362/18171362.xml">
Daniel Shanks</link></scientist>
</person>
.</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>


</p>
<p>

<list>
<entry level="1" type="bullet">

H. Cohen, A course in computational algebraic number theory, Springer, 1996.</entry>
<entry level="1" type="bullet">

D. Shanks. Class number, a theory of factorization and genera. In Proc. Symp. Pure Math. 20, pages 415--440. AMS, Providence, R.I., 1971.</entry>
<entry level="1" type="bullet">

A. Stein and E. Teske, Optimized baby step-giant step methods, Journal of the Ramanujan Mathematical Society 20 (2005), no. 1, 1–32.</entry>
<entry level="1" type="bullet">

A. V. Sutherland, Order computations in generic groups, PhD thesis, M.I.T., 2007, http://groups.csail.mit.edu/cis/theses/sutherland-phd.pdf.</entry>
<entry level="1" type="bullet">

D. C. Terr, A modification of Shanks’ baby-step giant-step algorithm, Mathematics of Computation 69 (2000), 767–773.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
