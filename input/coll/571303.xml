<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:21:01[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<information  confidence="0.8" wordnetid="106634376">
<structure  confidence="0.8" wordnetid="104341686">
<artifact  confidence="0.8" wordnetid="100021939">
<area  confidence="0.8" wordnetid="102735688">
<library  confidence="0.8" wordnetid="103660909">
<format  confidence="0.8" wordnetid="106636806">
<room  confidence="0.8" wordnetid="104105893">
<header>
<title>Position-independent code</title>
<id>571303</id>
<revision>
<id>242939272</id>
<timestamp>2008-10-04T11:00:46Z</timestamp>
<contributor>
<username>Tackat</username>
<id>6459957</id>
</contributor>
</revision>
<categories>
<category>Computer libraries</category>
<category>Operating system technology</category>
<category>Computer file formats</category>
</categories>
</header>
<bdy>
<p>

In <link xlink:type="simple" xlink:href="../213/5213.xml">
computing</link>, <b>position-independent code</b> (<b>PIC</b>) or <b>position-independent executable</b> (<b>PIE</b>) is machine instruction code that executes properly regardless of where in <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> it resides. PIC is commonly used for <link>
shared libraries</link>, so that the same library code can be loaded in a location in each program address space where it won't overlap any other uses of memory (for example, other shared libraries). PIC was also used on older computer systems lacking an <link xlink:type="simple" xlink:href="../112/177112.xml">
MMU</link>, so that the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> could keep applications away from each other even within the single <link xlink:type="simple" xlink:href="../144/507144.xml">
address space</link> of an MMU-less system.</p>
<p>

Position-independent code can be copied to any memory location without modification and executed, unlike <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../963/1938963.xml">
relocatable code</link></room>
</library>
</area>
</artifact>
</structure>
, which requires special processing by a <link xlink:type="simple" xlink:href="../566/18566.xml">
link editor</link> or <link xlink:type="simple" xlink:href="../773/483773.xml">
program loader</link> to make it suitable for execution at a given location.
Code must generally be written or <link xlink:type="simple" xlink:href="../739/5739.xml">
compiled</link> in a special fashion in order to be position independent. Instructions that refer to specific memory addresses, such as absolute branches, must be replaced with equivalent <link xlink:type="simple" xlink:href="../944/59944.xml">
program counter</link> relative instructions. The extra indirection may cause PIC code to be less efficient, although modern processors are designed to make this more tolerable.</p>

<sec>
<st>
 History </st>
<p>

In early computers, code was position-dependent: each program was built to be loaded into, and run from, a particular address.  In order to run multiple jobs using separate programs at the same time, an operator had to carefully schedule the jobs so that no two simultaneous jobs would run programs that required the same load addresses.  For example, if both the payroll program and the accounts receivable program were built to run at address 32K, the operator could not run both at the same time.  Sometimes, an operator would keep multiple versions of a program around, each built for a different load address, to expand his options.</p>
<p>

To make things more flexible, position-independent code was invented. Position-independent code could run from any address at which the operator chose to load it.</p>
<p>

The invention of dynamic address translation (the function provided by an <link xlink:type="simple" xlink:href="../112/177112.xml">
MMU</link>) obsoleted position-independent code, because every job could have its own separate address 32K, so the programmer could build all programs to run at address 32K and they could still run all at the same time (each in its own address space).  Because position-independent code is less efficient than position-dependent code, this was a better solution to the problem.</p>
<p>

The next problem to be attacked was the memory waste that happens when the same code is loaded multiple times to be used by multiple simultaneous jobs.  If two jobs run entirely identical programs, dynamic address translation provides a solution by allowing the system simply to map two different jobs' address 32K to the same bytes of real memory, containing the single copy of the program.  </p>
<p>

But more often, the programs are different and merely share a lot of common code.  For example, the payroll program and the accounts receivable program probably both contain an identical sort subroutine.  So designers invented shared modules (a shared library is a form of shared module).  While the main payroll and accounts receivable programs get loaded into separate memory, the shared module gets loaded once and simply mapped into the two address spaces.</p>
<p>

But this introduces a memory allocation problem similar to the one that position-independent code solved above:  If a program can have one shared module, it can have lots of them.  What if a single program, in a single address space, wants to use two shared modules, both built to run at the same address?  The system cannot load both at the same time, so there is no way to load the program.  To work around this, programmers made sure they never built two shared modules to run at the same address if they might both have to be used by the same program.  Sometimes, they made multiple versions of a shared module, each built to run at a different address.</p>
<p>

This is obviously not a desirable situation.  It's a lot of manual work and wastes address space.  Position-independent code comes to the rescue again, because if a shared module can run from any address, then the program loader can simply load it into any free address.  The sort subroutine might run at address 32K in a payroll job, but 48K in a simultaneous accounts receivable job.  Both addresses refer to the same real memory; there is only one copy of the sort subroutine in real memory.</p>
<p>

Position-independent code has been used not only to coordinate the work of user-level applications, but within operating systems as well.  The earliest paging systems did not use virtual memory address spaces; instead, the operating system would explicitly load individual modules of itself as needed, overwriting less needed ones (the memory available for the operating system was much smaller than the operating system).  A module had to be capable of running in whatever memory was free at the time it was needed, so individual operating system modules were made of position-independent code.</p>
<p>

The invention of virtual memory obsoleted that method, because the operating system could have a virtual address space so big that every module of the operating system could have its own permanent virtual address.</p>

</sec>
<sec>
<st>
 Technical details </st>

<p>

Procedure calls inside a shared library are typically made through small procedure linkage table <link xlink:type="simple" xlink:href="../329/674329.xml">
stub</link>s, which then call the definitive function. This notably allows a shared library to inherit certain function calls from previously loaded libraries rather than using its own versions.</p>
<p>

Data references from position-independent code are usually made indirectly, through <link>
global offset table</link>s (GOTs), which store the addresses of all accessed <link xlink:type="simple" xlink:href="../611/265611.xml">
global variable</link>s. There is one GOT per compilation unit or object module, and it is located at a fixed offset from the code (although this offset is not known until the library is <link xlink:type="simple" xlink:href="../421/106421.xml">
linked</link>). When a <link xlink:type="simple" xlink:href="../566/18566.xml">
linker</link> links modules to create a shared library, it merges the GOTs and sets the final offsets in code. It is not necessary to adjust the offsets when loading the shared library later.</p>
<p>

Position independent functions accessing global data start by determining the absolute address of the GOT given their own current program counter value. This often takes the form of a fake function call in order to obtain the return value on stack (<link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link>) or in a special register (<link xlink:type="simple" xlink:href="../281/24281.xml">
PowerPC</link>, <link xlink:type="simple" xlink:href="../954/36954.xml">
SPARC</link>, probably at least some other <link xlink:type="simple" xlink:href="../672/3963672.xml">
RISC</link> processors, <link xlink:type="simple" xlink:href="../266/1856266.xml">
ESA/390</link>), which can then be stored in a predefined standard register. Some processor architectures, like the <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../270/20270.xml">
Motorola 68000</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
, <artifact wordnetid="100021939" confidence="0.8">
<merchandise wordnetid="103748886" confidence="0.8">
<commodity wordnetid="103076708" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/20326.xml">
Motorola 6809</link></commodity>
</merchandise>
</artifact>
, <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/60558.xml">
ARM</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 and the new <link xlink:type="simple" xlink:href="../374/244374.xml">
AMD64</link> allow referencing data by offset from the <link xlink:type="simple" xlink:href="../944/59944.xml">
program counter</link>. This is specifically targeted at making position-independent code smaller, less register demanding and hence more efficient.</p>

</sec>
<sec>
<st>
 Windows DLLs </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../077/2701077.xml">
dynamic-link library</link></it>
</indent>

<link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../077/2701077.xml">
DLL</link></format>
s are not shared libraries in the <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 sense and do not use position independent code. This means they cannot have their routines overridden by previously loaded DLLs and require small tricks for sharing selected global data. Code has to be relocated after it has been loaded from disk, making it potentially non-shareable between processes; sharing mostly occurs on disk.</p>
<p>

To alleviate this limitation, almost all Windows system DLLs are pre-mapped at different fixed addresses in such a way that there is no conflict. It is not necessary to relocate the libraries before using them and memory can be shared. Even pre-mapped DLLs still contain information which allows them to be loaded at arbitrary addresses if necessary.</p>
<p>

A sharing technique Windows calls "memory mapping" (not to be confused with <link xlink:type="simple" xlink:href="../157/335157.xml">
Memory-mapped I/O</link>) is sometimes able to allow multiple processes to share an instance of a DLL loaded into memory. However, the reality is that Windows is not always able to share one instance of a DLL loaded by multiple processes.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Windows requires each compiled program to know where in <it>its</it> address space each DLL will be accessed &mdash; there is no support for position independence. </p>
<p>

A DLL specifies its <it>desired</it> base address when it is created (Visual C++ defaults to an offset of 0x10000000) but if multiple DLLs have the same desired base address, a program cannot relocate them all to that base offset and must specify new offsets when linking. When the Windows <structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../773/483773.xml">
loader</link></room>
</library>
</area>
</artifact>
</structure>
 loads an executable into memory for execution, it checks to see if each DLL has already been loaded with the offset used when the executable was created (not the DLL). If the DLL is not already loaded with that offset, it is relocated to the base requested by the executable. Note that this will provide sharing across multiple processes of the <it>same</it> executable (e.g. if started in different accounts via <link xlink:type="simple" xlink:href="../466/473466.xml">
Fast User Switching</link>), but not necessarily across different programs that link to the same DLL.</p>
<p>

Other platforms such as <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link> and <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 now support forms of prebinding as well. For <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link> the system is called <link xlink:type="simple" xlink:href="../962/1667962.xml">
prebinding</link>. Under <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
, the system used is implemented via a program called <link xlink:type="simple" xlink:href="../361/5082361.xml">
prelink</link>. This is vastly different from memory mapping.</p>

</sec>
<sec>
<st>
 Position-independent executables </st>
<p>

Position-independent executables (PIE) are executable binaries made entirely from position-independent code.  While some systems only run PIC executables, there are other reasons they are used.  PIE binaries are used in some <link xlink:type="simple" xlink:href="../298/682298.xml">
security-focused</link> <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
 distributions to allow <link xlink:type="simple" xlink:href="../117/657117.xml">
PaX</link> or <link xlink:type="simple" xlink:href="../665/841665.xml">
Exec Shield</link> to use <link xlink:type="simple" xlink:href="../515/866515.xml">
address space layout randomization</link> to prevent attackers from knowing where existing executable code is during a security attack using <link xlink:type="simple" xlink:href="../875/9875.xml">
exploits</link> that rely on knowing the offset of the executable code in the binary, such as <link xlink:type="simple" xlink:href="../717/846717.xml">
return-to-libc attack</link>s.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <accomplishment wordnetid="100035189" confidence="0.8">
<structure wordnetid="104341686" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<area wordnetid="102735688" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<library wordnetid="103660909" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<feat wordnetid="100036762" confidence="0.8">
<room wordnetid="104105893" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/3600079.xml">
Dynamic linker</link></room>
</feat>
</psychological_feature>
</act>
</action>
</library>
</event>
</area>
</artifact>
</structure>
</accomplishment>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
Rick Anderson&#32;(January 2000).&#32;"<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/ms811694.aspx#dlldanger1_topic2">
The End of DLL Hell</weblink>".&#32;<it><computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<social_group wordnetid="107950920" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<gathering wordnetid="107975026" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<community wordnetid="108223802" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<web_site wordnetid="106359193" confidence="0.8">
<link xlink:type="simple" xlink:href="../316/63316.xml">
Microsoft Developer Network</link></web_site>
</group>
</machine>
</community>
</device>
</gathering>
</instrumentality>
</social_group>
</artifact>
</computer>
</it>.&#32;Retrieved on <link>
2007-04-26</link>.&nbsp;"Sharing common DLLs does provide a significant savings on memory load. But Windows is not always able to share one instance of a DLL that is loaded by multiple processes."</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Further reading </st>
<p>

<list>
<entry level="1" type="bullet">

 <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../136/652136.xml">
John R. Levine</link></scholar>
</causal_agent>
</alumnus>
</intellectual>
</person>
</physical_entity>
&#32;(October 1999).&#32;"<weblink xlink:type="simple" xlink:href="http://www.iecc.com/linker/linker08.html">
Chapter 8: Loading and overlays</weblink>", Linkers and Loaders.&#32;Morgan-Kauffman. ISBN 1-55860-496-0.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gentoo.org/proj/en/hardened/pic-guide.xml">
Introduction to Position Independent Code</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.gentoo.org/proj/en/hardened/pic-internals.xml">
Position Independent Code internals</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://linux4u.jinr.ru/usoft/WWW/www_debian.org/Documentation/elf/node21.html">
Programming in Assembly Language with PIC</weblink></entry>
</list>
</p>


</sec>
</bdy>
</room>
</format>
</library>
</area>
</artifact>
</structure>
</information>
</message>
</article>
