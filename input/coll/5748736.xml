<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 21:56:48[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>DataReader</title>
<id>5748736</id>
<revision>
<id>203919525</id>
<timestamp>2008-04-07T04:57:35Z</timestamp>
<contributor>
<username>Liempt</username>
<id>5338642</id>
</contributor>
</revision>
<categories>
<category>SQL data access</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../840/1434840.xml">
ADO.NET</link>, a <b>DataReader</b> is a broad category of objects used to sequentially read data from a data source.  DataReaders provide a very efficient way to access data, and can be thought of as a <link>
Firehose cursor</link> from <link xlink:type="simple" xlink:href="../883/2883.xml">
ASP Classic</link>, except that no <link xlink:type="simple" xlink:href="../880/922880.xml">
server-side</link> <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../836/2104836.xml">
cursor</link></instrumentality>
</artifact>
</system>
 is used.  A DataReader parses a <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../844/404844.xml">
Tabular Data Stream</link></rule>
</direction>
</protocol>
</message>
 from <link xlink:type="simple" xlink:href="../245/28245.xml">
SQL Server</link>, and other methods of retrieving data from other sources.<p>

A DataReader is usually accompanied by a Command object that contains the query, optionally any parameters, and the connection object to run the query on.</p>

<sec>
<st>
 DataReader Types </st>

<p>

There is no DataReader class in <link xlink:type="simple" xlink:href="../840/1434840.xml">
ADO.NET</link>, but there are a number of classes that implement the <link>
IDataReader</link> interface:</p>
<p>

<list>
<entry level="1" type="bullet">

 System.Data.SqlClient.SqlDataReader</entry>
<entry level="1" type="bullet">

 System.Data.OleDb.OleDbDataReader</entry>
<entry level="1" type="bullet">

 System.Data.Odbc.OdbcDataReader</entry>
<entry level="1" type="bullet">

 Oracle.OracleClient.OracleDataReader</entry>
</list>
</p>
<p>

DataReaders have a small footprint and good performance because each is tailor-made to the task at hand, however this makes it more difficult to write an application that can be moved from one backend data source to another.  Some provider-specific DataReaders expose types used by the underlying database - for example, <b>int</b> values can be null in SQL Server, but not in the <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/60402.xml">
.NET Framework</link></implement>
</horizontal_surface>
</tool>
</instrumentality>
</surface>
</artifact>
</platform>
 prior to version 2.0.</p>

</sec>
<sec>
<st>
 Strong vs Weak Typing </st>

<p>

When using a DataReader to retrieve data, the developer can choose to read field values in strongly typed manner ( <it>example:  myReader.GetString(12)</it> ) or a weakly typed manner, returning then as <b>System.Object</b>s ( <it>example:  myReader.GetValue(12)</it> ).  Both approaches have their pros and cons.</p>
<p>

Using the strongly typed retrieval methods can be more cumbersome, especially without specific knowledge of the underlying data.  Numeric values in the database can translate to several <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/60402.xml">
.NET</link></implement>
</horizontal_surface>
</tool>
</instrumentality>
</surface>
</artifact>
</platform>
 types:  <link xlink:type="simple" xlink:href="../636/3844636.xml">
Int16</link>, <link>
Int32</link>, <link xlink:type="simple" xlink:href="../951/404951.xml">
Int64</link>, <link xlink:type="simple" xlink:href="../984/245984.xml">
Float</link>, <link xlink:type="simple" xlink:href="../214/8214.xml">
Decimal</link>, or <link xlink:type="simple" xlink:href="../665/5665.xml">
Currency</link>.  Trying to retrieve a value using the wrong type results in an exception being thrown, which stops code from running further, and slows the application down.  This is also true when you use the right type, but encounter a <link>
DbNull</link> value ( <it>this can be avoided by using the </it>'IsDbNull<b> boolean function of the DataReader class<it> ). The benefit to this retrieval method is that data validation is performed sooner, improving the probability of data correction being possible.</it></b></p>
<p>

Weakly typed data retrieval allows for quick code writing, and allows for the data to be used in some fashion when the developer doesn't know beforehand what types will be returned.  Further, with some effort, the programmer can extract the value into a variable of the proper type by using the <b>GetType</b> or <b>GetTypeName</b> methods of the DataReader.</p>

</sec>
<sec>
<st>
 Common Errors </st>

<p>

A DataReader can in some cases be used in place of a <link>
DataTable</link>, however many programmers have experienced <link>
connection bloat</link> when following this approach.  A DataReader can only be used against an (already) open <link xlink:type="simple" xlink:href="../925/8423925.xml">
database connection</link>;  that connection isn't closed until the DataReader's <b>Dispose</b> method is called.  If an exception is thrown while the data is being processed, for example as described in <it>Strong vs Weak Typing</it>, above, the <b>Dispose</b> method will never be called if the developer writes code explicitly declaring and disposing the DataReader.  The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 <b>using</b> construct is a good way to avoid this problem, as shown below in the code example.</p>

</sec>
<sec>
<st>
 Code </st>

<p>

Sample of accessing SQL Data using DataReader

void DataTest()
{
 using(SqlConnection conn1 = new SqlConnection(...)) {
  conn1.Open()
  SqlCommand mycommand = new SqlCommand("Select * From someTable", conn1);
  using(SqlDataReader myreader = mycommand.ExecuteReader()) {
   if(myreader != null)
    while(myreader.Read())
     Console.WriteLine(myreader.GetValue(0).ToString() + ":" + myreader.GetTypeName(0));

  }
  mycommand.Dispose(); 
 }
}

</p>
</sec>
</bdy>
</article>
