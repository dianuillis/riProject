<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:20:15[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Quadratic sieve</title>
<id>582340</id>
<revision>
<id>219063166</id>
<timestamp>2008-06-13T11:54:17Z</timestamp>
<contributor>
<username>Fivemack</username>
<id>230572</id>
</contributor>
</revision>
<categories>
<category>Integer factorization algorithms</category>
</categories>
</header>
<bdy>

The <b>quadratic sieve</b> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> (<b>QS</b>) is a modern <link xlink:type="simple" xlink:href="../491/15491.xml">
integer factorization</link> algorithm and, in practice, the second fastest method known (after the <link xlink:type="simple" xlink:href="../734/152734.xml">
general number field sieve</link>). It is still the fastest for integers under 100 decimal digits or so, and is considerably simpler than the number field sieve. It is a general-purpose factorization algorithm, meaning that its running time depends solely on the size of the <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link> to be factored, and not on special structure or properties. It was invented by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../159/2134159.xml">
Carl Pomerance</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
 in 1981 as an improvement to <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../877/1033877.xml">
Dixon's factorization method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.
<sec>
<st>
Basic aim</st>
<p>

The algorithm attempts to set up a <link xlink:type="simple" xlink:href="../713/576713.xml">
congruence of squares</link> <link xlink:type="simple" xlink:href="../087/20087.xml">
modulo</link> <it>n</it> (the integer to be factorized), which often leads to a factorization of <it>n</it>. The algorithm works in two phases: the <it>data collection</it> phase, where it collects information that may lead to a congruence of squares; and the <it>data processing</it> phase, where it puts all the data it has collected into a <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrix</link> and solves it to obtain a congruence of squares. The data collection phase can be easily <link xlink:type="simple" xlink:href="../162/145162.xml">
parallelized</link> to many processors, but the data processing phase requires large amounts of memory, and is difficult to parallelize efficiently over many nodes or if the processing nodes do not each have enough memory to store the whole matrix. The <link xlink:type="simple" xlink:href="../717/17911717.xml">
block Wiedemann algorithm</link> can be used in the case of a few systems each capable of holding the matrix.</p>
<p>

The naïve approach to finding a congruence of squares is to pick a random number, square it, and hope the least non-negative remainder <link xlink:type="simple" xlink:href="../087/20087.xml">
modulo</link> <it>n</it> is a <link xlink:type="simple" xlink:href="../198/52198.xml">
perfect square</link> (in the integers). For example, 802 mod 5959 is 441, which is 212. This approach finds a congruence of squares only rarely for large <it>n</it>, but when it does find one, more often than not, the congruence is nontrivial and the factorization is complete. This is roughly the basis of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../433/2132433.xml">
Fermat's factorization method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>
<p>

The quadratic sieve is a modification of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../877/1033877.xml">
Dixon's factorization method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>
<p>

The general running time required for the quadratic sieve (to factor an integer <it>n</it>) is
<indent level="1">

<math>O\left(e^\sqrt{\log n \log\log n}\right)=L_n\left[1/2,1\right]</math>
</indent>
in the <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link> and <link xlink:type="simple" xlink:href="../119/2811119.xml">
L</link> notations<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.</p>
<p>

The constant <it>e</it> is usually used as the base of the logarithm.</p>

</sec>
<sec>
<st>
 The approach </st>

<p>

Let <it>x</it> <link xlink:type="simple" xlink:href="../087/20087.xml">
mod</link> <it>y</it> denote the remainder after <link xlink:type="simple" xlink:href="../696/53696.xml#xpointer(//*[./st=%22Division+of+integers%22])">
dividing</link> x by y. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../433/2132433.xml">
Fermat's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 entails a search for a single number <it>a</it> such that <it>a</it>2 mod <it>n</it> is a square. But these <it>a</it> are hard to find. The quadratic sieve consists of computing <it>a</it>2 mod <it>n</it> for several <it>a</it>, then finding a subset of these whose product is a square. This will yield a <link xlink:type="simple" xlink:href="../713/576713.xml">
congruence of squares</link>.</p>
<p>

For example, 412 mod 1649 = 32, 422 mod 1649 = 115, and 432 mod 1649 is 200. None of these is a square, but the product (32)(200) = 6400 = 802, and mod 1649,  (32)(200) = (412)(432) = ((41)(43))2. Since (41)(43) mod 1649 = 114, this is a congruence of squares: 1142 ≡ 802 (mod 1649).</p>
<p>

But how to solve the problem of, given a set of numbers, finding a subset whose product is a square? The solution uses the concept of an <it>exponent <link xlink:type="simple" xlink:href="../370/32370.xml">
vector</link></it>. For example, the <link xlink:type="simple" xlink:href="../556/11556.xml">
prime-power factorization</link> of 504 is 23327. It can be represented by the exponent vector (3,2,0,1), which gives the exponents of 2, 3, 5, and 7 in the prime factorization. The number 490 would similarly have the vector (1,0,1,2). Multiplying the numbers is the same as componentwise adding their exponent vectors: (504)(490) has the vector (4,2,1,3).</p>
<p>

A number is a square if every number in its exponent vector is even. For example, the vectors (3,0,0,1) and (1,2,0,1) add to (4,2,0,2), so (56)(126) is a square. Searching for a square requires knowledge only of the <link xlink:type="simple" xlink:href="../088/25088.xml">
parity</link> of the numbers in the vectors, so it is possible to reduce the entire vector mod 2 and perform addition of elements mod 2: (1,0,0,1) + (1,0,0,1) = (0,0,0,0). This is particularly efficient in practical implementations, as the vectors can be represented as <link xlink:type="simple" xlink:href="../937/1189937.xml">
bitset</link>s and addition mod 2 reduces to <link xlink:type="simple" xlink:href="../399/264399.xml#xpointer(//*[./st=%22XOR%22])">
bitwise XOR</link>.</p>
<p>

The problem is reduced to: given a set of (0,1)-vectors, find a subset which adds to the <link xlink:type="simple" xlink:href="../977/1453977.xml">
zero vector</link> mod 2. This is a <link xlink:type="simple" xlink:href="../422/18422.xml">
linear algebra</link> problem; the solution is a <link xlink:type="simple" xlink:href="../863/101863.xml">
linear dependency</link>. It is a theorem of linear algebra that with more vectors than each vector has elements, such a dependency must exist. It can be found efficiently, for example by placing the vectors as rows in a <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrix</link> and then using <link xlink:type="simple" xlink:href="../035/13035.xml">
Gaussian elimination</link>, which is easily adapted to work for integers mod 2 instead of <link xlink:type="simple" xlink:href="../491/19725491.xml">
real number</link>s. The desired square is then the product of the numbers corresponding to those vectors.</p>
<p>

However, simply squaring many <link xlink:type="simple" xlink:href="../627/41627.xml">
random number</link>s mod <it>n</it> produces a very large number of different prime factors, and so very long vectors and a very large matrix. The answer is to look specifically  for numbers <it>a</it> such that <it>a</it>2 mod <it>n</it> has only small prime factors (they are <link xlink:type="simple" xlink:href="../039/1035039.xml">
smooth number</link>s). They are harder to find, but using only smooth numbers keeps the vectors and matrices smaller and more tractable. The quadratic sieve searches for smooth numbers using a technique called <link xlink:type="simple" xlink:href="../915/1035915.xml">
sieving</link>, discussed later, from which the algorithm takes its name.</p>

</sec>
<sec>
<st>
The algorithm</st>

<p>

To summarize, the basic quadratic sieve algorithm has these main steps:</p>
<p>

<list>
<entry level="1" type="number">

 Choose a smoothness bound <it>B</it>. The number π(<it>B</it>), denoting the number of prime numbers less than <it>B</it>, will control both the length of the vectors and the number of vectors needed.</entry>
<entry level="1" type="number">

 Use sieving to locate π(<it>B</it>)&nbsp;+&nbsp;1 numbers <it>ai</it> such that <it>bi</it>=(<it>ai</it>2 mod <it>n</it>) is <it>B</it>-smooth. </entry>
<entry level="1" type="number">

Factor the <it>bi</it> and generate exponent vectors mod 2 for each one.</entry>
<entry level="1" type="number">

 Use linear algebra to find a subset of these vectors which add to the zero vector. Multiply the corresponding <it>ai </it>together naming the result mod <it>n</it>: <it>a</it> and the <it>bi</it> together which yields a <it>B</it>-smooth square  <it>b2</it>.</entry>
<entry level="1" type="number">

We are now left with the equality <it>a</it>2=<it>b</it>2 mod <it>n</it> from which we get two square roots of  (<it>a</it>2 mod <it>n</it>), one by taking the square root in the integers of <it>b2</it> namely <it>b</it>, and the other the <it>a</it> computed in step 4.</entry>
<entry level="1" type="number">

 We now have the desired identity: <math>(a+b)(a-b)=0 \pmod n</math>. Compute the GCD of <it>n</it> with the difference (or sum) of <it>a</it> and <it>b</it>. This produces a factor, although it may be a trivial factor (<it>n</it> or 1). If the factor is trivial, try again with a different linear dependency or different <it>a</it>.</entry>
</list>
</p>
<p>

The remainder of this article explains details and extensions of this basic algorithm.</p>

</sec>
<sec>
<st>
How QS optimizes finding congruences</st>
<p>

The quadratic sieve attempts to find pairs of integers <it>x</it> and <it>y(x)</it> (where <it>y(x)</it> is a function of <it>x</it>) satisfying a much weaker condition than <it>x</it>2 ≡ <it>y</it>2 (mod <it>n</it>). It selects a set of <link xlink:type="simple" xlink:href="../666/23666.xml">
primes</link> called the <it>factor base</it>, and attempts to find <it>x</it> such that the least absolute remainder of <it>y(x)</it> = <it>x</it>2 mod <it>n</it> factorizes completely over the factor base. Such <it>x</it> values are said to be <it>smooth</it> with respect to the factor base.</p>
<p>

The factorisation of a value of y(x) that splits over the factor base, together with the value of x, is known as a <it>relation</it>. The quadratic sieve speeds up the process of finding relations by taking <it>x</it> close to the square root of <it>n</it>. This ensures that <it>y(x)</it> will be smaller, and thus have a greater chance of being smooth.</p>
<p>

<indent level="1">

<math>y(x)=\left(\left\lfloor\sqrt{n}\right\rfloor+x\right)^2-n\hbox{ (where }x\hbox{ is a small integer)}</math>
</indent>
:<math>y(x)\approx 2x\left\lfloor\sqrt{n}\right\rfloor</math></p>
<p>

This implies that <it>y</it> is on the order of 2<it>x</it>[√''n'']. However, it also implies that <it>y</it> grows linearly with  x times the square root of n.</p>
<p>

Another way to increase the chance of smoothness is by simply increasing the size of the factor base.  However, it is necessary to find at least one smooth relation more than the number of primes in the factor base, to ensure the existence of a linear dependency.</p>

<ss1>
<st>
Partial relations and cycles</st>
<p>

Even if for some relation <it>y(x)</it> is not smooth, it may be possible to merge two of these <it>partial relations</it> to form a full one, if the two <it>y</it> 's are products of the same prime(s) outside the factor base. For example, if the factor base is {2, 3, 5, 7} and <it>n</it> = 91, there are partial relations:</p>
<p>

<indent level="1">

<math>{21^2\equiv7^1\cdot11\pmod{91}}</math>
</indent>
:<math>{29^2\equiv2^1\cdot11\pmod{91}}</math></p>
<p>

Multiply these together:</p>
<p>

<indent level="1">

<math>{(21\cdot 29)^2\equiv2^1\cdot7^1\cdot11^2\pmod{91}}</math>
</indent>

and multiply both sides by (11&amp;minus;1)2 modulo 91. 11&amp;minus;1 modulo 91 is 58, so:</p>
<p>

<indent level="1">

<math>(58\cdot 21\cdot 29)^2\equiv 2^1\cdot7^1\pmod{91}</math>
</indent>
:<math>14^2\equiv 2^1\cdot7^1\pmod{91}</math></p>
<p>

producing a full relation. Such a full relation (obtained by combining partial relations) is called a <it>cycle</it>. Sometimes, forming a cycle from two partial relations leads directly to a congruence of squares, but rarely.</p>

</ss1>
<ss1>
<st>
Checking smoothness by sieving</st>
<p>

There are several ways to check for smoothness of the <it>y</it>s. The most obvious is by <link xlink:type="simple" xlink:href="../660/557660.xml">
trial division</link>, although this increases the running time for the data collection phase. Another method that has some acceptance is the <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
elliptic curve method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
. However, in practice, a process called <it>sieving</it> is used. </p>
<p>

<indent level="1">

<math>y(x)=x^2-n</math>
</indent>
:<math>y(x+kp)=(x+kp)^2-n</math>
<indent level="1">

<math>y(x+kp)=x^2+2xkp+(kp)^2-n</math>
</indent>
:<math>y(x+kp)=y(x)+2xkp+(kp)^2\equiv y(x)\pmod{p}</math></p>
<p>

Thus solving <it>y(x)</it> ≡ 0 (mod <it>p</it>) for <it>x</it> generates a whole sequence of <it>y</it>s which are divisible by <it>p</it>. This is finding a square root modulo a prime, for which there exist efficient algorithms, such as the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../375/3667375.xml">
Shanks-Tonelli algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. (This is where the quadratic sieve gets its name – <it>y</it> is a quadratic polynomial in <it>x</it>, and the sieving process works like the <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/73415.xml">
Sieve of Eratosthenes</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
.) </p>
<p>

The sieve starts by setting every entry in a large array A of bytes to zero. For each p, solve the quadratic equation mod p to get two roots α and β, and then add an approximation to log(p) to every entry for which y(x) = 0 mod p ... that is, A[kp+α] and A[kp+β].  It is also necessary to solve the quadratic equation modulo small powers of p in order to recognise numbers divisible by the square of a factor-base prime.</p>
<p>

At the end of the factor base, any A containing a value above a threshold of roughly log(n) will correspond to a value of y(x) which splits over the factor base.  The information about exactly which primes divide y(x) has been lost, but it has only small factors, and there are many good algorithms (trial division by small primes, <link xlink:type="simple" xlink:href="../328/3387328.xml">
SQUFOF</link>, <link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard rho</link>, and <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
ECM</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
 are usually used in some combination) for factoring a number known to have only small factors.</p>
<p>

There are many y(x) values that work, so the factorization process at the end doesn't have to be entirely reliable; often the processes misbehave on say 5% of inputs, requiring a small amount of extra sieving.</p>

</ss1>
</sec>
<sec>
<st>
Large primes</st>

<ss1>
<st>
One large prime</st>
<p>

After dividing by all the factors less than A, if the remaining part of the number (the cofactor) is less than A^2, then this cofactor must be prime. In effect, it can be added to the factor base, by sorting the list of relations into order by cofactor.  If y(a) = 7*11*23*137 and y(b) = 3*5*7*137, then y(a)y(b) = 3*5*11*23 * 7^2 * 137^2. This works by reducing the threshold of entries in the sieving array above which a full factorisation is performed.
</p>
</ss1>
<ss1>
<st>
More large primes</st>
<p>

Reducing the threshold even further, and using an effective process for factoring y(x) values into products of even relatively large primes - ECM is superb for this - can find relations with most of their factors in the factor base, but with two or even three larger primes. Cycle finding then allows combining a set of relations sharing several primes into a single relation.</p>

</ss1>
</sec>
<sec>
<st>
Multiple polynomials</st>
<p>

In practice, many different <link xlink:type="simple" xlink:href="../000/23000.xml">
polynomial</link>s are used for <it>y</it>, since only one polynomial will not typically provide enough (<it>x</it>, <it>y</it>) pairs that are smooth over the factor base. The polynomials used must have a special form, since they need to be squares modulo <it>n</it>. The polynomials must all have a similar form to the original <it>y</it>(<it>x</it>) = <it>x</it>2 &amp;minus; <it>n</it>:</p>
<p>

<indent level="1">

<math>y(x)=(Ax+B)^2-n \qquad A,B\in\mathbb{Z}</math>
</indent>

Assuming <math>B^2-n</math> is a multiple of A, so that <math>B^2-n = AC</math> the polynomial y(x) can be written as <math>y(x) = A*(Ax^2+2Bx+C)</math>. If then A is a square, only the factor <math>(Ax^2+2Bx+C)</math> have to be considered.</p>
<p>

This approach (called MPQS, Multiple Polynomial Quadratic Sieve) is ideally suited for <link xlink:type="simple" xlink:href="../840/148840.xml">
parallelization</link>, since each <link xlink:type="simple" xlink:href="../218/5218.xml">
processor</link> involved in the factorization can be given <it>n</it>, the factor base and a collection of polynomials, and it will have no need to communicate with the central processor until it is finished with its polynomials.</p>

</sec>
<sec>
<st>
Example</st>

<p>

Here is an example. Let <it>n</it> = 1817, therefore <it>m</it>, the floor of the square root of <it>n</it>, is 42. Since <it>n</it> is small, the basic polynomial is enough: <it>y</it>(<it>x</it>) = (<it>x</it> + 42)2 &amp;minus; 1817.</p>

<ss1>
<st>
Data collection</st>
<p>

For a factor base, only primes <it>p</it> whose <link xlink:type="simple" xlink:href="../567/18567.xml">
Legendre symbol</link> (n/p) is one are needed:
<indent level="1">

<math>F=\lbrace -1,2,7,13\rbrace.</math>
</indent>

Now, for sieving purposes, solve the congruence
<indent level="1">

<math>x^2\equiv 1817\pmod{p}</math>
</indent>
for each <it>p</it> in the factor base. The square roots are:
<indent level="1">

Mod 2: 1
</indent>
:Mod 7: 2 and 5
<indent level="1">

Mod 13: 6 and 7.
</indent>
This can be easily verified. Next list all the <it>y</it>(<it>x</it>) values for 0 ≤ x ≤ 100 (this interval can always be expanded later if it does not yield enough relations). Then, for each prime <it>p</it>, start at the <it>y</it>-value at the square root of <it>n</it> mod <it>p</it> and divide <it>p</it> out of that <it>y</it>-value. Move <it>p</it> positions up in the list and repeat the procedure. This is the sieving process in action.</p>
<p>

Once the sieving has been completed for all primes in the factor base, the positions in the list that have been reduced to 1 correspond to <it>y</it>-values which are smooth over <it>F</it>. At least five are needed, and in this case the interval used has yielded four. The pairs (<it>x</it>, <it>y</it>) are:
<indent level="1">

(1, 32), (3, 208), (9, 784), (81, 13312).
</indent>
Find one more by expanding the interval as necessary (note that <it>x</it> can also take on negative values). Increasing the upper bound produces:
<indent level="1">

(103, 19208).
</indent>

</p>
</ss1>
<ss1>
<st>
Data processing</st>
<p>

There are enough relations to build the exponent vector matrix, but first the <it>y</it>-values must be factored. This is easy, since there are only have three primes to trial-divide by. Here are the factorizations:</p>
<p>

<table class="wikitable">
<row >
<header>
<it>x''</it></header>
<col>
<it>y''</it></col>
</row>
<row >
<col>
1</col>
<col>
&amp;minus;10 • 25 • 70 • 130</col>
</row>
<row >
<col>
3</col>
<col>
&amp;minus;10 • 24 • 70 • 131</col>
</row>
<row >
<col>
9</col>
<col>
&amp;minus;10 • 24 • 72 • 130</col>
</row>
<row >
<col>
81</col>
<col>
&amp;minus;10 • 210 • 70 • 131</col>
</row>
<row >
<col>
103</col>
<col>
&amp;minus;10 • 23 • 74 • 130</col>
</row>
</table>
</p>
<p>

Now form the exponent vector matrix:
<indent level="1">

<math>\begin{pmatrix}
0 &amp; 5 &amp; 0 &amp; 0 \\
0 &amp; 4 &amp; 0 &amp; 1 \\
0 &amp; 4 &amp; 2 &amp; 0 \\
0 &amp; 10 &amp; 0 &amp; 1 \\
0 &amp; 3 &amp; 4 &amp; 0 \\
\end{pmatrix}\equiv\begin{pmatrix}
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
\end{pmatrix}\pmod{2}</math>
</indent>

Here, rows that add to all-zero vectors modulo 2 can be found by inspection. The third row (corresponding to (<it>x</it>, <it>y</it>) = (9, 784)) is already a congruence of squares, so try to factor <it>n</it> using that.</p>
<p>

<indent level="1">

<math>y(x)=(x+42)^2-1817</math>
</indent>
:<math>y(9)=784=28^2\equiv 51^2\pmod{1817}</math></p>
<p>

gcd(51 + 28, 1817) = 79 and gcd(51 &amp;minus; 28, 1817) = 23. These are the two non-trivial factors of 1817.</p>
<p>

This demonstration should also serve to show that the quadratic sieve is only appropriate when <it>n</it> is large. For a number as small as 1817, this algorithm is overkill. <problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
 could have found a factor with 9 divisions.</p>

</ss1>
</sec>
<sec>
<st>
Factoring records</st>
<p>

Until the discovery of the <link xlink:type="simple" xlink:href="../734/152734.xml">
number field sieve</link> (NFS), QS was the asymptotically-fastest known general-purpose factoring algorithm. Now, <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
Lenstra elliptic curve factorization</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
 has the same asymptotic running time as QS (in the case where <it>n</it> has exactly two prime factors of equal size), but in practice, QS is faster since it uses <link xlink:type="simple" xlink:href="../250/143250.xml">
single-precision</link> operations instead of the <link>
multi-precision</link> operations used by the elliptic curve method.</p>
<p>

On April 2, 1994, the factorization of <link>
RSA-129</link> was completed using QS. It was a 129-digit number, the product of two large primes, one of 64 digits and the other of 65. The factor base for this factorization contained 524339 primes. The data collection phase took 5000 <link xlink:type="simple" xlink:href="../409/2657409.xml">
MIPS-year</link>s, done in distributed fashion over the Internet. The data collected totaled 2<link xlink:type="simple" xlink:href="../570/12570.xml">
GB</link>. The data processing phase took 45 hours on <link xlink:type="simple" xlink:href="../972/1141972.xml">
Bellcore</link>'s (now <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../972/1141972.xml">
Telcordia Technologies</link></company>
) <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../837/2615837.xml">
MasPar</link></institution>
</company>
 (massively parallel) supercomputer. This was the largest published factorization by a general-purpose algorithm, until NFS was used to factor <link>
RSA-130</link>, completed April 10, 1996. All <link xlink:type="simple" xlink:href="../379/511379.xml">
RSA number</link>s factored since then have been factored using NFS.</p>

</sec>
<sec>
<st>
 Implementations </st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.asahi-net.or.jp/~KC2H-MSM/cn">
PPMPQS and PPSIQS</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://gforge.inria.fr/projects/mpqs/">
mpqs</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.friedspace.com/QS/">
SIMPQS</weblink> is a fast implementation of the self initialising multiple polynomial quadratic sieve written by William Hart.  It provides support for the large prime variant and uses Jason Papadopoulos' block Lanczos code for the linear algebra stage. SIMPQS is accessible as the qsieve command in the <link xlink:type="simple" xlink:href="../438/4012438.xml">
SAGE</link> computer algebra package or can be downloaded in source form. SIMPQS is optimized for use on Athlon and Opteron machines, but will operate on most common 32 and 64 bit architectures. It is written entirely in C.</entry>
<entry level="1" type="bullet">

 a <weblink xlink:type="simple" xlink:href="http://www.alpertron.com.ar/ECM.HTM">
factoring applet</weblink> by Dario Alpern, that uses the quadratic sieve if certain conditions are met.</entry>
<entry level="1" type="bullet">

 The <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../441/7311441.xml">
PARI/GP</link></instrumentality>
</artifact>
</system>
 computer algebra package includes an implementation of the self initialising multiple polynomial quadratic sieve implementing the large prime variant. It was adapted by Thomas Papanikolaou and Xavier Roblot from a sieve written for the LiDIA project. The self initialisation scheme is based on an idea from the thesis of Thomas Sosnowski. </entry>
<entry level="1" type="bullet">

 A variant of the quadratic sieve is available in the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../628/98628.xml">
MAGMA</link></software>
 computer algebra package. It is based on an implementation of Arjen Lenstra from 1995, used in his "factoring by email" program.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../917/1813917.xml">
UBASIC</link> written by Yuji Kida has a version of the multiple polynomial quadratic sieve. It is written in highly optimized 8086 assembly language and for factorizations up to around 60 digits will compete with implementations such as the PARI/GP implementation or Dario Alpern's JAVA applet.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 The msieve package for factoring large numbers, written by Jason Papadopoulos, includes a very fast implementation of PPSIQS, very carefully designed for cache-friendliness.  It is the fastest available implementation of MPQS, factoring <link>
RSA-100</link> in eleven hours on a 2200MHz <link>
Athlon64</link>; on the same system, a 60-digit number takes just over six seconds, a 70-digit number 80 seconds, an 80-digit number just under ten minutes and a 90-digit number about eighty minutes.  It is distributed as C source code, though one or two subroutines include x86 assembly language versions.  It can be downloaded from the <weblink xlink:type="simple" xlink:href="http://www.boo.net/~jasonp/qs.html">
msieve</weblink> page.</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../917/1813917.xml">
UBASIC</link></entry>
<entry level="1" type="bullet">

 <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
Lenstra elliptic curve factorization</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../751/183751.xml">
primality test</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
 <cite id="CITEREFPomerance1996" style="font-style:normal"><link>
Pomerance, Carl</link>&#32;(December 1996),&#32;"<weblink xlink:type="simple" xlink:href="http://www.ams.org/notices/199612/pomerance.pdf">
A Tale of Two Sieves</weblink>",&#32;<it>Notices of the AMS</it>&#32;<b>43</b>(12):  1473-1485, </cite>&nbsp;</entry>
</reflist>
</p>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../048/9210048.xml">
Richard Crandall</link></scientist>
</causal_agent>
</person>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../159/2134159.xml">
Carl Pomerance</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(2001). Prime Numbers: A Computational Perspective, 1st edition,&#32;Springer. ISBN 0-387-94777-9.</cite>&nbsp; Section 6.1: The quadratic sieve factorization method, pp.227&ndash;244.</entry>
</list>
</p>


</sec>
<sec>
<st>
 Other external links </st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.math.uiuc.edu/~landquis/quadsieve.pdf">
Reference paper</weblink> from <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../695/384695.xml">
University of Illinois at Urbana-Champaign</link></university>
</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible uncollapsed " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../527/21527.xml">
Number-theoretic</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../751/183751.xml">
Primality test</link>s</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<b><process wordnetid="105701363" confidence="0.8">
<institute wordnetid="108407330" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<association wordnetid="108049401" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../847/405847.xml">
AKS</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</association>
</thinking>
</inquiry>
</institute>
</process>
</b> · <b><link>
APR</link></b> · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../890/3609890.xml">
Ballie-PSW</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <b><process wordnetid="105701363" confidence="0.8">
<curve wordnetid="113867641" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<line wordnetid="113863771" confidence="0.8">
<shape wordnetid="100027807" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/4049015.xml">
ECPP</link></higher_cognitive_process>
</trial>
</shape>
</line>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</curve>
</process>
</b> · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../755/157755.xml">
Fermat</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <b><link>
Lucas–Lehmer</link></b> · <b><it><link>
Lucas–Lehmer (Mersenne numbers)</link></it></b> · <b><it><process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../861/15371861.xml">
Lucas–Lehmer–Riesel</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
</it></b> · <b><it><statement wordnetid="106722453" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/3225985.xml">
Proth's theorem</link></higher_cognitive_process>
</trial>
</proposition>
</experiment>
</problem_solving>
</theorem>
</thinking>
</inquiry>
</message>
</process>
</statement>
</it></b> · <b><it><link>
Pépin's</link></it></b> · <link>
Solovay–Strassen</link> · <link>
Miller–Rabin</link> · <b><problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
</b></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Sieving algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/2150920.xml">
Sieve of Atkin</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/73415.xml">
Sieve of Eratosthenes</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../330/14517330.xml">
Sieve of Sundaram</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../216/4621216.xml">
Wheel factorization</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<premise wordnetid="106753800" confidence="0.8">
<postulate wordnetid="106753299" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/15491.xml">
Integer factorization</link></proposition>
</postulate>
</premise>
</message>
</statement>
algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../392/1335392.xml">
CFRAC</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../877/1033877.xml">
Dixon's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
ECM</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
 · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../069/15822069.xml">
Euler's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../753/578753.xml">
P − 1</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../573/1916573.xml">
P + 1</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <link xlink:type="simple" xlink:href="../340/582340.xml">
QS</link> · <link xlink:type="simple" xlink:href="../734/152734.xml">
GNFS</link> · <it><link xlink:type="simple" xlink:href="../132/589132.xml">
SNFS</link></it> · <link xlink:type="simple" xlink:href="../510/2608510.xml">
rational sieve</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../433/2132433.xml">
Fermat's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../328/3387328.xml">
Shanks' square forms</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../674/42674.xml">
Shor's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Other algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../814/3975814.xml">
Ancient Egyptian multiplication</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../197/4039197.xml">
Aryabhata</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <link xlink:type="simple" xlink:href="../410/985410.xml">
Binary GCD</link> · <link xlink:type="simple" xlink:href="../658/4050658.xml">
Chakravala</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/99438.xml">
Extended Euclidean</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <link xlink:type="simple" xlink:href="../054/13644054.xml">
integer relation algorithm</link> · <link xlink:type="simple" xlink:href="../655/981655.xml">
integer square root</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/903032.xml">
Modular exponentiation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../375/3667375.xml">
Shanks-Tonelli</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
<it>Italics</it> indicate that algorithm is for numbers of special forms; <b>bold</b> indicates <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic algorithm</link>for primality tests.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
