<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:19:57[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Luhn algorithm</title>
<id>582440</id>
<revision>
<id>242281503</id>
<timestamp>2008-10-01T16:49:33Z</timestamp>
<contributor>
<username>Toschlog</username>
<id>472602</id>
</contributor>
</revision>
<categories>
<category>Modular arithmetic</category>
<category>Error detection and correction</category>
<category>Checksum algorithms</category>
<category>Articles with example C Sharp code</category>
</categories>
</header>
<bdy>

The <b>Luhn algorithm</b> or <b>Luhn formula</b>, also known as the "<link xlink:type="simple" xlink:href="../087/20087.xml">
modulus</link> 10" or "mod 10" <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>,
is a simple <link xlink:type="simple" xlink:href="../538/7538.xml">
checksum</link> formula used to validate a variety of identification numbers, such as <link xlink:type="simple" xlink:href="../399/15905399.xml">
credit card numbers</link> and <region wordnetid="108630039" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../916/5042916.xml">
Canadian</link></region>
 <amount wordnetid="105107765" confidence="0.8">
<magnitude wordnetid="105090441" confidence="0.8">
<property wordnetid="104916342" confidence="0.8">
<number wordnetid="105121418" confidence="0.8">
<link xlink:type="simple" xlink:href="../714/523714.xml">
Social Insurance Number</link></number>
</property>
</magnitude>
</amount>
s. It was created by <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link></company>
 scientist <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../602/1015602.xml">
Hans Peter Luhn</link></employee>
</scientist>
</causal_agent>
</worker>
</person>
</physical_entity>
 and described in <weblink xlink:type="simple" xlink:href="http://patft.uspto.gov/netacgi/nph-Parser?patentnumber=2950048">
U.S. Patent 2,950,048</weblink><weblink xlink:type="simple" xlink:href="http://www.pat2pdf.org/pat2pdf/foo.pl?number=2950048">
&nbsp;</weblink>, filed on <link xlink:type="simple" xlink:href="../986/15986.xml">
January 6</link>, <link xlink:type="simple" xlink:href="../982/34982.xml">
1954</link>, and granted on <link xlink:type="simple" xlink:href="../628/1628.xml">
August 23</link>, <link xlink:type="simple" xlink:href="../664/34664.xml">
1960</link>.<p>

The algorithm is in the <link xlink:type="simple" xlink:href="../551/18935551.xml">
public domain</link> and is in wide use today. It is not intended to be a <link xlink:type="simple" xlink:href="../526/439526.xml">
cryptographically secure hash function</link>; it was designed to protect against accidental errors, not malicious attacks. Most credit cards and many government identification numbers use the algorithm as a simple method of distinguishing valid numbers from collections of random digits.</p>

<sec>
<st>
Strengths and weaknesses</st>
<p>

The Luhn algorithm will detect any single-digit error, as well as almost all transpositions of adjacent digits. It will not, however, detect transposition of the two-digit sequence <it>09</it> to <it>90</it> (or vice versa). Other, more complex check-digit algorithms (such as the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../949/4766949.xml">
Verhoeff algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
) can detect more transcription errors. The <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/6870554.xml">
Luhn mod N algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is an extension that supports non-numerical strings.</p>
<p>

Because the algorithm operates on the digits in a right-to-left manner and zero digits only affect the result if they cause shift in position, zero-padding the beginning of a string of numbers does not affect the calculation.  Therefore, systems that normalize to a specific number of digits by converting 1234 to 00001234 (for instance) can perform Luhn validation before or after the normalization and achieve the same result.</p>
<p>

The algorithm appeared in a US Patent for a hand-held, mechanical device for computing the checksum. It was therefore required to be rather simple. The device took the mod 10 sum by mechanical means. The <it>substitution digits</it>, that is, the results of the double and reduce procedure, were not produced mechanically. Rather, the digits were marked in their permuted order on the body of the machine.</p>

</sec>
<sec>
<st>
Informal explanation</st>
<p>

The formula verifies a number against its included check digit, which is usually appended to a partial account number to generate the full account number. This account number must pass the following test:</p>
<p>

<list>
<entry level="1" type="number">

 Counting from rightmost digit (which is the check digit) and moving left, Double the value of every alternate digit. For any digits that thus become 10 or more, take the two numbers and add them together. For example, 1111 becomes 2121, while 8763 becomes 7733 (from 2&amp;times;6=12 → 1+2=3 and 2&amp;times;8=16 → 1+6=7).</entry>
<entry level="1" type="number">

 Add all these digits together. For example, if 1111 becomes 2121, then 2+1+2+1 is 6; and 8763 becomes 7733, so 7+7+3+3 is 20.</entry>
<entry level="1" type="number">

 If the total ends in 0 (put another way, if the total modulus 10 is congruent to 0), then the number is valid according to the Luhn formula; else it is not valid. So, 1111 is not valid (as shown above, it comes out to 6), while 8763 is valid (as shown above, it comes out to 20).</entry>
</list>
</p>
<p>

Taken from http://www.beachnet.com/~hstiles/cardtype.html</p>
<p>

Step 1: Double the value of alternate digits of the primary account number beginning with the second digit from the right (the first right--hand digit is the check digit.) </p>
<p>

Step 2: Add the individual digits comprising the products obtained in Step 1 to each of the unaffected digits in the original number. </p>
<p>

Step 3: The total obtained in Step 2 must be a number ending in zero (30, 40, 50, etc.) for the account number to be validated. </p>
<p>

For example, to validate the primary account number 49927398716: </p>
<p>

Step 1: </p>
<p>

4 9 9 2 7 3 9 8 7 1 6</p>
<p>

x2  x2  x2  x2  x2 </p>
<p>

18   4   6  16   2</p>
<p>

Step 2: 4 +(1+8)+ 9 + (4) + 7 + (6) + 9 +(1+6) + 7 + (2) + 6 </p>
<p>

Step 3: Sum = 70 : Card number is validated</p>

</sec>
<sec>
<st>
Implementation</st>

<p>

This <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../196/2356196.xml">
C#</link></programming_language>
 function implements the algorithm described above, returning true if the given array of digits represents a valid Luhn number, and false otherwise.</p>
<p>

bool CheckNumber(int digits)
{
int sum = 0;
bool alt = false;
for (int i = digits.Length - 1; i &amp;gt;= 0; --i) {
int thedigit = digits[i];
if (alt) {
thedigit *= 2;
if (thedigit &amp;gt; 9) {
thedigit -= 9; 
}
}
sum += thedigit;
alt = !alt;
}
return ((sum % 10) == 0);
}</p>

</sec>
<sec>
<st>
Other implementations</st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://coob.co.uk/freecode/as2/LuhnAlgorithm.as">
Luhn validation code in Actionscript2, with generation code</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.chriswareham.demon.co.uk/software/luhn.c">
Luhn validation code in C</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.codeguru.com/csharp/.net/net_security/authentication/article.php/c12283/">
Luhn validation code in C#</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://wiki.cdyne.com/wiki/index.php?title=Credit_Card_Verification#VB.Net_Source_Code">
Luhn validation code in VB.Net and C# with Card Identification</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://cflib.org/udf.cfm?id=825">
Luhn validation code in ColdFusion</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://lemonodor.com/archives/000217.html">
Luhn validation code in Common Lisp</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.chriswareham.demon.co.uk/software/Luhn.java">
Luhn validation code in Java</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.theeggeadventure.com/wikimedia/index.php/LUHN_Source_Code">
Luhn validation code in Java, with test cases</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://planzero.org/code/bits/viewcode.php?src=luhn_check.js">
Luhn validation code in JavaScript, with test page</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nawar.us/IBM_Lunhn_Algorithm.xls">
Luhn validation code in MS Excel</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://andrewdashin.com/luhn-algorithm.aspx">
Luhn validation code in MySQL</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://search.cpan.org/~ivan/Business-CreditCard/">
Luhn validation code in Perl</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://search.cpan.org/~tayers/Algorithm-LUHN/">
Luhn validation code in Perl</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://scriptolog.blogspot.com/2008/01/powershell-luhn-validation.html">
Luhn validation code in PowerShell</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://planzero.org/code/bits/viewcode.php?src=luhn_check.phps">
Luhn validation code in PHP</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/172845">
Luhn validation code in Python</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.elifulkerson.com/projects/python-creditcard-mod10-check.php">
Luhn validation code in Python, as a library</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://blog.flame.org/2008/3/24/checking-credit-card-numbers-in-ruby">
Luhn validation code in Ruby</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://blogs.missiondata.com/?p=25">
Luhn validation code in Ruby, with card type check</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://andrewdashin.com/luhn-scheme-implementation.aspx">
Luhn validation code in Scheme</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.sqlteam.com/forums/topic.asp?TOPIC_ID=76195">
 Luhn validation code in Transact-SQL</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://nextbit.blogspot.com/2007/06/doing-luhn-checksum-simply.html">
Alternative validation technique in C, awk and Python</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://patft.uspto.gov/netacgi/nph-Parser?patentnumber=2950048">
U.S. Patent 2,950,048</weblink><weblink xlink:type="simple" xlink:href="http://www.pat2pdf.org/pat2pdf/foo.pl?number=2950048">
&nbsp;</weblink>, <it>Computer for Verifying Numbers</it>, Hans P. Luhn, <link xlink:type="simple" xlink:href="../628/1628.xml">
August 23</link>, <link xlink:type="simple" xlink:href="../664/34664.xml">
1960</link>.</entry>
</list>




</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
