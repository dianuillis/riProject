<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:47:16[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>CDC 6600</title>
<id>58661</id>
<revision>
<id>241065490</id>
<timestamp>2008-09-26T05:15:14Z</timestamp>
<contributor>
<username>T-bonham</username>
<id>3297591</id>
</contributor>
</revision>
<categories>
<category>Supercomputers</category>
<category>1964 introductions</category>
<category>CDC hardware</category>
</categories>
</header>
<bdy>

<image location="right" width="300px" src="Personable_Computer.jpg" type="thumb">
<caption>

The CDC 6600. Behind the system console are two of the "arms" of the plus-sign shaped cabinet with the covers opened. Individual modules can be seen inside. The racks holding the modules are hinged to give access to the racks behind them. Each arm of the machine had up to four such racks. On the right is the cooling system.
</caption>
</image>

<image location="right" width="300px" src="Control_Data_6600_mainframe.jpg" type="thumb">
<caption>

A CDC 6600 system console. The displays could be driven through software to provide <link xlink:type="simple" xlink:href="../499/32499.xml">
vector graphics</link>.
</caption>
</image>

The <b>CDC 6600</b> was a <link xlink:type="simple" xlink:href="../266/20266.xml">
mainframe computer</link> from <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/58032.xml">
Control Data Corporation</link></institution>
</company>
, first delivered in <link xlink:type="simple" xlink:href="../550/34550.xml">
1964</link>. It is generally considered to be the first successful <link xlink:type="simple" xlink:href="../153/37153.xml">
supercomputer</link>, outperforming its fastest predecessor, <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<mainframe wordnetid="103711711" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<digital_computer wordnetid="103196324" confidence="0.8">
<supercomputer wordnetid="104358117" confidence="0.8">
<link xlink:type="simple" xlink:href="../708/149708.xml">
IBM 7030 Stretch</link></supercomputer>
</digital_computer>
</machine>
</device>
</mainframe>
</instrumentality>
</artifact>
</computer>
, by about three times. It remained the world's fastest computer from 1964 to <link xlink:type="simple" xlink:href="../610/34610.xml">
1969</link>, when it relinquished that status to its successor, the <link xlink:type="simple" xlink:href="../742/655742.xml">
CDC 7600</link>.<p>

The system organization of the CDC 6600 was used for the simpler (and slower) <link xlink:type="simple" xlink:href="../578/1998578.xml">
CDC 6400</link>, and later a version containing two 6400 processors known as the <link xlink:type="simple" xlink:href="../578/1998578.xml">
CDC 6500</link>. These machines were instruction-compatible with the 6600, but ran slower due to a much simpler and more sequential processor design. The entire family is now referred to as the <link xlink:type="simple" xlink:href="../803/4120803.xml">
CDC 6000 series</link>. The <link xlink:type="simple" xlink:href="../742/655742.xml">
CDC 7600</link> was originally to be compatible as well, starting its life as the CDC 6800, but during the design compatibility was dropped in favor of outright performance. The 7600 and 6600 were binary compatible, but the software developed in Sunnyvale was not compatible on the two machines.</p>

<sec>
<st>
History and impact</st>

<p>

<indent level="1">

<it>Main article: <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/58032.xml">
Control Data Corporation</link></institution>
</company>
</it>
</indent>

CDC's first products were based on the machines designed at <company wordnetid="108058098" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../901/77901.xml">
ERA</link></institution>
</company>
, which <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../103/29103.xml">
Seymour Cray</link></scientist>
</person>
 had been asked to update after moving to CDC. After an experimental machine known as the <it>Little Character</it>, they delivered the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../144/3758144.xml">
CDC 1604</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
, one of the first commercial <link xlink:type="simple" xlink:href="../011/30011.xml">
transistor</link>-based computers, and one of the fastest machines on the market. Management was delighted, and made plans for a new series of machines that were more tailored to business use; they would include instructions for character handling and record keeping for instance. Cray was not interested in such a project, and set himself the goal of producing a new machine that would be 50 times faster than the 1604. When asked to complete a detailed report on future plans at one and five years into the future, he wrote back that his five year goal was "to produce the largest computer in the world", "large" at that time being synonymous with "fast", and that his one year plan was "to be one-fifth of the way".</p>
<p>

Taking his core team to new offices nearby the original CDC headquarters, they started to experiment with higher quality versions of the "cheap" transistors Cray had used in the 1604. After much experimentation they found that there was simply no way the <link xlink:type="simple" xlink:href="../242/12242.xml">
germanium</link>-based transistors could be run much faster than the 1604. The "business machine" that management had originally wanted, now forming as the <link xlink:type="simple" xlink:href="../080/2966080.xml">
CDC 3000</link> series, pushed them about as far as they could go. Cray then decided the solution was to work with the then-new  <link xlink:type="simple" xlink:href="../114/27114.xml">
silicon</link>-based transistors from <company wordnetid="108058098" confidence="0.8">
<electronics_company wordnetid="108003035" confidence="0.8">
<institution wordnetid="108053576" confidence="0.8">
<link xlink:type="simple" xlink:href="../263/180263.xml">
Fairchild Semiconductor</link></institution>
</electronics_company>
</company>
, which were just coming onto the market and offered dramatically improved switching performance.</p>
<p>

During this period CDC grew from a startup to a large company and Cray became increasingly frustrated with what he saw as ridiculous management requirements. Things became considerably more tense in 1962 when the new CDC 3600 started to near production quality, and appeared to be exactly what management wanted, when they wanted it. Cray eventually told CDC's CEO, <physical_entity wordnetid="100001930" confidence="0.8">
<executive wordnetid="110069645" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<leader wordnetid="109623038" confidence="0.8">
<administrator wordnetid="109770949" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<head wordnetid="110162991" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<link xlink:type="simple" xlink:href="../611/184611.xml">
William Norris</link></creator>
</originator>
</head>
</causal_agent>
</administrator>
</leader>
</pioneer>
</person>
</executive>
</physical_entity>
 that something had to change, or he would leave the company. Norris felt he was too important to lose, and gave Cray the green light to set up a new lab wherever he wanted.</p>
<p>

After a short search, Cray decided to return to his home town of <link xlink:type="simple" xlink:href="../798/138798.xml">
Chippewa Falls, WI</link>, where he purchased a block of land and started up a new lab. Although this process introduced a fairly lengthy delay in the design of his new machine, once in the new lab things started to progress quickly. By this time the new transistors were becoming quite reliable, and modules built with them tended to work properly on the first try.  Working with Jim Thornton, who was the system architect and the 'hidden genius' behind the 6600, the machine soon took form.</p>
<p>

More than 100 CDC 6600s were sold over the machine's lifetime. Many of these went to various <link>
nuclear bomb</link>-related labs, and quite a few found their way into university computing labs. Cray immediately turned his attention to its replacement, this time setting a goal of 10 times the performance of the 6600, delivered as the <link xlink:type="simple" xlink:href="../742/655742.xml">
CDC 7600</link>. The later <link xlink:type="simple" xlink:href="../507/826507.xml">
CDC Cyber</link> 70 and 170 computers were very similar to the CDC 6600 in overall design.</p>

</sec>
<sec>
<st>
Description</st>

<p>

Typical machines of the era used a single complex <link xlink:type="simple" xlink:href="../218/5218.xml">
CPU</link> to drive the entire system. A typical program would first load data into memory (often using pre-rolled library code), process it, and then write it back out. This required the CPUs to be fairly complex in order to handle the complete set of instructions they would be called on to perform. A complex CPU implied a large CPU, introducing signalling delays while information flowed between the individual modules making it up. These delays set a maximum upper limit on performance, the machine could only operate at a cycle speed that allowed the signals time to arrive at the next module.</p>
<p>

Cray took another approach. At the time, CPUs generally ran slower than the <link>
main memory</link> they were attached to. For instance, a processor might take 15 cycles to multiply two numbers, while each memory access took only one or two. This meant there was a significant time where the main memory was idle. It was this idle time that the 6600 extracted.</p>
<p>

Instead of trying to make the CPU handle all the tasks, the 6600s handled math and logic only. This resulted in a much smaller CPU, which in turn allowed it to operate at a higher clock speed. Combined with the faster switching speeds of the silicon transistors, the new CPU design would easily outperform anything then available. The new design ran at 10&nbsp;MHz (100&nbsp;ns cycle), about ten times that of other machines on the market. Additionally the simple processor also made operations themselves faster; for instance, the CPU could complete a multiplication in ten cycles.</p>
<p>

Of course, being simple, the CPU wouldn't be able to do much. A typical CPU of the era had a <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../622/7622.xml">
complex instruction set</link></group>
</collection>
</class>
, which included instructions to handle all of the normal "housekeeping" tasks like memory access and <link xlink:type="simple" xlink:href="../558/14558.xml">
input/output</link>. Cray instead implemented these instructions in a simpler processor dedicated solely to these tasks, thus leaving the CPU itself with many fewer instructions.  (This was the first of what later came to be called <link xlink:type="simple" xlink:href="../201/26201.xml">
reduced instruction set computer</link> (RISC) design.) By allowing the CPU, peripheral processors (PPs) and I/O to operate in parallel, the design considerably improved the performance of the machine. Under normal conditions a machine with two processors would also make the machine dramatically twice as expensive. Key to the 6600's design was to make the I/O processor, known as <it>peripheral processors</it> (PPs), as simple as possible. The PPs were based on the simple 12-bit <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../245/7650245.xml">
CDC 160A</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
, which ran much slower than the CPU, gathering up data and "squirting" it into main memory at high speed via dedicated hardware.</p>
<p>

The machine as a whole operated in a fashion known as <it>barrel and slot</it>, the "barrel" referring to the ten PPs, and the "slot" the main CPU. For any given slice of time, one PP was given control of the CPU, asking it to complete some task (if required). Control was then handed off to the next PP in the barrel. Programs were written, with some difficulty, to take advantage of the exact timing of the machine to avoid any "dead time" on the CPU. With the CPU running much faster than normal each memory access required ten of these faster cycles to complete, so by using ten PPs, each PP was guaranteed one memory access per machine cycle.</p>
<p>

The 10 PPs were implemented virtually - there was CPU hardware only for a single PP. This CPU hardware was shared and operated on 10 PP register sets which represented each of the 10 PP <it>states</it> (similar to modern <link xlink:type="simple" xlink:href="../945/863945.xml">
multithreading</link> processors). The PP <it><link xlink:type="simple" xlink:href="../824/1274824.xml">
register barrel</link></it> would "rotate", with each PP register set presented to the "slot" which the actual PP CPU occupied. The shared CPU would execute all or some portion of a PP's instruction whereupon the barrel would rotate again, presenting the next PP's register set (state). Multiple rotations of the barrel were needed to complete an instruction.  A complete barrel rotation occurred in 1000 nanoseconds (100 nanoseconds per PP), and an instruction could take from 1 to 5 rotations of the barrel to be completed, or more if it was a data transfer instruction.</p>
<p>

The basis for the 6600 CPU is what would today be referred to as a <link xlink:type="simple" xlink:href="../672/3963672.xml">
RISC</link> system, one in which the processor is tuned to do instructions which are comparatively simple and have limited and well defined access to memory. The philosophy of many other machines was toward using instructions which were complicated—for example, a single instruction which would fetch an operand from memory and add it to a value in a register. In the 6600, loading the value from memory would require one instruction, and adding it would require a second. While slower in theory due to the additional memory accesses, the PPs offloaded this expense. This simplification also forced programmers to be very aware of their memory accesses, and therefore code deliberately to reduce them as much as possible.</p>

<ss1>
<st>
The Central Processor (CP)</st>
<p>

The Central Processor (CP) and main memory of the 6400, 6500, and 6600 machines have a 60 bit word length. The Central Processor has eight general purpose 60-<link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link> <link xlink:type="simple" xlink:href="../432/486432.xml">
registers</link> X0 through X7, eight 18-bit address registers A0 through A7, and eight 18-bit scratchpad registers B0 through B7 (typically used for array indexing, with B0 permanently set to zero). Additional registers used for bookkeeping (such as the <link xlink:type="simple" xlink:href="../102/4543102.xml">
scoreboard</link> register) are not accessible to the programmer. Additional registers (such as RA and FL) can only be loaded through the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>.  The CP has no instructions for input and output, which are accomplished through Peripheral Processors (below).  In keeping with the RISC "load/store" philosophy, there are no instructions to read or write from/to core memory. All memory accesses are performed through loading an address into the A registers; loading A1 through A5 with an address would cause the data word at that location to be read into the corresponding X register (X1 through X5), while loading an address into A6 or A7 would cause register X6 or X7 to be written out to memory at that address. (Registers X0 and A0 were not involved in load/store operations this way.) A separate hardware load/store unit handled the actual data movement independent of the operation of the instruction stream, allowing other operations to complete while memory was being accessed, which required (best case) eight cycles. In modern designs this sort of operation is normally supported directly by load/store instructions, which are given an explicit memory location to read or write, instead of the address registers used in the 6600.  Floating-point operations were given pride of place in this <link xlink:type="simple" xlink:href="../509/6509.xml">
architecture</link>: the CDC 6600 (and kin) stand virtually alone in being able to execute a 60-bit <link xlink:type="simple" xlink:href="../376/11376.xml">
floating point</link> multiplication in time comparable to that for a program branch.</p>
<p>

The 6600 CP included 10 parallel functional units, allowing multiple instructions to be worked on at the same time. Today this is known as a <link xlink:type="simple" xlink:href="../702/51702.xml">
superscalar</link> design, but was unique for its time. Unlike most modern CPU designs, functional units were not pipelined; the functional unit would become busy when an instruction was "issued" to it and would remain busy for the entire time required to execute that instruction.  (By contrast, the CDC 7600 introduced pipelining into its functional units.)  In the best case, an instruction could be issued to a functional unit every 100&nbsp;ns clock cycle.  The system read and decoded instructions from memory as fast as possible, generally faster than they could be completed, and fed them off to the units for processing. The units were:
<list>
<entry level="1" type="bullet">

floating point multiply (2 copies)</entry>
<entry level="1" type="bullet">

floating point divide</entry>
<entry level="1" type="bullet">

floating point add</entry>
<entry level="1" type="bullet">

"long" integer add</entry>
<entry level="1" type="bullet">

incrementers (2 copies; performed memory load/store)</entry>
<entry level="1" type="bullet">

shift</entry>
<entry level="1" type="bullet">

boolean logic</entry>
<entry level="1" type="bullet">

branch </entry>
</list>
</p>
<p>

Previously executed instructions went into an eight-word <link xlink:type="simple" xlink:href="../187/1236187.xml">
pipeline</link> (officially called a "stack") kept in onboard CP registers. Since the 15-bit instructions were packed four to a word, the system could pick any one of up to 32 previous instructions to run depending on which units were free. The pipeline was always flushed by an unconditional jump; it was sometimes faster (and would never be slower) than a <it>conditional</it> jump.  The system used a 10 megahertz clock, but used a four-phase signal, so the system could at times effectively operate at 40&nbsp;MHz. A floating point multiplication took ten cycles, while a division took 29, and the overall performance considering memory delays and other issues was about 3 <link xlink:type="simple" xlink:href="../930/82930.xml">
MFLOPS</link>. Using the best available compilers, late in the machine's history, <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link> programs could expect to maintain about 0.5 MFLOPS.</p>

</ss1>
<ss1>
<st>
Memory organization</st>
<p>

<image location="right" width="300px" src="CDC6600_core_memory_plane.jpg" type="thumb">
<caption>

CDC-6600 core memory slice from the hacker halfway house.
</caption>
</image>
</p>
<p>

User programs are restricted to use only a contiguous area of main memory. The portion of memory to which an executing program has access is controlled by the <it>RA</it> (Relative Address) and <it>FL</it> (Field Length) registers which are not accessible to the user program.  When a user program tries to read or write a word in central memory at address <it>a</it>, the processor will first verify that a is between 0 and FL-1. If it is, the processor accesses the word in central memory at address RA+a. This process is known as base-bound relocation; each user program sees core memory as a contiguous block words with length FL,  starting with address 0; in fact the program may be anywhere in the physical memory. Using this technique, each user program can be moved ("relocated") in main memory by the operating system, as long as the RA register reflects its position in memory.  A user program which attempts to access memory outside the allowed range (that is, with an address which is not less than FL) will trigger an interrupt, and will be terminated by the operating system. When this happens, the operating system may create a <link xlink:type="simple" xlink:href="../721/49721.xml">
core dump</link> which records the contents of the program's memory and registers in a file, allowing the developer of the program a means to know what happened. Note the distinction with <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> systems; in this case, the entirety of a process's addressable space must be in core memory, must be contiguous, and its size cannot be larger than the real memory capacity.</p>
<p>

All but the earliest 10 <link xlink:type="simple" xlink:href="../803/4120803.xml">
CDC 6000 series</link> machines could be configured with an optional Extended Core Storage (ECS) system. ECS was built from a different variety of core memory than was used in the central memory.  This made it economical for it to be both larger and slower.  The primary reason was that ECS memory was wired with only 2 wires per core (contrast with 4 for central memory), Because it performed very wide transfers, its sequential transfer rate was the same as that of the small core meory. A 6000 CPU could directly perform block memory transfers between a user's program (or operating system) and the ECS unit.  Wide data paths were used, so this was a very fast operation.  Memory bounds were maintained in a similar manner as central memory - with an RA/FL mechanism maintained by the operating system.  ECS could be used for a variety of purposes, including containing user data arrays that were too large for central memory, holding often-used files, swapping, and even as a communication path in a multi-mainframe complex.</p>

</ss1>
<ss1>
<st>
Peripheral Processors (PPs)</st>
<p>

To handle the 'household' tasks which other designs put in the CPU, Cray included ten other processors, based partly on his earlier computer, the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../245/7650245.xml">
CDC 160A</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
. These machines, called Peripheral Processors, or PPs, were full computers in their own right, but were tuned to performing <link xlink:type="simple" xlink:href="../558/14558.xml">
I/O</link> tasks and running the operating system. One of the PPs was in overall control of the machine, including control of the program running on the main CPU, while the others would be dedicated to various I/O tasks&mdash;quite similarly to <link xlink:type="simple" xlink:href="../370/2470370.xml">
I/O channel</link>s in <link xlink:type="simple" xlink:href="../872/14872.xml">
IBM mainframe</link>s of the time. When the program needed to perform some sort of I/O, it instead loaded a small program into one of these other machines and let it do the work. The PP would then inform the CPU when the task was complete with an interrupt.</p>
<p>

Each PP included its own memory of 4096 12-bit words.  This memory served for both for I/O buffering and program storage, but the execution units were shared by 10 PPs, in a configration called the <link xlink:type="simple" xlink:href="../824/1274824.xml">
Barrel and slot</link>. This meant that the execution units (the "slot") would execute one instruction cycle from the first PP, then one instruction cycle from the second PP, etc. in a round robin fashion. This was done both to reduce costs, and because access to CP memory required 10 PP clock cycles: when a PP accesses CP memory, the data is available next time the PP receives its slot time.</p>

</ss1>
<ss1>
<st>
Wordlengths, characters</st>
<p>

The central processor had 60-bit words, whilst the peripheral processors had 12-bit words. CDC used the term "byte" to refer to 12-bit entities used by peripheral processors; characters were 6-bit, and central processor instructions were either 15 bits, or 30 bits with a signed 18-bit address field, the latter allowing for a directly addressable memory space of 128K words of central memory (converted to modern terms, with 8-bit bytes, this is 0.94 megabytes). The signed nature of the address registers limited an individual program to 128K words.  (Later CDC 6000-compatible machines could have 256K or more words of central memory, budget permitting, but individual user programs were still limited to 128K words of CM.)  Central processor instructions started on a word boundary when they were the target of a jump statement or subroutine return jump instruction, so no-operations were sometimes required to fill out the last 15, 30 or 45 bits of a word. </p>
<p>

The 6-bit characters, in an encoding called <link xlink:type="simple" xlink:href="../830/4488830.xml">
display code</link>, could be used to store up to 10 characters in a word. They permitted a character set of 64 characters, which is enough for all upper case letters, digits, and some punctuation. Certainly, enough to write <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link>, or print financial or scientific reports. There were actually two variations of the <link xlink:type="simple" xlink:href="../830/4488830.xml">
display code</link> character sets in use, 64-character and 63-character. The 64-character set had the disadvantage that two consecutive ':' (colon) characters might be interpreted as the end of a line if they fell at the end of a 10-byte word.  A later variant, called 6/12 <link xlink:type="simple" xlink:href="../830/4488830.xml">
display code</link>, was also used in the KRONOS and <link xlink:type="simple" xlink:href="../363/8716363.xml">
NOS</link> timesharing systems to allow full use of the <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<representation wordnetid="105926676" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../586/586.xml">
ASCII</link></rule>
</direction>
</representation>
</protocol>
</message>
 character set in a manner somewhat compatible with older software.</p>
<p>

With no byte addressing instructions at all, code had to be written to pack and shift characters into words. The very large words, and comparatively small amount of memory, meant that programmers would frequently economize on memory by packing data into words at the bit level.</p>
<p>

It is interesting to note that due to the large word size, and with 10 characters per word, it was often faster to process words full of characters at a time - rather than unpacking/processing/repacking them.  For example, the CDC <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link> compiler was actually quite good at processing decimal fields using this technique.  These sorts of techniques are now commonly used in the 'multi-media' instructions of current processors.</p>

</ss1>
<ss1>
<st>
Physical design</st>
<p>

The machine was built in a plus-sign-shaped cabinet with a pump and heat exchanger in the outermost 18 inches of each of the 4 arms.  Cooling was done with <link xlink:type="simple" xlink:href="../280/232280.xml">
Freon</link> circulating within the machine and exchanging heat to an external chilled water supply.  Each arm could hold 4 chassis, each about 8 inches thick, hinged near the center, and opening a bit like a book.   The intersection of the "plus" was filled with cables which interconnected the chassis.   The chassis were numbered from 1 (containing all 10 PPUs and their memories, as well as the 12 rather minimal I/O channels) to 16.  The main memory for the CPU was spread over many of the chassis.  In a system with only 64K words of main memory, one of the arms of the "plus" was omitted. </p>
<p>

The logic of the machine was packaged into modules about 2.5 inches square and about an inch thick.  Each module had a connector (roughly 20 pins in each of 2 vertical rows) on one edge, and 6 test points on the opposite edge.  The module was placed between two aluminum cold plates to remove heat.  The module itself consisted of two parallel printed circuit boards, with components mounted either on one of the boards or between the two boards.  This provided a very dense, if somewhat difficult to repair, package with good heat removal that was known as <link xlink:type="simple" xlink:href="../742/695742.xml#xpointer(//*[./st=%22Other+meanings%22])">
cordwood packaging</link>.</p>

</ss1>
</sec>
<sec>
<st>
Operating system and programming</st>

<p>

If there was a sore point with the 6600 it was the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> support, which took entirely too long to work out.</p>
<p>

The machines originally ran a very simple <link xlink:type="simple" xlink:href="../285/37285.xml">
job-control</link> system known as <it>COS</it> (Chippewa Operating System), which was quickly "thrown together" based on the earlier <link xlink:type="simple" xlink:href="../080/2966080.xml">
CDC 3000</link> operating system in order to have something running to test the systems for delivery. However the machines were intended to be delivered with a much more powerful system known as <it>SIPROS</it> (for Simultaneous Processing Operating System), which was being developed at the company's System Sciences Division in <link xlink:type="simple" xlink:href="../110/18110.xml">
Los Angeles</link>. Customers were impressed with SIPROS's feature list, and many had SIPROS written into their delivery contracts.</p>
<p>

SIPROS turned out to be a major fiasco. Development timelines continued to slip, costing CDC major amounts of profit in the form of delivery delay penalties. After several months of waiting with the machines ready to be shipped, the project was eventually cancelled. Luckily the programmers who had worked on COS had little faith in SIPROS (likely due largely to <link xlink:type="simple" xlink:href="../102/60102.xml">
not invented here</link> syndrome) and had continued working on improving COS. </p>
<p>

<message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../119/229119.xml">
Operating system development</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
 then split into two camps. The CDC-sanctioned evolution of COS was undertaken at the Sunnyvale (California) software development lab. Many customers eventually took delivery of their systems with this software, then known as <it><link xlink:type="simple" xlink:href="../953/6975953.xml">
SCOPE</link></it> (Supervisory Control Of Program Execution). (Some Control Data Field Engineers used to refer to SCOPE as <it>Sunnyvale's Collection Of Programming Errors</it>). SCOPE version 1 was, essentially, dis-assembled COS; SCOPE version 2 included new device and file system support; SCOPE version 3 included permanent file support, EI/200 remote batch support, and INTERCOM <link xlink:type="simple" xlink:href="../958/30958.xml">
time sharing</link> support. SCOPE always had significant reliability and maintainability issues.</p>
<p>

The underground evolution of COS took place at the <village wordnetid="108672738" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../575/124575.xml">
Arden Hills, Minnesota</link></village>
 assembly plant. <it>MACE</it> ([Greg] Mansfield And [Dave] Cahlander Executive) was written largely by a single programmer in the off-hours when machines were available. Its feature set was essentially the same as COS and SCOPE 1. It retained the earlier COS file system, but made significant advances in code modularity to improve system reliability and adaptiveness to new storage devices. MACE was never an official product, although many customers were able to wrangle a copy from CDC.</p>
<p>

MACE was later used as the basis of <it><link xlink:type="simple" xlink:href="../989/5929989.xml">
KRONOS</link></it>, named after the <link xlink:type="simple" xlink:href="../576/79576.xml">
Greek god of time</link>. The main marketing reason for its adoption was the development of its TELEX <link xlink:type="simple" xlink:href="../958/30958.xml">
time sharing</link> feature and its BATCHIO remote batch feature. KRONOS continued to use the COS/SCOPE 1 file system with the addition of a permanent file feature.</p>
<p>

An attempt to unify the SCOPE and KRONOS operating system products produced <it><link xlink:type="simple" xlink:href="../363/8716363.xml">
NOS</link></it>, (Network Operating System). NOS was intended to be the sole operating system for all CDC machines, a fact CDC promoted heavily. Many SCOPE customers remained software-dependent on the SCOPE architecture, so CDC simply renamed it <it><link>
NOS/BE</link></it> (Batch Environment), and were able to claim that everyone was thus running NOS. In practice, it was far easier to modify the KRONOS code base to add SCOPE features than the reverse.</p>
<p>

The assembly plant environment also produced other operating systems which were never intended for customer use. These included the engineering tools SMM for hardware testing, and KALEIDOSCOPE, for software <link xlink:type="simple" xlink:href="../049/46049.xml">
smoke testing</link>. Another commonly used tool for CDC Field Engineers during testing was MALET (Maintenance Application Language for Equipment Testing), which was used to stress test components and devices after repairs and/or servicing by engineers. Testing conditions often used hard disk packs and magnetic tapes which were deliberately marked with errors to determine if the errors would be detected by MALET and the engineer.</p>

</sec>
<sec>
<st>
Emulation</st>
<p>

<link xlink:type="simple" xlink:href="../123/15411123.xml">
Desktop CYBER</link> emulates the CDC 6400 and various CDC CYBER mainframes in software running on modern desktop PCs.</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

Grishman, Ralph (1974). <it>Assembly Language Programming for the Control Data 6000 Series and the Cyber 70 Series</it>. New York, NY: Algorithmics Press. <weblink xlink:type="simple" xlink:href="http://computer-refuge.org/bitsavers/pdf/cdc/6x00/books/Grishman_CDC6000AsmLangPgmg.pdf">
http://computer-refuge.org/bitsavers/pdf/cdc/6x00/books/Grishman_CDC6000AsmLangPgmg.pdf</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://ed-thelen.org/comp-hist/CDC-6600-R-M.html#TOC/">
CONTROL DATA 6400/6500/6600 COMPUTER SYSTEMS Reference Manual</weblink></entry>
<entry level="1" type="bullet">

Thornton, J. (1963). <it>Considerations in Computer Design - Leading up to the Control Data 6600</it> <weblink xlink:type="simple" xlink:href="http://computer-refuge.org/bitsavers/pdf/cdc/6x00/thornton_6600_paper.pdf">
http://computer-refuge.org/bitsavers/pdf/cdc/6x00/thornton_6600_paper.pdf</weblink></entry>
<entry level="1" type="bullet">

Thornton, J. (1970). <it>Design of a Computer -- The Control Data 6600</it>. Glenview, IL: Scott, Foresman and Co. <weblink xlink:type="simple" xlink:href="http://computer-refuge.org/bitsavers/pdf/cdc/6x00/books/DesignOfAComputer_CDC6600.pdf">
http://computer-refuge.org/bitsavers/pdf/cdc/6x00/books/DesignOfAComputer_CDC6600.pdf</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../803/4120803.xml">
CDC 6000 series</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://research.microsoft.com/~gbell/Computer_Structures__Readings_and_Examples/00000509.htm">
Parallel operation in the Control Data 6600, James Thornton</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/gbell/craytalk/sld001.htm">
Presentation of the CDC 6600 and other machines designed by Seymour Cray</weblink> &ndash; by C. <expert wordnetid="109617867" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<interior_designer wordnetid="110210648" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<specialist wordnetid="110631941" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<link xlink:type="simple" xlink:href="../136/349136.xml">
Gordon Bell</link></originator>
</employee>
</causal_agent>
</worker>
</creator>
</associate>
</engineer>
</colleague>
</specialist>
</pioneer>
</interior_designer>
</person>
</physical_entity>
</peer>
</expert>
 of Microsoft Research (formerly of DEC)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://members.iinet.net.au/~tom-hunter/">
Emulator of a "typical" CDC CYBER 6600, 7x, 17x based system</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
