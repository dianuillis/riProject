<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:47:09[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<system  confidence="0.8" wordnetid="104377057">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Object-relational mapping</title>
<id>59202</id>
<revision>
<id>244315958</id>
<timestamp>2008-10-10T06:14:55Z</timestamp>
<contributor>
<username>DragonBot</username>
<id>5466012</id>
</contributor>
</revision>
<categories>
<category>Databases</category>
<category>Database management systems</category>
<category>Articles with specifically-marked weasel-worded phrases</category>
</categories>
</header>
<bdy>

For another use of "ORM", see <link xlink:type="simple" xlink:href="../006/827006.xml">
Object role modelling</link>.
<b>Object-relational mapping</b> (aka <b>ORM</b>, <b>O/RM</b>, and <b>O/R mapping</b>) is a <link xlink:type="simple" xlink:href="../311/5311.xml">
programming</link> technique for converting data between incompatible <link xlink:type="simple" xlink:href="../701/199701.xml">
type system</link>s in <link xlink:type="simple" xlink:href="../873/25873.xml">
relational database</link>s and <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented</link> programming languages. This creates, in effect, a "virtual <link xlink:type="simple" xlink:href="../826/22826.xml">
object database</link>" which can be used from within the programming language. There are both free and commercial packages available that perform object-relational mapping, although some programmers opt to create their own ORM tools.
<sec>
<st>
Problem description</st>
<p>

<b>Data management</b> tasks in object-oriented (OO) programming are typically implemented by manipulating <link xlink:type="simple" xlink:href="../665/169665.xml">
objects</link>, which are almost always non-scalar values. For example, consider an address book entry which represents a single person along with zero or more phone numbers and zero or more addresses. This could be modeled in an object-oriented implementation by a "person <link>
object</link>" with "slots" to hold the data that comprise the entry: the person's name, a list (or <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>) of phone numbers, and a list of addresses. The list of phone numbers would itself contain "phone number objects" and so on. The address book entry is treated as a single value by the programming language (it can be referenced by a single variable, for instance). Various methods can be associated with the object, such as a method to return the preferred phone number, the home address, and so on.</p>
<p>

However, many popular database products such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
 <link xlink:type="simple" xlink:href="../513/8513.xml">
DBMS</link> can only store and manipulate <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../475/5565475.xml">
scalar</link></kind>
</type>
</category>
</concept>
</idea>
 values such as integers and strings organized within <link xlink:type="simple" xlink:href="../163/1701163.xml">
tables</link>.</p>
<p>

The programmer must either convert the object values into groups of simpler values for storage in the database (and convert them back upon retrieval), or only use simple scalar values within the program. Object-relational mapping is used to implement the first approach.</p>
<p>

The crux of the problem is translating those objects to forms which can be stored in the database, and which can later be retrieved easily, while preserving the properties of the objects and their relationships; these objects are then said to be <link xlink:type="simple" xlink:href="../550/6025550.xml">
persistent</link>.</p>

</sec>
<sec>
<st>
Implementations</st>
<p>

The most common type of database used is the relational database, which predates the rise of object-oriented programming in the 1990s. Relational databases use a series of <it><link xlink:type="simple" xlink:href="../163/1701163.xml">
table</link>s</it> to organize data. Data in different tables are associated through the use of declarative constraints, rather than explicit pointers or links. The same data that can be stored in a single object value would likely need to be stored across several of these tables.</p>
<p>

An object-relational mapping implementation should systematically and predictably choose which tables to use and generate the necessary SQL. The <link xlink:type="simple" xlink:href="../278/2063278.xml">
Object-Relational impedance mismatch</link> between object oriented languages, such as <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, <link>
 C#</link>, or <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, and data stored in a relational database management system (<link xlink:type="simple" xlink:href="../743/98743.xml">
RDBMS</link>), such as <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../725/323725.xml">
Oracle</link></instrumentality>
</artifact>
</system>
, <link>
 SQL Server</link> or <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../983/142983.xml">
IBM DB2</link></instrumentality>
</artifact>
</system>
, presents a number of challenges in achieving:
<list>
<entry level="1" type="bullet">

 performance,</entry>
<entry level="1" type="bullet">

 linear <link xlink:type="simple" xlink:href="../529/185529.xml">
scalability</link>,</entry>
<entry level="1" type="bullet">

 manageability of the <link xlink:type="simple" xlink:href="../180/287180.xml">
CRUD</link> (Create, read, update and delete) operations for complex relationships,</entry>
<entry level="1" type="bullet">

 simplification and consistency of coding for <link xlink:type="simple" xlink:href="../993/239993.xml">
rapid application development</link>,</entry>
<entry level="1" type="bullet">

 application maintainability and flexibility</entry>
</list>

The real values in using an ORM tool are to save time, simplify development (i.e. the ORM tool handles the complexity for the developer), increase performance or scalability, and minimize architectural challenges related to inability of the ORM tool or developer's experience.</p>
<p>

Many packages have been developed to reduce the tedium of developing object-relational mapping systems by providing libraries of classes which are able to perform mappings automatically. Given a list of tables in the database, and objects in the program, they will automatically map requests from one to the other. Asking a person object for its phone numbers will result in the proper query being created and sent, and the results being translated directly into phone number objects inside the program. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

From a programmer's perspective, the system should look like a persistent object store. One can create objects and work with them as one would normally, and they automatically end up in the database.</p>
<p>

In practice, however, things are never quite that simple. All ORM systems tend to make themselves visible in various ways, reducing to some degree one's ability to ignore the database. Worse, the translation layer can be slow and inefficient (notably in terms of the <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
 it writes), resulting in programs that are slower and use more memory than code written "by hand."</p>
<p>

A number of ORM systems have been created over the years, but their effect on the market seems mixed. <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
's <link xlink:type="simple" xlink:href="../561/59561.xml">
Enterprise Objects Framework</link> (EOF) was once considered one of the best such systems, but it never achieved broad marketshare, chiefly because it was tightly tied to NeXT's entire toolkit, <link xlink:type="simple" xlink:href="../114/53114.xml">
OpenStep</link>. It was later integrated into <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
's  <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/317400.xml">
WebObjects</link></software>
, the first object-oriented Web Application Server. Since <link xlink:type="simple" xlink:href="../856/856.xml">
Apple Computer</link> bought <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
 in 1997, EOF provides the technology behind the company's e-commerce Web site, the <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../446/288446.xml">
.Mac</link></software>
 services and the <link xlink:type="simple" xlink:href="../232/218232.xml">
iTunes Music Store</link>.  Apple provides EOF in two implementations: the Objective-C implementation that comes with the Apple Developers Tools and the Pure Java implementation that comes in <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/317400.xml">
WebObjects</link></software>
 5.X.</p>
<p>

<link xlink:type="simple" xlink:href="../561/59561.xml">
Enterprise Objects Framework</link> has influenced and inspired many subsequent ORM efforts, including open source <link xlink:type="simple" xlink:href="../708/11719708.xml">
Apache Cayenne</link>. Cayenne has similar goals to EOF and aims to meet the <weblink xlink:type="simple" xlink:href="http://jcp.org/en/jsr/detail?id=220">
JPA standard</weblink>.</p>
<p>

An alternative approach is being taken with technologies such as <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../847/53847.xml">
RDF</link></format>
 and <work wordnetid="100575741" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<service wordnetid="100577525" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../343/2574343.xml">
SPARQL</link></activity>
</system_of_measurement>
</psychological_feature>
</act>
</service>
</event>
</standard>
</work>
, and the concept of the "<link xlink:type="simple" xlink:href="../386/16727386.xml">
triplestore</link>". RDF is a serialization of the subject-predicate-object concept, <link xlink:type="simple" xlink:href="../688/13246688.xml">
RDF/XML</link> is an XML representation of it, <work wordnetid="100575741" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<service wordnetid="100577525" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../343/2574343.xml">
SPARQL</link></activity>
</system_of_measurement>
</psychological_feature>
</act>
</service>
</event>
</standard>
</work>
 is an SQL-like query language, and a <link xlink:type="simple" xlink:href="../386/16727386.xml">
triplestore</link> is a general description of any database that deals with a triple.</p>
<p>

More recently, a similar system has started to evolve in the Java world, known as <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../249/147249.xml">
Java Data Objects</link></request>
</message>
 (JDO). Unlike EOF, JDO is a standard, and several implementations are available from different vendors. The <link xlink:type="simple" xlink:href="../750/42750.xml">
Enterprise Java Beans</link> 3.0 (EJB3) specification also covers this same area. There has been standards conflict between the two standards bodies in terms of pre-eminence. JDO has several commercial implementations, while EJB 3.0 is still under development. However, most recently another new standard has been announced by JCP to bring these two standards together and make the future standard something that works with various Java architectures. </p>
<p>

Another example to mention is <software wordnetid="106566077" confidence="0.9508927676800064">
<link>
Hibernate</link></software>
, a popular O/R mapping framework in the Java world that has features similar to EJB3.  <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../261/3086261.xml">
NHibernate</link></software>
 is a free, open-source port of Hibernate to the Microsoft .NET platform.</p>
<p>

<link xlink:type="simple" xlink:href="../705/3488705.xml">
Service Data Objects</link> is another standard driven by the need of delivering updatable datagraphs to business level components written in any programming language. Then the O/R mapping is done at the data access layer level, possibly driven by an enterprise <link xlink:type="simple" xlink:href="../632/18933632.xml">
Metadata</link> repository, and reusable by every client application.</p>

</sec>
<sec>
<st>
Non-SQL databases</st>

<p>

Another solution would be to use an <link xlink:type="simple" xlink:href="../826/22826.xml">
object-oriented database management system</link>, which, as the name implies, is a database designed specifically for working with object-oriented values. Using an OODBMS would eliminate the need for converting data to and from its SQL form, as the data would be stored in its original object representation.</p>
<p>

Object-oriented databases have yet to come into widespread use. One of their main limitations is that switching from an SQL DBMS to a purely object-oriented DBMS means you lose the capability to create <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
 queries, a tried and tested method for retrieving ad-hoc combinations of data. For this reason, many programmers find themselves more at home with an object-SQL mapping system, even though most commercial object-oriented databases are able to process SQL queries to a limited extent.</p>

</sec>
<sec>
<st>
Criticism</st>
<p>

Some &#91;&#93; have proposed that the promotion of Object-Relational Mapping tools is symptomatic of an intent to solve <it>the wrong side</it> of the <link xlink:type="simple" xlink:href="../278/2063278.xml">
Object-Relational impedance mismatch</link> issue. The information principle underpinning <link xlink:type="simple" xlink:href="../873/25873.xml">
relational database</link>s implies that object orientation itself is inadequate for the full needs of data manipulation, and it is that '<link xlink:type="simple" xlink:href="../308/175308.xml">
paradigm</link>' as a whole that should be addressed. If this were the case, ORM would be left redundant.  In this view, the "impedance mismatch" and the supposed need for object-relational mapping arises from the mistaken equation of object and relation (table or view in SQL speak). The correct mapping in the relational model is between object and type.
Also, ORM systems tend to perform worse than writing SQL directly for more complex tasks. However, most ORM systems allow writing raw SQL to some degree.</p>
<p>

Because of the complexity associated with high performance physical data models, it is often impossible to build any usable interface to a relational database which is easily navigable by a naive user.  This is simply a consequence of having a high quality, normalized relational database. When interfacing with database, multiple tables must therefore be "merged" in the users view, or alternatively, information must be abstracted into data formats such as XML which utilize data structures which are more easily managed by object oriented methodologies.  </p>
<p>

These needs are almost ubiquitous in the enterprise environment, even when ORM tools are not being used.  This suggests the fact that many, if not all, data driven systems with high level interfaces which are not "ORM" in name must implement ORM on some level (especially since many enterprise systems are built on object oriented frameworks such as Java).  For example, a join operation on two related tables may be considered a type of object relational mapping since it merges lower level data tuples into a more easily navigable, higher order structure. Thus, a join is a way of hardcoding object relational logic into SQL.  </p>
<p>

ORM tools have been criticized for their tendency to eclipse the work done by Database Administrators for optimization and performance.  This issue has been solved by most tools by redundantly allowing hardcoded SQL, stored procedure calling, and by implementing dirty solutions for data acquisition and insertion, such as transaction management.  In addition, the convenience involved with caching custom selected data sets in memory using ORM methodologies makes the implementation of dirty solutions at the database level unnecessary in many environments.</p>
<p>

In this context, an ORM tool is simply any tool which joins relational data in the context of a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../333/1538333.xml">
business object</link></concept>
</idea>
 required for some real world application.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../136/5612136.xml">
List of object-relational mapping software</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../240/17034240.xml">
AutoFetch</link> - automatic query tuning</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../799/4096799.xml">
CORBA</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../377/8377.xml">
Database</link></entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../826/22826.xml">
Object database</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../788/19632788.xml">
Object Prevalence</link></entry>
<entry level="1" type="bullet">

<system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../960/68960.xml">
Object-relational database</link></instrumentality>
</artifact>
</system>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../278/2063278.xml">
Object-relational impedance mismatch</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../220/26220.xml">
Relational model</link></entry>
<entry level="1" type="bullet">

<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../705/3488705.xml">
Service Data Objects</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www.service-architecture.com/object-relational-mapping/articles/transparent_persistence.html">
Animation showing how an object-relational mapping utility works</weblink></entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.artima.com/intv/abstract3.html">
Anders Hejlsberg about ORM</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.upgrade.ur.ru/atlas/engl/">
ATLAS Object-Relational Mapping for .NET Framework</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.agiledata.org/essays/mappingObjects.html">
Scott W. Ambler: Mapping Objects to Relational Databases: O/R Mapping In Detail</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://c2.com/cgi/wiki?ObjectRelationalToolComparisonDotNet">
Object Relational Tool Comparison in .NET </weblink> - outdated</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html">
Core J2EE Design Pattern: Data Access Objects</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://madgeek.com/Articles/ORMapping/EN/mapping.htm">
Choosing an Object-Relational mapping tool</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://search.cpan.org/~ash/DBIx-Class-0.08010/lib/DBIx/Class/Manual/Intro.pod">
Perl's DBIx::Class ORM</weblink></entry>
</list>
</p>




</sec>
</bdy>
</entity>
</instrumentality>
</artifact>
</system>
</article>
