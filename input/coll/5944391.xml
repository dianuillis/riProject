<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:06:06[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Hopcroft–Karp algorithm</title>
<id>5944391</id>
<revision>
<id>244527883</id>
<timestamp>2008-10-11T07:17:12Z</timestamp>
<contributor>
<username>Michael Veksler</username>
<id>8043180</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>

The <b>Hopcroft–Karp algorithm</b> finds maximum cardinality <link xlink:type="simple" xlink:href="../797/581797.xml">
matching</link>s in <link xlink:type="simple" xlink:href="../431/244431.xml">
bipartite graph</link>s in <math>O(\sqrt{V} E)</math> time, where <it>V</it> is the number of vertices and <it>E</it> is the number of edges of the graph.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> In the worst case of dense graphs, i.e., when <math>E=O(V^2)</math>, the worst-case time estimate is <math>O(V^{5/2})</math>. <p>

The algorithm is an adaptation of the <link xlink:type="simple" xlink:href="../230/239230.xml">
Edmonds-Karp algorithm</link> for maximum flow, since bipartite matching is equivalent to finding the maximum (integer) flow if the vertices in each partition are considered sources (respectively sinks) of capacity 1. The <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../130/78130.xml">
minimal cut</link></proposition>
</theorem>
</message>
</statement>
 associated with the flow is equivalent to the <link>
minimal vertex cover</link> associated with the matching.</p>
<p>

Instead of finding just a single augmenting path, the algorithm finds a maximal set of shortest paths in each iteration <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>. As a result only <math>O(\sqrt{V})</math> iterations are needed.</p>



<sec>
<st>
 Definition </st>


<p>

Consider a graph G(V,E). The following definitions are relative to a matching M in G.
<list>
<entry level="1" type="bullet">

 An alternating path is a path in which the edges would belong alternatively to M and E-M. </entry>
<entry level="1" type="bullet">

 A free vertex is a vertex which has no incoming edges which belong to M.</entry>
<entry level="1" type="bullet">

 Finally, an augmenting path P is an alternating path such that both its end points are free vertices.</entry>
<entry level="1" type="bullet">

 Symmetric difference <math>M'=M\oplus P</math> has all edges of M and P except shared edges <math>M\cap P</math></entry>
</list>
</p>

</sec>
<sec>
<st>
 Algorithm </st>

<p>

The Basic concept that the algorithm relies on is that if we have a matching N of size n, and P is the augmenting path relative to N, then the matching <math>N\oplus P</math> would have a size of n+1. Thus, since there would be no matching greater in size than the maximum matching, the maximum matching would not have an augmenting path. </p>
<p>

Lets name the two sets in which G can be partitioned as U and V. The matching from U to V at any time is represented as the set M.</p>
<p>

The algorithm is run in phases. Each phase consists of:
<list>
<entry level="1" type="bullet">

 A BFS is run from free U vertices. This BFS stops at layer <it>k</it> where one or more free V vertices are reached. Collect <it>all</it> free V vertices at layer <it>k</it> and put them in the set F. A vertex <it>v</it> is put in F iff  <math> v\in V</math> and <it>v</it> ends a shortest augmenting path.</entry>
<entry level="1" type="bullet">

 Find a maximal set of <it>vertex disjoint</it> augmenting paths of length <it>k</it>. This is set is computed by DFS from F  (computed by BFS) to free U vertices. Every one of this paths is used to enlarge M.</entry>
</list>
</p>
<p>

<it>Pseudo Code</it>
for all <math>q\in U \cup V</math>
q.matching= null;
end for
while (true)
// Find all potential beginnings of shortest augmenting paths
B := empty;
for all u:U s.t. (u.matching = null)
insert u in B;
end for</p>
<p>

// Find all endings of shortest augmenting paths
F := Find_Augmenting_Path_Endings(B);
if (F is empty)
M:= empty;
for all u:U s.t. (u.matching ≠ null)
insert (u, u.matching) in M; // insert edge
end for
return M;
end if
Augment_Paths(F);
end while</p>
<p>

// Perform BFS starting with vertices of B.
// <b>Return</b>: a list of free vertices which potentially 
//         end the shortest vertex-disjoint augmenting paths.
// <b>Side effect</b>: For any vertex v.layer has the index of
//              the BFS layer to reach this vertex (or -1)
// <b>B</b>: potential beginning of augmenting paths
Find_Augmenting_Path_Endings(B):</p>
<p>

Q := B;
// F: The set of free endings (the other side of augmenting paths)
F := empty;
for all <math>q\in U \cup V</math>
q.layer:=-1;
end for
// The potential beginnings of augmenting paths are at layer 0.
for all b:B
b.layer:=0;
end for</p>
<p>

while (Q is not empty)
Q' := empty;
for all q: Q
for all (q,p):E s.t. (p.layer = -1)
p.layer:= q.layer+1;
if (p.matching = null)
insert p in F; // Collect the free vertex, continue BFS
else
insert p in Q';
end if
end for
end for
if (F is not empty)
return F; // Free vertices found, stop at this layer.
end if
Q:= empty;
for all q:Q'
// By construction, q matched.
p:= q.matching;
p.layer:= q.layer+1;
insert p in Q;
end for
end while
return empty;</p>
<p>

Augment_Paths(F): 
for all <math>q\in U \cup V</math>
q.visited= false;
end for
for all q:F
P:=Get_Augmenting_Path(q);
// Make sure q ends a <it>vertex-disjoint</it> augmenting path
if (P is not empty) 
// Perform <math> M := M\oplus P </math>
odd := true;
for all (t,q):P
if (odd)
// Make (t,q) match (first, third, ... edges)
p.matching := q;
q.matching := t;
odd := false;
else
// t.matching has already been updated by the <it>odd</it> condition
q.matching := null; // This is not strictly required
odd := true;
end if
end for
end if
end for</p>
<p>

// DFS from p, avoiding previously visited vertices.
// Start at the last layer of BFS, and go backwards
// to layer 0.
Get_Augmenting_Path(p):
if (p.visited)
return empty;
end if
p.visited:= true;
if (p.layer = 0) // layer 0 has free vertices.
return (p);
end if
// Consider only edges going one layer backwards.
for all (q,p):E such that p.layer+1=q.layer
P= Get_Augmenting_Path(q);
if (P not empty)
return (q, P); // Prepend q to the path found so far.
end if
end for
// Could not find a vertex-disjoint augmenting path ending with p.
return empty;</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
John E. Hopcroft, Richard M. Karp: <it>An <math>n^{5/2}</math> Algorithm for Maximum Matchings in Bipartite Graphs.</it> SIAM J. Comput. 2(4), 225-231 (1973)</entry>
<entry id="2">
 <cite id="Reference-Cormen-2001" style="font-style:normal" class="book"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Cormen, Thomas H.</link></scientist>
;&#32;<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Leiserson, Charles E.</link></scientist>
, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../057/68057.xml">
Rivest, Ronald L.</link></scientist>
</person>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Stein, Clifford</link></scientist>
&#32;[1990]&#32;(2001).&#32;"26.5: The relabel-to-front algorithm", <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, 2nd edition,&#32;<company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../601/719601.xml">
MIT Press</link></company>
 and <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../269/651269.xml">
McGraw-Hill</link></company>
,&#32;pp. 696–697. ISBN 0-262-03293-7.</cite>&nbsp;</entry>
<entry id="3">
Norbert Blum&#32;(1999).&#32;"<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/258961.html">
A Simplified Realization of the Hopcroft-Karp Approach to Maximum Matching in Nonbipartite Graphs</weblink>".</entry>
</reflist>
</p>




</sec>
</bdy>
</algorithm>
</article>
