<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:05:09[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<entity  confidence="0.9511911446218017" wordnetid="100001740">
<header>
<title>Rabin signature algorithm</title>
<id>5954800</id>
<revision>
<id>219696593</id>
<timestamp>2008-06-16T13:33:17Z</timestamp>
<contributor>
<username>Doma-w</username>
<id>3099163</id>
</contributor>
</revision>
<categories>
<category>Asymmetric-key cryptosystems</category>
<category>Cryptography</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link> the <b>Rabin Signature Scheme</b> is a method of <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../644/59644.xml">
Digital signature</link></writing>
</written_communication>
</document>
 originally proposed by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../404/298404.xml">
Michael O. Rabin</link></scientist>
</person>
 in <link xlink:type="simple" xlink:href="../754/34754.xml">
1979</link>.  The Rabin          Signature Scheme was one of the first digital signature schemes proposed, and it was the first to relate the hardness of forgery directly to the problem of integer    factorization.  Because of its simplicity and prominent role in early public key cryptography, the Rabin Signature Scheme is covered in most introductory courses on   cryptography.  The Rabin Signature Scheme is <link>
existentially unforgeable</link> in the <link xlink:type="simple" xlink:href="../286/451286.xml">
random oracle</link> model assuming the <link xlink:type="simple" xlink:href="../491/15491.xml">
integer factorization</link>   problem is intractable.  The Rabin Signature Scheme is also closely related to the <link xlink:type="simple" xlink:href="../283/451283.xml">
Rabin cryptosystem</link>.
<sec>
<st>
Original Algorithm</st>
<p>

The algorithm relies on a collision-resistant hash function <math>H : \{0,1\}^* \rightarrow \{0,1\}^k</math></p>
<p>

<list>
<entry level="1" type="bullet">

<b>Key Generation</b></entry>
<entry level="2" type="bullet">

The signer <it>S</it> chooses primes <it>p</it>,<it>q</it> each of size approximately <it>k/2</it> bits, and computes the product <math>n = pq</math></entry>
<entry level="2" type="bullet">

<it>S</it> then chooses a random <it>b</it> in <math>\{1,\ldots,n\}</math>.</entry>
<entry level="2" type="bullet">

The public key is <it>(n,b)''</it></entry>
<entry level="2" type="bullet">

The private key is <it>(p,q)''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Signing</b></entry>
<entry level="2" type="bullet">

To sign a message <it>m</it> the signer <it>S</it> picks random padding <it>U</it> and calculates <it>H(mU)''</it></entry>
<entry level="2" type="bullet">

<it>S</it> then solves <math>x(x+b) = H(mU) \mod n</math></entry>
<entry level="2" type="bullet">

If there is no solution <it>S</it> picks a new pad <it>U</it> and tries again.  If <it>H</it> is truly random the expected number of tries is 4.</entry>
<entry level="2" type="bullet">

The signature on <it>m</it> is the pair <it>(U,x)''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Verification</b></entry>
<entry level="2" type="bullet">

Given a message <it>m</it> and a signature <it>(U,x)</it> the verifier <it>V</it> calculates <it>x(x+b)</it> and <it>H(mU)</it> and verifies that they are equal</entry>
</list>
</p>

</sec>
<sec>
<st>
Modern Terminology</st>
<p>

In modern presentations, the algorithm is often simplified as follows</p>
<p>

The hash function <it>H</it> is assumed to be a <link xlink:type="simple" xlink:href="../286/451286.xml">
random oracle</link> and the algorithm works as follows</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Key Generation</b></entry>
<entry level="2" type="bullet">

The signer <it>S</it> chooses primes <it>p</it>,<it>q</it> each of size approximately <it>k/2</it> bits, and computes the product <math>n = pq</math></entry>
<entry level="2" type="bullet">

The public key is <it>n''</it></entry>
<entry level="2" type="bullet">

The private key is <it>(p,q)''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Signing</b></entry>
<entry level="2" type="bullet">

To sign a message <it>m' the signer </it>S<it> picks random padding </it>U<it> and calculates </it>H(mU)''</entry>
<entry level="2" type="bullet">

If <it>H(mU)</it> is not a square modulo <it>n</it>, <it>S</it> picks a new pad <it>U''</it></entry>
<entry level="2" type="bullet">

<it>S</it> solves the equation <math>x^2 = H(mU) \mod n</math></entry>
<entry level="2" type="bullet">

The signature on <it>m</it> is the pair <it>(U,x)''</it></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<b>Verification</b></entry>
<entry level="2" type="bullet">

Given a message <it>m</it> and a signature <it>(U,x)</it> the verifier <it>V</it> calculates <it>x</it>2 and <it>H(mU)</it> and verifies that they are equal</entry>
</list>
</p>
<p>

In some treatments, the random pad <it>U</it> is eliminated and instead we add two numbers <it>a</it> and <it>b</it> to the public key with <math>(\tfrac{a}{p}) = -(\tfrac{a}{q}) = 1</math> and <math>(\tfrac{b}{q}) = -(\tfrac{b}{p}) = 1</math> where <math>(\cdot)</math> denotes the <link xlink:type="simple" xlink:href="../567/18567.xml">
legendre symbol</link>.  Then for any <it>r</it> modulo <it>n</it> exactly one of the four numbers <math>r,ar,br,abr</math> will be a square, and the signer chooses that one for   his signature.</p>

</sec>
<sec>
<st>
Security</st>
<p>

If <it>H</it> is a random oracle, i.e. its output is truly random in <math>\mathbb{Z}/n\mathbb{Z}</math> then, forging a signature on any message <it>m</it> is as hard as
calculating the square root of a random element in <math>\mathbb{Z}/n\mathbb{Z}</math>.  To see that taking a random square root is as hard as factoring, we first     note that any square modulo <it>n</it> has four square roots since <it>n</it> has two square roots modulo <it>p</it> and two square roots modulo <it>q</it>, and each pair gives a unique  square root modulo <it>n</it> by the <link xlink:type="simple" xlink:href="../713/7713.xml">
chinese remainder theorem</link>.  Now, if we have two different square roots, <it>x</it>,<it>y</it> such that <math>x^2 = y^2 \mod n</math> but    <math>x \ne \pm y \mod n</math>, then this immediately leads to a factorization of <it>n</it> since <it>n</it> divides <math>x^2 - y^2 = (x-y)(x+y)</math> but it does not divide either factor.  Thus taking <math>gcd(x\pm y,n)</math> will lead to a nontrivial factorization of <it>n</it>.  Now, there exists an algorithm to take square roots, we pick a random <it>r</it> modulo <it>n</it> and square it <math>r^2 = R \mod n</math>, then, using the algorithm to take the square root of <it>R</it> modulo <it>n</it>, we will get a  new square root <math>r^\prime</math>, and with probability half <math>r \ne \pm r^\prime \mod n</math>.</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://publications.csail.mit.edu/lcs/pubs/pdf/MIT-LCS-TR-212.pdf">
Original Paper</weblink></entry>
</list>
</p>


</sec>
</bdy>
</entity>
</article>
