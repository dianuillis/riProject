<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:45:41[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Enterprise Objects Framework</title>
<id>59561</id>
<revision>
<id>230609435</id>
<timestamp>2008-08-08T13:40:14Z</timestamp>
<contributor>
<username>Perique des Palottes</username>
<id>2630</id>
</contributor>
</revision>
<categories>
<category>Data management</category>
</categories>
</header>
<bdy>

The <b>Enterprise Objects Framework</b> (or more commonly, <it>EOF</it>) was introduced by <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
 in 1994 as a pioneering <link xlink:type="simple" xlink:href="../202/59202.xml">
object-relational mapping</link> product for its <link xlink:type="simple" xlink:href="../642/40642.xml">
NeXTSTEP</link> and <link xlink:type="simple" xlink:href="../114/53114.xml">
OpenStep</link> development platforms. The EOF abstracts the process of interacting with a <link xlink:type="simple" xlink:href="../873/25873.xml">
relational database</link>, mapping database rows to <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 or <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/22802.xml">
Objective-C</link></programming_language>
 <link xlink:type="simple" xlink:href="../665/169665.xml">
objects</link>. This largely relieves developers from writing low-level <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
 code. EOF enjoyed some niche success in the mid-1990s among financial institutions who were attracted to the rapid application development advantages of NeXT's object-oriented platform. Since <link xlink:type="simple" xlink:href="../856/856.xml">
Apple Computer</link>'s merger with NeXT in 1996, EOF has evolved into a fully-integrated part of Apple's web application server software, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/317400.xml">
WebObjects</link></software>
, where it is considered by many to be a hallmark feature.
<sec>
<st>
 History </st>

<p>

In the early 1990s <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
 Computer recognized that connecting to databases was essential to most businesses and yet also potentially complex.  Every data source has a different data-access language (or <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link>), driving up the costs to learn and use each vendor's product. The NeXT engineers wanted to apply the advantages of <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented programming</link>, by getting objects to "talk" to relational databases. As the two technologies are very different, the solution was to create an abstraction layer, insulating developers from writing the low-level procedural code (<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../004/29004.xml">
SQL</link></programming_language>
) specific to each data source.</p>
<p>

The first attempt came in <link xlink:type="simple" xlink:href="../669/34669.xml">
1992</link> with the release of Database Kit (DBKit), which wrapped an object-oriented framework around any database. Unfortunately, <link xlink:type="simple" xlink:href="../642/40642.xml">
NEXTSTEP</link> at the time was not powerful enough and DBKit had serious design flaws.</p>
<p>

<image location="right" width="150px" src="EoSleeve.jpg" type="frame">
<caption>

Enterprise Objects Framework - packaging for beta CD (circa 1993/1994?)
</caption>
</image>
NeXT's second attempt came in <link xlink:type="simple" xlink:href="../337/18948337.xml">
1994</link> with the Enterprise Objects Framework (EOF) version 1. While far more powerful than dbKit, the basic concepts behind it were the same.</p>
<p>

A <link xlink:type="simple" xlink:href="../181/13653181.xml">
complete rewrite</link> of the underpinings, to make it more modular and <link xlink:type="simple" xlink:href="../114/53114.xml">
OpenStep</link> compatible, led to the release of EOF 2.0 in late <link xlink:type="simple" xlink:href="../658/34658.xml">
1995</link>. EOF 2.0 was the first product released by <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../694/21694.xml">
NeXT</link></company>
 using the Foundation Kit and introduced autoreleased objects to the developer community. The development team at the time was only three people: <link>
Craig Federighi</link>, Eric Noyau and Dan Willhite.</p>
<p>

EOF achieved a modest level of popularity in the financial programming community in the mid-1990s, but it would come into its own with the emergence of the <invention wordnetid="105633385" confidence="0.8">
<link xlink:type="simple" xlink:href="../139/33139.xml">
World Wide Web</link></invention>
 and the concept of <link xlink:type="simple" xlink:href="../311/288311.xml">
web application</link>s. It was clear that EOF could help companies plug their legacy databases into the Web without any rewriting of that data. With the addition of frameworks to do state management, load balancing and dynamic HTML generation, NeXT was able to launch the first object-oriented Web application server, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../400/317400.xml">
WebObjects</link></software>
, in <link xlink:type="simple" xlink:href="../636/34636.xml">
1996</link>, with EOF at its core.</p>
<p>

In <link xlink:type="simple" xlink:href="../548/34548.xml">
2000</link>, Apple Computer (which had merged with NeXT) officially dropped EOF as a standalone product, meaning that developers would be unable to use it to create desktop applications for the forthcoming <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>.  It would, however, continue to be an integral part of a major new release of WebObjects.  WebObjects 5, released in 2001, was significant for the fact that its frameworks had been ported from their native <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/22802.xml">
Objective-C</link></programming_language>
 programming language to the <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 language.  Critics of this change argue that most of the power of EOF was a side effect of its Objective-C roots, and that EOF lost the beauty or simplicity it once had.  Third-party tools, such as <link>
EOGenerator</link>, help fill the deficiencies introduced by Java (mainly due to the loss of <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/22802.xml#xpointer(//*[./st=%22Categories%22])">
categories</link></programming_language>
).</p>

</sec>
<sec>
<st>
How EOF works</st>

<p>

Enterprise Objects provides tools and frameworks for object-relational mapping. The technology specializes in providing mechanisms to retrieve data from various data sources, such as relational databases via JDBC and JNDI directories, and mechanisms to commit data back to those data sources. These mechanisms are designed in a layered, abstract approach that allows developers to think about data retrieval and commitment at a higher level than a specific data source or data source vendor.</p>
<p>

Central to this mapping is a model file (an "EOModel") that you build with a visual tool &mdash; either EOModeler, or the EOModeler plug-in to <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../878/356878.xml">
Xcode</link></software>
. The mapping works as follows:</p>
<p>

<list>
<entry level="1" type="bullet">

 Database tables are mapped to classes.</entry>
<entry level="1" type="bullet">

 Database columns are mapped to class attributes.</entry>
<entry level="1" type="bullet">

 Database rows are mapped to objects (or class instances).</entry>
</list>
</p>
<p>

You can build data models based on existing data sources or you can build data models from scratch, which you then use to create data structures (tables, columns, joins) in a data source. The result is that database records can be transposed into Java objects.</p>
<p>

The advantage of using data models is that applications are isolated from the idiosyncrasies of the data sources they access. This separation of an application’s business logic from database logic allows developers to change the database an application accesses without needing to change the application.</p>
<p>

EOF provides a level of database transparency not seen in other tools and allows the same model to be used to access different vendor databases and even allows relationships across different vendor databases without changing source code.</p>

<ss1>
<st>
Using Inheritance</st>

<p>

In designing Enterprise Objects developers can leverage the object-oriented feature known as <link xlink:type="simple" xlink:href="../746/2617746.xml">
inheritance</link>. A Customer object and an Employee object, for example, might both inherit certain characteristics from a more generic Person object, such as name, address, and phone number. While this kind of thinking is inherent in object-oriented design, relational databases have no explicit support for inheritance. However, using Enterprise Objects, you can build data models that reflect object hierarchies. That is, you can design database tables to support inheritance by also designing enterprise objects that map to multiple tables or particular views of a database table.</p>

</ss1>
</sec>
<sec>
<st>
What is an Enterprise Object (EO)? </st>

<p>

An Enterprise Object is analogous to what is often known in object-oriented programming as a <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../333/1538333.xml">
business object</link></concept>
</idea>
 &mdash; a class which models a physical or <link xlink:type="simple" xlink:href="../995/509995.xml">
conceptual object</link> in the business domain (eg. a customer, an order, an item, etc.). What makes an EO different from other objects is that its instance data maps to a data store. Typically, an enterprise object contains key-value pairs that represent a row in a relational database. The key is basically the column name, and the value is what was in that row in the database. So it can be said that an EO's properties persist beyond the life of any particular running application.</p>
<p>

More precisely, an Enterprise Object is an instance of a class that implements the com.webobjects.eocontrol.EOEnterpriseObject interface.</p>
<p>

An Enterprise Object has a corresponding model (called an EOModel) that defines the mapping between the class’s object model and the database schema. However, an enterprise object doesn’t explicitly know about its model. This level of abstraction means that database vendors can be switched without it affecting the developer's code. This gives Enterprise Objects a high degree of reusability.</p>

</sec>
<sec>
<st>
 EOF and Core Data </st>

<p>

Many of the concepts behind EOF were re-introduced to desktop application developers with the release of <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link> Tiger in <fundamental_quantity wordnetid="113575869" confidence="0.8">
<time_period wordnetid="115113229" confidence="0.8">
<time wordnetid="115122231" confidence="0.8">
<day wordnetid="115123115" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/1490045.xml">
April 2005</link></day>
</time>
</time_period>
</fundamental_quantity>
.  <link xlink:type="simple" xlink:href="../228/2400228.xml">
Core Data</link> is an object-graph management and persistence framework for developers using Apple's <link xlink:type="simple" xlink:href="../890/55890.xml">
Cocoa API</link>.  In simple terms, this means that Core Data organizes the application's model layer into a set of defined in-memory data objects.  Core Data tracks changes to these objects and can reverse those changes on demand, such as when a user performs an undo command.  Then, when it is time to save changes to an application's data, Core Data takes care of archiving the objects to a persistent store.</p>
<p>

However, despite many similarities, the two technologies have different goals.  EOF is a <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
-based framework that connects as a client to a database server.  Core Data is an <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/22802.xml">
Objective-C</link></programming_language>
-based framework designed to support desktop application development.  Core Data supports a number of features not supported by EOF, and vice-versa.</p>

<ss1>
<st>
 Features Supported Only by EOF </st>
<p>

EOF allows you to use custom SQL, shared editing contexts, and nested editing contexts.  Core Data does not provide the equivalent of an EOModelGroup—the NSManagedObjectModel class provides methods for merging models from existing models, and for retrieving merged models from bundles.  EOF supports pre-fetching and batch faulting of relationships, Core Data does not.</p>

</ss1>
<ss1>
<st>
 Features Supported Only by Core Data </st>
<p>

Core Data supports fetched properties; multiple configurations within a managed object model; local stores; and store aggregation (the data for a given entity may be spread across multiple stores); customization and localization of property names and validation warnings; and the use of predicates for property validation.</p>

</ss1>
</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://developer.apple.com/documentation/WebObjects/UsingEOModeler/">
Apple documentation: <it>Introduction to Using EOModeler''</it></weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://developer.apple.com/documentation/WebObjects/Enterprise_Objects/">
Apple documentation: <it>Enterprise Objects''</it></weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.apple.com/webobjects">
Apple WebObjects product page</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.linuxjournal.com/article.php?sid=7101&amp;mode=thread&amp;order=0&amp;thold=0">
article in linuxjournal about GDL2</weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
