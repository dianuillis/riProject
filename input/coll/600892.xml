<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:22:16[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Arbitrary-precision arithmetic</title>
<id>600892</id>
<revision>
<id>242764536</id>
<timestamp>2008-10-03T15:30:02Z</timestamp>
<contributor>
<username>Worobiew</username>
<id>5025754</id>
</contributor>
</revision>
<categories>
<category>Computer arithmetic</category>
<category>Arbitrary precision algorithms</category>
</categories>
</header>
<bdy>

On a <link xlink:type="simple" xlink:href="../457/7878457.xml">
computer</link>, <b>arbitrary-precision arithmetic</b>, also called <b>bignum</b> arithmetic, is a technique whereby <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s perform <link xlink:type="simple" xlink:href="../121/239121.xml">
calculation</link>s on <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>s or <link xlink:type="simple" xlink:href="../024/19727024.xml">
rational number</link>s (including <link xlink:type="simple" xlink:href="../376/11376.xml">
floating-point</link> numbers) with an arbitrary number of <link xlink:type="simple" xlink:href="../582/280582.xml">
digit</link>s of <link xlink:type="simple" xlink:href="../110/552110.xml">
precision</link>, typically limited only by the available <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link> of the host system.  Using many digits of precision, as opposed to the approximately 6&ndash;16 decimal digits available in most hardware arithmetic, is important for a number of applications as described below; the most widespread usage is probably for <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link> used in every modern <link xlink:type="simple" xlink:href="../173/33173.xml">
web browser</link>.<p>

It is often implemented by storing a number as a variable-length <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link> of digits in some <link xlink:type="simple" xlink:href="../368/5101368.xml">
base</link> such as 10 or 10000 or 256 or 65536, etc., in contrast to most computer arithmetic which uses a fixed number of <link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link>s in binary related to the size of the <link xlink:type="simple" xlink:href="../432/486432.xml">
processor register</link>s.  Numbers can be stored in a <link xlink:type="simple" xlink:href="../736/449736.xml">
fixed-point</link> format, or in a <link xlink:type="simple" xlink:href="../376/11376.xml">
floating-point</link> format as a <link xlink:type="simple" xlink:href="../250/419250.xml">
significand</link> multiplied by an arbitrary exponent. However, since division almost immediately introduces infinitely repeating sequences of digits (such as 4/7 in decimal), should this possibility arise then either the representation would be truncated at some satisfactory size or else rational numbers would be used: a large integer for the <link xlink:type="simple" xlink:href="../039/113039.xml">
numerator</link> and for the <link xlink:type="simple" xlink:href="../824/1704824.xml">
denominator</link>, with the <link xlink:type="simple" xlink:href="../354/12354.xml">
greatest common divisor</link> divided out. Unfortunately, arithmetic with rational numbers can become unwieldy very swiftly: 1/99 - 1/100 = 1/9900, and if 1/101 is then added the result is 10001/999900.</p>
<p>

An early widespread implementation was available via the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../577/92577.xml">
IBM 1620</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 of 1959-1970 which was a decimal-digit machine that despite using discrete transistors had hardware that performed integer or floating-point arithmetic (via lookup tables) on digit strings of a length that could be from two to whatever memory was available, though the mantissa of floating-point numbers was restricted to 100 digits or less and the exponent of floating-point numbers was restricted to two digits only: the largest memory supplied offered sixty thousand digits. Compilers for the IBM 1620 (<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
), however, settled on some fixed size (which could be specified on a control card if the default was not satisfactory), such as ten digits. IBM's first business computer, the <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../631/2015631.xml">
IBM 702</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
, which was a <link xlink:type="simple" xlink:href="../496/32496.xml">
vacuum tube</link> machine, implemented integer arithmetic <it>entirely in hardware</it> on digit strings of any length from one to 511 digits. The earliest widespread software implementation of arbitrary precision arithmetic was probably that in <link xlink:type="simple" xlink:href="../774/47774.xml">
Maclisp</link>.  Later, around 1980, the <link xlink:type="simple" xlink:href="../517/32517.xml">
VAX</link>/<O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../736/32736.xml">
VMS</link></O>
 and <link xlink:type="simple" xlink:href="../018/315018.xml">
VM/CMS</link> <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s offered bignum facilities as a collection of <link xlink:type="simple" xlink:href="../706/199706.xml">
string</link> <link xlink:type="simple" xlink:href="../988/40988.xml">
function</link>s in the one case and in the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/9424829.xml">
EXEC 2</link></language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../858/25858.xml">
REXX</link></programming_language>
 languages in the other.  Today, arbitrary-precision libraries are available for most modern programming languages (see below).  Almost all <link xlink:type="simple" xlink:href="../427/54427.xml">
computer algebra system</link>s implement arbitrary-precision arithmetic.</p>
<p>

Arbitrary-precision arithmetic is sometimes called <b>infinite-precision arithmetic</b>, which is something of a misnomer: the number of digits of precision always remains finite (and is bounded in practice), although it can grow very large. Aside from the question of the total storage available, the variables used by the software to index the digit strings are themselves limited in size.</p>
<p>

Arbitrary-precision arithmetic should not be confused with <link xlink:type="simple" xlink:href="../200/3189200.xml">
symbolic computation</link>, as provided by computer algebra systems.  The latter represent numbers by symbolic expressions such as <math>\pi \sin(3)</math>, or even by <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s, and in this way can symbolically represent any <link xlink:type="simple" xlink:href="../206/6206.xml">
computable number</link> (limited by available memory).  Numeric results can still only be provided to arbitrary (finite) precision in general, however, by evaluating the symbolic expression using arbitrary-precision arithmetic.</p>

<sec>
<st>
Applications</st>
<p>

Arbitrary-precision arithmetic is considerably slower than arithmetic using numbers that fit entirely within processor registers, since the latter are usually implemented in <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<electrical_device wordnetid="103269401" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<circuit wordnetid="103033362" confidence="0.8">
<link xlink:type="simple" xlink:href="../504/199504.xml">
hardware arithmetic</link></circuit>
</device>
</electrical_device>
</instrumentality>
</artifact>
 whereas the former must be implemented in software <it>in most cases</it>: note that certain "variable word length" machines of the 1950s and 1960s, notably the IBM 1401 and the Honeywell "Liberator" series, could manipulate numbers bound only by available storage, with an extra bit that delimited the value. Even if the computer lacks hardware for certain operations (such as integer division, or all floating-point operations) and software is provided instead it will use number sizes closely related to the available hardware registers: one or two words only and definitely not N words.  Consequently, arbitrary precision is used in applications where the speed of arithmetic is not a limiting factor, or where precise results or exact integer arithmetic with very large numbers is required.  It is also useful for checking the results of fixed-precision calculations, and for determining the best possible value for coefficients needed in formulae, such as the √⅓ that appears in <link xlink:type="simple" xlink:href="../579/50579.xml">
Gaussian integration</link> as just one example.</p>
<p>

A common application is <link xlink:type="simple" xlink:href="../222/24222.xml">
public-key cryptography</link>, whose algorithms commonly employ arithmetic with integers of hundreds or thousands of digits; another is in human-centric applications where artificial limits and overflows would be inappropriate.</p>
<p>

Arbitrary precision arithmetic is also used to compute fundamental <link xlink:type="simple" xlink:href="../371/19371.xml">
mathematical constant</link>s such as <link xlink:type="simple" xlink:href="../601/23601.xml">
π</link> to millions or more digits and to analyze the properties of the digit strings (e.g. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>), or more generally to investigate the precise behaviour of functions such as the <link xlink:type="simple" xlink:href="../809/25809.xml">
Riemann Zeta function</link> where answers via analytical methods are difficult to obtain.
Another example is in rendering <link xlink:type="simple" xlink:href="../913/10913.xml">
Fractal</link> images with an extremely high magnification, such as those found in the <link xlink:type="simple" xlink:href="../562/19562.xml">
Mandelbrot set</link>.</p>
<p>

Arbitrary-precision arithmetic can also be used to avoid <link xlink:type="simple" xlink:href="../724/40724.xml">
overflow</link>, which is an inherent limitation of fixed-precision arithmetic. Just like a 4-digit odometer which rolls around from 9999 to 0000, a fixed-precision integer can exhibit <it>wraparound</it> if numbers grow too large to represent at the fixed level of precision.  Some processors can deal with overflow by <it>saturation,</it> which means that if a result would be unrepresentable, it is replaced with the nearest representable value. (With 16-bit unsigned saturation, adding 1 to 65535 yields 65535 &mdash; see <link xlink:type="simple" xlink:href="../167/1830167.xml">
saturation arithmetic</link>.) Some processors can generate an <abnormality wordnetid="114501726" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<physical_condition wordnetid="114034177" confidence="0.8">
<anomaly wordnetid="114505821" confidence="0.8">
<link xlink:type="simple" xlink:href="../231/59231.xml">
exception</link></anomaly>
</physical_condition>
</state>
</condition>
</abnormality>
 if an arithmetic result exceeds the available precision. Where necessary, the exception can be caught and the operation can be restarted in software with arbitrary-precision operands.</p>
<p>

Since many computers now routinely use 32-bit or even 64-bit integers, it can often be guaranteed that the integer numbers in a specific application will never grow large enough to cause an overflow, though as time passes the exact nature of the constraint can be forgotten, as in implementations of the <link xlink:type="simple" xlink:href="../266/4266.xml">
Binary search</link> method which often employ the form (L + R)/2; this means that for correct functioning the <it>sum</it> of L and R is limited to sixteen bits (or thirty-two, etc.), not the individual variables. However, some programming languages such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../119/28119.xml">
Scheme</link></programming_language>
, <link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link>, <link xlink:type="simple" xlink:href="../858/25858.xml">
Rexx</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
 use, or have an option to use, arbitrary-precision numbers for <it>all</it> integer arithmetic.  Although this reduces performance, it eliminates the possibility of incorrect results (or exceptions) due to simple overflow, and makes it possible to guarantee that arithmetic results will be the same on all machines, regardless of any particular machine’s word size. The exclusive use of arbitrary-precision numbers in a programming language also simplifies the language, because “a number is a number” and there is no need for the multiplicity of types needed to represent different levels of precision.</p>

</sec>
<sec>
<st>
Algorithms</st>
<p>

Numerous <link xlink:type="simple" xlink:href="../775/775.xml">
algorithms</link> have been developed to efficiently perform arithmetic operations on numbers stored with arbitrary precision.  In particular, supposing that <it>N</it> digits are employed, algorithms have been designed to minimize the asymptotic <link xlink:type="simple" xlink:href="../543/7543.xml">
complexity</link> for large <it>N</it>.</p>
<p>

The simplest algorithms are for <link xlink:type="simple" xlink:href="../338/61338.xml">
addition</link> and <link xlink:type="simple" xlink:href="../141/74141.xml">
subtraction</link>, where one simply adds or subtracts the digits in sequence, carrying as necessary, which yields an <it>O</it>(<it>N</it>) algorithm (see <link xlink:type="simple" xlink:href="../578/44578.xml">
big O notation</link>).</p>
<p>

For <link xlink:type="simple" xlink:href="../845/20845.xml">
multiplication</link>, the most straightforward algorithms used for multiplying numbers by hand (as taught in primary school) requires <math>O(N^2)</math> operations, but <link xlink:type="simple" xlink:href="../411/57411.xml">
multiplication algorithm</link>s that achieve <math>O(N \log(N) \log(\log(N)))</math> complexity have been devised, such as the <link>
Schönhage-Strassen algorithm</link>, based on <link xlink:type="simple" xlink:href="../512/11512.xml">
fast Fourier transform</link>s, and there are also algorithms with slightly worse complexity but with sometimes superior real-world performance for smaller <it>N</it>.</p>
<p>

For a list of algorithms along with complexity estimates, see: <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../220/6497220.xml">
Computational complexity of mathematical operations</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</p>

</sec>
<sec>
<st>
Example</st>
<p>

Calculation of <link xlink:type="simple" xlink:href="../606/10606.xml">
factorial</link>s produce very large numbers very swiftly. This is not a problem for their usage in many formulae (such as <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../448/30448.xml">
Taylor series</link></function>
</mathematical_relation>
) because they appear along with other terms so that given careful attention to the order of evaluation the net calculation value is not troublesome. If actual values of factorial numbers are desired, <link xlink:type="simple" xlink:href="../783/151783.xml">
Stirling's approximation</link> gives good results. If exact values are of interest then alas, the integer limit is soon exceeded. Even floating-point approximations soon exceed the maximum floating-point value possible, to the degree that the calculations should be recast into using the log of the number.</p>
<p>

But if exact values for large factorials are desired, then special software is required, somewhat as in the pseudocode that follows, which implements the classic primary school algorithm to calculate 1, 1*2, 1*2*3, 1*2*3*4, etc. the successive factorial numbers.</p>
<p>

Constant Limit = 1000;           %Sufficient digits.
Constant Base = 10;              %The base of the simulated arithmetic.
Array digit[1:Limit] of integer; %The big number.
Integer carry,d;                 %Assistants during multiplication.
Integer last,i;                  %Indices to the big number's digits.
Array text[1:Limit] of character;
Constant tdigit[0:9] of character = ["0","1","2","3","4","5","6","7","8","9"];
BEGIN
digit:=0;                       %Clear the whole array.
digit[1]:=1;                    %The big number starts with 1,
last:=1;                        %Its highest-order digit is number 1.
<b>for</b> n:=1 <b>to</b> 365 <b>do</b>
carry:=0;                      %Start a multiply.
<b>for</b> i:=1 <b>to</b> last <b>do</b>            %Step along every digit.
d:=digit[i]*n + carry;        %The classic multiply.
digit[i]:=d <b>mod</b> Base;         %The low-order digit of the result.
carry:=d <b>div</b> Base;            %The carry to the next digit.
<b>next</b> i;
<b>while</b> carry &amp;gt; 0                %Store the carry in the big number.            
<b>if</b> last &amp;gt;= Limit <b>then</b> croak('Overflow!'); %If possible!
last:=last + 1;               %One more digit.
digit[last]:=carry <b>mod</b> Base;  %Placed.
carry:=carry <b>div</b> Base;        %The carry reduced.
<b>Wend</b>                           %With n &amp;gt; base, maybe &amp;gt; 1 digit extra.
text:=" ";                     %Now prepare the output.
<b>for</b> i:=1 <b>to</b> last <b>do</b>            %Translate from binary to text.
text[Limit - i + 1]:=tdigit[digit[i]]; %Reversing the order.
<b>next</b> i;                        %Arabic numerals put the low order last.
<b>Print</b> text," = ",n,"!";   
<b>next</b> n;
END;</p>
<p>

With the example in view, a number of details can be described. The most important is the choice of the representation of the big number. In this case, only integer values are required for factorials, so a fixed-point scheme is adequate. The powers of the base are zero and upwards, so it is convenient to have successive elements of the array represent higher powers. The computer language may not enable a convenient choice of the array bounds (for example, the lower bound might have to be one, always, or zero, always) and the requirements of the calculation in general might not involve a permitted bound, so this example proceeds with an array starting from one, not zero, to demonstrate the simple issues of accountancy. That the index into the digit array corresponds to a certain power of the base is not directly utilised as a part of the method.</p>
<p>

The second most important decision is in the choice of the base of arithmetic, here ten. There are many considerations. The scratchpad variable <it>d</it> must be able to hold the result of a single-digit multiply <it>plus the carry</it> from the previous digit's multiply. In base ten, a sixteen-bit integer is certainly adequate as it allows up to 32767. However, this example cheats, in that the value of <it>n</it> is not itself limited to be a single-digit base ten number. This has the consequence that the method will fail for <it>n</it> &amp;gt; 3200 or so, not a pressing limit in this example. In general, <it>n</it> would be a multi-digit big number also. A second consequence of the shortcut is that after the multi-digit multiply has been completed, the last value of <it>carry</it> must be carried into higher-order digits beyond what was the upper limit of the previous number because it may be carrying multiple digits not just the single digit that would otherwise be normal.</p>
<p>

Flowing from the choice of the base for the bignumber comes the issue of presenting its value. Because the base is ten, the result could be shown simply by printing the successive digits of array <it>digit</it>, but, they would appear with the highest-order digit last (so that a hundred and twenty-three would appear as "321") because of the first choice for the representation of the bignumber. The tradition for Arabic numbers is the other way around, so they could be printed in reverse order. But that would present the number with leading zeroes ("00000...000123") which may not be appreciated, so the final decision is to build the representation in a text variable and then print that. The first few results (with many leading spaces removed) are:
Reach of computer numbers.
1 =  1!
2 =  2!
6 =  3!
24 =  4!
120 =  5!   8-bit unsigned
720 =  6!
5040 =  7!
40320 =  8!  16-bit unsigned
362880 =  9!   
3628800 = 10!   
39916800 = 11!   
479001600 = 12!  32-bit unsigned   
6227020800 = 13!   
87178291200 = 14!   
1307674368000 = 15!   
20922789888000 = 16!   
355687428096000 = 17!   
6402373705728000 = 18!   
121645100408832000 = 19!   
2432902008176640000 = 20!  64-bit unsigned   
51090942171709440000 = 21!   
1124000727777607680000 = 22!   
25852016738884976640000 = 23!   
620448401733239439360000 = 24!   
15511210043330985984000000 = 25!   
403291461126605635584000000 = 26!   
10888869450418352160768000000 = 27!   
304888344611713860501504000000 = 28!   
8841761993739701954543616000000 = 29!   
265252859812191058636308480000000 = 30!   
8222838654177922817725562880000000 = 31!
263130836933693530167218012160000000 = 32!
8683317618811886495518194401280000000 = 33!
295232799039604140847618609643520000000 = 34! 128-bit unsigned   
10333147966386144929666651337523200000000 = 35!</p>
<p>

More serious attempts would try to use the available arithmetic of the computer more efficiently. A simple escalation would be to base 100 (with corresponding changes to the translation process for output), or, bigger computer variables (such as 32-bit integers) could be used so as to enable larger bases, such as 10,000. Conversion from non-decimal bases to a decimal base for output is a significant computation. Nevertheless, working in bases closer to the computer's built-in integer operations offers advantages. Operations on an integer holding a value such as six take just as long as the same operation on an integer holding a larger value, so there are large gains in packing as much of a bignumber into each element of the digit array as possible. The computer may also offer facilities for splitting a product into a digit and carry without requiring the two operations of <it>mod</it> and <it>div</it> as in the example. For instance, the <link xlink:type="simple" xlink:href="../965/565965.xml">
IBM1130</link> integer multiply of 16-bit integers (actually of a 32-bit accumulator and extension register pair, with a nominated 16-bit word) produced a 32-bit result which could be treated as two separate 16-bit words, thus if the bignumber base was 65536 the <it>carry</it> would be in the high-order sixteen bits, and the <it>digit</it> would be in the lower-order sixteen bits. No <it>mod</it> and <it>div</it> operations would be required to separate them.</p>
<p>

This sort of detail is the grist of machine-code programmers, and a suitable bignumber routine would run orders of magnitude faster than the result of the compilation of a high-level language, which do not offer similar facilities. Even so, it may be possible to juggle 16-bit and 32-bit variables in cunning ways, but the tricks (essentially, arranging that a 32-bit variable overlays the same storage as two 16-bit variables) are frowned upon by computer language purists. Thus the EQUIVALENCE statement of <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
 and the OVERLAY statement of <link xlink:type="simple" xlink:href="../708/23708.xml">
Pl/1</link> are deprecated.</p>
<p>

For a single-digit multiply the working variables must be able to hold the value (base -1)² + carry, where the maximum value of the carry is (base - 1). Notice that the IBM1130 offered a working register of 32 bits for 16-bit arithmetic so that many calculations whose intermediate results exceeded the 16-bit limit nevertheless worked; in a high-level language, if the bignumber's digit array were of unsigned 16-bit integers and the base 65536, the maximum result of a digit multiply would not exceed 4,294,901,760 but this exceeds the capacity of a 32-bit signed integer which is 2³¹ - 1 = 2,147,483,647. The high-level language may not offer a 32-bit unsigned integer as a variable (limit 2³² - 1 =  4,294,967,295), even if the computer's internal arithmetic register allows this or is bigger still. Or, if 32-bit unsigned integers <it>are</it> available, what then of the required 64-bit unsigned integers?</p>
<p>

Choosing instead a base of 256 has the advantage of simplicity, and moreover, it is quite possible to check for the correct function of the basic arithmetic operations on <it>all possible digit combinations</it>. Errors in computer hardware are <link xlink:type="simple" xlink:href="../637/24637.xml">
not unknown</link>. Since the prime purpose for slow but exact or at least high-precision computation is to obtain definitive results, some sort of assurance is helpful.</p>

</sec>
<sec>
<st>
Arbitrary-precision software</st>
<p>

Arbitrary-precision arithmetic in most computer software is implemented by calling an external <link xlink:type="simple" xlink:href="../421/106421.xml">
library</link> that provides <link xlink:type="simple" xlink:href="../817/93817.xml">
data type</link>s and <link xlink:type="simple" xlink:href="../988/40988.xml">
subroutine</link>s to store numbers with the requested precision and to perform computations.</p>
<p>

<table class="sortable wikitable">
<row>
<header>
Package / Library Name</header>
<header>
Number Type</header>
<header>
Language</header>
<header>
License</header>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.apfloat.org">
apfloat</weblink></col>
<col>
Float</col>
<col>
<message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://crd.lbl.gov/~dhbailey/mpdist">
ARPREC and MPFUN</weblink></col>
<col>
Decimal</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.iw-net.org/index.php?title=Bbnum_library">
bbnum library</weblink></col>
<col>
Integers and floating point numbers</col>
<col>
<link xlink:type="simple" xlink:href="../368/1368.xml">
Assembler</link> and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>
<col>
<link xlink:type="simple" xlink:href="../111/18933111.xml">
New BSD</link></col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.php.net/manual/en/book.bc.php">
BCMath</weblink></col>
<col>
Decimal</col>
<col>
<physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../131/24131.xml">
PHP</link></writer>
</language>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.di-mgt.com.au/bigdigits.html">
BigDigits</weblink></col>
<col>
<link xlink:type="simple" xlink:href="../474/21474.xml">
Naturals</link></col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
</col>

</row>
<row>
<col>
<software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../377/15113377.xml">
CLN, a Class Library for Numbers</link></software>
</col>
<col>
Integers and Floats</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>
<col>
<link xlink:type="simple" xlink:href="../683/18938683.xml">
GPL</link></col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.haible.de/bruno/MichaelStoll/reals.html">
Computable Real Numbers</weblink></col>
<col>
Reals</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../068/6068.xml">
Common Lisp</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.cryptopp.com">
Crypto++</weblink></col>
<col>
Arbitrary-precision for <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link></col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.vni.com/products/imsl/c/imslc.php">
IMSL</weblink></col>
<col>
C Numerical Library</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www2.hursley.ibm.com/decimal/#decNumber">
decNumber</weblink></col>
<col>
Decimal</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://myweb.lmu.edu/dmsmith/FMLIB.html">
FMLIB</weblink></col>
<col>
Multiple Precision Computation</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../168/11168.xml">
Fortran</link></programming_language>
</col>

</row>
<row>
<col>
<software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../126/483126.xml">
GNU Multi-Precision Library</link></software>
 (and <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../902/1042902.xml">
MPFR</link></software>
)</col>
<col>
Integers and Reals</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 and <link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link>with bindings</col>
<col>
<link xlink:type="simple" xlink:href="../073/13073.xml">
LGPL</link></col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.emath.ac.cn/hugecalc/">
HugeCalc</weblink></col>
<col>
Factorial Computation</col>

<col>
Proprietary</col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://codeplex.com/IntX/">
IntX</weblink></col>
<col>
Integers</col>
<col>
<link xlink:type="simple" xlink:href="../139/238139.xml">
C#</link> / <link xlink:type="simple" xlink:href="../164/3582164.xml">
.NET</link></col>
<col>
<link xlink:type="simple" xlink:href="../111/18933111.xml">
New BSD</link></col>
</row>
<row>
<col>
<link>
Java.math</link></col>
<col>
Integers and Decimals</col>
<col>
<message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://jscience.org/api/org/jscience/mathematics/numbers/LargeInteger.html">
JScience LargeInteger</weblink></col>
<col>
Integers</col>
<col>
<message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.cdc.informatik.tu-darmstadt.de/TI/LiDIA/">
LiDIA</weblink></col>
<col>
Computational Number Theory</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.tc.umn.edu/~ringx004/mapm-main.html">
MAPM</weblink></col>

<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 (bindings for <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
 and <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../150/46150.xml">
Lua</link></machine>
</device>
</instrumentality>
</artifact>
</system>
)</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://perldoc.perl.org/Math/BigInt.html">
Math::BigInt</weblink>, <weblink xlink:type="simple" xlink:href="http://perldoc.perl.org/Math/BigFloat.html">
Math::BigFloat</weblink></col>
<col>
Integers and Reals</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="ftp://ftp.compapp.dcu.ie/pub/crypto/">
Miracl-C</weblink></col>
<col>
Integers and Reals (as Rationals)</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://xyssl.org/code/source/mpi/">
MPI</weblink></col>
<col>
Integers</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
</col>
<col>
<link xlink:type="simple" xlink:href="../073/13073.xml">
LGPL</link></col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://code.google.com/p/mpmath/">
mpmath</weblink></col>
<col>
Floats</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
</col>
<col>
<link xlink:type="simple" xlink:href="../111/18933111.xml">
New BSD</link></col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://www.shoup.net/ntl/">
NTL</weblink></col>
<col>
Number Theory</col>
<col>
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://caml.inria.fr/pub/docs/manual-ocaml/manual036.html">
Num</weblink></col>
<col>
Integers and Rationals</col>
<col>
<link xlink:type="simple" xlink:href="../652/39652.xml">
OCaml</link></col>

</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://ttmath.slimaczek.pl">
TTMath library</weblink></col>
<col>
Integer and floating point numbers</col>
<col>
<link xlink:type="simple" xlink:href="../368/1368.xml">
Assembler</link> and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
</col>
<col>
<link xlink:type="simple" xlink:href="../111/18933111.xml">
New BSD</link></col>
</row>
<row>
<col>
<weblink xlink:type="simple" xlink:href="http://codeplex.com/Sine">
W3b.Sine</weblink></col>
<col>
Integers and Reals</col>
<col>
<link xlink:type="simple" xlink:href="../139/238139.xml">
C#</link> / <link xlink:type="simple" xlink:href="../164/3582164.xml">
.NET</link></col>
<col>
<link xlink:type="simple" xlink:href="../111/18933111.xml">
New BSD</link></col>
</row>
</table>
</p>
<p>

Stand-alone <link xlink:type="simple" xlink:href="../746/454746.xml">
application software</link> that supports arbitrary precision computations:</p>
<p>

<list>
<entry level="1" type="bullet">

 <system wordnetid="104377057" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<link xlink:type="simple" xlink:href="../441/7311441.xml">
PARI/GP</link></instrumentality>
</artifact>
</system>
, an <link xlink:type="simple" xlink:href="../758/18938758.xml">
open source</link> computer algebra system that supports arbitrary precision.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../359/646359.xml">
bc programming language</link>: the <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../305/23305.xml">
POSIX</link></system_of_measurement>
</standard>
 / <link xlink:type="simple" xlink:href="../875/11875.xml">
GNU</link> basic calculator</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../904/562904.xml">
dc programming language</link>: the POSIX desk calculator </entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../918/440918.xml">
Fractint</link></software>
 is a <link xlink:type="simple" xlink:href="../592/11592.xml">
freeware</link> <link xlink:type="simple" xlink:href="../758/18938758.xml">
open source</link> <link xlink:type="simple" xlink:href="../309/5309.xml">
software</link> package  that can render and display many kinds of <link xlink:type="simple" xlink:href="../913/10913.xml">
fractal</link>s</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../024/49024.xml">
Mathematica</link></software>
, and several other <link xlink:type="simple" xlink:href="../427/54427.xml">
computer algebra</link> software include arbitrary-precision arithmetic. Mathematica employs <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../126/483126.xml">
GMP</link></software>
 for approximate number computation.</entry>
<entry level="1" type="bullet">

 The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python programming language</link></programming_language>
: the built-in <b>long</b> integer type is of arbitrary precision. The <b>Decimal</b> built-in module has user definable precision.</entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../858/25858.xml">
REXX</link></programming_language>
: programming language (including Open Object Rexx and NetRexx)</entry>
<entry level="1" type="bullet">

 <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../319/28319.xml">
Smalltalk</link></programming_language>
: programming languages (including <link xlink:type="simple" xlink:href="../426/37426.xml">
Squeak</link>, <link>
Smalltalk/X</link>, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../226/7081226.xml">
GNU Smalltalk</link></software>
, <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../986/14352986.xml">
Dolphin Smalltalk</link></software>
, etc.)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.speedcrunch.org/">
SpeedCrunch</weblink> is an <link xlink:type="simple" xlink:href="../758/18938758.xml">
open source</link> <link xlink:type="simple" xlink:href="../193/81193.xml">
cross-platform</link> high precision calculator</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../063/2794063.xml">
Ultra Fractal</link></software>
: a fractal generation program.</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../925/95925.xml">
Maxima (software)</link></software>
: a <link xlink:type="simple" xlink:href="../990/573990.xml">
CAS</link> using bignums.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.edepot.com/win95.html">
Virtual Calc 2000</weblink>: arbitrary-precision and arbitrary-base calculator for Windows</entry>
<entry level="1" type="bullet">

 The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell programming language</link></programming_language>
: the built-in <b>Integer</b> datatype implements arbitrary-precision arithmetic.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://ttcalc.sourceforge.net">
TTCalc</weblink> an open source mathematical calculator (TTMath library).</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>


<p>

<reflist>
<entry id="1">
R.K. Pathria, A Statistical Study of the Randomness amongst the first 10,000 Digits of Pi, 1962 Mathematics of Computation , v16, N77-80, pp 188-97 in which appears the remark "Such an extreme pattern is dangerous even if diluted by one of its neighbouring blocks" - this was the occurrence of the sequence 77 twenty-eight times in one block of a thousand digits</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../211/17211.xml">
Knuth</link>, Donald, <it>The Art of Computer Programming,</it> ISBN 0-201-89684-2, Volume 2: Seminumerical Algorithms, Section 4.3.1: The Classical Algorithms</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
