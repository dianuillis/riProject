<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:09:20[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<parlance  confidence="0.8" wordnetid="107081177">
<formulation  confidence="0.8" wordnetid="107069948">
<expressive_style  confidence="0.8" wordnetid="107066659">
<header>
<title>Swap (computer science)</title>
<id>6067549</id>
<revision>
<id>224576743</id>
<timestamp>2008-07-09T14:20:33Z</timestamp>
<contributor>
<username>Jafet</username>
<id>1031429</id>
</contributor>
</revision>
<categories>
<category>Programming idioms</category>
</categories>
</header>
<bdy>

<indent level="1">

<it>For other uses of "swap", see <link xlink:type="simple" xlink:href="../112/401112.xml">
swap</link> (disambiguation).</it>
</indent>
In <link xlink:type="simple" xlink:href="../311/5311.xml">
computer programming</link>, the act of <b>swapping</b> two <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s refers to mutually exchanging the values of the variables. Usually, this is done with the data in <link xlink:type="simple" xlink:href="../300/5300.xml">
memory</link>. For example, in a <link xlink:type="simple" xlink:href="../783/5783.xml">
program</link>, two variables may be defined thus (in <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>):<p>


data_item x := 1
data_item y := 0
</p>
<p>

To swap them one might do
swap (x, y);
(In many <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s where the swap <link xlink:type="simple" xlink:href="../988/40988.xml">
function</link> is built-in; in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, <link xlink:type="simple" xlink:href="../811/261811.xml">
overloads</link> are provided allowing std::swap to swap some large structures in O(1) time.)
After swap() is performed, <it>x</it> will contain the value 0 and <it>y</it> will contain 1; their values have been exchanged. Of course, this operation may be generalized to other types of values, such as <link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link>, aggregated <link xlink:type="simple" xlink:href="../817/93817.xml">
data type</link>s and possibly entire <link xlink:type="simple" xlink:href="../615/5170615.xml">
container</link>s.</p>

<sec>
<st>
Swap methods</st>
<p>

Swapping data is a very important component of numerous <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s. For example, many of the <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>s, especially <link xlink:type="simple" xlink:href="../304/3189304.xml">
comparison sort</link>s, utilize swaps to change the positions of data.</p>

<ss1>
<st>
Using a temporary variable</st>
<p>

The simplest and probably most widely used method to swap two variables is to use a third temporary variable:</p>
<p>


define swap (x, y)
    temp := x
    x := y
    y := temp
</p>
<p>

While this is conceptually simple and in many cases the only convenient way to swap two variables, it uses extra memory. Although this should not be a problem in most applications, the sizes of the values being swapped may be huge (which means the temporary variable may occupy a lot of memory as well), or the swap operation may need to be performed many times, as in sorting algorithms.</p>
<p>

In addition, swapping two variables in <link xlink:type="simple" xlink:href="../757/22757.xml">
object-oriented</link> languages, such as <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
 may involve one call to the <link xlink:type="simple" xlink:href="../392/7392.xml">
class</link> <link xlink:type="simple" xlink:href="../453/939453.xml">
constructor</link> and <link xlink:type="simple" xlink:href="../076/2253076.xml">
destructor</link> for the temporary variable, and three calls to the <link xlink:type="simple" xlink:href="../954/233954.xml#xpointer(//*[./st=%22creation+methods%22])">
copy constructor</link>. Some classes may allocate memory in the constructor and deallocate it in the destructor, thus creating expensive calls to the system. Copy constructors for classes containing a lot of data, e.g. in an <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>, may even need to copy the data manually.</p>

</ss1>
<ss1>
<st>
XOR swap</st>
<p>

<indent level="1">

</indent>
:<it>Main article: <link xlink:type="simple" xlink:href="../555/145555.xml">
XOR swap algorithm</link></it>
XOR swap uses the <link xlink:type="simple" xlink:href="../399/264399.xml#xpointer(//*[./st=%22XOR%22])">
XOR</link> operation to swap two numeric variables. It is generally touted to be faster than the naive method mentioned above; however it does have <link xlink:type="simple" xlink:href="../555/145555.xml#xpointer(//*[./st=%22Reasons+for+avoidance+in+practice%22])">
disadvantages</link>. XOR swap is generally used to swap low-level data types, like <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>s. However, it is, in theory, capable of swapping any two values which can be represented by fixed-length <link xlink:type="simple" xlink:href="../412/3087412.xml">
bitstring</link>s.</p>

</ss1>
<ss1>
<st>
Swap through addition and subtraction</st>
<p>

<indent level="1">

</indent>
:<it>Main article: <link xlink:type="simple" xlink:href="../555/145555.xml">
swap by addition and subtraction</link></it>
This method swaps two variables by adding and subtracting their values. This is rarely used in practical applications, mainly because:
<list>
<entry level="1" type="bullet">

 It can only swap numeric variables; it may not be possible or logical to add or subtract complex data types, like <link xlink:type="simple" xlink:href="../615/5170615.xml">
containers</link>.</entry>
<entry level="1" type="bullet">

 When swapping variables of a fixed size, <link xlink:type="simple" xlink:href="../724/40724.xml">
arithmetic overflow</link> becomes an issue.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Swapping containers</st>
<p>

<link xlink:type="simple" xlink:href="../615/5170615.xml">
Container</link>s which allocate memory from the <link xlink:type="simple" xlink:href="../117/547117.xml">
heap</link> using <link xlink:type="simple" xlink:href="../018/459018.xml">
pointer</link>s may be swapped in a single operation, by swapping the pointers alone. This is usually found in programming languages supporting pointers, like <link xlink:type="simple" xlink:href="../021/6021.xml">
C/C++</link>. For example, the <link xlink:type="simple" xlink:href="../777/156777.xml">
STL</link> <link xlink:type="simple" xlink:href="../837/105837.xml#xpointer(//*[./st=%22Template+specialization%22])">
specialize</link>s its built-in swap function to exchange containers efficiently this way. <weblink xlink:type="simple" xlink:href="http://www.sgi.com/tech/stl/swap.html#2">
http://www.sgi.com/tech/stl/swap.html#2</weblink></p>
<p>

As pointer variables are usually of a fixed size (e.g., most desktop computers have pointers 32 <link xlink:type="simple" xlink:href="../364/3364.xml">
bit</link>s long), and they are numeric, they can be swapped quickly using <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22XOR+swap%22])">
XOR swap</link>.</p>

</ss1>
</sec>
<sec>
<st>
Facilitation of swapping in modern computers</st>

<ss1>
<st>
Dedicated instructions</st>
<p>

Because of the many applications of swapping data in computers, most <link xlink:type="simple" xlink:href="../218/5218.xml">
processor</link>s now provide the ability to swap variables directly through built-in instructions. <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> processors, for example, include an <it>XCHG</it> instruction to swap two <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link>s directly without requiring that a third temporary register is used. A <it>CMPXCHG</it> instruction, which compares and conditionally swaps two registers, is even provided in some processor architectures.</p>
<p>

<it>XCHG</it> may not be as efficient as one may think. For example, in <link xlink:type="simple" xlink:href="../198/34198.xml">
x86</link> processors, <it>XCHG</it> will implicitly lock access to any operands in <link xlink:type="simple" xlink:href="../847/25847.xml">
memory</link> to keep the operation <link xlink:type="simple" xlink:href="../560/2114560.xml">
atomic</link>, and so may not be efficient when swapping memory. However, an <it>XCHG</it> is usually the fastest way to swap two machine-size words residing in <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link>s.</p>
<p>

<register wordnetid="106507041" confidence="0.8">
<record wordnetid="106647206" confidence="0.8">
<indication wordnetid="106797169" confidence="0.8">
<evidence wordnetid="106643408" confidence="0.8">
<written_record wordnetid="106502378" confidence="0.8">
<link xlink:type="simple" xlink:href="../852/435852.xml">
Register renaming</link></written_record>
</evidence>
</indication>
</record>
</register>
 may also be used to swap registers efficiently.</p>

</ss1>
<ss1>
<st>
Parallel execution</st>
<p>

With the advent of <link xlink:type="simple" xlink:href="../314/220314.xml">
instruction pipelining</link> in modern computers and <link xlink:type="simple" xlink:href="../207/3503207.xml">
multi-core processor</link>s facilitating <link xlink:type="simple" xlink:href="../162/145162.xml">
parallel computing</link>, two or more operations can be performed at once. This can speed up the lowly temporary-variable swap algorithm and give it an edge over other algorithms. For example, the <link xlink:type="simple" xlink:href="../555/145555.xml">
XOR swap algorithm</link> requires sequential execution of three instructions. However, using two temporary registers, two processors executing in parallel can swap two variables in two clock cycles:</p>
<p>

<b>Step 1</b>
Processor 1: temp_1 := X
Processor 2: temp_2 := Y</p>
<p>

<b>Step 2</b>
Processor 1: X := temp_2
Processor 2: Y := temp_1</p>
<p>

This uses fewer instructions; but other temporary registers may be in use, and four instructions are needed instead of three. In any case, in practice this could not be implemented in separate processors, as it would be infeasible to keep the processors sufficiently in sync with one another for this swap to have any significant advantage over traditional versions. However, it can be used to optimize swapping for a single processor with multiple load/store units.</p>



</ss1>
</sec>
</bdy>
</expressive_style>
</formulation>
</parlance>
</article>
