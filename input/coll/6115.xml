<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:23:11[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<condition  confidence="0.8" wordnetid="113920835">
<state  confidence="0.8" wordnetid="100024720">
<class  confidence="0.8" wordnetid="107997703">
<problem  confidence="0.8" wordnetid="114410605">
<difficulty  confidence="0.8" wordnetid="114408086">
<collection  confidence="0.8" wordnetid="107951464">
<group  confidence="0.8" wordnetid="100031264">
<header>
<title>P = NP problem</title>
<id>6115</id>
<revision>
<id>242541151</id>
<timestamp>2008-10-02T17:41:18Z</timestamp>
<contributor>
<username>LouScheffer</username>
<id>639456</id>
</contributor>
</revision>
<categories>
<category>Millennium Prize Problems</category>
<category>Unsolved problems in mathematics</category>
<category>Unsolved problems in computer science</category>
<category>Conjectures</category>
<category>Complexity classes</category>
<category>Mathematical optimization</category>
</categories>
</header>
<bdy>

<image width="250px" src="Complexity_classes.svg" type="thumb">
<caption>

Diagram of complexity classes provided that <b>P</b> ≠ <b>NP</b>. The existence of problems outside both <b>P</b> and <b>NP</b>-complete in this case was established by Ladner.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
</caption>
</image>
<p>

The relationship between the <b><link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link>es <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
 and <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
</b> is an unsolved question in <link xlink:type="simple" xlink:href="../392/323392.xml">
theoretical computer science</link>. It is considered to be the most important problem in the field – the <institute wordnetid="108407330" confidence="0.8">
<association wordnetid="108049401" confidence="0.8">
<link xlink:type="simple" xlink:href="../655/7655.xml">
Clay Mathematics Institute</link></association>
</institute>
 has offered a $1 million US prize for the first correct proof.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

In essence, the question <b>P</b> = <b>NP</b>? asks: if 'yes'-answers to a <link xlink:type="simple" xlink:href="../336/8336.xml">
'yes'-or-'no'-question</link> can be <it>verified</it> "quickly" (in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link>), can the answers themselves also be <it>computed</it> quickly?</p>
<p>

Consider, for instance, the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../811/36811.xml">
subset-sum problem</link></difficulty>
</problem>
</state>
</condition>
, an example of a problem which is "easy" to verify, but whose answer is <it>believed</it> (but not proven) to be "difficult" to compute. Given a set of <link xlink:type="simple" xlink:href="../563/14563.xml">
integer</link>s, does some nonempty <link xlink:type="simple" xlink:href="../631/27631.xml">
subset</link> of them sum to 0? For instance, does a subset of the set  {−2, −3, 15, 14, 7, −10}  add up to 0? The answer "yes, because  {−2, −3, −10, 15}  add up to zero", can be quickly verified with a few additions. However, finding such a subset in the first place could take much longer. The information needed to verify a positive answer is also called a <it>certificate</it>. Given the right certificates, "yes" answers to our problem can be verified in polynomial time, so this problem is in <b>NP</b>.</p>
<p>

An answer to the <b>P</b> = <b>NP</b> question would determine whether problems like the subset-sum problem are as "easy" to compute as to verify. If it turned out <b>P</b> does not equal <b>NP</b>, it would mean that some <b>NP</b> problems are substantially "harder" to compute than to verify.</p>
<p>

The restriction to yes/no problems is unimportant; the resulting problem when more complicated answers are allowed (whether <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/663347.xml">
FP</link></group>
</collection>
</class>
</b> = <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/663351.xml">
FNP</link></group>
</collection>
</class>
</b>) is equivalent.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

<p>

<table style="text-align: center;" class="infobox">
<header style="background: #ccf; font-size: larger;">
 <b><condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../916/20916.xml">
Millennium Prize Problems</link></difficulty>
</problem>
</state>
</condition>
</b></header>
<row>
<col>
 <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../115/6115.xml">
P versus NP</link></group>
</collection>
</difficulty>
</problem>
</class>
</state>
</condition>
</col>
</row>
<row>
<col>
 <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../518/244518.xml">
The Hodge conjecture</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
</col>
</row>
<row>
<col>
 <link>
The Poincaré conjecture</link></col>
</row>
<row>
<col>
 <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../125/19344125.xml">
The Riemann hypothesis</link></difficulty>
</problem>
</state>
</condition>
</col>
</row>
<row>
<col>
 <link>
Yang–Mills existence and mass gap</link></col>
</row>
<row>
<col>
 <link>
Navier–Stokes existence and smoothness</link></col>
</row>
<row>
<col>
 <link xlink:type="simple" xlink:href="../161/435161.xml">
The Birch and Swinnerton-Dyer conjecture</link></col>
</row>
</table>
</p>

<sec>
<st>
Context of the problem</st>

<p>

The relation between the <b><link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link>es P and NP</b> is studied in <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, the part of the <link xlink:type="simple" xlink:href="../402/30402.xml">
theory of computation</link> dealing with the resources required during computation to solve a given problem. The most common resources are time (how many steps it takes to solve a problem) and space (how much memory it takes to solve a problem).</p>
<p>

In such analysis, a model of the computer for which time must be analyzed is required. Typically, such models assume that the computer is <link xlink:type="simple" xlink:href="../722/3934722.xml">
<it>deterministic''</it></link> (given the computer's present state and any inputs, there is only one possible action that the computer might take) and <it>sequential</it> (it performs actions one after the other). As of 2008, these assumptions are satisfied by all practical computers yet devised, even those featuring <link xlink:type="simple" xlink:href="../162/145162.xml">
parallel computing</link>.</p>
<p>

In this theory, the class <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
</b> consists of all those <it><link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link>s</it> (defined <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Formal+definitions+for+P+and+NP%22])">
below</link>) that can be solved on a deterministic sequential machine in an amount of time that is <link xlink:type="simple" xlink:href="../000/23000.xml">
polynomial</link> in the size of the input; the class <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
</b> consists of all those decision problems whose positive solutions can be verified in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link> given the right information, or equivalently, whose solution can be found in polynomial time on a <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../935/21935.xml">
non-deterministic</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 machine.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> Arguably, the biggest open question in <link xlink:type="simple" xlink:href="../392/323392.xml">
theoretical computer science</link> concerns the relationship between those two classes:
<indent level="1">

Is <b>P</b> equal to <b>NP</b>?
</indent>
In a 2002 poll of 100 researchers, 61 believed the answer is no, 9 believed the answer is yes, 22 were unsure, and 8 believed the question may be independent of the currently accepted axioms, and so impossible to prove or disprove.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>

</sec>
<sec>
<st>
Formal definitions for P and NP</st>

<p>

Conceptually, a <it>decision problem</it> is a problem that takes as input some <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/27701.xml">
string</link></kind>
</type>
</language>
</category>
</concept>
</idea>
, and outputs "yes" or "no". If there is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> (say a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
, or a <link xlink:type="simple" xlink:href="../311/5311.xml">
computer program</link> with unbounded memory) which is able to produce the correct answer for any input string of length <math>n</math> in at most <math>c \cdot n^k</math> steps, where <math>k</math> and <math>c</math> are constants independent of the input string, then we say that the problem can be solved in <it>polynomial time</it> and we place it in the class <b>P</b>. Formally, <b>P</b> is defined as the set of all languages which can be decided by a deterministic polynomial-time Turing machine. That is,</p>
<p>

<b>P</b> = <math>\{ L : L=L(M) \text{ for some deterministic polynomial-time Turing machine } M \}</math></p>
<p>

where <math>L(M) = \{ w\in\Sigma^{*}: M \text{ accepts } w \}</math></p>
<p>

and a deterministic polynomial-time Turing machine is a deterministic Turing machine <math>M</math> which satisfies the following two conditions:</p>
<p>

<list>
<entry level="1" type="number">

<math>M \text{ halts on all input } w</math>; and</entry>
<entry level="1" type="number">

there exists <math>k \in N</math> such that <math>T_{M}(n)\in\; </math><link xlink:type="simple" xlink:href="../578/44578.xml#xpointer(//*[./st=%22Formal+definition%22])">
<it>O''</it></link><math>(n^{k})</math>,</entry>
<entry level="2" type="indent">

where <math>T_{M}(n) = \max\{ t_{M}(w) : w\in\Sigma^{*}, \left|w\right| = n \}</math></entry>
<entry level="2" type="indent">

and <math>t_{M}(w) = \text{ number of steps M takes to halt on input } w.</math></entry>
</list>
</p>
<p>

<b>NP</b> can be defined similarly using nondeterministic Turing machines (the traditional way). However, a modern approach to define <b>NP</b> is to use the concept of <it><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../760/14933760.xml">
certificate</link></group>
</collection>
</class>
</it> and <it>verifier</it>. Formally, <b>NP</b> is defined as the set of languages over a finite alphabet that have a verifier that runs in polynomial time, where the notion of "verifier" is defined as follows.</p>
<p>

Let <math>L</math> be a language over a finite alphabet, <math>\Sigma</math>.</p>
<p>

<math>L\in\mathbf{NP}</math> if, and only if, there exists a binary relation <math>R\subset\Sigma^{*}\times\Sigma^{*}</math> and a positive integer <math>k</math> such that the following two conditions are satisfied:</p>
<p>

<list>
<entry level="1" type="number">

For all <math>x\in\Sigma^{*}</math>, <math>x\in L \Leftrightarrow\exists y\in\Sigma^{*}</math> such that <math>(x,y)\in R\;</math> and <math>\left|y\right|\in\;</math><link xlink:type="simple" xlink:href="../578/44578.xml#xpointer(//*[./st=%22Formal+definition%22])">
<it>O''</it></link><math>(\left|x\right|^{k})</math>; and</entry>
<entry level="1" type="number">

the language <math>L_{R} = \{ x\# y:(x,y)\in R\}</math> over <math>\Sigma\cup\{\#\}</math> is decidable by a Turing machine.</entry>
</list>
</p>
<p>

A Turing machine that decides <math>L_{R}</math> is called a <it>verifier</it> for <math>L</math> and a <math>y</math> such that  <math>(x,y)\in R</math> is called a <it>certificate of membership</it> of <math>x </math> in <math>L</math>.</p>
<p>

In general, a verifier does not have to be polynomial-time. However, for <math>L</math> to be in <b>NP</b>, there must be a verifier that runs in polynomial time.</p>

<ss1>
<st>
Example</st>

<p>

Let <math>\mathit{COMPOSITE} = \{x\in N:x=pq \;\text{for integers}\; p, q &amp;gt; 1 \}</math> and <math>R = \{(x,y)\in N\times N: 1&amp;lt;y&amp;lt; \sqrt x\; ; \;y\; \text{divides}\; x\}</math>.</p>
<p>

Clearly, the question of whether a given <math>x</math> is a composite is equivalent to the question of whether <math>x</math> is a member of <math>\mathit{COMPOSITE}</math>. It can be shown that <math>\mathit{COMPOSITE}\in\mathbf{NP}</math> by verifying that <math>\mathit{COMPOSITE}</math> satisfies the above definition.</p>
<p>

<math>\mathit{COMPOSITE}</math> also happens to be in <b>P</b> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>.</p>

</ss1>
</sec>
<sec>
<st>
NP-complete</st>

<p>

To attack the <b>P</b> = <b>NP</b> question, the concept of <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
<b>NP</b>-completeness</link></group>
</collection>
</class>
 is very useful. Informally, the <b>NP</b>-complete problems are the "toughest" problems in <b>NP</b> in the sense that they are the ones most likely not to be in <b>P</b>. <b>NP</b>-complete problems are those <b>NP</b>-hard problems which are in <b>NP</b>, where <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
<b>NP</b>-hard</link></group>
</collection>
</class>
 problems are those to which <it>any</it> problem in <b>NP</b> can be reduced in polynomial time. For instance, the decision problem version of the <link xlink:type="simple" xlink:href="../248/31248.xml">
traveling salesman problem</link> is <b>NP</b>-complete, so <it>any</it> instance of <it>any</it> problem in <b>NP</b> can be transformed mechanically into an instance of the traveling salesman problem, in polynomial time. The traveling salesman problem is one of many such <b>NP</b>-complete problems. If any <b>NP</b>-complete problem is in <b>P</b>, then it would follow that <b>P</b> = <b>NP</b>. Unfortunately, many important problems have been shown to be <b>NP</b>-complete and as of 2008, not a single fast algorithm for any of them is known.</p>
<p>

Based on the definition alone, it's not obvious that <b>NP</b>-complete problems exist. A trivial and contrived <b>NP</b>-complete problem can be formulated as: given a description of a Turing machine M guaranteed to halt in polynomial time, does there exist a polynomial-size input that M will accept?<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> It is in <b>NP</b> because, given an input, it is simple to check whether or not M accepts the input by simulating M; it is <b>NP</b>-hard because the verifier for any particular instance of a problem in <b>NP</b> can be encoded as a polynomial-time machine M that takes the solution to be verified as input. Then the question of whether the instance is a yes or no instance is determined by whether a valid input exists.</p>
<p>

The first natural problem proven to be <b>NP</b>-complete was the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
. This result
came to be known as <link>
Cook–Levin theorem</link>; its
proof that satisfiability is NP-complete contains technical details about Turing machines as they relate to the definition of <b>NP</b>. However, after this problem was proved to be NP-complete, <link xlink:type="simple" xlink:href="../067/848067.xml">
proof by reduction</link> provided a simpler way to show that many other problems are in this class. Thus, a vast class of seemingly unrelated problems are all reducible to one another, and are in a sense the "same problem".</p>

</sec>
<sec>
<st>
Formal definition for NP-completeness</st>

<p>

Although there are many equivalent ways of describing <b>NP</b>-completeness, in the context of the <b>P</b> vs <b>NP</b> question, it is best to define <b>NP</b>-complete problems in terms of <b>NP</b> problems.</p>
<p>

Let <math>\ L</math> be a language over a finite alphabet <math>\ \Sigma</math>.</p>
<p>

<math>\ L</math> is <b>NP</b>-complete if, and only if, the following two conditions are satisfied:</p>
<p>

<list>
<entry level="1" type="number">

<math>L\in\mathbf{NP}</math>; and</entry>
<entry level="1" type="number">

any <math>L^{'}\in\mathbf{NP}</math> is polynomial time reducible to <math>\ L</math> (written as <math>L^{'}\leq_{p} L</math>), where <math>L^{'}\leq_{p} L</math> if, and only if, the following two conditions are satisfied:</entry>
<entry level="2" type="number">

There exists <math>f : \Sigma^{*}\rightarrow\Sigma^{*}</math> such that <math>
\forall w\in\Sigma^{*}(w\in L^{'}\Leftrightarrow f(w)\in L)</math>; and</entry>
<entry level="2" type="number">

there exists a polynomial time Turing machine which halts with <math>\ f(w)</math> on its tape on any input <math>\ w</math>.</entry>
</list>
</p>

</sec>
<sec>
<st>
Still harder problems</st>

<p>

<indent level="1">

<it>See also: <link xlink:type="simple" xlink:href="../426/502426.xml">
Complexity class</link></it>
</indent>

Although it is unknown whether <b>P</b> = <b>NP</b>, problems outside of <b>P</b> are known. A number of <link>
succinct problem</link>s, that is, problems which operate not on normal input but on a computational description of the input, are known to be <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../694/54694.xml">
<b>EXPTIME</b>-complete</link></group>
</collection>
</class>
. Because it can be shown that <b>P</b> <math>\subsetneq</math> <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../694/54694.xml">
EXPTIME</link></group>
</collection>
</class>
</b>, these problems are outside <b>P</b>, and so require more than polynomial time. In fact, by the <link xlink:type="simple" xlink:href="../120/184120.xml">
time hierarchy theorem</link>, they cannot be solved in significantly less than exponential time.</p>
<p>

The problem of deciding the truth of a statement in <process wordnetid="105701363" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../756/23756.xml">
Presburger arithmetic</link></higher_cognitive_process>
</theory>
</explanation>
</thinking>
</process>
 requires even more time. Fischer and <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../404/298404.xml">
Rabin</link></scientist>
</person>
 proved in <link xlink:type="simple" xlink:href="../654/34654.xml">
1974</link> that every algorithm which decides the truth of Presburger statements has a runtime of at least <math>2^{2^{cn}}</math> for some constant <it>c</it>. Here, <it>n</it> is the length of the Presburger statement. Hence, the problem is known to need more than exponential run time. Even more difficult are the <link xlink:type="simple" xlink:href="../090/1188090.xml">
undecidable problems</link>, such as the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link>. They cannot be completely solved by any algorithm, in the sense that for any particular algorithm there is at least one input for which that algorithm will not produce the right answer; it will either produce the wrong answer, finish without giving a conclusive answer, or otherwise run forever without producing any answer at all.</p>

</sec>
<sec>
<st>
 Is P really practical? </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../179/3262179.xml">
Cobham's thesis</link></it>
</indent>

All of the above discussion has assumed that <b>P</b> means "easy" and "not in <b>P</b>" means "hard". While this is a common and reasonably accurate assumption in complexity theory, it is not always true in practice.  See <link xlink:type="simple" xlink:href="../179/3262179.xml">
Cobham's thesis</link> for an in-depth discussion of this point, but the main arguments are:
<list>
<entry level="1" type="bullet">

It ignores the size of the exponents.  In fields where practical problems have millions of variables (such as <link xlink:type="simple" xlink:href="../476/43476.xml">
Operations Research</link> or <link>
Electronic Design Automation</link>), even O(n3) algorithms are often impractical.</entry>
<entry level="1" type="bullet">

It ignores constant factors, which can be arbitrarily large and important in practice.</entry>
<entry level="1" type="bullet">

It only considers worst-case times. The <link xlink:type="simple" xlink:href="../458/349458.xml">
simplex algorithm</link> often (or even usually) solves problem instances in time <math>n</math>, but on very rare occasions takes time <math>2^{n}</math>.  Since the worst case time is exponential, the algorithm is not polynomial time, but still very practical.</entry>
<entry level="1" type="bullet">

It only considers deterministic solutions. There might be a problem that can be solved quickly if a tiny error probability is acceptable, but is much harder to solve exactly. </entry>
<entry level="1" type="bullet">

Advances in technology may make exponential-time algorithms efficient for practical ranges of problem sizes.</entry>
</list>
</p>

</sec>
<sec>
<st>
Why do many computer scientists think P ≠ NP?</st>

<p>

Most computer scientists believe that <b>P</b>≠<b>NP</b>. A key reason for this belief is that after decades of studying these problems, no one has been able to find a polynomial-time algorithm for any of the more than 3000 <b>NP</b>-complete problems (see <link xlink:type="simple" xlink:href="../754/1707754.xml">
List of NP-complete problems</link>). These algorithms were sought long before the concept of <b>NP</b>-completeness was even known (<condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/2012564.xml">
Karp's 21 NP-complete problems</link></difficulty>
</problem>
</state>
</condition>
, among the first found, were all well-known existing problems at the time they were shown to be NP-complete). Furthermore, the result <b>P</b> = <b>NP</b> would imply many other startling results that are currently believed to be false, such as <b>NP</b> = <b><link xlink:type="simple" xlink:href="../184/6184.xml">
co-NP</link></b> and <b>P</b> = <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../608/658608.xml">
<b>PH</b></link></group>
</collection>
</class>
.</p>
<p>

It is also intuitively argued that the existence of problems that are hard to solve but for which the solutions are easy to verify matches real-world experience.</p>
<p>

On the other hand, some researchers believe that we are overconfident in <b>P</b> ≠ <b>NP</b> and should explore proofs of <b>P</b> = <b>NP</b> as well. For example, in 2002 these statements were made:<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>
<p>

The main argument in favour of <b>P</b>≠<b>NP</b> is the total lack of fundamental progress in the area of exhaustive search. This is, in my opinion, a very weak argument. The space of algorithms is very large and we are only at the beginning of its exploration. [. . .] The resolution of <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../953/19021953.xml">
Fermat's Last Theorem</link></proposition>
</theorem>
</message>
</statement>
 also shows that very simply [''sic''] questions may be settled only by very deep theories.
&#8212; <cite ><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../215/12067215.xml">
Moshe Y. Vardi</link></associate>
</employee>
</causal_agent>
</colleague>
</worker>
</person>
</peer>
</physical_entity>
, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../813/25813.xml">
Rice University</link></university>
</cite></p>
<p>

Being attached to a speculation is not a good guide to research planning. One should always try both directions of every problem. Prejudice has caused famous mathematicians to fail to solve famous problems whose solution was opposite to their expectations, even though they had developed all the methods required.
&#8212; <cite ><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../551/3057551.xml">
Anil Nerode</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
, <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../422/7954422.xml">
Cornell University</link></university>
</cite></p>

</sec>
<sec>
<st>
Consequences of proof</st>

<p>

One of the reasons the problem attracts so much attention is the consequences of the answer.</p>
<p>

A proof of <b>P</b> = <b>NP</b> could have stunning practical consequences, if the proof leads to efficient methods for solving some of the important problems in NP. Various NP-complete problems are fundamental in many fields. There are enormous positive consequences that would follow from rendering tractable many currently mathematically intractable problems. For instance, many problems in <link xlink:type="simple" xlink:href="../476/43476.xml">
operations research</link> are NP-complete, such as some types of <link>
integer programming</link>, and the <link xlink:type="simple" xlink:href="../248/31248.xml">
travelling salesman problem</link>, to name two of the most famous examples. Efficient solutions to these problems would have enormous implications for <link xlink:type="simple" xlink:href="../547/77547.xml">
logistics</link>. Many other important problems, such as some problems in <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../769/306769.xml">
Protein structure prediction</link></method>
</know-how>
 are also <b>NP</b>-complete;<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> if these problems were solvable efficiently it could spur considerable advances in biology.</p>
<p>

But such changes may pale in significance compared to the revolution an efficient method for solving NP-complete problems would cause in mathematics itself. According to <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../432/39432.xml">
Stephen Cook</link></scientist>
</person>
,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></p>

<p>

...it would transform mathematics by allowing a computer to find a formal proof of any theorem which has a proof of a reasonable length, since formal proofs can easily be recognized in polynomial time. Example problems may well include all of the <link xlink:type="simple" xlink:href="../655/7655.xml#xpointer(//*[./st=%22Millennium+Prize+Problems%22])">
CMI prize problems</link>.</p>

<p>

Research mathematicians spend their careers trying to prove theorems, and some proofs have taken decades or even centuries to find after problems have been stated – for instance, <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../953/19021953.xml">
Fermat's Last Theorem</link></proposition>
</theorem>
</message>
</statement>
 took over three centuries to prove. A method that is guaranteed to find proofs to theorems, should one exist of a "reasonable" size, would essentially end this struggle.</p>
<p>

A proof that showed that <b>P</b> ≠ <b>NP</b>, while lacking the practical computational benefits of a proof that <b>P</b> = <b>NP</b>, would also represent a massive advance in computational complexity theory and provide guidance for future research. It would allow one to show in a formal way that many common problems cannot be solved efficiently, so that the attention of researchers can be focused on partial solutions or solutions to other problems. Due to widespread belief in <b>P</b> ≠ <b>NP</b>, much of this focusing of research has already taken place.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref></p>

</sec>
<sec>
<st>
Results about difficulty of proof</st>

<p>

The Clay Mathematics Institute million-dollars prize and a huge amount of dedicated research with no substantial results suggest that the problem is difficult. In fact, some of the most fruitful research related to the <b>P</b> = <b>NP</b> problem has been in showing that existing proof techniques are not powerful enough to answer the question, thus suggesting that novel technical approaches are probably required.</p>
<p>

Essentially all known proof techniques in <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link> theory fall into one of the following classifications, each of which is known to be insufficient to prove that <b>P</b> ≠ <b>NP</b>:</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Relativizing proofs:</b> Imagine a world where every algorithm is allowed to make queries to some fixed subroutine called an <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle</link>, and the running time of the oracle is not counted against the running time of the algorithm. Most proofs, especially classical ones, apply uniformly in a world with oracles, regardless of what the oracle does. These proofs are called <it>relativizing</it>. In 1975, Baker, Gill, and Solovay showed that <b>P</b> = <b>NP</b> with respect to some oracles, while <b>P</b> ≠ <b>NP</b> for other oracles.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref> Since relativizing proofs can only prove statements that are uniformly true with respect to all possible oracles, this showed that relativizing techniques cannot resolve <b>P</b> = <b>NP</b>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Natural proofs:</b> In 1993, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../454/3533454.xml">
Alexander Razborov</link></scientist>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<link xlink:type="simple" xlink:href="../947/1822947.xml">
Steven Rudich</link></recipient>
</scientist>
</acquirer>
</causal_agent>
</laureate>
</honoree>
</person>
</physical_entity>
 defined a general class of proof techniques for circuit complexity lower bounds, called <it><link xlink:type="simple" xlink:href="../262/662262.xml">
natural proof</link>s</it>. At the time, all previously known circuit lower bounds were natural, and circuit complexity was considered a very promising approach for resolving <b>P</b> = <b>NP</b>. However, Razborov and Rudich showed that in order to prove <b>P</b> ≠ <b>NP</b> using a natural proof, one necessarily must also prove an even stronger statement, which is believed to be false. Thus it is unlikely that natural proofs alone can resolve <b>P</b> = <b>NP</b>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Algebrizing proofs:</b> After the Baker-Gill-Solovay result, new non-relativizing proof techniques were successfully used to prove that <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP</link></group>
</collection>
</class>
 = <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
. However, in 2008, Aaronson and Wigderson showed that the main new technical tool used in the <b>IP</b> = <b>PSPACE</b> proof, which they called <it>algebrization</it>, was also insufficient to resolve <b>P</b> = <b>NP</b>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></entry>
</list>
</p>
<p>

These barriers are another reason why <b>NP</b>-complete problems are useful: if a polynomial-time algorithm can be demonstrated for an <b>NP</b>-complete problem, this would solve the <b>P</b> = <b>NP</b> problem in a way which is not excluded by the above results.</p>

</sec>
<sec>
<st>
Polynomial-time algorithms</st>

<p>

No one knows whether polynomial-time algorithms exist for <b>NP</b>-complete languages. But if such algorithms do exist, some of them are already known. For example, the following algorithm (due to Levin) correctly accepts an <b>NP</b>-complete language, but as of 2008, it is unknown how long it takes in general.</p>
<p>

// Algorithm that accepts the NP-complete language <link xlink:type="simple" xlink:href="../811/36811.xml">
SUBSET-SUM</link>.
//
// This is a polynomial-time algorithm if and only if <b>P</b>=<b>NP</b>.
//
// "Polynomial-time" means it returns "yes" in polynomial time when 
// the answer should be "yes", and runs forever when it is "no".
//
// Input:  S = a finite set of integers
// Output: "yes" if any subset of S adds up to 0.
//         Runs forever with no output otherwise.
// Note:  "Program number P" is the program obtained by
//         writing the integer P in binary, then
//         considering that string of bits to be a
//         program. Every possible program can be
//         generated this way, though most do nothing
//         because of syntax errors.
FOR N = 1...infinity
FOR P = 1...N
Run program number P for N steps with input S
IF the program outputs a list of distinct integers
AND the integers are all in S
AND the integers sum to 0
THEN
OUTPUT "yes" and HALT</p>
<p>

If, and only if, <b>P</b> = <b>NP</b>, then this is a polynomial-time algorithm accepting an <b>NP</b>-complete language. "Accepting" means it gives "yes" answers in polynomial time, but is allowed to run forever when the answer is "no".</p>
<p>

Perhaps we want to "solve" the SUBSET-SUM problem, rather than just "accept" the SUBSET-SUM language. That means we want the algorithm to always halt and return a "yes" or "no" answer. <link xlink:type="simple" xlink:href="../491/6699491.xml">
As of 2008</link>, it is unknown whether an algorithm exists that does this in polynomial time. But if there is an algorithm that provably does this in polynomial time, then so does the algorithm that is obtained by replacing the IF statement in the above algorithm with this:</p>
<p>

IF the program outputs a complete math proof
AND each step of the proof is legal
AND the conclusion is that S does (or does not) have a subset summing to 0
THEN
OUTPUT "yes" (or "no") and HALT</p>

</sec>
<sec>
<st>
Logical characterizations</st>

<p>

The <b>P</b> = <b>NP</b> problem can be restated in terms of the expressibility of certain classes of logical statements, as a result of work in <link xlink:type="simple" xlink:href="../009/1212009.xml">
descriptive complexity</link>. All languages (of finite structures with a fixed <link xlink:type="simple" xlink:href="../156/7788156.xml">
signature</link> including a <link xlink:type="simple" xlink:href="../330/30330.xml">
linear order</link> relation) in <b>P</b> can be expressed in <link xlink:type="simple" xlink:href="../983/10983.xml">
first-order logic</link> with the addition of a suitable <link xlink:type="simple" xlink:href="../913/1211913.xml">
least fixed point</link> operator (effectively, this, in combination with the order, allows the definition of recursive functions); indeed, (as long as the signature contains at least one predicate or function in addition to the distinguished order relation [so that the amount of space taken to store such finite structures is actually polynomial in the number of elements in the structure]), this precisely characterizes <b>P</b>. Similarly, <b>NP</b> is the set of languages expressible in existential <link xlink:type="simple" xlink:href="../428/341428.xml">
second-order logic</link> &mdash; that is, second-order logic restricted to exclude <link xlink:type="simple" xlink:href="../174/76174.xml">
universal quantification</link> over relations, functions, and subsets. The languages in the <link xlink:type="simple" xlink:href="../651/658651.xml">
polynomial hierarchy</link>, <b><class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../608/658608.xml">
PH</link></group>
</collection>
</class>
</b>, correspond to all of <link xlink:type="simple" xlink:href="../428/341428.xml">
second-order logic</link>. Thus, the question "is <b>P</b> a proper subset of <b>NP</b>" can be reformulated as "is existential second-order logic able to describe languages (of finite linearly ordered structures with nontrivial signature) that first-order logic with least fixed point cannot?". The word "existential" can even be dropped from the previous characterization, since <b>P</b> = <b>NP</b> if and only if <b>P</b> = <b>PH</b> (as the former would establish that <b>NP</b> = <b>co-NP</b>, which in turn would imply that <b>NP</b> = <b>PH</b>).</p>

</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
<b>P</b> (complexity)</link></group>
</collection>
</class>
</entry>
<entry level="1" type="bullet">

<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
<b>NP</b> (complexity)</link></group>
</collection>
</class>
</entry>
<entry level="1" type="bullet">

<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
<b>NP</b>-complete</link></group>
</collection>
</class>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../419/317419.xml">
Game complexity</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../179/3262179.xml">
Cobham's thesis</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../069/1101069.xml">
List of open problems in computer science</link></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../091/183091.xml">
Unsolved problems in mathematics</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>


<p>

<reflist>
<entry id="1">
R. E. Ladner "On the structure of polynomial time reducibility," J.ACM, 22, pp. 151&ndash;171, 1975. Corollary 1.1. <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?id=321877&amp;dl=ACM&amp;coll=&amp;CFID=15151515&amp;CFTOKEN=6184618">
ACM site</weblink>.</entry>
<entry id="2">
"<weblink xlink:type="simple" xlink:href="http://www.claymath.org/millennium/">
Millennium Prize Problems</weblink>"&#32;(2000-05-24).&#32;Retrieved on <link>
2008-01-12</link>.</entry>
<entry id="3">
Scott Aaronson. Complexity Zoo: FP. "FP = FNP if and only if P = NP". http://qwiki.stanford.edu/wiki/Complexity_Zoo#fp</entry>
<entry id="4">
Sipser, Michael: <it>Introduction to the Theory of Computation, Second Edition, International Edition</it>, page 270. Thomson Course Technology, 2006. Definition 7.19 and Theorem 7.20.</entry>
<entry id="5">
 <cite style="font-style:normal">William I. Gasarch&#32;(June 2002).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/~gasarch/papers/poll.pdf">
The P=?NP poll.</weblink>"&#32;(PDF). <it>SIGACT News</it>&#32;<b>33</b>&#32;(2): 34–47. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F1052796.1052804">
10.1145/1052796.1052804</weblink>.</cite>&nbsp;</entry>
<entry id="6">
M. Agrawal, N. Kayal, N. Saxena.&#32;"<weblink xlink:type="simple" xlink:href="http://www.cse.iitk.ac.in/users/manindra/algebra/primality_v6.pdf">
Primes is in P</weblink>".</entry>
<entry id="7">
<process wordnetid="105701363" confidence="0.8">
<institute wordnetid="108407330" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<association wordnetid="108049401" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../847/405847.xml">
AKS primality test</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</association>
</thinking>
</inquiry>
</institute>
</process>
</entry>
<entry id="8">
Scott Aaronson.&#32;"<weblink xlink:type="simple" xlink:href="http://www.scottaaronson.com/democritus/lec6.html">
PHYS771 Lecture 6: P, NP, and Friends</weblink>".&#32;Retrieved on <link>
2007-08-27</link>.</entry>
<entry id="9">
 <cite style="font-style:normal">Berger B, Leighton T&#32;(1998).&#32;"Protein folding in the hydrophobic-hydrophilic (HP) model is NP-complete". <it>J. Comput. Biol.</it>&#32;<b>5</b>&#32;(1): 27–40. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F1052796.1052804">
10.1145/1052796.1052804</weblink>. PMID 9541869.</cite>&nbsp;</entry>
<entry id="10">
Stephen Cook.&#32;"<weblink xlink:type="simple" xlink:href="http://www.claymath.org/millennium/P_vs_NP/Official_Problem_Description.pdf">
The P versus NP Problem</weblink>"&#32;(PDF).&#32;Retrieved on <link>
2007-08-27</link>.</entry>
<entry id="11">
 <cite style="font-style:normal">L. R. Foulds&#32;(October 1983).&#32;"<weblink xlink:type="simple" xlink:href="http://www.jstor.org/pss/2580891">
The Heuristic Problem-Solving Approach</weblink>". <it>The Journal of the Operational Research Society</it>&#32;<b>34</b>&#32;(10): pp. 927–934. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.2307%2F2580891">
10.2307/2580891</weblink>.</cite>&nbsp;</entry>
<entry id="12">
T. P. Baker, J. Gill, R. Solovay. <it>Relativizations of the P =? NP Question</it>. <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<periodical wordnetid="106593296" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../724/1230724.xml">
SIAM Journal on Computing</link></publication>
</periodical>
</artifact>
</creation>
</product>
</work>
, 4(4): 431-442 (1975)</entry>
<entry id="13">
S. Aaronson and A. Wigderson. Algebrization: A New Barrier in Complexity Theory, in Proceedings of ACM STOC'2008, pp. 731-740.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
Further reading</st>

<p>

<list>
<entry level="1" type="bullet">

 A. S. Fraenkel and D. Lichtenstein, Computing a perfect strategy for n*n chess requires time exponential in n, Proc. 8th Int. Coll. <it>Automata, Languages, and Programming</it>, Springer LNCS 115 (1981) 278–293 and <it>J. Comb. Th. A</it> 31 (1981) 199–214.</entry>
<entry level="1" type="bullet">

 E. Berlekamp and D. Wolfe, Mathematical Go: Chilling Gets the Last Point, A. K. Peters, 1994. D. Wolfe, Go endgames are hard, MSRI Combinatorial Game Theory Research Worksh., 2000.</entry>
<entry level="1" type="bullet">

 <peer wordnetid="109626238" confidence="0.8">
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/1370768.xml">
Neil Immerman</link></scholar>
</causal_agent>
</alumnus>
</laureate>
</associate>
</recipient>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</physical_entity>
</peer>
. Languages Which Capture Complexity Classes. <it>15th ACM STOC Symposium</it>, pp.347–354. 1983.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
&#32;(2001).&#32;"Chapter 34: NP-Completeness", <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, Second Edition,&#32;MIT Press and McGraw-Hill,&#32;pp.966–1021. ISBN 0-262-03293-7.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<link xlink:type="simple" xlink:href="../428/3509428.xml">
Christos Papadimitriou</link></scholar>
</writer>
</causal_agent>
</academician>
</alumnus>
</laureate>
</communicator>
</associate>
</educator>
</recipient>
</professional>
</adult>
</scientist>
</acquirer>
</colleague>
</intellectual>
</honoree>
</person>
</peer>
</physical_entity>
&#32;(1993).&#32;"Chapter 14: On P vs. NP", Computational Complexity, 1st edition,&#32;Addison Wesley,&#32;pp.329–356. ISBN 0-201-53082-1.</cite>&nbsp;</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.claymath.org/millennium/">
The Clay Mathematics Institute Millennium Prize Problems</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.claymath.org/millennium/P_vs_NP/Official_Problem_Description.pdf">
The Clay Math Institute Official Problem Description</weblink><message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../077/24077.xml">
PDF</link></format>
</language>
</information>
</message>
&nbsp;(118&nbsp;<link xlink:type="simple" xlink:href="../755/149755.xml">
KiB</link>)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.claymath.org/Popular_Lectures/Minesweeper/">
Ian Stewart on Minesweeper as <b>NP</b>-complete at The Clay Math Institute</weblink></entry>
<entry level="1" type="bullet">

 Gerhard J. Woeginger. <weblink xlink:type="simple" xlink:href="http://www.win.tue.nl/~gwoegi/P-versus-NP.htm">
The P-versus-NP page</weblink>. A list of links to a number of purported solutions to the problem. Some of these links state that P equals NP, some of them state the opposite. It is probable that all these alleged solutions are incorrect.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ics.uci.edu/~eppstein/cgt/hard.html">
Computational Complexity of Games and Puzzles</weblink></entry>
<entry level="1" type="bullet">

 Scott Aaronson's Complexity Zoo: <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#p">
P</weblink>, <weblink xlink:type="simple" xlink:href="http://qwiki.caltech.edu/wiki/Complexity_Zoo#np">
NP</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.qeden.com/">
Qeden</weblink>, a wiki that aims to solve the Millennium Prize Problems ("down for maintenance" as of 15th of July 2008)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://scottaaronson.com/blog/?p=122">
Scott Aaronson's Shtetl Optimized blog: Reasons to believe</weblink>, a list of justifications for the belief that P ≠ NP</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
Important <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link>es (<link xlink:type="simple" xlink:href="../359/663359.xml">
more</link>)</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../550/658550.xml">
P</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
&nbsp;• <link xlink:type="simple" xlink:href="../184/6184.xml">
co-NP</link>&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-C</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../680/54680.xml">
co-NP-C</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../681/54681.xml">
NP-hard</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../240/312240.xml">
UP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../924/27924.xml">
<list>
<entry level="1" type="number">

P</entry>
</list>
</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../925/27925.xml">
<list>
<entry level="1" type="number">

P-C</entry>
</list>
</link></group>
</collection>
</class>
&nbsp;• <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../999/1149999.xml">
L</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
&nbsp;• <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../955/1145955.xml">
NL</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../073/22073.xml">
NC</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../683/54683.xml">
P-C</link></group>
</collection>
</class>
&nbsp;• <mathematical_relation wordnetid="113783581" confidence="0.8">
<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<operator wordnetid="113786413" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../351/39351.xml">
PSPACE</link></function>
</operator>
</group>
</collection>
</class>
</mathematical_relation>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../685/54685.xml">
PSPACE-C</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../694/54694.xml">
EXPTIME</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../657/663657.xml">
NEXPTIME</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../703/54703.xml">
EXPSPACE</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../202/11387202.xml">
2-EXPTIME</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../897/3106897.xml">
PR</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../703/3106703.xml">
RE</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../741/3106741.xml">
Co-RE</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../251/3123251.xml">
RE-C</link></group>
</collection>
</class>
&nbsp;• <link xlink:type="simple" xlink:href="../283/3123283.xml">
Co-RE-C</link>&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../763/3106763.xml">
R</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../080/4080.xml">
BQP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../079/4079.xml">
BPP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../771/54771.xml">
RP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../772/54772.xml">
ZPP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../509/504509.xml">
PCP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../070/2197070.xml">
IP</link></group>
</collection>
</class>
&nbsp;• <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../608/658608.xml">
PH</link></group>
</collection>
</class>
</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</group>
</collection>
</difficulty>
</problem>
</class>
</state>
</condition>
</article>
