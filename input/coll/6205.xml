<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:23:09[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Chaitin&apos;s constant</title>
<id>6205</id>
<revision>
<id>233719573</id>
<timestamp>2008-08-23T11:44:47Z</timestamp>
<contributor>
<username>Physis</username>
<id>822864</id>
</contributor>
</revision>
<categories>
<category>Theory of computation</category>
<category>Algorithmic information theory</category>
<category>Transcendental numbers</category>
</categories>
</header>
<bdy>

In the <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link> subfield of <link xlink:type="simple" xlink:href="../647/2829647.xml">
algorithmic information theory</link> a <b>Chaitin <link xlink:type="simple" xlink:href="../453/12860453.xml">
constant</link></b> or <b>halting probability</b> is a <link xlink:type="simple" xlink:href="../491/19725491.xml">
real number</link> that informally represents the <link xlink:type="simple" xlink:href="../934/22934.xml">
probability</link> that a randomly-chosen program will halt. These numbers are formed from a construction due to <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../308/12308.xml">
Gregory Chaitin</link></person>
. <p>

Although there are infinitely many halting probabilities, it is common to use the letter Ω to refer to them as if there were only one.  Because Ω depends on the program encoding used, it is sometimes called <b>Chaitin's construction</b> instead of <b>Chaitin's constant</b> when not referring to any specific encoding.</p>
<p>

Each halting probability is a <link xlink:type="simple" xlink:href="../277/204277.xml">
normal</link> and <link xlink:type="simple" xlink:href="../325/30325.xml">
transcendental</link> real number which is not <link xlink:type="simple" xlink:href="../206/6206.xml">
computable</link>, which means that there is no halting <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that enumerates its digits. 
</p>
<sec>
<st>
Background</st>

<p>

The definition of a halting probability relies on the existence of <b>prefix-free universal computable functions.</b>  Such a function, intuitively, represents a programming language with the property that no valid program can be obtained as a proper extension of another valid program.</p>
<p>

Suppose that a function <it>F</it> takes two arguments, each of which is a finite binary string, and returns a single binary string as output.  The function <it>F</it> is called <b><link xlink:type="simple" xlink:href="../338/1139338.xml">
computable</link></b> if there is a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 that computes it.</p>
<p>

The function <it>F</it> is called <b><link xlink:type="simple" xlink:href="../621/30621.xml">
universal</link></b> if the following property holds:  for every computable function <it>f</it> of a single variable <it>x</it> there is a constant <it>p</it> such that for all <it>x</it>, <it>F</it>(<it>p</it>,<it>x</it>) = <it>f</it>(<it>x</it>).  This means that <it>F</it> can be used to simulate any computable function of one variable.  Informally, <it>p</it> represents a "program" for the computable function <it>f</it>, and <it>F</it> represents an emulator that takes the program as input and then executes it. 
Note that for any fixed <it>p</it> the function <it>f</it>(<it>x</it>) = <it>F</it>(<it>p</it>,<it>x</it>) is computable; thus the universality property states that all computable functions of one variable can be obtained in this fashion.</p>
<p>

The <b>domain</b> of <it>F</it> is the set of all programs <it>p</it> such that for at least one value of <it>x</it> the value of <it>F</it>(<it>p</it>,<it>x</it>) is defined. In other words, the domain is the set of all programs that encode functions other than the <link xlink:type="simple" xlink:href="../274/309274.xml">
empty function</link>.</p>
<p>

The function <it>F</it> is called <b>prefix-free</b> if there are no two elements <it>p</it>, <it>p&amp;prime;</it> in its domain such that <it>p&amp;prime;</it> is a proper extension of <it>p</it>.   This can be rephrased as: the domain of <it>F</it> is a <link xlink:type="simple" xlink:href="../193/66193.xml">
prefix-free code</link> (instantaneous code) on the set of finite binary strings.   The domain of any universal computable function is a <link xlink:type="simple" xlink:href="../090/332090.xml">
computably enumerable set</link> but never a <link xlink:type="simple" xlink:href="../264/332264.xml">
computable set</link>.  The domain is always <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> to the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link>.</p>

</sec>
<sec>
<st>
Definition of halting probabilities</st>

<p>

Let <it>P</it>F be the domain of a prefix-free universal computable function <it>F</it>.  The constant ΩF is then defined as
<indent level="1">

<math>\Omega_F = \sum_{p \in P_F} 2^{-|p|}</math>,
</indent>
where <math>\left|p\right|</math> denotes the length of a string <it>p</it>.
This is an <link xlink:type="simple" xlink:href="../287/15287.xml">
infinite sum</link> which has one summand for every <it>p</it> in the domain of <it>F</it>.  The requirement that the domain be prefix-free, together with <link xlink:type="simple" xlink:href="../798/1471798.xml">
Kraft's inequality</link>, ensures that this sum converges to a <link xlink:type="simple" xlink:href="../491/19725491.xml">
real number</link> between 0 and 1.  If <it>F</it> is clear from context then ΩF may be denoted simply Ω, although different prefix-free universal computable functions lead to different values of Ω.</p>

</sec>
<sec>
<st>
Use of Chaitin's constant in proving unsolved problems in number theory</st>

<p>

Chaitin's constant can be used, in principle, to solve many outstanding problems in number theory, including <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<condition wordnetid="113920835" confidence="0.8">
<speculation wordnetid="105891783" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<hypothesis wordnetid="105888929" confidence="0.8">
<link xlink:type="simple" xlink:href="../758/44758.xml">
Goldbach's conjecture</link></hypothesis>
</difficulty>
</problem>
</state>
</speculation>
</condition>
</concept>
</idea>
 and the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../125/19344125.xml">
Riemann hypothesis</link></difficulty>
</problem>
</state>
</condition>
.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

Goldbach's  conjecture says every even number greater than 2 is the sum of two primes.  For a given even number, let a computer program iterate through the even numbers, beginning with the given one, searching for corresponding two primes in each instance.  If the appropriate primes exist, then the program finds them eventually, advances to the next even number and the search is continued.  If there are no two primes that add to the even number, then the program exhausts eventually all possible prime pairs in the test, thus it notices that a counterexample has just been found, it halts and Goldbach's conjecture has been disproved. Thus, this is a counterexample-searching program, it "freezes" exactly if Goldbach's conjecture is true, it halts (with a counterexample) exactly if the conjecture is false.</p>
<p>

Let this program be <it>N</it> bits long.  Given unlimited resources and time, Chaitin's number can be used to prove Goldbach's conjecture as follows.  In parallel, all of the programs of <it>N</it>+1 bits or less are run.  If the <it>N</it> bit Goldbach program halts, then the conjecture is proven false.  If, on the other hand, enough of the other programs stop such that one more program stopping would result in a number exceeding Chaitin's number, then if a program hasn't halted, it will never halt and Goldbach's conjecture is proved.  To use this procedure, we only require the first <it>N</it>+1 bits of Chaitin's number.</p>
<p>

The same Chaitin constant can be used to prove (or disprove) the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../125/19344125.xml">
Riemann hypothesis</link></difficulty>
</problem>
</state>
</condition>
 and many other of the <link xlink:type="simple" xlink:href="../091/183091.xml">
unsolved problems in mathematics</link>.</p>

</sec>
<sec>
<st>
Interpretation as a probability</st>

<p>

The <link xlink:type="simple" xlink:href="../376/352376.xml">
Cantor space</link> is the collection of all infinite sequences of 0s and 1s. A halting probability can be interpreted as the <link xlink:type="simple" xlink:href="../873/19873.xml">
measure</link> of a certain subset of Cantor space under the usual <link>
probability measure</link> on Cantor space.  It is from this interpretation that halting probabilities take their name.</p>
<p>

The probability measure on Cantor space, sometimes called the fair-coin measure, is defined so that for any binary string <it>x</it> the set of sequences that begin with <it>x</it> has measure 2-|<it>x</it>|. This implies that for each natural number <it>n</it>, the set of sequences <it>f</it> in Cantor space such that <it>f</it>(<it>n</it>) = 1 has measure 1/2, and the set of sequences whose <it>n</it>th element is 0 also has measure 1/2.</p>
<p>

Let <it>F</it> be a prefix-free universal computable function. The domain <it>P</it> of <it>F</it> consists of an infinite set of binary strings
<indent level="1">

<math>P = \{p_1,p_2,\ldots\}</math>.
</indent>
Each of these strings <it>pi</it> determines a subset <it>Si</it> of Cantor space; the set <it>Si</it>  contains all sequences in cantor space that begin with <it>pi</it>. These sets are disjoint because <it>P</it> is a prefix-free set.  The sum
<indent level="1">

<math>\sum_{p \in P} 2^{-|p|}</math>
</indent>
represents the measure of the set 
<indent level="1">

<math>\bigcup_{i \in \mathbb{N}} S_i</math>.
</indent>

In this way, Ω<it>F</it> represents the probability that a randomly selected infinite sequence of 0s and 1s begins with a bit string (of some finite length) that is in the domain of <it>F</it>. It is for this reason that Ω<it>F</it> is called a halting probability.</p>

</sec>
<sec>
<st>
 Properties </st>

<p>

Each Chaitin constant Ω has the following properties:
<list>
<entry level="1" type="bullet">

 It is <link xlink:type="simple" xlink:href="../635/1635.xml">
algorithmically random</link>. This means that for each particular programming language there is a constant <it>C</it> such that for each <it>n</it> any halting program in that language that outputs the first <it>n</it> bits must have length no shorter than (<it>n</it> — <it>C</it>). </entry>
<entry level="1" type="bullet">

 It is a <link xlink:type="simple" xlink:href="../277/204277.xml">
normal number</link>, which means that its digits are equidistributed as if they were generated by tossing a fair coin.</entry>
<entry level="1" type="bullet">

 It is not a <link xlink:type="simple" xlink:href="../206/6206.xml">
computable number</link>; there is no computable function that enumerates its binary expansion, as discussed below. </entry>
<entry level="1" type="bullet">

 The set of rational numbers <it>q</it> such that <it>q</it> ≤ Ω is <link xlink:type="simple" xlink:href="../090/332090.xml">
computably enumerable</link>; a real number with such a property is called a <b>left-c.e. real number</b> in <link xlink:type="simple" xlink:href="../414/155414.xml">
recursion theory</link>. </entry>
<entry level="1" type="bullet">

 It is <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> to the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link> and thus at level <math>\Sigma^0_1</math> of the <link xlink:type="simple" xlink:href="../475/186475.xml">
arithmetical hierarchy</link>. </entry>
</list>
</p>
<p>

Not every set Turing equivalent to the halting problem is a halting probability.   A finer equivalence relation, <b>Solovay equivalence</b>, can be used to characterize the halting probabilities among the left-c.e. reals.</p>

</sec>
<sec>
<st>
 Uncomputability of halting probabilities </st>
<p>

A real number is called computable if there is an algorithm which, given <it>n</it>, returns the first <it>n</it> digits of the number.  This is equivalent to the existence of a program that enumerates the digits of the real number.</p>
<p>

No halting probability is computable. The proof of this fact relies on an algorithm which, given the first <it>n</it> digits of Ω, solves Turing's <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link> for programs of length up to <it>n</it>. Since the halting problem is <link xlink:type="simple" xlink:href="../795/54795.xml">
undecidable</link>, Ω can not be computed.</p>
<p>

The algorithm proceeds as follows.  Given the first <it>n</it> digits of Ω and a <it>k</it>≤<it>n</it>, the algorithm enumerates the domain of <it>F</it> until enough elements of the domain have been found so that the probability they represent is within 2-(k+1) of Ω. After this point, no additional program of length <it>k</it> can be in the domain, because each of these would add 2-<it>k</it> to the measure, which is impossible.  Thus the set of strings of length <it>k</it> in the domain is exactly the set of such strings already enumerated. </p>

</sec>
<sec>
<st>
 Incompleteness theorem for halting probabilities </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../635/1635.xml#xpointer(//*[./st=%22Chaitin's+incompleteness+theorem%22])">
Kolmogorov complexity#Chaitin's incompleteness theorem</link></it>
</indent>

For each specific consistent effectively represented <link xlink:type="simple" xlink:href="../401/188401.xml">
axiomatic system</link> for the <link xlink:type="simple" xlink:href="../474/21474.xml">
natural numbers</link>, such as <process wordnetid="105701363" confidence="0.8">
<maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/25005.xml">
Peano arithmetic</link></higher_cognitive_process>
</theory>
</explanation>
</auditory_communication>
</thinking>
</saying>
</speech>
</maxim>
</process>
, there exists a constant <it>N</it> such that no bit of Ω after the <it>N</it>th can be proven to be one or zero within that system. The constant <it>N</it> depends on how the <link xlink:type="simple" xlink:href="../102/396102.xml">
formal system</link> is effectively represented, and thus does not directly reflect the complexity of the axiomatic system. This incompleteness result is similar to <link>
Gödel's incompleteness theorem</link> in that it shows that no consistent formal theory for arithmetic can be complete. </p>

</sec>
<sec>
<st>
 Super Omega </st>

<p>

As mentioned above, the first n bits of <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../308/12308.xml">
Gregory Chaitin</link></person>
's constant Omega are random or  incompressible in the sense that we cannot compute them by a halting algorithm with fewer than n-O(1) bits. However, consider the short but never halting algorithm which systematically lists and runs all possible programs; whenever one of them halts its probability gets added to the output (initialized by zero). After finite time the first n bits of the output will never change any more (it does not matter that this time itself is not computable by a halting program). So there is a short non-halting algorithm whose output converges (after finite time) onto the first n bits of Omega, for any n. In other words, the <link xlink:type="simple" xlink:href="../115/212115.xml">
enumerable</link> first n bits of Omega are highly <link xlink:type="simple" xlink:href="../084/166084.xml">
compressible</link> in the sense that they are limit-computable by a very short algorithm; they are not <link xlink:type="simple" xlink:href="../523/19196523.xml">
random</link> with respect to the set of enumerating algorithms. <link>
Jürgen Schmidhuber</link> (2000) constructed a limit-computable "Super Omega" which in a sense is much more random than the original limit-computable Omega, as one cannot significantly compress the Super Omega by any enumerating non-halting algorithm.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../635/1635.xml">
Kolmogorov complexity</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../863/58863.xml">
Incompleteness theorem</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Thomas M. Cover and Joy A. Thomas, Elements of Information Theory, 2nd Edition, Wiley-Interscience, 2006.</entry>
</reflist>

<list>
<entry level="1" type="bullet">

Cristian S. Calude (2002). <it>Information and Randomness: An Algorithmic Perspective</it>, second edition. Springer.  ISBN 3-5404-3466-6</entry>
<entry level="1" type="bullet">

Cristian S. Calude, Michael J. Dinneen, and Chi-Kou Shu. <it><weblink xlink:type="simple" xlink:href="http://www.expmath.org/expmath/volumes/11/11.3/Calude361_370.pdf">
Computing a Glimpse of Randomness</weblink>.''</it></entry>
<entry level="1" type="bullet">

R. Downey, and D. Hirschfeldt (200?), <it>Algorithmic Randomness and Complexity</it>, monograph in preparation, Springer-Verlag. Preliminary version can be found <weblink xlink:type="simple" xlink:href="http://www.mcs.vuw.ac.nz/~downey">
online</weblink>.</entry>
<entry level="1" type="bullet">

 Ming Li and Paul Vitányi (1997).  <it>An Introduction to Kolmogorov Complexity and Its Applications</it>. Springer. <weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/li97introduction.html">
Introduction chapter full-text</weblink>.</entry>
<entry level="1" type="bullet">

 <link>
Jürgen Schmidhuber</link> (2000). Algorithmic Theories of Everything (arXiv: quant-ph/ 0011122). Journal reference:  J. Schmidhuber (2002). Hierarchies of generalized Kolmogorov complexities and nonenumerable universal measures computable in the limit. International Journal of Foundations of Computer Science 13(4):587-612.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.plus.maths.org.uk/issue37/features/omega/index.html">
Omega and why math has no TOEs</weblink> article based on one written by <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../308/12308.xml">
Gregory Chaitin</link></person>
 which appeared in the August 2004 edition of Mathematics Today, on the occasion of the 50th anniversary of Alan Turing's death.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.auckland.ac.nz/CDMTCS/chaitin/sciamer3.html">
<it>The Limits of Reason''</it></weblink>, Gregory Chaitin, originally appeared in Scientific American, March 2006.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.idsia.ch/~juergen/kolmogorov.html">
Limit-computable Super Omega more random than Omega</weblink> and generalizations of algorithmic information, by <link>
Jürgen Schmidhuber</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
