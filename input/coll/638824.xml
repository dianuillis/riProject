<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:26:18[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Interrupt handler</title>
<id>638824</id>
<revision>
<id>223885312</id>
<timestamp>2008-07-06T09:51:17Z</timestamp>
<contributor>
<username>Himynameisjosie</username>
<id>7809196</id>
</contributor>
</revision>
<categories>
<category>Interrupts</category>
<category>Operating system technology</category>
</categories>
</header>
<bdy>

An <b>interrupt handler</b>, also known as an <b>interrupt service routine</b> (<b>ISR</b>), is a <link xlink:type="simple" xlink:href="../246/645246.xml">
callback</link> subroutine in an <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> or <link xlink:type="simple" xlink:href="../101/9101.xml">
device driver</link> whose execution is triggered by the reception of an <link xlink:type="simple" xlink:href="../289/15289.xml">
interrupt</link>. Interrupt handlers have a multitude of functions, which vary based on the reason the interrupt was generated and the speed at which the Interrupt Handler completes its task.<p>

An interrupt handler is a low-level counterpart of <link xlink:type="simple" xlink:href="../300/444300.xml">
event handler</link>s. These handlers are initiated by either hardware interrupts or interrupt instructions in software, and are used for servicing hardware devices and transitions between protected modes of operation such as system calls.</p>

<sec>
<st>
 Overview </st>
<p>

In modern operating systems, interrupt handlers are divided into two parts: the First-Level Interrupt Handler (FLIH) and the Second-Level Interrupt Handlers (SLIH). FLIHs are also known as <it>hard interrupt handlers</it>, <it>fast interrupt handlers</it> and <it>top-half of interrupt</it>, and SLIHs are also known as <it>interrupt threads</it>, <it>slow interrupt handlers</it> and <it>bottom-half of interrupt</it>. </p>
<p>

A FLIH implements at minimum platform specific interrupt handling similarly to <it>interrupt routines</it>. In response to an interrupt, there is a <link xlink:type="simple" xlink:href="../904/6904.xml">
context switch</link>, and the code for the interrupt is loaded and executed. The job of a FLIH is to quickly service the interrupt, or to record platform specific critical information which is only available at the time of the interrupt, and <link xlink:type="simple" xlink:href="../457/400457.xml">
schedule</link> the execution of a SLIH for further long-lived interrupt handling.</p>
<p>

FLIHs cause <link xlink:type="simple" xlink:href="../296/41296.xml">
jitter</link> in process execution. FLIHs also mask interrupts. Reducing the jitter is most important for <link xlink:type="simple" xlink:href="../123/26123.xml">
real-time operating system</link>s, since they must maintain a guarantee that execution of specific code will complete within an agreed amount of time.
To reduce jitter and to reduce the potential for losing data from masked interrupts, programmers attempt to minimize the execution time of a FLIH, moving as much as possible to the SLIH.
With the speed of modern computers, FLIHs may implement all device and platform dependent handling, and use a SLIH for further platform independent long-lived handling.</p>
<p>

FLIHs which service hardware typically mask their associated interrupt (or keep it masked as the case may be) until they complete their execution. Otherwise, these interrupt handlers might cause a stack overflow from multiple <link xlink:type="simple" xlink:href="../566/2204566.xml">
preemption</link>s by the same <link xlink:type="simple" xlink:href="../036/1303036.xml">
interrupt vector</link>.  In a <link xlink:type="simple" xlink:href="../500/3457500.xml">
priority interrupt</link> system, the FLIH also (briefly) masks other interrupts of equal or lesser priority.</p>
<p>

A SLIH completes long interrupt processing tasks similarly to a process. SLIHs either have a dedicated <link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link> thread for each handler, or are executed by a pool of kernel worker threads. These threads sit on a <link xlink:type="simple" xlink:href="../849/638849.xml">
run queue</link> in the operating system until processor time is available for them to perform processing for the interrupt. SLIHs may have a long-lived execution time, and thus are typically scheduled similarly to threads and processes.</p>
<p>

It is worth noting that in many systems the FLIH and SLIH are referred to as <it>upper halves</it> and <it>lower halves</it>, <it>hardware</it> and <it>software</it> interrupts, or a derivation of those names.</p>

</sec>
<sec>
<st>
 Interrupt threads </st>
<p>

Several operating systems - <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/46145.xml">
Solaris</link></database>
</wordnet>
</lexical_database>
</electronic_database>
</information>
</message>
, <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link>, <link xlink:type="simple" xlink:href="../360/230360.xml">
WinCE</link> and <platform wordnetid="103961939" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<surface wordnetid="104362025" confidence="0.8">
<horizontal_surface wordnetid="103536348" confidence="0.8">
<link xlink:type="simple" xlink:href="../554/7580554.xml">
FreeBSD</link></horizontal_surface>
</surface>
</artifact>
</platform>
, for example - use different scheme known as interrupt threads: interrupt handler is just a high-priority thread which runs with interrupts enabled and, more importantly, may block on <link xlink:type="simple" xlink:href="../827/36827.xml">
mutex</link>. This greatly simplifies locking in the kernel. Also, interrupt thread may be preempted by higher-priority interrupt thread.</p>

</sec>
<sec>
<st>
 SymbianOS </st>
<p>

Because (amongst other reasons) extended processing in a ISR delays the servicing of other interrupts, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../446/72446.xml">
Symbian OS</link></O>
 uses <link>
Delayed Function Calls</link> (DFCs) to perform processing that would be impossible inside the ISR <weblink xlink:type="simple" xlink:href="http://developer.symbian.com/main/downloads/papers/HWinterupt/HwInterrupt.pdf">
http://developer.symbian.com/main/downloads/papers/HWinterupt/HwInterrupt.pdf</weblink>. </p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../403/3253403.xml">
Advanced Programmable Interrupt Controller</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../322/3280322.xml">
Inter-Processor Interrupt</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../289/15289.xml">
Interrupt</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../467/15467.xml">
Interrupt Latency</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../055/1250055.xml">
Non-Maskable Interrupt</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../419/1805419.xml">
Programmable Interrupt Controller</link></entry>
</list>
</p>
<p>

<table style="background:#f9f9f9; font-size:85%; line-height:110%; ">
<row>
<col>
 <image width="32x28px" src="Portal.svg">
</image>
</col>
<col style="padding:0 0.2em;">
 <b><it>
Computer science&#32;portal</it></b></col>
</row>
</table>
</p>




</sec>
</bdy>
</article>
