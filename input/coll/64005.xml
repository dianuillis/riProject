<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:48:40[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Bresenham&apos;s line algorithm</title>
<id>64005</id>
<revision>
<id>242753194</id>
<timestamp>2008-10-03T14:34:05Z</timestamp>
<contributor>
<username>Ed Poor</username>
<id>188</id>
</contributor>
</revision>
<categories>
<category>Computer graphics algorithms</category>
<category>Articles with example pseudocode</category>
<category>Digital geometry</category>
</categories>
</header>
<bdy>
<p>

The <b>Bresenham line algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that determines which points in an n-dimensional <link xlink:type="simple" xlink:href="../787/208787.xml">
raster</link> should be plotted in order to form a close approximation to a straight line between two given points. It is commonly used to draw lines on a computer screen, as it uses only integer addition, subtraction and <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../399/264399.xml">
bit shifting</link></concept>
</idea>
 all of which are very cheap operations in standard computer architectures. It is one of the earliest algorithms developed in the field of <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>.</p>
<p>

Through a minor expansion, the original algorithm for lines can also be used to draw circles. Also this can be done with simple arithmetic operations; quadratic or trigonometric expressions can be avoided or recursively dissolved into simpler steps.</p>
<p>

The mentioned properties make it still an important algorithm, and it is used among others in <link xlink:type="simple" xlink:href="../085/23085.xml">
plotter</link>s, in <substance wordnetid="100019613" confidence="0.8">
<paper wordnetid="114974264" confidence="0.8">
<card wordnetid="102962545" confidence="0.8">
<part wordnetid="113809207" confidence="0.8">
<material wordnetid="114580897" confidence="0.8">
<link xlink:type="simple" xlink:href="../214/390214.xml">
graphics chips</link></material>
</part>
</card>
</paper>
</substance>
 of modern <link xlink:type="simple" xlink:href="../624/113624.xml">
graphics card</link>s, and in many <link xlink:type="simple" xlink:href="../299/4417299.xml">
graphics libraries</link>. Because the algorithm is very simple, it is often implemented in both the <link xlink:type="simple" xlink:href="../155/41155.xml">
firmware</link> and the <link xlink:type="simple" xlink:href="../615/13615.xml">
hardware</link> of graphics cards.</p>
<p>

The label "Bresenham" is today often used for a whole family of algorithms, which have been developed by others, later, yet in succession of Bresenham and with a similar basic approach. See deeper references below.</p>

<sec>
<st>
 The algorithm </st>
<p>

<image location="right" width="300px" src="Bresenham.svg" type="thumb">
<caption>

Illustration of the result of Bresenham's line algorithm.  (0,0) is at the top left corner.
</caption>
</image>

The common conventions that pixel coordinates increase in the down and right directions and that pixel centers have integer coordinates will be used.
The endpoints of the line are the pixels at (<it>x</it>0, <it>y</it>0) and (<it>x</it>1, <it>y</it>1), where the first coordinate of the pair is the column and the second is the row. </p>
<p>

The algorithm will be initially presented only for the <link xlink:type="simple" xlink:href="../982/725982.xml">
octant</link> in which the segment goes down and to the right (<it>x</it>0≤<it>x</it>1 and <it>y</it>0≤<it>y</it>1 ) , and its horizontal projection <math>x_1-x_0</math> is longer than the vertical projection <math>y_1-y_0</math> (in other words, the line has a <link xlink:type="simple" xlink:href="../368/29368.xml">
slope</link> less than 1 and greater than 0.) 
In this octant, for each column <it>x</it> between <math>x_0</math> and <math>x_1</math>, there is exactly one row <it>y</it> (computed by the algorithm) containing a pixel of the line, while each row between <math>y_0</math> and <math>y_1</math> may contain multiple rasterized pixels.</p>
<p>

Bresenham's algorithm chooses the integer <it>y</it> corresponding to the pixel center that is closest to the ideal (fractional) <it>y</it> for the same <it>x</it>; on successive columns y can remain the same or increase by 1.
The general equation of the line through the endpoints is given by:
<indent level="1">

<math>y - y_0 = \frac{y_1-y_0}{x_1-x_0} (x-x_0).</math>
</indent>

Since we know the column, <it>x</it>, the pixel's row, <it>y</it>, is given by rounding this quantity to the nearest integer:</p>
<p>

<indent level="1">

<math>\frac{y_1-y_0}{x_1-x_0} (x-x_0) + y_0.</math>
</indent>

The slope <math>(y_1-y_0)/(x_1-x_0)</math> depends on the endpoint coordinates only and can be precomputed, and the ideal <it>y</it> for successive integer values of <it>x</it> can be computed starting from <math>y_0</math> and repeatedly adding the slope.</p>
<p>

In practice, the algorithm can track, instead of possibly large y values, a small <it>error value</it> between −0.5 and 0.5: the vertical distance between the rounded and the exact <it>y</it> values for the current <it>x</it>. 
Each time <it>x</it> is increased, the error is increased by the slope; if it exceeds 0.5, the rasterization <it>y</it> is increased by 1 (the line continues on the next lower row of the raster) and the error is decremented by 1.0.</p>
<p>

In the following pseudocode sample plot(x,y) plots a point and abs returns <link xlink:type="simple" xlink:href="../991/991.xml">
absolute value</link>:</p>
<p>

<b>function</b> line(x0, x1, y0, y1)
<it>int</it> deltax := x1 - x0
<it>int</it> deltay := y1 - y0
<it>real</it> error := 0
<it>real</it> deltaerr := deltay / deltax    // Assume deltax != 0 (line is not vertical),
// note that this division needs to be done in a way that preserves the fractional part
<it>int</it> y := y0
<b>for</b> x <b>from</b> x0 <b>to</b> x1
plot(x,y)
error := error + deltaerr
<b>if</b> abs(error) ≥ 0.5 <b>then</b>
y := y + 1
error := error - 1.0</p>

</sec>
<sec>
<st>
 Generalization </st>

<p>

Actually this first formation was done by Bresenham.This first version only handles lines that descend to the right. We would of course like to be able to draw all lines. The first case is allowing us to draw lines that still slope downwards but head in the opposite direction. This is a simple matter of swapping the initial points if x0 &amp;gt; x1. Trickier is determining how to draw lines that go up. To do this, we check if <it>y</it>0 ≥ <it>y</it>1; if so, we step <it>y</it> by -1 instead of 1. Lastly, we still need to generalize the algorithm to drawing lines in <it>all</it> directions. Up until now we have only been able to draw lines with a slope less than one. To be able to draw lines with a steeper slope, we take advantage of the fact that a steep line can be reflected across the line <it>y=x</it> to obtain a line with a small slope. The effect is to switch the <it>x</it> and <it>y</it> variables throughout, including switching the parameters to <it>plot</it>. The code looks like this:</p>
<p>

<b>function</b> line(x0, x1, y0, y1)
<it>boolean</it> steep := abs(y1 - y0) &amp;gt; abs(x1 - x0)
<b>if</b> steep <b>then</b>
swap(x0, y0)
swap(x1, y1)
<b>if</b> x0 &amp;gt; x1 <b>then</b>
swap(x0, x1)
swap(y0, y1)
<it>int</it> deltax := x1 - x0
<it>int</it> deltay := abs(y1 - y0)
<it>real</it> error := 0
<it>real</it> deltaerr := deltay / deltax
<it>int</it> ystep
<it>int</it> y := y0
<b>if</b> y0  y1 <b>then</b> ystep := 1 <b>else</b> ystep := -1
<b>for</b> x <b>from</b> x0 <b>to</b> x1
<b>if</b> steep <b>then</b> plot(y,x) <b>else</b> plot(x,y)
error := error + deltaerr
<b>if</b> error ≥ 0.5 <b>then</b>
y := y + ystep
error := error - 1.0</p>
<p>

The function now handles all lines and implements the complete Bresenham's algorithm.</p>

</sec>
<sec>
<st>
 Optimization </st>

<p>

The problem with this approach is that computers operate relatively slowly on fractional numbers like error and deltaerr; moreover, errors can accumulate over many floating-point additions. Working with integers will be both faster and more accurate. The trick we use is to multiply all the fractional numbers above by deltax, which enables us to express them as integers. The only problem remaining is the constant 0.5&mdash;to deal with this, we change the initialization of the variable error, and invert it for an additional small optimization. The new program looks like this:</p>
<p>

<b>function</b> line(x0, x1, y0, y1)
<it>boolean</it> steep := abs(y1 - y0) &amp;gt; abs(x1 - x0)
<b>if</b> steep <b>then</b>
swap(x0, y0)
swap(x1, y1)
<b>if</b> x0 &amp;gt; x1 <b>then</b>
swap(x0, x1)
swap(y0, y1)
<it>int</it> deltax := x1 - x0
<it>int</it> deltay := abs(y1 - y0)
<it>int</it> error := deltax / 2
<it>int</it> ystep
<it>int</it> y := y0
<b>if</b> y0  y1 <b>then</b> ystep := 1 <b>else</b> ystep := -1
<b>for</b> x <b>from</b> x0 <b>to</b> x1
<b>if</b> steep <b>then</b> plot(y,x) <b>else</b> plot(x,y)
error := error - deltay
<b>if</b> error  0 <b>then</b>
y := y + ystep
error := error + deltax</p>

</sec>
<sec>
<st>
 History </st>

<p>

The algorithm was developed by <link xlink:type="simple" xlink:href="../326/938326.xml">
Jack E. Bresenham</link> in 1962 at <link xlink:type="simple" xlink:href="../259/18622259.xml">
IBM</link>. In 2001 Bresenham wrote<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>:
<indent level="1">

"<it>I was working in the computation lab at IBM's San Jose development lab. A <link xlink:type="simple" xlink:href="../316/856316.xml">
Calcomp plotter</link> had been attached to an <computer wordnetid="103082979" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../579/92579.xml">
IBM 1401</link></machine>
</device>
</instrumentality>
</artifact>
</computer>
 via the 1407 typewriter console. [The algorithm] was in production use by summer 1962, possibly a month or so earlier. Programs in those days were freely exchanged among corporations so Calcomp (Jim Newland and Calvin Hefte) had copies. When I returned to Stanford in Fall 1962, I put a copy in the Stanford comp center library.</it>
</indent>

<indent level="1">

<it>A description of the line drawing routine was accepted for presentation at the 1963 <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
ACM</link></organization>
 national convention in Denver, Colorado. It was a year in which no proceedings were published, only the agenda of speakers and topics in an issue of Communications of the ACM. A person from the IBM Systems Journal asked me after I made my presentation if they could publish the paper. I happily agreed, and they printed it in 1965.</it>"
</indent>

Bresenham's algorithm was later modified to produce circles, the resulting algorithm being sometimes known as either "Bresenham's circle algorithm" or <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../133/9732133.xml">
Midpoint circle algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>

</sec>
<sec>
<st>
 Similar algorithms </st>
<p>

The Bresenham algorithm can be interpreted as slightly modified <link>
DDA</link> (Using 0.5 as error threshold instead of 0, which is required for non-overlapping polygon rasterizing).</p>
<p>

The principle of using an incremental error in place of division operations has other applications in graphics. It is possible to use this technique to calculate the U,V co-ordinates during raster scan of texture mapped polygons. The <link xlink:type="simple" xlink:href="../573/222573.xml">
voxel</link> heightmap software-rendering engines seen in some PC games also used this principle.</p>
<p>

Bresenham also published a Run-Slice (as opposed to the Run-Length) computational algorithm.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 Jack E. Bresenham, <weblink xlink:type="simple" xlink:href="http://www.research.ibm.com/journal/sj/041/ibmsjIVRIC.pdf">
"Algorithm for computer control of a digital plotter"</weblink>, <it>IBM Systems Journal</it>, Vol. 4, No.1, January 1965, pp. 25-30</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html">
"The Bresenham Line-Drawing Algorithm"</weblink>, by Colin Flanagan</entry>
</list>
</p>

<p>

<reflist>
<entry id="1">
Paul E. Black. <it>Dictionary of Algorithms and Data Structures,</it> <link xlink:type="simple" xlink:href="../888/21888.xml">
NIST</link>. http://www.nist.gov/dads/HTML/bresenham.html</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.chez.com/pmaillot">
Patrick-Gilles Maillot's Thesis</weblink> an extension of the Bresenham line drawing algorithm to perform 3D hidden lines removal; also published in MICAD '87 proceedings on CAD/CAM and Computer Graphics, page 591 - ISBN 2-86601-084-1.</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../224/12767224.xml">
Digital Differential Analyzer (graphics algorithm)</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a simple and general method for rasterizing lines and triangles.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../689/222689.xml">
Xiaolin Wu's line algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, a similarly fast method of drawing lines with <link xlink:type="simple" xlink:href="../507/113507.xml">
antialiasing</link>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../133/9732133.xml">
Midpoint circle algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, a similar algorithm for drawing circles.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://tide4javascript.com/?s=Bresenham">
Analyze Bresenham's line algorithm in an online Javascript IDE</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://programmers-lounge-basicgraphics.blogspot.com/">
Basic Graphics Programs</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html">
<it>The Bresenham Line-Drawing Algorithm</it> by Colin Flanagan</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/bresenham.html">
National Institute of Standards and Technology page on Bresenham's algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.pdp8.net/563/563.shtml">
Calcomp 563 Incremental Plotter Information</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.codecodex.com/wiki/index.php?title=Bresenham%27s_line_algorithm">
Implementations in Java, C, and OCaml</weblink> at the Code Codex</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://plagiata.net.ru/?p=277">
Implementations in Delphi</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
