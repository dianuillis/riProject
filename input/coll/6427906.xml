<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:14:55[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Macro instruction</title>
<id>6427906</id>
<revision>
<id>230038870</id>
<timestamp>2008-08-05T19:02:01Z</timestamp>
<contributor>
<username>Wetman</username>
<id>21492</id>
</contributor>
</revision>
<categories>
<category>Computer programming</category>
</categories>
</header>
<bdy>

A <b>macro instruction</b> is a line of computer program coding that results in one or more lines of program coding in the target programming language. In the mid 1950s, when <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly language</link> programming was commonly used to write programs for <link xlink:type="simple" xlink:href="../457/7878457.xml">
digital computers</link>, the use of macro instructions was initiated for two main purposes: to reduce the amount of program coding that had to be written by generating several assembly language statements from one macro instructions and to enforce program writing standards, e.g. specifying input/output commands in standard ways. Macro instructions were effectively a middle step between assembly language programming and the <link>
high-level  programming languages</link> that followed, such as <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link> and <link xlink:type="simple" xlink:href="../799/6799.xml">
COBOL</link>. Two of the earliest programming installations to develop "macro languages" for the IBM 705 computer were at Dow Chemical Corp. in Delaware and the Air Material Command, Ballistics Missile Logistics Office in California. A macro instruction written in the format of the target assembly language would be processed by a macro compiler, which was a pre-processor to the assembler, to generate one or more assembly language instructions to be processed next by the assembler program that will would  translate the assembly language instructions into <link xlink:type="simple" xlink:href="../683/20683.xml">
machine language</link> instructions.<p>

While <it>macro instructions</it> can be defined by a programmer as a shorthand for any set of native assembler program instructions, typically macro's are associated with macro libraries delivered with the operating system allowing access to operating system functions such as peripheral access by <link xlink:type="simple" xlink:href="../141/13568141.xml">
access methods</link> (including macro's such as OPEN, CLOSE, READ and WRITE) and other operating system functions such as ATTACH, WAIT and POST for subtask creation and synchronization. Typically such macro's expand into a list of <it>define constant</it> instructions representing the parameters of the macro instruction (such as a reference to a file and a data area for a READ instruction) followed by either a <it>branch and link</it> instruction to call a routine, or a <link xlink:type="simple" xlink:href="../914/13578914.xml">
supervisor call</link> instruction to call an operating system function directly.</p>
<p>

In older operating systems such as used on IBM mainframes, full operating system functionality was only available to assembler language programs, not to high level language programs (unless assembly language subroutines were used, of course), as the standard macro instructions did not always have counterparts in routines available to high-level languages.</p>
<p>

In modern operating systems such as Unix and derivatives, operating system access is provided through subroutines, usually invoking DLL routines. High-level languages such as C offer comprehensive access to operating system functions, obviating the need for assembler language programs for such functionality.</p>


</bdy>
</article>
