<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:26:22[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Double dabble</title>
<id>6459360</id>
<revision>
<id>197259576</id>
<timestamp>2008-03-10T16:34:16Z</timestamp>
<contributor>
<username>AnaZ</username>
<id>177879</id>
</contributor>
</revision>
<categories>
<category>Arbitrary precision algorithms</category>
<category>Articles with example C code</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>double dabble</b> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is used to convert <link xlink:type="simple" xlink:href="../686/238686.xml">
binary numbers</link> into <link xlink:type="simple" xlink:href="../214/8214.xml">
decimal</link> (in particular, <link xlink:type="simple" xlink:href="../821/3821.xml">
binary-coded decimal</link>, or BCD, notation). The algorithm operates as follows:<p>

Suppose the original number to be converted is stored in a <link xlink:type="simple" xlink:href="../432/486432.xml">
register</link> that is <it>n</it> bits wide. Reserve a scratch space wide enough to hold both the original number and its BCD representation &mdash; <math>n + 4n/3</math> bits will be enough. Partition the scratch space into BCD digits (on the left) and the original register (on the right). For example, if the original number to be converted is eight bits wide, the scratch space would be partitioned as follows:</p>
<p>

100S TENS ONES ORIGINAL
0010 0100 0011 11110011</p>
<p>

The diagram above shows the binary representation of 24310 in the original register, and the BCD representation of 243 on the left.</p>
<p>

The scratch space is initialized to all zeros, and then the value to be converted is copied into the "original register" space on the right.</p>
<p>

0000 0000 0000 11110011</p>
<p>

Then, the algorithm iterates <it>n</it> times. On each iteration, the entire scratch space is left-shifted one bit. However, <it>before</it> the left-shift is done, any BCD digit which is greater than 4 is incremented by 3. The increment ensures that a value of 5, incremented and left-shifted, becomes 16, thus correctly "carrying" into the next BCD digit.</p>
<p>

The double-dabble algorithm, performed on the value 24310, looks like this:</p>
<p>

0000 0000 0000 11110011      Initialization
0000 0000 0001 11100110      Shift
0000 0000 0011 11001100      Shift
0000 0000 0111 10011000      Shift
0000 0000 1010 10011000      Add 3 to ONES, since it was 7
0000 0001 0101 00110000      Shift
0000 0001 1000 00110000      Add 3 to ONES, since it was 5
0000 0011 0000 01100000      Shift
0000 0110 0000 11000000      Shift
0000 1001 0000 11000000      Add 3 to TENS, since it was 6
0001 0010 0001 10000000      Shift
0010 0100 0011 00000000      Shift</p>
<p>

Now eight shifts have been performed, so the algorithm terminates. The BCD digits to the left of the "original register" space display the BCD encoding of the original value 243.</p>

<sec>
<st>
C implementation</st>
<p>

The double dabble algorithm might look like this when implemented in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
. Notice that this implementation is designed to convert an "input register" of any width, by taking an array as its parameter and returning a <link xlink:type="simple" xlink:href="../289/384289.xml">
dynamically allocated</link> string. Also notice that this implementation does not store an explicit copy of the input register in its scratch space, as the description of the algorithm did; copying the input register into the scratch space was just a <link xlink:type="simple" xlink:href="../686/419686.xml">
pedagogical</link> device.</p>


<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

/*
This function takes an array of n unsigned integers,
each holding a value in the range [0, 65535],
representing a number in the range [0, 2**(16n)-1].
arr[0] is the most significant "digit".
This function returns a new array containing the given
number as a string of decimal digits.</p>
<p>

For the sake of brevity, this example assumes that
calloc and realloc will never fail.
<list>
<entry level="1" type="bullet">

/</entry>
</list>

void double_dabble(int n, const unsigned int *arr, char **result)
{
int nbits = 16*n;         /* length of arr in bits */
int nscratch = nbits/3;   /* length of scratch in bytes */
char *scratch = calloc(1 + nscratch, sizeof *scratch);
int i, j, k;
int smin = nscratch-2;    /* speed optimization */</p>
<p>

for (i=0; i  n; ++i) {
for (j=0; j  16; ++j) {
/* This bit will be shifted in on the right. */
int shifted_in = (arr[i] &amp; (1  (15-j)))? 1: 0;</p>
<p>

/* Add 3 everywhere that scratch[k] &amp;gt;= 5. */
for (k=smin; k  nscratch; ++k)
scratch[k] += (scratch[k] &amp;gt;= 5)? 3: 0;</p>
<p>

/* Shift scratch to the left by one position. */
if (scratch[smin] &amp;gt;= 8)
smin -= 1;
for (k=smin; k  nscratch-1; ++k) {
scratch[k] = 1;
scratch[k] &amp;= 0xF;
scratch[k] |= (scratch[k+1] &amp;gt;= 8);
}</p>
<p>

/* Shift in the new bit from arr. */
scratch[nscratch-1] = 1;
scratch[nscratch-1] &amp;= 0xF;
scratch[nscratch-1] |= shifted_in;
}
}</p>
<p>

/* Remove leading zeros from the scratch space. */
for (k=0; k  nscratch-1; ++k)
if (scratch[k] != 0) break;
nscratch -= k;
memmove(scratch, scratch+k, nscratch+1);</p>
<p>

/* Convert the scratch space from BCD digits to ASCII. */
for (k=0; k  nscratch; ++k)
scratch[k] += '0';</p>
<p>

/* Resize and return the resulting string. */
<list>
<entry level="1" type="bullet">

result = realloc(scratch, nscratch+1);</entry>
</list>

return;
}</p>
<p>

/*
This test driver should print the following decimal values:
246
16170604
1059756703745
<list>
<entry level="1" type="bullet">

/</entry>
</list>

int main(void)
{
unsigned int arr = { 246, 48748, 1 };
char *text = NULL;
int i;
for (i=0; i  3; ++i) {
double_dabble(i+1, arr, &amp;text);
printf("%s\n", text);
free(text);
}
return 0;
}</p>


</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 "<weblink xlink:type="simple" xlink:href="http://cbfalconer.home.att.net/download/dubldabl.txt">
An Explanation of the Double-Dabble Bin-BCD Conversion Algorithm</weblink>" by C.B. Falconer</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
