<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:49:14[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<structure  confidence="0.8" wordnetid="105726345">
<form  confidence="0.8" wordnetid="105930736">
<header>
<title>Singleton pattern</title>
<id>65041</id>
<revision>
<id>244121632</id>
<timestamp>2008-10-09T13:08:24Z</timestamp>
<contributor>
<username>Sz-iwbot</username>
<id>7780295</id>
</contributor>
</revision>
<categories>
<category>Software design patterns</category>
<category>Articles with example Python code</category>
<category>Articles with example C++ code</category>
<category>Articles with example Java code</category>
<category>Articles with example C Sharp code</category>
<category>Articles with example PHP code</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../010/27010.xml">
software engineering</link>, the <b>singleton pattern</b> is a <link xlink:type="simple" xlink:href="../952/164952.xml">
design pattern</link> that is used to restrict <link xlink:type="simple" xlink:href="../665/169665.xml">
instantiation</link> of a class to one <link xlink:type="simple" xlink:href="../757/22757.xml">
object</link>. (This concept is also sometimes generalized to restrict the instance to a specific number of objects - for example, we can restrict the number of instances to five objects.) This is useful when exactly one object is needed to coordinate actions across the system.  Sometimes it is generalized to systems that operate more efficiently when only one or a few objects exist. It is also considered an <link xlink:type="simple" xlink:href="../956/233956.xml">
anti-pattern</link> by some people, who feel that it is overly used, introducing unnecessary limitations in situations where a sole instance of a class is not actually required. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>
<sec>
<st>
Common uses</st>
<p>

<list>
<entry level="1" type="bullet">

 The <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../836/41836.xml">
Abstract Factory</link></form>
</structure>
, <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../849/164849.xml">
Builder</link></form>
</structure>
, and <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../851/164851.xml">
Prototype</link></form>
</structure>
 patterns can use Singletons in their implementation.</entry>
<entry level="1" type="bullet">

Facade objects are often Singletons because only one Facade object is required.</entry>
<entry level="1" type="bullet">

State objects are often Singletons.</entry>
<entry level="1" type="bullet">

Singletons are often preferred to global variables because:</entry>
<entry level="2" type="bullet">

They don't pollute the global namespace (or, in languages with namespaces, their containing namespace) with unnecessary variables.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></entry>
<entry level="2" type="bullet">

They permit <change_of_state wordnetid="100199130" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<change wordnetid="100191142" confidence="0.8">
<improvement wordnetid="100248977" confidence="0.8">
<action wordnetid="100037396" confidence="0.8">
<optimization wordnetid="100260051" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../155/18155.xml">
lazy</link></psychological_feature>
</act>
</optimization>
</action>
</improvement>
</change>
</event>
</change_of_state>
 allocation and initialization, where global variables in many languages will <it>always</it> consume resources.</entry>
<entry level="1" type="bullet">

Singletons behave differently depending on the lifetime of the virtual machine. While a software development kit may start a new virtual machine for every run which results in a new instance of the singleton being created, calls to a singleton e.g. within the virtual machine of an application server behave differently. There the virtual machine remains alive, therefore the instance of the singleton remains as well. Running the code again therefore can retrieve the "old" instance of the singleton which then may be contaminated with values in local fields which are the result of the first run.</entry>
</list>
</p>

</sec>
<sec>
<st>
Class diagram</st>
<p>

<image location="center" width="250px" src="Singleton_UML_class_diagram.svg">
</image>
</p>

</sec>
<sec>
<st>
Implementation</st>
<p>

Implementation of a singleton pattern must satisfy the single instance and global access principles. It requires a mechanism to access the singleton class member without creating a class object and a mechanism to persist the value of class members among class objects. The singleton pattern is implemented by creating a <link xlink:type="simple" xlink:href="../392/7392.xml">
class</link> with a method that creates a new instance of the class if one does not exist. If an instance already exists, it simply returns a reference to that object. To make sure that the object cannot be instantiated any other way, the <link xlink:type="simple" xlink:href="../453/939453.xml">
constructor</link> is made protected (not private, because reuse and unit test could need to access the constructor). Note the <b>distinction</b> between a simple static instance of a class and a singleton: although a singleton can be implemented as a static instance, it can also be lazily constructed, requiring no memory or resources until needed. Another notable difference is that static member classes cannot implement an interface, unless that interface is simply a marker. So if the class has to realize a contract expressed by an interface, it really has to be a singleton.</p>
<p>

The singleton pattern must be carefully constructed in <link xlink:type="simple" xlink:href="../303/45303.xml">
multi-threaded</link> applications. If two threads are to execute the creation method at the same time when a singleton does not yet exist, they both must check for an instance of the singleton and then only one should create the new one.  If the programming language has concurrent processing capabilities the method should be constructed to execute as a mutually exclusive operation.</p>
<p>

The classic solution to this problem is to use <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link> on the class that indicates that the object is being <b>instantiated</b>.</p>

</sec>
<sec>
<st>
Example implementations</st>

<ss1>
<st>
Scala</st>
<p>

The <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../510/3254510.xml">
Scala programming language</link></programming_language>
 supports Singleton objects out-of-the-box. The 'object' keyword creates a class and also defines a singleton object of that type. As the concept is implemented natively, the design pattern to implement the concept is not required in this language.</p>

<p>

object Example extends ArrayList {
// creates a singleton called Example
}</p>


</ss1>
<ss1>
<st>
Java</st>
<p>

The <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java programming language</link></request>
</message>
 solutions provided here are all <link xlink:type="simple" xlink:href="../634/45634.xml">
thread-safe</link> but differ in supported language versions and <link xlink:type="simple" xlink:href="../427/93427.xml">
lazy-loading</link>.</p>

<ss2>
<st>
The solution of <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../645/1910645.xml">
Bill Pugh</link></educator>
</professional>
</adult>
</academician>
</causal_agent>
</person>
</physical_entity>
</st>

<p>

This is the recommended method. It is known as the <link xlink:type="simple" xlink:href="../372/5799372.xml">
initialization on demand holder idiom</link> and is as lazy as possible. Moreover, it works in all known versions of Java. This solution is the most portable across different Java compilers and virtual machines.</p>
<p>

The inner class is referenced no earlier (and therefore loaded no earlier by the class loader) than the moment that getInstance() is called. Thus, this solution is <link xlink:type="simple" xlink:href="../634/45634.xml">
thread-safe</link> without requiring special language constructs (i.e. volatile and/or synchronized).</p>
<p>

public class Singleton {
// Protected constructor is sufficient to suppress unauthorized calls to the constructor
protected Singleton() {}</p>
<p>

/**
<list>
<entry level="1" type="bullet">

 SingletonHolder is loaded on the first execution of Singleton.getInstance() </entry>
<entry level="1" type="bullet">

 or the first access to SingletonHolder.instance , not before.</entry>
<entry level="1" type="bullet">

/</entry>
</list>

private static class SingletonHolder { 
private final static Singleton INSTANCE = new Singleton();
}</p>
<p>

public static Singleton getInstance() {
return SingletonHolder.INSTANCE;
}
}</p>


</ss2>
<ss2>
<st>
Traditional simple way</st>

<p>

Just like the one above, this solution is <link xlink:type="simple" xlink:href="../634/45634.xml">
thread-safe</link> without requiring special language constructs, but it lacks the laziness. The INSTANCE is created as soon as the Singleton class loads. That might even be long before getInstance() is called. It might be (for example) when some static method of the class is used. If laziness is not needed or the instance needs to be created early in the application's execution, this (slightly) simpler solution can be used:</p>
<p>

public class Singleton {
public final static Singleton INSTANCE = new Singleton();</p>
<p>

// Protected constructor is sufficient to suppress unauthorized calls to the constructor
protected Singleton() {}
}</p>

<p>

Sometimes the static final field is made private and a static factory-method is provided to get the instance. This way the underlying implementation may change easily while it has no more performance-issues on modern JVMs.</p>

</ss2>
<ss2>
<st>
Java 5 solution</st>

<p>

If and only if the compiler used is Java 5 (also known as Java 1.5) or newer, AND all Java virtual machines the application is going to run on fully support the Java 5  memory model, then (and only then) the volatile double checked locking can be used (for a detailed discussion of <it>why it should never be done before Java 5</it> see <weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">
The "Double-Checked Locking is Broken" Declaration</weblink>):</p>

<p>

public class Singleton {
private static volatile Singleton INSTANCE;</p>
<p>

// Protected constructor is sufficient to suppress unauthorized calls to the constructor
protected Singleton() {}</p>
<p>

public static Singleton getInstance() {
if (INSTANCE == null) {
synchronized(Singleton.class) {
if (INSTANCE == null)
INSTANCE = new Singleton();
}
}
return INSTANCE;
}
}</p>

<p>

Allen Holub (in "Taming Java Threads", Berkeley, CA: Apress, 2000, pp. 176&ndash;178) notes that on multi-CPU systems (which are widespread as of 2007), the use of volatile may have an impact on performance approaching to that of synchronization, and raises the possibility of other problems.  Thus this solution has little to recommend it over Pugh's solution described above.</p>

</ss2>
<ss2>
<st>
 The Enum-way </st>
<p>

In the second edition of his book "Effective Java" <link xlink:type="simple" xlink:href="../938/10038938.xml">
Joshua Bloch</link> claims that "a single-element enum type is the best way to implement a singleton"<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> for any Java that supports enums. The use of an enum is very easy to implement and has no drawbacks regarding serializable objects, which have to be circumvented in the other ways.</p>

<p>

public enum Singleton {
INSTANCE;
}</p>


</ss2>
</ss1>
<ss1>
<st>
PHP 5</st>
<p>

Singleton pattern in PHP 5<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref>:</p>

<p>

?php
class Singleton {
// object instance
private static $instance;
// The private construct prevents instantiating the class externally.  The construct can be
// empty, or it can contain additional instructions...
private function __construct() {
...
}</p>
<p>

// The clone and wakeup methods prevents external instantiation of copies of the Singleton class,
// thus eliminating the possibility of duplicate objects.  The methods can be empty, or
// can contain additional code (most probably generating error messages in response
// to attempts to call).
public function __clone() {
trigger_error('Clone is not allowed.', E_USER_ERROR);
}
public function __wakeup() {
trigger_error('Deserializing is not allowed.', E_USER_ERROR);
}
//This method must be static, and must return an instance of the object if the object
//does not already exist.
public static function getInstance() {
if (!self::$instance instanceof self) { 
self::$instance = new self;
}
return self::$instance;
}
//One or more public methods that grant access to the Singleton object, and its private
//methods and properties via accessor methods.
public function doAction() {
...
}
}</p>
<p>

//usage
Singleton::getInstance()-&amp;gt;doAction();</p>
<p>

?&amp;gt;</p>


</ss1>
<ss1>
<st>
Actionscript 3.0</st>

<p>

Private constructors are not available in ActionScript 3.0 - which prevents the use of the ActionScript 2.0 approach to the Singleton Pattern. Many different AS3 Singleton implementations have been published around the web.</p>


<p>

package {
public class Singleton  {</p>
<p>

private static var _instance:Singleton;</p>
<p>

public function Singleton () {	
if (_instance){
throw new Error( "Singleton and can only be accessed through Singleton.getInstance()" );
}
}</p>
<p>

public static function getInstance():Singleton {
if(!_instance) _instance = new Singleton();
return _instance;
}</p>

<p>

}
}</p>



</ss1>
<ss1>
<st>
Objective-C</st>
<p>

A common way to implement a singleton in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../802/22802.xml">
Objective-C</link></programming_language>
 is the following:</p>

<p>

@interface MySingleton : NSObject
{
}</p>
<p>

+ (MySingleton *)sharedSingleton;
@end</p>
<p>

@implementation MySingleton</p>
<p>

+ (MySingleton *)sharedSingleton
{
static MySingleton *sharedSingleton;</p>
<p>

@synchronized(self)
{
if (!sharedSingleton)
sharedSingleton = <link>
MySingleton alloc] ini</link>;</p>
<p>

return sharedSingleton;
}
}</p>
<p>

@end</p>

<p>

If thread-safety is not required, the synchronization can be left out, leaving the +sharedSingleton method like this:</p>

<p>

+ (MySingleton *)sharedSingleton
{
static MySingleton *sharedSingleton;</p>
<p>

if (!sharedSingleton)
sharedSingleton = <link>
MySingleton alloc] ini</link>;</p>
<p>

return sharedSingleton;
}</p>

<p>

This pattern is widely used in the <link xlink:type="simple" xlink:href="../890/55890.xml">
Cocoa</link> frameworks (see for instance, NSApplication, NSColorPanel, NSFontPanel or NSWorkspace, to name but a few).</p>
<p>

Some may argue that this is not, strictly speaking, a Singleton, because it is possible to allocate more than one instance of the object. A common way around this is to use assertions or exceptions to prevent this double allocation.</p>

<p>

@interface MySingleton : NSObject
{
}</p>
<p>

+ (MySingleton *)sharedSingleton;
@end</p>
<p>

@implementation MySingleton</p>
<p>

static MySingleton *sharedSingleton;</p>
<p>

+ (MySingleton *)sharedSingleton
{
@synchronized(self)
{
if (!sharedSingleton)
<link>
MySingleton alloc] ini</link>;</p>
<p>

return sharedSingleton;
}
}</p>
<p>

+(id)alloc
{
@synchronized(self)
{
NSAssert(sharedSingleton == nil, @"Attempted to allocate a second instance of a singleton.");
sharedSingleton = [super alloc];
return sharedSingleton;
}
}</p>
<p>

@end</p>

<p>

There are alternative ways to express the Singleton pattern in Objective-C, but they are not always as simple or as easily understood, not least because they may rely on the -init method returning an object other than self. Some of the <link xlink:type="simple" xlink:href="../890/55890.xml">
Cocoa</link> "Class Clusters" (e.g. NSString, NSNumber) are known to exhibit this type of behaviour.</p>
<p>

Note that @synchronized is not available in some Objective-C configurations, as it relies on the NeXT/Apple runtime. It is also comparatively slow, because it has to look up the lock based on the object in parentheses. Check the history of this page for a different implementation using an NSConditionLock.</p>



</ss1>
<ss1>
<st>
C++ (using pthreads)</st>

<p>

<list>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

class Singleton
{ public:
static Singleton&amp; instance();
int example_data;
private:
Singleton(): example_data(42) {}
Singleton(Singleton const&amp; ); //not defined, not copyable
Singleton&amp; operator= (Singleton const&amp; ); //not defined, not assignable
~Singleton() {}
};</p>
<p>

namespace
{ struct ForceSingletonInitialization
{ ForceSingletonInitialization() { Singleton::instance(); }
} instance;
}</p>
<p>

Singleton&amp; Singleton::instance()
{ static Singleton * pointerToTheSingletonInstance = new Singleton;
return *pointerToTheSingletonInstance;
}</p>
<p>

int main()
{ std::cout  Singleton::instance().example_data  std::endl;
return 0;
}</p>

<p>

This is an example of an almost correct (see note at the bottom of C++(using pthreads)), eager initialized, thread-safe singleton implementation in C++.</p>
<p>

This implementation depends upon the guarantee that namespace scope variables are constructed in a thread-safe and single threaded way. This is generally true. However, if someone in the process create threads before main, or if you create threads inside a <link>
dynamically loaded library</link> while it's being loaded, then we can no longer guarantee that the initialization happens in a single threaded environment. We would then be unable to guarantee thread-safe single initialization. </p>
<p>

Notice how the pointer to the singleton is a static local of the function and not a global or a static member of the class. This is because of the static initialization order fiasco<weblink xlink:type="simple" xlink:href="http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12">
http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12</weblink>; there is no specified order of construction of namespace scope variables between translation units. The pointer is a static local of the function to avoid this lack of defined construction order. </p>
<p>

Also note that we never destroy the Singleton instance. The problem is if we destroy it, another static storage object may refer to our singleton after it's been destroyed in its destructor, probably causing bad things to happen. This problem is known as the static deinitialization order fiasco.<weblink xlink:type="simple" xlink:href="http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14">
http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14</weblink> If the Singleton is only memory, leaking the singleton is ok. The operating system will reclaim all of the process's memory anyway when the process dies. However, if the singleton has other non-memory resources which the operating system will not reclaim when the process dies, then you would want to destroy your singleton before the process exits, but you would have to be careful to ensure the proper order of destruction. </p>

<p>

By using a <link xlink:type="simple" xlink:href="../827/36827.xml">
mutex</link> in the singleton's initialization, we may perform lazy initialization in a thread-safe way. The following sample demonstrates correct usage with the pthreads threading library.</p>
<p>

It also demonstrates the broken <link xlink:type="simple" xlink:href="../874/164874.xml">
double-checked locking</link> anti-pattern with commented code. A common broken "pattern" for <link xlink:type="simple" xlink:href="../634/45634.xml">
thread safety</link> with the singleton pattern is to use double-checked locking. However, due to the absence of any consideration being given to multiple threads of execution in the language standard, the ability of modern processors to re-order instructions (as long as the result is consistent with their architecturally-specified  memory model), and the cache coherency problem of multi-core processors, double-checked locking is <it>intrinsically prone to failure</it> in C++. There is no model &mdash; other than runtime libraries (e.g. <link xlink:type="simple" xlink:href="../671/634671.xml">
POSIX threads</link>, designed to provide concurrency primitives) &mdash; that can provide the necessary execution order.<weblink xlink:type="simple" xlink:href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf#search=%22meyers%20double%20checked%20locking%22">
http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf#search=%22meyers%20double%20checked%20locking%22</weblink></p>

<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

class Mutex
{ public:
Mutex() { pthread_mutex_init(&amp;m, 0); }
~Mutex() { pthread_mutex_destroy(&amp;m); }
void lock() { pthread_mutex_lock(&amp;m); }
void unlock() { pthread_mutex_unlock(&amp;m); }
private:
pthread_mutex_t m;
};</p>
<p>

class MutexGuard
{ public:
MutexGuard(Mutex&amp; pm): m(pm) { m.lock(); }
~MutexGuard() { m.unlock(); }
private:
Mutex&amp; m;
};</p>
<p>

class Singleton
{ public:
static Singleton&amp; instance();
int example_data;
private:
Singleton(): example_data(42) {}
Singleton(Singleton const&amp; ); //not defined, not copyable
Singleton&amp; operator= (Singleton const&amp; ); //not defined, not assignable
~Singleton() {}
};</p>
<p>

namespace
{ Mutex&amp; getSingletonsMutex()
{ static Mutex m;
return m;
}
struct ForceMutexInitialization
{ ForceMutexInitialization() { getSingletonsMutex(); }
} instance;
}</p>
<p>

Singleton&amp; Singleton::instance()
{
//All static storage variables are zero initialized before runtime.
static Singleton * pointerToTheSingletonInstance;</p>
<p>

/*If you remove the comments to add in the outer if statement, it
becomes double-checked locking, and double-checked locking does not work. */
//if (pointerToTheSingletonInstance == 0)
//{
MutexGuard obtain_lock(getSingletonsMutex());
if (pointerToTheSingletonInstance == 0)
pointerToTheSingletonInstance = new Singleton;
//}
return *pointerToTheSingletonInstance;
}</p>
<p>

int main()
{ std::cout  Singleton::instance().example_data  std::endl;
return 0;
}</p>

<p>

This is an almost correct (see note at the bottom of C++(using pthreads)), lazy initialized, thread safe singleton example. </p>
<p>

Notice that we did not create the mutex as a static local in the function. This would lead to not thread-safe initialization of the mutex, the very thing we're trying to solve with the mutex! Nor can we make it a static class member or a namespace member because of the static initialization order fiasco. The only alternative is to make the mutex it's own eager initialized singleton. </p>
<p>

Note the use of the MutexGuard class in the Singleton::instance() function. The MutexGuard is being used as an <link xlink:type="simple" xlink:href="../532/693532.xml">
RAII</link> object, also known as <it>scoped lock</it>, guaranteeing that the Mutex's lock will be relinquished even if an <link xlink:type="simple" xlink:href="../231/59231.xml">
exception</link> is thrown during the memory allocation or Singleton's constructor as the language specification pledges that the destructors of stack objects are invoked during stack unwinding.</p>
<p>

This implementation acquires the Mutex's lock on every call to Singleton::instance(), even though the Mutex is only needed for the first few calls to guarantee a single initialization and to guarantee that the single initialization is visible to all calling threads. </p>
<p>

One option to avoid this extra overhead is to use the eager initialized version.</p>
<p>

Another option is to use thread local storage to better implement the instance() method.</p>
<p>

Alternatively, one could use pthread_once to guarantee single initialization. </p>
<p>

However, it's preferable to not try to lessen the overhead by having users cache the pointer. Having users cache the return of instance() is begging for the static deinitialization order fiasco. For this very reason, try to phrase your singletons as a list of namespace functions instead of as a class. The namespace functions will still be implemented in terms of your singleton class, but it will be impossible for the user to cache a pointer to your singleton and accidentally access it after it's been destroyed. (You would still have to clearly document that your interface is implemented with a static storage object to allow users to force the correct order of destruction.)</p>

<p>

More code must be written if the singleton code is located in a static shared library as each library statically linked against the static library will have their own copy of the singleton. If several <link>
dynamically loaded libraries</link> are created by statically linking against the static shared library with the singleton, each dynamically linked library will have their own copy of the singleton. An executable might load several of these dynamically linked libraries at the same time, resulting in a process with multiple copies of the singleton. To avoid that, the singleton code must be inside the executable itself or inside a dynamically linked library. Alternatively, the singleton can be rewritten to use a <link>
memory-mapped</link> file to store the singleton instance.</p>

<p>

Finally, both of these examples are not technically safe and correct. The C++ standard allows the dynamic initialization of namespace scope variables to be delayed until the first use of the translation unit. Thus we are unable to guarantee that the eager initialization will occur before main is called (or the DLL is loaded), and thus before there are threads. Most compilers do not delay the initialization, but it's possible a compiler could. Thus the only remaining safe and platform independent way is to use pthread_once to guarantee a single, thread-safe initialization of a singleton.</p>

</ss1>
<ss1>
<st>
C#</st>
<p>

The simplest of all is:</p>
<p>

public class Singleton
{
// The combination of static and readonly makes the instantiation 
// thread safe.  Plus the constructor being protected (it can be 
// private as well), makes the class sure to not have any other 
// way to instantiate this class than using this member variable.
public static readonly Singleton Instance = new Singleton();</p>
<p>

// Protected constructor is sufficient to avoid other instantiation
// This must be present otherwise the compiler provides a default 
// public constructor
//
protected Singleton()
{
}
}</p>

<p>

This example is <link xlink:type="simple" xlink:href="../634/45634.xml">
thread-safe</link> with <link xlink:type="simple" xlink:href="../427/93427.xml">
lazy initialization</link>.  </p>


<p>

/// Class implements singleton pattern.</p>
<p>

public class Singleton
{
// Protected constructor is sufficient to avoid other instantiation
// This must be present otherwise the compiler provides 
// a default public constructor
protected Singleton()
{
}</p>

<p>

/// Return an instance of </p>
<p>

public static Singleton Instance
{
get
{
/// An instance of Singleton wont be created until the very first 
/// call to the sealed class. This is a CLR optimization that
/// provides a properly lazy-loading singleton. 
return SingletonCreator.CreatorInstance;
}
}</p>

<p>

/// Sealed class to avoid any heritage from this helper class</p>
<p>

private sealed class SingletonCreator
{
// Retrieve a single instance of a Singleton
private static readonly Singleton _instance = new Singleton();</p>

<p>

/// Return an instance of the class </p>
<p>

public static Singleton CreatorInstance
{
get { return _instance; }
}
}
}</p>
<p>

Another example(using static constructor)</p>
<p>

using System;
using System.Threading;</p>
<p>

namespace Singleton1
{
class Singleton
{
private static readonly Singleton _instance;
private int v;</p>

<p>

/// Protected constructor is sufficient to prevent
/// instantiation by using 'new' keyword.</p>
<p>

protected Singleton()
{
Console.WriteLine("Singleton Instance Creating...");
this.V = 0;</p>
<p>

Thread.Sleep(1000); // Simulate a HEAVY creation cost.</p>
<p>

Console.WriteLine("Singleton Instance Created.");
}</p>

<p>

/// Static constructor</p>
<p>

static Singleton()
{
_instance = new Singleton();
}</p>
<p>

public static Singleton Instance
{
get
{
return _instance;
}
}</p>
<p>

public int V
{
get { return v; }
set { v = value; }
}</p>
<p>

public void DoSomeWork()
{
Console.Write("#");
lock(this)
{
V++;
}
Thread.Sleep(500);
}
}</p>
<p>

class TestClass
{</p>
<p>

/// Singleton with Multithread</p>
<p>

static void Multithread()
{
Singleton instance = Singleton.Instance;</p>
<p>

Thread t = new Thread(new ThreadStart(instance.DoSomeWork));
t.Start();
}</p>
<p>

static void Main(string args)
{
int i;</p>
<p>

for(i = 0; i  10; i++)
{
Console.WriteLine("Do some work...");
Thread.Sleep(100);
}</p>
<p>

// ^- Until now, this application has no any singleton instance. -^ //</p>
<p>

for(i = 0; i  300; i++)
{
// At first time, Singleton class make an instance of itself.
// Other time, it will return absolutly same instance.
Multithread();
}</p>
<p>

Thread.Sleep(1000); // Wait for sure all threads finished.</p>
<p>

Console.WriteLine("");
Console.WriteLine("V value - expected: {0}, actual: {1}",i,Singleton.Instance.V);</p>
<p>

// Singleton with 'new' is Strictly forbidden.</p>
<p>

// Singleton y = new Singleton(); // No acceptable.
}
}
}</p>

<p>

Example in C# 2.0 (thread-safe with lazy initialization)
Note: This is not a recommended implementation because "TestClass" has a default public constructor, and that violates the definition of a Singleton.  A proper Singleton must never be instantiable more than once.</p>

<p>

/// Parent for singleton</p>
<p>

/// Singleton class
public class Singleton where T : class, new()
{</p>
<p>

protected Singleton() { }</p>
<p>

private sealed class SingletonCreator where S : class, new()
{
private static readonly S instance = new S();</p>
<p>

public static S CreatorInstance
{
get { return instance; }
}
}</p>
<p>

public static T Instance
{
get { return SingletonCreator.CreatorInstance; }
}</p>
<p>

}</p>

<p>

/// Concrete Singleton</p>
<p>

public class TestClass : Singleton
{
public string TestProc()
{
return "Hello World";
}
}</p>
<p>

// Somewhere in the code
.....
TestClass.Instance.TestProc();
.....</p>


</ss1>
<ss1>
<st>
Python</st>
<p>

According to influential <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 programmer <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<link xlink:type="simple" xlink:href="../784/6073784.xml">
Alex Martelli</link></employee>
</scientist>
</causal_agent>
</worker>
</person>
</physical_entity>
, <it>The Singleton design pattern (DP) has a catchy name, but the wrong focus—on identity rather than on state. The Borg design pattern has all instances share state instead</it>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref>  A rough consensus in the Python community is that sharing state among instances is more elegant, at least in Python, than is caching creation of identical instances on class initialization. Coding shared state is nearly transparent:</p>

<p>

class Borg:
__shared_state = {}
def __init__(self):
self.__dict__ = self.__shared_state
<list>
<entry level="1" type="number">

 and whatever else is needed in the class -- that's all!</entry>
</list>
</p>

<p>

But with the new style class, this is a better solution, because only one instance is created:</p>
<p>

class  Singleton (object):
instance = None       
def __new__(cls, *args, **kwargs): 
if cls.instance is None:
cls.instance = object.__new__(cls, *args, **kwargs)
return cls.instance</p>
<p>

<list>
<entry level="1" type="number">

Usage</entry>
</list>

mySingleton1 =  Singleton()
mySingleton2 =  Singleton()</p>
<p>

<list>
<entry level="1" type="number">

mySingleton1 and  mySingleton2 are the same instance.</entry>
</list>

assert mySingleton1 is mySingleton2</p>

<p>

Two s: </p>
<p>

<list>
<entry level="1" type="bullet">

 The <it>__init__</it>-method is called every time <it>Singleton()</it> is called, unless <it>cls.__init__</it> is set to an empty function.</entry>
<entry level="1" type="bullet">

 If it is needed to inherit from the <it>Singleton</it>-class, <it>instance</it> should probably be a <it>dictionary</it> belonging explicitly to the <it>Singleton</it>-class.</entry>
</list>
</p>

<p>

class  InheritableSingleton (object):
instances = {}
def __new__(cls, *args, **kwargs): 
if InheritableSingleton.instances.get(cls) is None:
cls.__original_init__ = cls.__init__
InheritableSingleton.instances[cls] = object.__new__(cls, *args, **kwargs)
elif cls.__init__ == cls.__original_init__:
def nothing(*args, **kwargs):
pass
cls.__init__ = nothing
return InheritableSingleton.instances[cls]</p>

<p>

To create a singleton that inherits from a non-singleton, multiple inheritance must be used.</p>

<p>

class  Singleton (NonSingletonClass, object):
instance = None       
def __new__(cls, *args, **kargs): 
if cls.instance is None:
cls.instance = object.__new__(cls, *args, **kargs)
return cls.instance</p>

<p>

Be sure to call the NonSingletonClass's __init__ function from the Singleton's __init__ function.</p>

</ss1>
<ss1>
<st>
 Perl </st>

<p>

In a Perl version equal or superior to 5.10 a state variable can be used.</p>

<p>

package MySingletonClass;
use strict;
use warnings;
use 5.10;</p>
<p>

sub new {
my ($class) = @_;
state $the_instance;</p>
<p>

if (! defined $the_instance) {
$the_instance = bless { }, $class;
}
return $the_instance;
}</p>


<p>

In older Perls, just use a closure.</p>

<p>

package MySingletonClass;
use strict;
use warnings;</p>
<p>

my $THE_INSTANCE;
sub new {
my ($class) = @_;</p>
<p>

if (! defined $THE_INSTANCE) {
$THE_INSTANCE = bless { }, $class;
}
return $THE_INSTANCE;
}</p>

<p>

If Moose is used, there is the <weblink xlink:type="simple" xlink:href="http://search.cpan.org/perldoc?MooseX::Singleton">
MooseX::Singleton</weblink> extension module.</p>

</ss1>
<ss1>
<st>
 Ruby </st>
<p>

In Ruby, just include the Singleton in the class.</p>

<p>

require 'singleton'</p>
<p>

class Example
include Singleton
end</p>


</ss1>
</sec>
<sec>
<st>
 ABAP Objects </st>

<p>

In ABAP Objects, to make instantiation private, add an attribute of type ref to the class, and a static method to control instantiation.</p>
<p>

program pattern_singleton.</p>
<p>

<list>
<entry level="71" type="bullet">
</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Singleton</entry>
<entry level="1" type="bullet">

 =========</entry>
<entry level="1" type="bullet">

 Intent</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">
</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Ensure a class has only one instance, and provide a global point</entry>
<entry level="1" type="bullet">

 of access to it.</entry>
</list>
</p>
<p>

<list>
<entry level="71" type="bullet">
</entry>
</list>
</p>
<p>

class lcl_Singleton definition create private.</p>
<p>

public section.</p>
<p>

class-methods:
get_Instance returning value(Result) type ref to lcl_Singleton.</p>
<p>

private section.
class-data:
fg_Singleton type ref to lcl_Singleton.</p>
<p>

endclass.</p>
<p>

class lcl_Singleton implementation.</p>
<p>

method get_Instance.
if ( fg_Singleton is initial ).
create object fg_Singleton.
endif.
Result = fg_Singleton.
endmethod.</p>
<p>

endclass.</p>

</sec>
<sec>
<st>
Prototype-based singleton</st>
<p>

In a <link xlink:type="simple" xlink:href="../003/61003.xml">
prototype-based programming</link> language, where objects but not classes are used, a "singleton" simply refers to an object without copies or that is not used as the prototype for any other object. Example in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../340/323340.xml">
Io</link></programming_language>
:</p>
<p>

Foo := Object clone
Foo clone := Foo</p>

</sec>
<sec>
<st>
Example of use with the factory method pattern</st>
<p>

The singleton pattern is often used in conjunction with the <link xlink:type="simple" xlink:href="../850/164850.xml">
factory method pattern</link> to create a system-wide resource whose specific type is not known to the code that uses it.  An example of using these two patterns together is the Java <link xlink:type="simple" xlink:href="../049/85049.xml">
Abstract Windowing Toolkit</link> (AWT).</p>
<p>

<weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/awt/Toolkit.html">
java.awt.Toolkit</weblink> is an <link xlink:type="simple" xlink:href="../576/3893576.xml">
abstract class</link> that <link xlink:type="simple" xlink:href="../906/449906.xml">
binds</link> the various AWT components to particular native toolkit implementations. The Toolkit class has a <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/awt/Toolkit.html#getDefaultToolkit()">
Toolkit.getDefaultToolkit()</weblink> factory method that returns the <link xlink:type="simple" xlink:href="../164/401164.xml">
platform-specific</link> <link xlink:type="simple" xlink:href="../350/565350.xml">
subclass</link> of Toolkit.  The Toolkit object is a singleton because the AWT needs only a single object to perform the binding and the object is relatively expensive to create. The toolkit methods must be implemented in an object and not as <link>
static method</link>s of a class because the specific implementation is not known by the platform-independent components.  The name of the specific Toolkit subclass used is specified by the "awt.toolkit" <link>
environment property</link> accessed through <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/lang/System.html#getProperties()">
System.getProperties()</weblink>.</p>
<p>

The binding performed by the toolkit allows, for example, the backing implementation of a <weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/awt/Window.html">
java.awt.Window</weblink> to bound to the platform-specific java.awt.peer.WindowPeer implementation. Neither the Window class nor the application using the window needs to be aware of which platform-specific subclass of the peer is used.</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Alex Miller. <weblink xlink:type="simple" xlink:href="http://tech.puredanger.com/2007/07/03/pattern-hate-singleton/">
Patterns I hate #1: Singleton</weblink>, July 2007</entry>
<entry id="2">
Scott Densmore. <weblink xlink:type="simple" xlink:href="http://blogs.msdn.com/scottdensmore/archive/2004/05/25/140827.aspx">
Why singletons are evil</weblink>, May 2004</entry>
<entry id="3">
Steve Yegge. <weblink xlink:type="simple" xlink:href="http://steve.yegge.googlepages.com/singleton-considered-stupid">
Singletons considered stupid</weblink>, September 2004</entry>
<entry id="4">
J.B. Rainsberger, IBM. <weblink xlink:type="simple" xlink:href="http://www-128.ibm.com/developerworks/webservices/library/co-single.html">
Use your singletons wisely</weblink>, July 2001</entry>
<entry id="5">
Chris Reath. <weblink xlink:type="simple" xlink:href="http://www.codingwithoutcomments.com/2008/10/08/singleton-i-love-you-but-youre-bringing-me-down/">
Singleton I love you, but you're bringing me down</weblink>, October 2008</entry>
<entry id="6">
Gamma, E, Helm, R, Johnson, R, Vlissides, J: "Design Patterns", page 128. Addison-Wesley, 1995</entry>
<entry id="7">
Joshua Bloch: Effective Java 2nd edition, ISBN 978-0-321-35668-0, 2008, p. 18</entry>
<entry id="8">
McArthur, Kevin: "Pro PHP:  Patterns, Frameworks, Testing and More", pp 22&ndash;23. Apress, 2008</entry>
<entry id="9">
Zandstra, Matt:  "PHP Objects, Patterns and Practice", pp 147&ndash;149. Apress, 2008</entry>
<entry id="10">
Alex Martelli.&#32;"<weblink xlink:type="simple" xlink:href="http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/66531">
Singleton? We don't need no stinkin' singleton: the Borg design pattern</weblink>".&#32;<it>ASPN Python Cookbook</it>.&#32;Retrieved on <link>
2006-09-07</link>.</entry>
</reflist>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf#search=%22meyers%20double%20checked%20locking%22">
"C++ and the Perils of Double-Checked Locking"</weblink> Meyers, Scott and Alexandrescu, Andrei, September 2004.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ddj.com/dept/cpp/184401518">
"The Boost.Threads Library"</weblink> Kempf, B., Dr. Dobb's Portal, April 2003.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html">
The "Double-Checked Locking is Broken" Declaration</weblink> (Java)</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.javabeginner.com/singleton.htm">
Java Singleton Pattern</weblink></entry>
<entry level="1" type="bullet">

A <weblink xlink:type="simple" xlink:href="http://pec.dev.java.net/">
Pattern Enforcing Compiler</weblink> that enforces the Singleton pattern amongst other patterns</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://c2.com/cgi/wiki?SingletonPattern">
Description from the Portland Pattern Repository</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.yoda.arachsys.com/csharp/singleton.html">
Implementing the Singleton Pattern in C#</weblink> by Jon Skeet</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.opbarnes.com/blog/Programming/OPB/Snippets/Singleton.html">
A Threadsafe C++ Template Singleton Pattern for Windows Platforms</weblink> by O. Patrick Barnes</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://svn.shadanakar.org/filedetails.php?repname=onPHP&amp;path=%2Ftrunk%2Fcore%2FBase%2FSingleton.class.php&amp;rev=0&amp;sc=0">
Implementing the Inheritable Singleton Pattern in PHP5</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.oaklib.org/docs/oak/singleton.html">
Singleton Pattern and Thread Safety</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.php.net/manual/en/language.oop5.patterns.php">
PHP patterns</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://prototyp.ical.ly/index.php/2007/03/01/javascript-design-patterns-1-the-singleton/">
Javascript implementation of a Singleton Pattern</weblink> by Christian Schaefer</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.prestonlee.com/archives/22">
Singletons Cause Cancer</weblink> by Preston Lee</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.oodesign.com/oo_design_patterns/creational_patterns/singleton.html">
Singleton examples</weblink></entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://www-128.ibm.com/developerworks/java/library/j-dcl.html?loc=j">
Double-checked locking and the Singleton pattern</weblink>" by Peter Haggar</entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://www-106.ibm.com/developerworks/library/co-single.html">
Use your singletons wisely</weblink>" by <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../927/2789927.xml">
J. B. Rainsberger</link></writer>
</causal_agent>
</person>
</communicator>
</physical_entity>
</entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://www.javaworld.com/javaworld/jw-04-2003/jw-0425-designpatterns.html">
 Simply Singleton</weblink>" by David Geary </entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://www.dofactory.com/Patterns/PatternSingleton.aspx">
Description of Singleton</weblink>" by Aruna</entry>
<entry level="1" type="bullet">

Article "<weblink xlink:type="simple" xlink:href="http://code.google.com/p/google-singleton-detector/wiki/WhySingletonsAreControversial">
Why Singletons Are Controversial</weblink>"</entry>
<entry level="1" type="bullet">

The <weblink xlink:type="simple" xlink:href="http://code.google.com/p/google-singleton-detector/">
Google Singleton Detector</weblink> analyzes <link xlink:type="simple" xlink:href="../680/1934680.xml">
Java bytecode</link> to detect singletons, so that their usefulness can be evaluated.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.fsw.com/Jt/Jt.htm">
Jt</weblink> J2EE Pattern Oriented Framework</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.exampledepot.com/egs/java.io/DeserSingle.html?l=rel">
Serialization of Singleton in Java</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://msdn.microsoft.com/en-us/library/ms998426.aspx">
Singleton at Microsoft patterns &amp; practices Developer Center</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://tomschober.blogspot.com/2007/01/singleton-pattern-in-cairngorm-21-with.html">
Singleton Pattern in Cairngorm 2.1 with Actionscript 3</weblink></entry>
</list>
</p>
<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link>
 Design patterns</link> in the book <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../394/40394.xml">
Design Patterns</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
''</it></header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
Creational</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../836/41836.xml">
Abstract factory</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../849/164849.xml">
Builder</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../850/164850.xml">
Factory</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../851/164851.xml">
Prototype</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../041/65041.xml">
Singleton</link></form>
</structure>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Structural</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../020/65020.xml">
Adapter</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../033/65033.xml">
Bridge</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../853/164853.xml">
Composite</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../854/164854.xml">
Decorator</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../028/65028.xml">
Façade</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../538/140538.xml">
Flyweight</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../856/164856.xml">
Proxy</link></form>
</structure>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Behavioral</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../875/164875.xml">
Chain of responsibility</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../858/164858.xml">
Command</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../860/164860.xml">
Interpreter</link></form>
</structure>
&nbsp;·  <link xlink:type="simple" xlink:href="../859/164859.xml">
Iterator</link>&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../862/164862.xml">
Mediator</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../542/140542.xml">
Memento</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../863/164863.xml">
Observer</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../864/164864.xml">
State</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../865/164865.xml">
Strategy</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../866/164866.xml">
Template method</link></form>
</structure>
&nbsp;·  <structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../689/38689.xml">
Visitor</link></form>
</structure>
</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</form>
</structure>
</article>
