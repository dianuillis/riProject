<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:48:14[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<know-how  confidence="0.8" wordnetid="105616786">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<method  confidence="0.8" wordnetid="105660268">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Support vector machine</title>
<id>65309</id>
<revision>
<id>244375584</id>
<timestamp>2008-10-10T14:26:02Z</timestamp>
<contributor>
<username>Mpost89</username>
<id>21585</id>
</contributor>
</revision>
<categories>
<category>Statistical classification</category>
<category>All pages needing cleanup</category>
<category>Articles to be expanded since June 2008</category>
<category>Neural networks</category>
<category>Kernel methods for machine learning</category>
<category>Ensemble learning</category>
<category>Cleanup from June 2008</category>
<category>All articles to be expanded</category>
<category>Wikipedia articles needing clarification</category>
<category>Machine learning</category>
<category>Classification algorithms</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_content.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <p>

This article or section has multiple issues. Please help <b><weblink xlink:type="simple" xlink:href="http://localhost:18088/wiki/index.php?title=Support_vector_machine&amp;action=edit">
improve the article</weblink></b> or discuss these issues on the .
<list>
<entry level="1" type="bullet">

 It may require  to meet Wikipedia's <b>
Wikipedia style guidelines|quality standards</b>. Tagged since June 2008.</entry>
<entry level="1" type="bullet">

 It may be  for some readers.</entry>
<entry level="1" type="bullet">

 It needs to be . Tagged since June 2008.</entry>
</list>
</p>
</col>
</row>
</table>

<p>

<b>Support vector machines</b> (<b>SVMs</b>) are a set of related <link xlink:type="simple" xlink:href="../926/20926.xml">
supervised learning</link> methods used for <link xlink:type="simple" xlink:href="../244/1579244.xml">
classification</link> and <link xlink:type="simple" xlink:href="../997/826997.xml">
regression</link>.  Viewing input <link xlink:type="simple" xlink:href="../040/18985040.xml">
data</link> as two sets of <link xlink:type="simple" xlink:href="../688/292688.xml">
vector</link>s in an <link xlink:type="simple" xlink:href="../401/2498401.xml">
<it>n</it>-dimensional space</link>, an SVM will construct a separating <link xlink:type="simple" xlink:href="../862/99862.xml">
hyperplane</link> in that <link xlink:type="simple" xlink:href="../500/197500.xml">
space</link>, one which maximizes the <it>margin</it> between the two data sets. To calculate the margin, two <link xlink:type="simple" xlink:href="../954/76954.xml">
parallel</link> hyperplanes are constructed, one on each side of the separating hyperplane, which are "pushed up against" the two data sets. Intuitively, a good separation is achieved by the hyperplane that has the largest distance to the neighboring datapoints of both classes, since in general the larger the margin the better the <link xlink:type="simple" xlink:href="../249/2456249.xml">
generalization error</link> of the classifier.</p>

<sec>
<st>
Motivation</st>
<p>

<image location="right" width="150px" src="Svm_separating_hyperplanes.png" type="thumb">
<caption>

H3 (green) doesn't separate the 2 classes. H1 (blue) does, with a small margin and H2 (red) with the maximum margin.
</caption>
</image>

<link xlink:type="simple" xlink:href="../244/1579244.xml">
Classifying data</link> is a common need in <link xlink:type="simple" xlink:href="../488/233488.xml">
machine learning</link>.
Suppose some given data points each belong to one of two classes, and the goal is to decide which class a <it>new</it> data point will be in. In the case of support vector machines, a data point is viewed as a <math>p</math>-dimensional vector (a list of <math>p</math> numbers), and we want to know whether we can separate such points with a <math>p-1</math>-dimensional <link xlink:type="simple" xlink:href="../862/99862.xml">
hyperplane</link>. This is called a <link xlink:type="simple" xlink:href="../974/98974.xml">
linear classifier</link>. There are many hyperplanes that might classify the data. However, we are additionally interested in finding out if we can achieve maximum separation (margin) between the two classes. By this we mean that we pick the hyperplane so that the distance from the hyperplane to the nearest data point is maximized.  That is to say that the nearest distance between a point in one <it>separated</it> hyperplane and a point in the other <it>separated</it> hyperplane is maximized. Now, if such a hyperplane exists, it is clearly of interest and is known as the <it><link xlink:type="simple" xlink:href="../781/1423781.xml">
maximum-margin hyperplane</link></it> and such a linear classifier is known as a <b>maximum <link xlink:type="simple" xlink:href="../674/17562674.xml">
margin classifier</link></b>.</p>

</sec>
<sec>
<st>
Formalization</st>
<p>

We are given some training data, a set of points of the form
<indent level="1">

<math>\mathcal{D} = \{ (\mathbf{x}_i, c_i)|\mathbf{x}_i \in \mathbb{R}^p, c_i \in \{-1,1\}\}_{i=1}^n</math>
</indent>
where the <it>ci</it> is either 1 or &amp;minus;1, indicating the class to which the point <math>\mathbf{x}_i </math> belongs. Each <math> \mathbf{x}_i </math> is a <math>p</math>-dimensional <link xlink:type="simple" xlink:href="../491/19725491.xml">
real</link> vector. We want to give the maximum-margin hyperplane which divides the points having <math>c_i=1</math> from those having <math>c_i=-1</math>. Any hyperplane can be written as the set of points <math>\mathbf{x}</math> satisfying
<image location="right" width="150px" src="Svm_max_sep_hyperplane_with_margin.png" type="thumb">
<caption>

Maximum-margin hyperplane and margins for a SVM trained with samples from two classes. Samples on the margin are called the support vectors.
</caption>
</image>

<indent level="1">

 <math>\mathbf{w}\cdot\mathbf{x} - b=0.</math>
</indent>
The vector <math>\mathbf{w}</math> is a <link xlink:type="simple" xlink:href="../224/173224.xml">
normal</link> vector: it is perpendicular to the hyperplane. The parameter <math>\tfrac{b}{\|\mathbf{w}\|}</math> determines the offset of the hyperplane from the origin along the normal vector <math>\mathbf{w}</math>.</p>
<p>

We want to choose the <math>\mathbf{w}</math> and <math>b</math> to maximize the margin, or distance between the parallel hyperplanes that are as far apart as possible while still separating the data. These hyperplanes can be described by the equations
<indent level="1">

 <math>\mathbf{w}\cdot\mathbf{x} - b=1</math> and
</indent>
: <math>\mathbf{w}\cdot\mathbf{x} - b=-1.</math>
Note that if the training data are <link xlink:type="simple" xlink:href="../173/523173.xml">
linearly separable</link>, we can select the two hyperplanes of the margin in a way that there are no points between them and then try to maximize their distance. By using geometry, we find the distance between these two hyperplanes is <math>\tfrac{2}{\|\mathbf{w}\|}</math>, so we want to minimize <math>\|\mathbf{w}\|</math>. As we also have to prevent data points falling into the margin, we add the following constraint: for each <math>i</math> either
<indent level="1">

 <math>\mathbf{w}\cdot\mathbf{x}_i - b \ge 1\qquad</math> for <math> \mathbf{x}_i </math> for the first class or
</indent>
: <math>\mathbf{w}\cdot\mathbf{x}_i - b \le -1\qquad</math> for <math> \mathbf{x}_i </math> of the second.
This can be rewritten as:
<indent level="1">

 <math>c_i(\mathbf{w}\cdot\mathbf{x}_i - b) \ge 1,  \quad \text{ for all }  1 \le i \le n.\qquad\qquad(1)</math>
</indent>
We can put this together to get the optimization problem:
<indent level="1">

 choose <math>{\mathbf{w},b}</math> to minimize <math>\|\mathbf{w}\|</math>
</indent>
: subject to <math>c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1,  \quad \text{ for all }  1 \le i \le n</math></p>

<ss1>
<st>
Primal Form</st>
<p>

The optimization problem presented in the preceding section is difficult to solve because it depends on the absolute value of |w|.
Fortunately it is possible to alter the equation by substituting ||<b>w</b>|| with <math>\tfrac{1}{2}\|\mathbf{w}\|^2</math> without changing the solution (the minimum of the original and the modified equation have the same w and b).
This is a <link xlink:type="simple" xlink:href="../324/40324.xml">
quadratic programming</link> (QP) <link xlink:type="simple" xlink:href="../033/52033.xml">
optimization</link> problem. More clearly,
<indent level="1">

 minimize <math>\frac{1}{2}\|\mathbf{w}\|^2</math>, subject to <math>c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1, \quad 1 \le i \le n.</math>.
</indent>
The factor of 1/2 is used for mathematical convenience.
This problem can now be solved by standard quadratic programming techniques and programs.</p>

</ss1>
<ss1>
<st>
Dual Form</st>
<p>

Writing the classification rule in its unconstrained <link xlink:type="simple" xlink:href="../737/609737.xml">
dual form</link> reveals that the maximum margin hyperplane and therefore the classification task is only a function of the <it>support vectors</it>, the training data that lie on the margin.
The dual of the SVM can be shown to be:
<indent level="1">

<math>\max \sum_{i=1}^n \alpha_i - \frac{1}{2}\sum_{i,j} \alpha_i \alpha_j c_i c_j \mathbf{x}_i^T \mathbf{x}_j</math> subject to <math> \alpha_i \geq 0 </math>, and <math> \sum_{i=1}^n \alpha_i c_i = 0 </math>
</indent>
where the <math>\alpha</math> terms constitute a dual representation for the weight vector in terms of the training set:
<indent level="1">

<math>\mathbf{w} = \sum_i \alpha_i c_i \mathbf{x}_i</math>
</indent>
</p>

</ss1>
</sec>
<sec>
<st>
 Properties </st>

<p>

SVMs belong to a family of generalized <link xlink:type="simple" xlink:href="../974/98974.xml">
linear classifier</link>s. They can also be considered a special case of <link xlink:type="simple" xlink:href="../323/954323.xml">
Tikhonov regularization</link>. A special property is that they simultaneously minimize the empirical <it>classification error</it> and maximize the <it>geometric margin</it>; hence they are also known as <b>maximum <link xlink:type="simple" xlink:href="../674/17562674.xml">
margin classifier</link>s</b>.  </p>
<p>

A comparison of the SVM to other classifiers has been made by Meyer, Leisch and Hornik.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
Extensions to the linear SVM</st>

<ss1>
<st>
 Soft margin </st>
<p>

In <link xlink:type="simple" xlink:href="../658/34658.xml">
1995</link>, <link>
Corinna Cortes</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../673/209673.xml">
Vladimir Vapnik</link></educator>
</mathematician>
</professional>
</adult>
</scientist>
</academician>
</causal_agent>
</person>
</physical_entity>
 suggested a modified maximum margin idea that allows for mislabeled examples.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>  If there exists no hyperplane that can split the "yes" and "no" examples, the <it>Soft Margin</it> method will choose a hyperplane that splits the examples as cleanly as possible, while still maximizing the distance to the nearest cleanly split examples.  This work popularized the expression <it>Support Vector Machine</it> or <it>SVM</it>. The method introduces slack variables, <math>\xi_i</math>, which measure the degree of misclassification of the datum <math>x_i</math>
<indent level="1">

 <math>c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1 - \xi_i \quad 1 \le i \le n \quad\quad(2)</math>.  
</indent>
The objective function is then increased by a function which penalises non-zero <math>\xi_i</math>, and the optimisation becomes a trade off between a large margin, and a small error penalty.  If the penalty function is linear, the equation (3) now transforms to
<indent level="1">

 <math> \min \frac{1}{2} \|\mathbf{w}\|^2 + C \sum_i \xi_i \quad \mbox{such  that}\quad c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1 - \xi_i \quad 1 \le i \le n. </math>
</indent>
This constraint in (2) along with the objective of minimizing |<b><it>w</it></b>| can be solved using <link xlink:type="simple" xlink:href="../974/159974.xml">
Lagrange multipliers</link>.  The key advantage of a linear penalty function is that the slack variables vanish from the dual problem, with the constant <it>C</it> appearing only as an additional constraint on the Lagrange multipliers.   Non-linear penalty functions have been used, particularly to reduce the effect of outliers on the classifier, but unless care is taken, the problem becomes non-convex, and thus it is considerably more difficult to find a global solution.</p>

</ss1>
<ss1>
<st>
 Non-linear classification </st>
<p>

The original optimal hyperplane algorithm proposed by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../673/209673.xml">
Vladimir Vapnik</link></educator>
</mathematician>
</professional>
</adult>
</scientist>
</academician>
</causal_agent>
</person>
</physical_entity>
 in <link xlink:type="simple" xlink:href="../648/34648.xml">
1963</link> was a <link xlink:type="simple" xlink:href="../974/98974.xml">
linear classifier</link>.  However, in <link xlink:type="simple" xlink:href="../669/34669.xml">
1992</link>, <link>
Bernhard Boser</link>, <link>
Isabelle Guyon</link> and Vapnik suggested a way to create non-linear classifiers by applying the <link xlink:type="simple" xlink:href="../912/303912.xml">
kernel trick</link> (originally proposed by Aizerman et al..<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>
) to maximum-margin hyperplanes.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> The resulting algorithm is formally similar, except that every <link xlink:type="simple" xlink:href="../093/157093.xml">
dot product</link> is replaced by a non-linear <link xlink:type="simple" xlink:href="../912/430912.xml">
kernel</link> function. This allows the algorithm to fit the maximum-margin hyperplane in the transformed feature <link xlink:type="simple" xlink:href="../667/27667.xml#xpointer(//*[./st=%22Mathematics%22])">
space</link>. The transformation may be non-linear and the transformed space high dimensional; thus though the classifier is a hyperplane in the high-dimensional feature space it may be non-linear in the original input space.</p>
<p>

If the kernel used is a <link xlink:type="simple" xlink:href="../918/299918.xml">
Gaussian</link> <link xlink:type="simple" xlink:href="../753/2310753.xml">
radial basis function</link>, the corresponding feature space is a <link xlink:type="simple" xlink:href="../167/18994167.xml">
Hilbert space</link> of infinite dimension. Maximum margin classifiers are well <link xlink:type="simple" xlink:href="../061/2009061.xml">
regularized</link>, so the infinite dimension does not spoil the results.  Some common kernels include,
<list>
<entry level="1" type="bullet">

 Polynomial (homogeneous): <math>k(\mathbf{x},\mathbf{x}')=(\mathbf{x} \cdot \mathbf{x'})^d</math></entry>
<entry level="1" type="bullet">

 Polynomial (inhomogeneous): <math>k(\mathbf{x},\mathbf{x}')=(\mathbf{x} \cdot \mathbf{x'} + 1)^d</math></entry>
<entry level="1" type="bullet">

 Radial Basis Function: <math>k(\mathbf{x},\mathbf{x}')=\exp(-\gamma \|\mathbf{x} - \mathbf{x'}\|^2)</math>, for <math>\gamma &amp;gt; 0</math></entry>
<entry level="1" type="bullet">

 Gaussian Radial basis function: <math>k(\mathbf{x},\mathbf{x}')=\exp\left(- \frac{\|\mathbf{x} - \mathbf{x'}\|^2}{2 \sigma^2}\right)</math></entry>
<entry level="1" type="bullet">

 <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../210/87210.xml">
Sigmoid</link></function>
</mathematical_relation>
: <math>k(\mathbf{x},\mathbf{x}')=\tanh(\kappa \mathbf{x} \cdot \mathbf{x'}+c)</math>, for some (not every) <math>\kappa &amp;gt; 0 </math> and <math> c &amp;lt; 0 </math></entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 MultiClass SVM </st>

<p>

Multiclass SVM aims to assign labels to instances by using support vector machine, where the labels are drawn
from a finite set of several elements . The dominating approach for doing so, is to reduce the single multiclass
problem into multiple binary problems. Each of the problems yields a binary classifier, which is assumed to
produce an output function that gives relatively large values for examples from the positive class and relatively
small values for examples belonging to the negative class. Two common methods to build such binary classifiers
are where each classifier distinguishes between (i) one of the labels to the rest (one-versus-all) or (ii) between
every pair of classes (one-versus-one). Classification of new instances for one-versus-all case is done by winner takes-
all strategy, in which the classifier with the highest output function assign the class. The classification of
one-versus-one case is done by max-wins voting strategy, in which every classifier assign the instance to one of
the two classes, then the vote for the assigned class is increased by one vote. Finally the class with most votes
determines the instance classification</p>

</sec>
<sec>
<st>
 Regression </st>

<p>

A version of a SVM for <link xlink:type="simple" xlink:href="../997/826997.xml">
regression</link> was proposed in <link xlink:type="simple" xlink:href="../636/34636.xml">
1996</link> by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<academician wordnetid="109759069" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../673/209673.xml">
Vladimir Vapnik</link></educator>
</mathematician>
</professional>
</adult>
</scientist>
</academician>
</causal_agent>
</person>
</physical_entity>
, Harris Drucker, Chris Burges, Linda Kaufman and Alex Smola.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> This method is called <link>
support vector regression</link> (SVR). The model produced by support vector classification (as described above) only depends on a subset of the training data, because the cost function for building the model does not care about training points that lie beyond the margin. Analogously, the model produced by SVR only depends on a subset of the training data, because the cost function for building the model ignores any training data that are close (within a threshold <math>\epsilon</math>) to the model prediction.</p>

</sec>
<sec>
<st>
 Implementation </st>
<p>

The parameters of the maximum-margin hyperplane are derived by solving the optimization. There exist several specialized algorithms for quickly solving the QP problem that arises from SVMs, mostly reliant on heuristics for breaking the problem down into smaller, more-manageable chunks.  A common method for solving the QP problem is the <weblink xlink:type="simple" xlink:href="http://research.microsoft.com/users/jplatt/smo.html">
Platt's</weblink> <link>
Sequential Minimal Optimization</link> (SMO) <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>, which breaks the problem down into 2-dimensional sub-problems that may be solved analytically, eliminating the need for a numerical optimization algorithm such as <link xlink:type="simple" xlink:href="../821/1448821.xml">
conjugate gradient</link> methods.</p>
<p>

Another approach is to use an <link xlink:type="simple" xlink:href="../862/1622862.xml">
interior point method</link> that uses Newton-like iterations to find a solution of  the <link xlink:type="simple" xlink:href="../362/2397362.xml">
Karush-Kuhn-Tucker conditions</link> of the primal and dual problems.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>
Instead of solving a sequence of broken down problems, this approach directly solves the problem as a whole. To avoid solving a linear system involving the large kernel matrix, a row rank approximation to the matrix is often used to use the kernel trick.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../576/3424576.xml">
Kernel machines</link></entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../563/4141563.xml">
Predictive analytics</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../092/4195092.xml">
Relevance Vector Machine</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, a probabilistic sparse kernel model identical in functional form to SVM.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
David Meyer, Friedrich Leisch, and Kurt Hornik. The support vector machine under test. Neurocomputing 55(1-2): 169-186, 2003
http://dx.doi.org/10.1016/S0925-2312(03)00431-4</entry>
<entry id="2">
Corinna Cortes and V. Vapnik, "Support-Vector Networks<it>, Machine Learning, 20, 1995. http://www.springerlink.com/content/k238jx04hm87j80g/
</it></entry>
<entry id="3">
 <cite style="font-style:normal">M. Aizerman, E. Braverman, and L. Rozonoer&#32;(1964).&#32;"Theoretical foundations of the potential function method in pattern recognition learning". <it>Automation and Remote Control</it>&#32;<b>25</b>: 821–837.</cite>&nbsp;</entry>
<entry id="4">
B. E. Boser, I. M. Guyon, and V. N. Vapnik. <it>A training algorithm for optimal margin classifiers</it>. In D. Haussler, editor, 5th Annual ACM Workshop on COLT, pages 144-152, Pittsburgh, PA, 1992. ACM Press</entry>
<entry id="5">
Harris Drucker, Chris J.C. Burges, Linda Kaufman, Alex Smola and Vladimir Vapnik (1997). "Support Vector Regression Machines". <it>Advances in Neural Information Processing Systems 9, NIPS 1996</it>, 155-161, MIT Press.</entry>
<entry id="6">
 <cite style="font-style:normal">M. Ferris, and T. Munson&#32;(2002).&#32;"Interior-point methods for massive support vector machines". <it>SIAM Journal on Optimization</it>&#32;<b>13</b>: 783-804.</cite>&nbsp;</entry>
<entry id="7">
Christopher J. C. Burges.  "A Tutorial on Support Vector Machines for Pattern Recognition". Data Mining and Knowledge Discovery 2:121 - 167, 1998 http://research.microsoft.com/~cburges/papers/SVMTutorial.pdf
</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 Bibliography </st>
<p>

<list>
<entry level="1" type="bullet">

 Nello Cristianini and John Shawe-Taylor. <it>An Introduction to Support Vector Machines and other kernel-based learning methods</it>. Cambridge University Press, 2000. ISBN 0-521-78019-5 <it>(<weblink xlink:type="simple" xlink:href="http://www.support-vector.net">
http://www.support-vector.net</weblink> SVM Book)''</it></entry>
<entry level="1" type="bullet">

 Huang T.-M., Kecman V., Kopriva I. (2006), Kernel Based Algorithms for Mining Huge Data Sets, Supervised, Semi-supervised, and Unsupervised Learning,  Springer-Verlag, Berlin, Heidelberg, 260 pp. 96 illus., Hardcover, ISBN 3-540-31681-7<weblink xlink:type="simple" xlink:href="http://learning-from-data.com">
http://learning-from-data.com</weblink></entry>
<entry level="1" type="bullet">

 Vojislav Kecman: "Learning and Soft Computing - Support Vector Machines, Neural Networks, Fuzzy Logic Systems", The MIT Press, Cambridge, MA, 2001.<weblink xlink:type="simple" xlink:href="http://www.support-vector.ws">
http://www.support-vector.ws</weblink></entry>
<entry level="1" type="bullet">

 Bernhard Schölkopf and A. J. Smola: <it>Learning with Kernels</it>. MIT Press, Cambridge, MA, 2002. <it>(Partly available on line: <weblink xlink:type="simple" xlink:href="http://www.learning-with-kernels.org">
http://www.learning-with-kernels.org</weblink>.)</it> ISBN 0-262-19475-9</entry>
<entry level="1" type="bullet">

 Bernhard Schölkopf, Christopher J.C. Burges, and Alexander J. Smola (editors).  "Advances in Kernel Methods: Support Vector Learning".  MIT Press, Cambridge, MA, 1999.  ISBN 0-262-19416-3.  <weblink xlink:type="simple" xlink:href="http://www.kernel-machines.org/nips97/book.html">
http://www.kernel-machines.org/nips97/book.html</weblink></entry>
<entry level="1" type="bullet">

 John Shawe-Taylor and Nello Cristianini.  <it>Kernel Methods for Pattern Analysis</it>.  Cambridge University Press, 2004.  ISBN 0-521-81397-2 <it>(<weblink xlink:type="simple" xlink:href="http://www.kernel-methods.net">
http://www.kernel-methods.net</weblink> Kernel Methods Book)''</it></entry>
<entry level="1" type="bullet">

P.J. Tan and <weblink xlink:type="simple" xlink:href="http://www.csse.monash.edu.au/~dld">
D.L. Dowe</weblink> (2004), <weblink xlink:type="simple" xlink:href="http://www.csse.monash.edu.au/~dld/David.Dowe.publications.html#TanDowe2004">
MML Inference of Oblique Decision Trees</weblink>, Lecture Notes in Artificial Intelligence (LNAI) 3339, Springer-Verlag, <weblink xlink:type="simple" xlink:href="http://www.csse.monash.edu.au/~dld/Publications/2004/Tan+DoweAI2004.pdf">
pp1082-1088</weblink>. (This paper uses <link xlink:type="simple" xlink:href="../210/302210.xml">
minimum message length</link> (<link xlink:type="simple" xlink:href="../210/302210.xml">
MML</link>) and actually incorporates probabilistic support vector machines in the leaves of <link xlink:type="simple" xlink:href="../602/232602.xml">
decision tree</link>s.)</entry>
<entry level="1" type="bullet">

 Vladimir Vapnik. <it>The Nature of Statistical Learning Theory</it>.  Springer-Verlag, 1995. ISBN 0-387-98780-0</entry>
<entry level="1" type="bullet">

 Vladimir Vapnik, S.Kotz "Estimation of Dependences Based on Empirical Data"  Springer, 2006. ISBN 0387308652, 510 pages [this is a reprint of Vapnik's early book describing philosophy behind SVM approach. The 2006 Appendix describes recent development].</entry>
<entry level="1" type="bullet">

 Dmitriy Fradkin and Ilya Muchnik "Support Vector Machines for Classification" in J. Abello and G. Carmode (Eds) "Discrete Methods in Epidemiology", DIMACS Series in Discrete Mathematics and Theoretical Computer Science, volume 70, pp. 13-20, 2006.  <weblink xlink:type="simple" xlink:href="http://paul.rutgers.edu/~dfradkin/papers/svm.pdf">
http://paul.rutgers.edu/~dfradkin/papers/svm.pdf</weblink>. Succinctly describes theoretical ideas behind SVM.</entry>
<entry level="1" type="bullet">

 Kristin P. Bennett and Colin Campbell, "Support Vector Machines: Hype or Hallelujah?", SIGKDD Explorations, 2,2, 2000, 1-13. <weblink xlink:type="simple" xlink:href="http://www.acm.org/sigs/sigkdd/explorations/issue2-2/bennett.pdf">
http://www.acm.org/sigs/sigkdd/explorations/issue2-2/bennett.pdf</weblink>. Excellent introduction to SVMs with helpful figures.</entry>
<entry level="1" type="bullet">

 Ovidiu Ivanciuc, "Applications of Support Vector Machines in Chemistry", In: <it>Reviews in Computational Chemistry</it>, Volume 23, 2007, pp. 291–400. Reprint available: <weblink xlink:type="simple" xlink:href="http://www.ivanciuc.org/Files/Reprint/Ivanciuc_SVM_CCR_2007_23_291.pdf">
http://www.ivanciuc.org/Files/Reprint/Ivanciuc_SVM_CCR_2007_23_291.pdf</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>

<ss1>
<st>
General</st>

<p>

<list>
<entry level="1" type="bullet">

 A tutorial on SVMs has been produced by C.J.C Burges.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> </entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.pascal-network.org">
www.pascal-network.org</weblink> <it>(EU Funded Network on Pattern Analysis, Statistical Modelling and Computational Learning)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.kernel-machines.org">
www.kernel-machines.org</weblink> <it>(general information and collection of research papers)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.kernel-methods.net">
www.kernel-methods.net</weblink> <it>(News, Links, Code related to Kernel methods - Academic Site)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.support-vector.net">
www.support-vector.net</weblink> <it>(News, Links, Code related to Support Vector Machines - Academic Site)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.support-vector-machines.org">
www.support-vector-machines.org</weblink> <it>(Literature, Review, Software, Links related to Support Vector Machines - Academic Site)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.support-vector.ws">
www.support-vector.ws</weblink> <it>(Free educational MATLAB based software for SVMs, NN and FL , Links, Publications downloads, Semisupervised learning software SemiL, Links)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://videolectures.net/Top/Computer_Science/Machine_Learning/Kernel_Methods/Support_Vector_Machines/">
videolectures.net</weblink> <it>(SVM-related video lectures)''</it></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.youtube.com/watch?v=3liCbRZPrZA">
Animation clip</weblink>: SVM with polynomial kernel visualization.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Software</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.zementis.com/adapa.htm">
ADAPA</weblink> -- a batch and real-time <link xlink:type="simple" xlink:href="../802/2876802.xml">
PMML</link> based scoring engine for data mining models including Support Vector Machines.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/~lairdm/Algorithm-SVM-0.11/lib/Algorithm/SVM.pm">
Algorithm::SVM</weblink> --  Perl bindings for the libsvm Support Vector Machine library</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://dclib.sourceforge.net">
dlib C++ Library</weblink> --  A C++ library that includes an easy to use SVM classifier</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://cran.r-project.org/src/contrib/Descriptions/e1071.html">
e1071</weblink> - Machine learning library for R</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://bioinformatics.ubc.ca/gist/">
Gist</weblink> -- implementation of the SVM algorithm with feature selection.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://cran.r-project.org/src/contrib/Descriptions/kernlab.html">
kernlab</weblink> - Kernel-based Machine Learning library for R</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/">
LIBLINEAR</weblink> -- A Library for Large Linear Classification, Machine Learning Group at National Taiwan University </entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">
LIBSVM</weblink> -- A Library for Support Vector Machines, Chih-Chung Chang and Chih-Jen Lin</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://lush.sourceforge.net/">
Lush</weblink> -- a Lisp-like interpreted/compiled language with C/C++/Fortran interfaces that has packages to interface to a number of different SVM implementations. Interfaces to LASVM, LIBSVM, mySVM, SVQP, SVQP2 (SVQP3 in future) are available. Leverage these against Lush's other interfaces to machine learning, hidden markov models, numerical libraries (LAPACK, BLAS, GSL), and builtin vector/matrix/tensor engine.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.esat.kuleuven.ac.be/sista/lssvmlab">
LS-SVMLab</weblink> - Matlab/C SVM toolbox - well-documented, many features</entry>
<entry level="1" type="bullet">

 [https://mlpy.fbk.eu mlpy] - Machine Learning Py - Python/NumPy based package for machine learning.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://sourceforge.net/projects/svm/">
OSU SVM</weblink> - Matlab implementation based on LIBSVM</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.procoders.net">
pcSVM</weblink> is an object oriented SVM framework written in C++ and provides wrapping to Python classes. The site provides a stand alone <weblink xlink:type="simple" xlink:href="http://www.procoders.net/?p=22">
demo tool</weblink> for experimenting with SVMs.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://pcp.sourceforge.net/">
PCP</weblink> -- C program for supervised pattern classification. Includes LIBSVM wrapper.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://pyml.sourceforge.net">
PyML</weblink> -- a Python machine learning package. Includes: SVM, nearest neighbor classifiers, ridge regression, Multi-class methods (one-against-one and one-against-rest), Feature selection (filter methods, RFE, multiplicative update, Model selection, Classifier testing (cross-validation, error rates, ROC curves, statistical test for comparing classifiers).</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.shogun-toolbox.org">
Shogun</weblink> - Large Scale Machine Learning Toolbox that provides several SVM implementations (like libSVM, SVMlight) under a common framework and interfaces to Octave, Matlab, Python, R</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://asi.insa-rouen.fr/~gloosli/simpleSVM.html">
SimpleSVM</weblink> - SimpleSVM toolbox for Matlab</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.kyb.tuebingen.mpg.de/bs/people/spider/">
Spider</weblink> - Machine learning library for Matlab</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://cmp.felk.cvut.cz/cmp/software/stprtool/">
Statistical Pattern Recognition Toolbox for Matlab</weblink>.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://asi.insa-rouen.fr/~arakotom/toolbox/index.html">
SVM and Kernel Methods Matlab Toolbox</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.patternrecognition.co.za/applet.html">
SVM Classification Applet</weblink> -- Performs classification on any given data set and gives 10-fold cross-validation error rate</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://svmlight.joachims.org/">
SVMlight</weblink> -- a popular implementation of the SVM algorithm by Thorsten Joachims; it can be used to solve classification, regression and ranking problems.</entry>
<entry level="2" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://cfn.upenn.edu/aguirre/wiki/support_vector_machines">
automation of SVMlight in Matlab</weblink> -- complete automation of SVMlight for use with fMRI data</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://jing.cz3.nus.edu.sg/cgi-bin/svmprot.cgi/">
SVMProt</weblink> -- Protein Functional Family Prediction.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.torch.ch/">
Torch</weblink> - C++ machine learning library with SVM</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.terborg.net/research/kml/">
The Kernel-Machine Library</weblink> (GNU) C++ template library for Support Vector Machines</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://chasen.org/~taku/software/TinySVM/">
TinySVM</weblink> -- a small SVM implementation, written in C++</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://rapid-i.com/content/blogcategory/10/69/">
YALE</weblink> (now <work wordnetid="100575741" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<undertaking wordnetid="100795720" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../865/5100865.xml">
RapidMiner</link></activity>
</psychological_feature>
</act>
</undertaking>
</event>
</work>
) -- a powerful machine learning toolbox containing wrappers for SVMLight, LibSVM, and MySVM in addition to many evaluation and preprocessing methods.</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/3829034.xml">
Weka</link></software>
 -- a machine learning toolkit that includes an implementation of an SVM classifier; Weka can be used both interactively though a graphical interface or as a software library.  (The SVM implementation is called "SMO".  It can be found in the Weka Explorer GUI, under the "functions" category or in the Weka Explorer GUI as SVMAttributeEval, under Select attributes, attributeSelection.)</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Interactive SVM applications</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mips.gsf.de/proj/est/">
ECLAT</weblink> classification of <link xlink:type="simple" xlink:href="../426/477426.xml">
Expressed Sequence Tag</link> (EST) from mixed EST pools using codon usage</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mips.gsf.de/proj/este/">
EST3</weblink> classification of <link xlink:type="simple" xlink:href="../426/477426.xml">
Expressed Sequence Tag</link> (EST) from mixed EST pools using nucleotide triples</entry>
</list>
</p>


</ss1>
</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</method>
</rule>
</event>
</know-how>
</article>
