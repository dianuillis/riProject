<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:29:08[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Deterministic finite-state machine</title>
<id>653404</id>
<revision>
<id>244261755</id>
<timestamp>2008-10-10T00:26:39Z</timestamp>
<contributor>
<username>Slysplace</username>
<id>3404724</id>
</contributor>
</revision>
<categories>
<category>Automata</category>
<category>Computational models</category>
</categories>
</header>
<bdy>

In the <link xlink:type="simple" xlink:href="../402/30402.xml">
theory of computation</link>, a <b><link xlink:type="simple" xlink:href="../722/3934722.xml">
deterministic</link> finite state machine</b> (also known as <b>deterministic finite state automaton (DFSA)</b> or <b>deterministic finite automaton (DFA)</b> ) is a <link xlink:type="simple" xlink:href="../931/10931.xml">
finite state machine</link> where for each pair of state and input symbol there is one and only one transition to a next state. DFAs recognize the set of <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>s and no other languages.<p>

A DFA will take in a string of input symbols. For each input symbol it will then transition to a state given by following a transition function. When the last input symbol has been received it will either accept or reject the string depending on whether the DFA is in an accepting state or a non-accepting state.</p>

<sec>
<st>
Formal definition</st>

<p>

A DFA is a 5-<link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link>,
(<it>S</it>, &amp;Sigma;, <it>T</it>, <it>s</it>, <it>A</it>), consisting of
<list>
<entry level="1" type="bullet">

 a finite set of <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../512/285512.xml">
states</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 (<it>S</it>)</entry>
<entry level="1" type="bullet">

 a finite set called the alphabet (&amp;Sigma;) </entry>
<entry level="1" type="bullet">

 a transition <link xlink:type="simple" xlink:href="../427/185427.xml">
function</link> (<it>T</it> : <it>S</it> &amp;times; &amp;Sigma; &amp;rarr; <it>S</it>)</entry>
<entry level="1" type="bullet">

 a start state (<it>s</it> &amp;isin; <it>S</it>)</entry>
<entry level="1" type="bullet">

 a set of <link xlink:type="simple" xlink:href="../931/10931.xml">
accept state</link>s (<it>A</it> &amp;sube; <it>S</it>)</entry>
</list>
</p>
<p>

Let <b>M</b> be a DFA such that <b>M</b> = (<it>S</it>, &amp;Sigma;, <it>T</it>, <it>s</it>, <it>A</it>), and <it>X = x0x1 ... xn</it> be a string over the alphabet &amp;Sigma;. <b>M</b> accepts the string <it>X</it> if a sequence of states,
<it>r0,r1, ..., rn</it>, exists in <it>S</it> with the following conditions:
<list>
<entry level="1" type="number">

 <it>r0</it> = <it>s''</it></entry>
<entry level="1" type="number">

 <it>ri+1</it> = <it>T</it>(<it>ri</it>, <it>xi</it>), for <it>i</it> = <it>0, ..., n-1''</it></entry>
<entry level="1" type="number">

 <it>rn</it> &amp;isin; <it>A</it>.</entry>
</list>
</p>
<p>

As shown in the first condition, the machine starts in the start state <it>s</it>.
The second condition says that given each character of string <it>X</it>, the machine will transition from state to state according to the transition function <it>T</it>. 
The last condition says that the machine accepts <it>X</it> if the last input of <it>X</it> causes the machine to halt in one of the accepting states.  Otherwise, it is said to reject the string. The set of strings the DFA accepts form a <link xlink:type="simple" xlink:href="../939/10939.xml">
language</link>, which is the language the DFA recognizes.</p>
<p>

A DFA without a list of accept states and without a designated starting state is known as a <link xlink:type="simple" xlink:href="../417/396417.xml">
transition system</link> or <link xlink:type="simple" xlink:href="../937/10766937.xml">
semiautomaton</link>.</p>

</sec>
<sec>
<st>
Example</st>

<p>

The following example is of a DFA <it>M</it>, with a binary alphabet, which requires that the input contains an even number of 0s.</p>
<p>

<image location="right" width="350px" src="DFAexample.svg" type="thumb">
<caption>

The <link xlink:type="simple" xlink:href="../337/187337.xml">
state diagram</link> for <it>M''</it>
</caption>
</image>

<it>M</it> = (<it>S</it>, &amp;Sigma;, <it>T</it>, <it>s</it>, <it>A</it>) where
<list>
<entry level="1" type="bullet">

<it>S</it> = {<it>S</it>1, <it>S</it>2},</entry>
<entry level="1" type="bullet">

&amp;Sigma; = {0, 1},</entry>
<entry level="1" type="bullet">

<it>s</it> = <it>S</it>1,</entry>
<entry level="1" type="bullet">

<it>A</it> = {<it>S</it>1}, and</entry>
<entry level="1" type="bullet">

<it>T</it> is defined by the following <link xlink:type="simple" xlink:href="../857/548857.xml">
state transition table</link>:</entry>
<entry level="1" type="indent">

| border="1" cellpadding="1" cellspacing="0"</entry>
</list>

| || <b>0</b> || <b>1</b>
|-
|<b><it>S</it></b><b>1</b> || <it>S</it>2 || <it>S</it>1
|-
|<b><it>S</it></b><b>2</b> || <it>S</it>1 || <it>S</it>2
|}</p>
<p>

The state <it>S</it>1 represents that there has been an even number of 0s in the input so far, while <it>S</it>2 signifies an odd number. A 1 in the input does not change the state of the automaton. When the input ends, the state will show whether the input contained an even number of 0s or not. If the language did contain an even number of 0s, <it>M</it> will finish in state <it>S</it>1, an accepting state, so the input string will be accepted.</p>
<p>

The language of <it>M</it> is the <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link> given by the <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link>
(1*(0(1)*0)*)*</p>



</sec>
<sec>
<st>
 Advantages and disadvantages </st>

<p>

DFAs are one of the most practical models of computation, since there is a trivial linear time, constant-space, <link xlink:type="simple" xlink:href="../716/22716.xml">
online algorithm</link> to simulate a DFA on a stream of input. Given two DFAs there are efficient algorithms to find a DFA recognizing:
<list>
<entry level="1" type="bullet">

 the union of the two DFAs</entry>
<entry level="1" type="bullet">

 the intersection of the two DFAs</entry>
<entry level="1" type="bullet">

 complements of the languages the DFAs recognize</entry>
</list>

There are also efficient algorithms to determine:
<list>
<entry level="1" type="bullet">

 whether a DFA accepts any strings</entry>
<entry level="1" type="bullet">

 whether a DFA accepts all strings</entry>
<entry level="1" type="bullet">

 whether two DFAs recognize the same language</entry>
<entry level="1" type="bullet">

 the DFA with a minimum number of states for a particular regular language</entry>
</list>
</p>
<p>

DFAs are equivalent in computing power to <link xlink:type="simple" xlink:href="../406/653406.xml">
nondeterministic finite automata</link>.</p>
<p>

On the other hand, Finite State Automata are of strictly limited power in the languages they can recognize &mdash; many simple languages, including any problem that requires more than constant space to solve, cannot be recognized by a DFA. The classical example of a simply described language that no DFA can recognize is 
bracket language, that is, language that consists of properly paired brackets, such as (()()). More formally the language consisting of strings of the form anbn &mdash; some finite number of a's, followed by an equal number of b's. If there is no limit to <link xlink:type="simple" xlink:href="../407/25407.xml">
recursion</link> (i.e., you can always embed another pair of brackets inside) it would require an infinite amount of states to recognize.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../002/204002.xml">
Acyclic deterministic finite automata</link></entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
Nondeterministic finite state machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../401/12302401.xml">
Read only right moving Turing Machines</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../428/341428.xml">
Monadic second-order logic</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Michael Sipser, <it>Introduction to the Theory of Computation</it>. PWS, Boston. 1997. ISBN 0-534-94728-X. Section 1.1: Finite Automata, pp.31&ndash;47. Subsection "Decidable Problems Concerning Regular Languages" of section 4.1: Decidable Languages, pp.152&ndash;155.4.4 DFA can accept only regular language</entry>
</list>
</p>

<p>

<table style=";width:auto;" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../356/103356.xml">
Automata theory</link>: <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>s and <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;background:transparent;color:inherit;" class="navbox-list navbox-odd">
<table style="text-align:left;width:100%;" class="navbox-columns-table" cellspacing="0">
<row>
<col colspan="1" style="" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky
hierarchy</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../716/18020716.xml">
Grammars</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><link xlink:type="simple" xlink:href="../939/10939.xml">
Languages</link></b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b>Minimal
<link xlink:type="simple" xlink:href="../931/10931.xml">
automaton</link></b></col>
</row>
<row style="height:2px;">

</row>
<row style="vertical-align:top;">
<col style="padding:0px;text-align: center;;;;width:10em;">
Type-0 n/a Type-1 n/a n/a Type-2 n/a Type-3 n/a</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../174/4906174.xml">
Unrestricted</link></language>
(no common name) <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../211/6211.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/12656637.xml">
Indexed</link></language>
<model wordnetid="105890249" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<hypothesis wordnetid="105888929" confidence="0.8">
<link xlink:type="simple" xlink:href="../555/567555.xml">
Tree-adjoining</link></hypothesis>
</concept>
</idea>
</model>
 etc.<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../759/6759.xml">
Context-free</link></language>
</subject>
</message>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/10609024.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../855/25855.xml">
Regular</link></language>
n/a</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../789/54789.xml">
Recursively enumerable</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../874/53874.xml">
Recursive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/6212.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../284/7324284.xml">
Indexed</link></language>
(<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/13026226.xml">
Mildly context-sensitive</link></language>
)<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/6867.xml">
Context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../589/7962589.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../723/25723.xml">
Regular</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../792/4922792.xml">
Star-free</link></language>
</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/1352564.xml">
Decider</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../962/1811962.xml">
Linear-bounded</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../447/9791447.xml">
Nested stack</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../961/14345961.xml">
Embedded pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../510/24510.xml">
Nondeterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../656/3972656.xml">
Deterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<link xlink:type="simple" xlink:href="../931/10931.xml">
Finite</link><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../149/17995149.xml">
Aperiodic finite</link></language>
</p>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
Each category of languages or grammars is a <link xlink:type="simple" xlink:href="../631/27631.xml">
proper subset</link>of the category directly above it; and any automaton in each category has an equivalent automaton in the category directly above it.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
