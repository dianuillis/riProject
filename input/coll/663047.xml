<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:28:47[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<theorem  confidence="0.9511911446218017" wordnetid="106752293">
<header>
<title>Cook–Levin theorem</title>
<id>663047</id>
<revision>
<id>237540268</id>
<timestamp>2008-09-10T17:59:08Z</timestamp>
<contributor>
<username>Deworde</username>
<id>2600059</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
<category>Articles containing proofs</category>
<category>Mathematical theorems</category>
<category>Wikipedia articles needing clarification</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, the <b>Cook–Levin theorem</b>, also known as <b>Cook's theorem</b>, states that the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 is <link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link>.  That is, any problem in <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
 can be <link xlink:type="simple" xlink:href="../067/848067.xml">
reduced</link> in polynomial time by a <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link> to a problem of determining whether a Boolean formula is satisfiable.<p>

An important consequence of the theorem is this: if there were a deterministic polynomial time algorithm for solving Boolean satisfiability, then <link xlink:type="simple" xlink:href="../420/91420.xml">
there would exist</link> a deterministic polynomial time algorithm for solving <it>all</it> problems in <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
.  Crucially, the same follows for any <link xlink:type="simple" xlink:href="../466/39466.xml">
NP complete</link> problem as these are also in NP.  </p>
<p>

The question of whether such an algorithm exists is called the <link xlink:type="simple" xlink:href="../115/6115.xml">
P=NP problem</link> and it is widely considered the most important unsolved problem in theoretical computer science.</p>

<sec>
<st>
Contributions</st>
<p>

The concept of NP-completeness was developed in the late 1960s and early 70s in parallel by researchers in the US and the <link xlink:type="simple" xlink:href="../779/26779.xml">
USSR</link>.
In the US in 1971, <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../432/39432.xml">
Stephen Cook</link></scientist>
</person>
 published his paper "The complexity of theorem proving procedures"<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> in conference proceedings of the newly-founded <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
ACM</link></organization>
 Symposium on Theory of Computing. <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../763/298763.xml">
Richard Karp</link></scientist>
</person>
's subsequent paper, "Reducibility among
combinatorial problems", generated renewed interest in Cook's paper by providing a list of 21 <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>

problems. Cook and Karp received a <symbol wordnetid="106806469" confidence="0.8">
<award wordnetid="106696483" confidence="0.8">
<signal wordnetid="106791372" confidence="0.8">
<link xlink:type="simple" xlink:href="../093/31093.xml">
Turing Award</link></signal>
</award>
</symbol>
 for this work.</p>

<p>

The theoretical interest in NP-completeness was also enhanced by the work of Theodore P. Baker, <person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../035/1797035.xml">
John Gill</link></person>
, and <link xlink:type="simple" xlink:href="../110/3160110.xml">
Robert Solovay</link> who showed that solving NP-problems in <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/22431.xml">
Oracle machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 models requires exponential time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

In the USSR, a result equivalent to Baker, Gill, and Solovay's was
published in 1969 by M. Dekhtiar.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Later <person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../708/402708.xml">
Levin</link></person>
's paper, "Universal search problems",<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> was published in 1973, although it was mentioned in talks and submitted for publication a few years earlier.</p>
<p>

Levin's approach was slightly different from Cook's and Karp's in that he considered <link xlink:type="simple" xlink:href="../816/1471816.xml">
search problem</link>s, which require finding solutions rather than simply determining existence. He provided 6 such NP-complete search problems, or <it>universal problems</it>, and
additionally found that each has an algorithm which solves it in optimal time.
&#91;&#93;</p>

</sec>
<sec>
<st>
Definitions</st>
<p>

A <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problem</link> is in <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../562/21562.xml">
NP</link></group>
</collection>
</class>
 <link xlink:type="simple" xlink:href="../922/14922.xml">
iff</link> it can be solved by a <link xlink:type="simple" xlink:href="../957/665957.xml">
non-deterministic algorithm</link> in <link xlink:type="simple" xlink:href="../576/44576.xml">
polynomial time</link>.</p>
<p>

An instance of the Boolean satisfiability problem is a <link xlink:type="simple" xlink:href="../968/3126968.xml">
Boolean expression</link> that combines <link xlink:type="simple" xlink:href="../077/3954077.xml">
Boolean variable</link>s using <link xlink:type="simple" xlink:href="../153/18153.xml">
Boolean operator</link>s.</p>
<p>

An expression is satisfiable <link xlink:type="simple" xlink:href="../922/14922.xml">
iff</link> there is some assignment of <link xlink:type="simple" xlink:href="../711/161711.xml">
truth value</link>s to the variables that makes the entire expression true.</p>

</sec>
<sec>
<st>
Proof</st>
<p>

<it>This proof is based on the one given by Garey and Johnson.</it><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></p>
<p>

There are two parts to proving that the Boolean satisfiability problem (SAT) is NP-complete. One is to show that SAT is an NP problem. The other is to show that every NP problem can be reduced to an instance of a SAT problem by a <link xlink:type="simple" xlink:href="../695/159695.xml">
polynomial-time many-one reduction</link>.</p>
<p>

SAT is in NP because any assignment of Boolean values to Boolean variables that is claimed to satisfy the given expression can be <it>verified</it> in polynomial time by a deterministic Turing machine. This means that SAT is in NP by an equivalence theorem found in many textbooks, for example Sipser's <it>Introduction to the Theory of Computation</it>, section 7.3.</p>
<p>

Now suppose that a given problem in NP can be solved by the nondeterministic Turing machine <math>M = (Q, \Sigma, s, F, \delta)</math>, where <math>Q</math> is the set of states, <math>\Sigma</math> is the alphabet of tape symbols, <math>s\in Q</math> is the initial state, <math>F\subseteq Q</math> is the set of accepting states, and <math>\delta : Q\times\Sigma\rightarrow Q\times\Sigma\times\{-1,+1\}</math> is the set of transitions, and that <math>M</math> accepts or rejects an instance of the problem in time <math>p(n)</math> where <math>n</math> is the size of the instance and <math>p</math> is a polynomial function.</p>
<p>

For each input <math>I</math> we specify a Boolean expression which is satisfiable <link xlink:type="simple" xlink:href="../922/14922.xml">
if and only if</link> the machine <math>M</math> accepts <math>I</math>.</p>
<p>

The Boolean expression uses the variables set out in the following table. Here, <math>q\in Q</math>, <math>-p(n)\leq i\leq p(n)</math>, <math>j\in\Sigma</math>, and <math>0\leq k\leq p(n)</math>.</p>
<p>

<table class="wikitable">
<header>
Variables</header>
<header>
Intended interpretation</header>
<header>
How many?</header>
<row>
<col>
<it>Tijk''</it></col>
<col>
True if tape cell <it>i</it> contains symbol <it>j</it> at step <it>k</it> of the computation.</col>
<col>
O(<it>p</it>(<it>n</it>)²)</col>
</row>
<row>
<col>
<it>Hik''</it></col>
<col>
True if the <it>M</it>&#39;s read/write head is at tape cell <it>i</it> at step <it>k</it> of the computation.</col>
<col>
O(<it>p</it>(<it>n</it>)²)</col>
</row>
<row>
<col>
<it>Qqk''</it></col>
<col>
True if <it>M</it> is in state <it>q</it> at step <it>k</it> of the computation.</col>
<col>
O(<it>p</it>(<it>n</it>))</col>
</row>
</table>
</p>
<p>

Define the Boolean expression <math>B</math> to be the <link xlink:type="simple" xlink:href="../152/18152.xml">
conjunction</link> of the clauses in the following table, for all <math>-p(n) \leq i \leq p(n)</math> and <math>0 \leq k \leq p(n)</math>:</p>
<p>

<table class="wikitable">
<header>
Clauses</header>
<header>
Conditions</header>
<header>
Interpretation</header>
<header>
How many?</header>
<row>
<col>
<it>Tij0''</it></col>
<col>
Tape cell <it>i</it> of the input <it>I</it> contains symbol <it>j</it>.</col>
<col>
Initial contents of the tape.</col>
<col>
O(<it>p</it>(<it>n</it>))</col>
</row>
<row>
<col>
<it>Qs0''</it></col>
<col>
&nbsp;</col>
<col>
Initial  state of <it>M''</it></col>
<col>
O(1)</col>
</row>
<row>
<col>
<it>H00''</it></col>
<col>
&nbsp;</col>
<col>
Initial position of read/write head.</col>
<col>
O(1)</col>
</row>
<row>
<col>
<it>Tijk</it> → ¬ <it>Tij&amp;prime;k''</it></col>
<col>
<it>j</it> ≠ <it>j&amp;prime;''</it></col>
<col>
One symbol per tape cell.</col>
<col>
O(<it>p</it>(<it>n</it>)²)</col>
</row>
<row>
<col>
<it>Tijk</it> = <it>Tij</it>(<it>k</it>+1) ∨ <it>Hik''</it></col>
<col>
&nbsp;</col>
<col>
Tape remains unchanged unless written.</col>
<col>
O(<it>p</it>(<it>n</it>)²)</col>
</row>
<row>
<col>
<it>Qqk</it> → ¬ <it>Qq&amp;prime;k''</it></col>
<col>
<it>q</it> ≠ <it>q&amp;prime;''</it></col>
<col>
Only one state at a time.</col>
<col>
O(<it>p</it>(<it>n</it>))</col>
</row>
<row>
<col>
<it>Hik</it> → ¬ <it>Hi&amp;prime;k''</it></col>
<col>
<it>i</it> ≠ <it>i&amp;prime;''</it></col>
<col>
Only one head position at a time.</col>
<col>
O(<it>p</it>(<it>n</it>)²)</col>
</row>
<row>
<col>
The <link>
disjunction</link>of the clauses(<it>Hik</it> ∧ <it>Qqk</it> ∧ <it>Tiσk</it>) → (<it>H</it>(<it>i</it>+<it>d</it>)(<it>k</it>+1) ∧ <it>Qq&amp;prime;</it>(<it>k</it>+1) ∧ <it>Tiσ&amp;prime;</it>(<it>k</it>+1))</col>
<col>
(<it>q</it>, <it>σ</it>, <it>q&amp;prime;</it>, <it>σ&amp;prime;</it>, <it>d</it>) ∈ <it>δ''</it></col>
<col>
Possible transitions at computation step <it>k</it> when head is at position <it>i</it>.</col>
<col>
O(<it>p</it>(<it>n</it>)²)</col>
</row>
<row>
<col>
The disjunction of the clauses<it>Qf</it>(<it>p</it>(<it>n</it>))</col>
<col>
<it>f</it> ∈ <it>F</it>.</col>
<col>
Must finish in an accepting state.</col>
<col>
O(1)</col>
</row>
</table>
</p>
<p>

If there is an accepting computation for <math>M</math> on input <math>I</math>, then <math>B</math> is satisfiable by assigning <math>T_{ijk}</math>, <math>H_{ik}</math> and <math>Q_{ik}</math> their intended interpretations. On the other hand, if <math>B</math> is satisfiable, then there is an accepting computation for <math>M</math> on input <math>I</math> that follows the steps indicated by the assignments to the variables.</p>
<p>

There are <math>O(p(n)^2)</math> Boolean variables, each encodeable in space <math>O(\log {p(n)})</math>. The number of clauses is <math>O(p(n)^2)</math> so the size of <math>B</math> is <math>O(\log {(p(n))} p(n)^2)</math>. Thus the transformation is certainly a polynomial-time many-one reduction, as required.</p>

</sec>
<sec>
<st>
Consequences</st>
<p>

The proof shows that any problem in NP can be reduced in polynomial time (in fact, logarithmic space suffices) to an instance of the Boolean satisfiability problem. This means that if the Boolean satisfiability problem could be solved in polynomial time by a <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link>, then all problems in NP could be solved in polynomial time, and so the <link xlink:type="simple" xlink:href="../426/502426.xml">
complexity class</link> NP would be equal to the complexity class P.</p>
<p>

The significance of NP-completeness was made clear by the publication in 1972 of <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../763/298763.xml">
Richard Karp</link></scientist>
</person>
's landmark paper, "Reducibility among combinatorial problems", in which he showed that <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/2012564.xml">
21 diverse combinatorial and graph theoretical problems</link></difficulty>
</problem>
</state>
</condition>
, each infamous for its intractability, are NP-complete.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>
<p>

Karp showed each of his problems to be NP-complete by reducing another problem (already shown to be NP-complete) to that problem.  For example, he showed the problem 3SAT (the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
 for expressions in <link xlink:type="simple" xlink:href="../342/73342.xml">
conjunctive normal form</link> with exactly three variables or negations of variables per clause) to be NP-complete by showing how to reduce (in polynomial time) any instance of SAT to an equivalent instance of 3SAT.  (First you use <process wordnetid="105701363" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<rule wordnetid="105846054" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../669/64669.xml">
De Morgan's laws</link></higher_cognitive_process>
</theory>
</explanation>
</rule>
</thinking>
</concept>
</idea>
</process>
 to get the formula into conjunctive normal form, then you introduce new variables to split clauses with more than 3 atoms, since (A ∨ B ∨ C ∨ D) ≡ (A ∨ B ∨ Z) ∧ (¬Z ∨ C ∨ D), and you pad out clauses with fewer than 3 atoms with new variables that are guaranteed to be false, since A ≡ (A ∨ Z ∨ Z) ∧ (¬Z ∨ ¬Z ∨ ¬Z).)</p>
<p>

Garey and Johnson presented more than 300 NP-complete problems in their book <it>Computers and Intractability: A Guide to the Theory of NP-Completeness</it>,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> and new problems are still being discovered to be within that complexity class.</p>
<p>

As of 2008, although many practical instances of SAT can be <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link>
solved by heuristic methods</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
, the question of whether there is a deterministic polynomial-time algorithm for SAT (and consequently all other NP-complete problems) is still a famous unsolved problem, despite decades of intense effort by complexity theorists, mathematical logicians, and others.  For more details, see the article <link xlink:type="simple" xlink:href="../115/6115.xml">
P=NP problem</link>.</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
 <cite id="Reference-Cook-1971" style="font-style:normal" class="book"><person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../432/39432.xml">
Cook, Stephen</link></scientist>
</person>
&#32;(1971).&#32;"<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?coll=GUIDE&amp;dl=GUIDE&amp;id=805047">
The complexity of theorem proving procedures</weblink>", Proceedings of the Third Annual ACM Symposium on Theory of Computing,&#32;151–158.</cite>&nbsp;</entry>
<entry id="2">
 <cite style="font-style:normal">T. P. Baker; J. Gill, R. Solovay&#32;(1975).&#32;"Relativizations of the P = NP question". <it>SIAM Journal on Computing</it>&#32;<b>4</b>&#32;(4): 431–442. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137%2F0204037">
10.1137/0204037</weblink>.</cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal">Dekhtiar, M.&#32;(1969).&#32;"On the impossibility of eliminating exhaustive search in computing a function relative to its graph". <it><link xlink:type="simple" xlink:href="../850/15050850.xml">
Proceedings of the USSR Academy of Sciences</link></it>&#32;<b>14</b>: 1146–1148.</cite>&nbsp; (Russian)</entry>
<entry id="4">
 <cite style="font-style:normal"><person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../708/402708.xml">
Levin, Leonid</link></person>
&#32;(1973).&#32;"Universal search problems (<language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../431/25431.xml">
Russian</link></language>
: Универсальные задачи перебора, Universal'nye perebornye zadachi)". <it>Problems of Information Transmission (<language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../431/25431.xml">
Russian</link></language>
: Проблемы передачи информации, Problemy Peredachi Informatsii)</it>&#32;<b>9</b>&#32;(3): 265–266.</cite>&nbsp; (Russian), translated into English by  <cite style="font-style:normal">Trakhtenbrot, B. A.&#32;(1984).&#32;"A survey of Russian approaches to perebor (brute-force searches) algorithms". <it>Annals of the History of Computing</it>&#32;<b>6</b>&#32;(4): 384–400. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1109%2FMAHC.1984.10036">
10.1109/MAHC.1984.10036</weblink>.</cite>&nbsp;</entry>
<entry id="5">
 <cite id="Reference-Garey-1979" style="font-style:normal" class="book">Garey, Michael R.;&#32;David S. Johnson&#32;(1979). Computers and Intractability: A Guide to the Theory of NP-Completeness.&#32;W. H. Freeman. ISBN 0716710455.</cite>&nbsp;</entry>
<entry id="6">
 <cite id="Reference-Karp-1972" style="font-style:normal" class="book"><link xlink:type="simple" xlink:href="../763/298763.xml">
Karp, Richard M.</link>&#32;(1972).&#32;"Reducibility among combinatorial problems",&#32;in Raymond E. Miller and James W. Thatcher (editors): Complexity of Computer Computations.&#32;New York:&#32;Plenum,&#32;85–103. ISBN 0306307073.</cite>&nbsp;</entry>
</reflist>
</p>


</sec>
</bdy>
</theorem>
</article>
