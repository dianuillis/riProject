<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:30:25[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Deterministic algorithm</title>
<id>665951</id>
<revision>
<id>243141557</id>
<timestamp>2008-10-05T09:45:12Z</timestamp>
<contributor>
<username>DragonBot</username>
<id>5466012</id>
</contributor>
</revision>
<categories>
<category>Analysis of algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>deterministic algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> which, in informal terms, behaves predictably. Given a particular input, it will always produce the same output, and the underlying machine will always pass through the same sequence of states. Deterministic algorithms are by far the most studied and familiar kind of algorithm, as well as one of the most practical, since they can be run on real machines efficiently.<p>

One simple model for deterministic algorithms is the <link xlink:type="simple" xlink:href="../427/185427.xml">
mathematical function</link>; just as a function always produces the same output given a certain input, so do deterministic algorithms. The difference is that algorithms describe precisely how the output is obtained from the input, whereas abstract functions may be defined implicitly.</p>

<sec>
<st>
 Formal definition </st>

<p>

Formally, deterministic algorithms can be defined in terms of a <link xlink:type="simple" xlink:href="../931/10931.xml">
state machine</link>: a <it>state</it> describes what a machine is doing at a particular instant in time. State machines pass in a discrete manner from one state to another. Just after we enter the input, the machine is in its <it>initial state</it> or <it>start state</it>. If the machine is deterministic, this means that from this point onwards, its current state determines what its next state will be; its course through the set of states is predetermined. Note that a machine can be deterministic and still never stop or finish, as long as we can predict with certainty what states it will pass through.</p>
<p>

Examples of particular <link xlink:type="simple" xlink:href="../492/60492.xml">
abstract machine</link>s which are deterministic include the <link xlink:type="simple" xlink:href="../403/30403.xml">
deterministic Turing machine</link> and <link xlink:type="simple" xlink:href="../404/653404.xml">
deterministic finite automaton</link>.</p>

</sec>
<sec>
<st>
 What makes algorithms non-deterministic? </st>

<p>

A variety of factors can cause an algorithm to behave in a way which is not deterministic, or non-deterministic:
<list>
<entry level="1" type="bullet">

 If it uses external state other than the input, such as user input, a global variable, a hardware timer value, a random value, or stored disk data.</entry>
<entry level="1" type="bullet">

 If it operates in a way that is timing-sensitive, for example if it has multiple processors writing to the same data at the same time. In this case, the precise order in which each processor writes its data will affect the result.</entry>
<entry level="1" type="bullet">

 If a hardware error causes its state to change in an unexpected way.</entry>
</list>
</p>
<p>

Although real programs are rarely purely deterministic, it is easier for humans as well as other programs to reason about programs that are. For this reason, most <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s and especially <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming</link> languages make an effort to prevent the above events from happening except under controlled conditions. Because of the way such restrictions enforce determinism, deterministic algorithms are sometimes called <link xlink:type="simple" xlink:href="../375/468375.xml">
purely functional</link>.</p>

</sec>
<sec>
<st>
 Problems with deterministic algorithms </st>

<p>

Unfortunately, for some problems deterministic algorithms are also hard to find. For example, there are simple and efficient <link xlink:type="simple" xlink:href="../383/495383.xml">
probabilistic algorithm</link>s that determine whether a given number is prime but have a very small chance of being wrong. These have been known since the 1970s (see for example <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../755/157755.xml">
Fermat primality test</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
); the known deterministic algorithms remain considerably slower in practice.</p>
<p>

As another example, <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 problems, which include many of the most important practical problems, can be solved quickly using a machine called a <link>
nondeterministic Turing machine</link>, but efficient practical algorithms have never been found for any of them. At best, we can currently only find approximate solutions or solutions in special cases.</p>
<p>

Another major problem with deterministic algorithms is that sometimes, we don't <it>want</it> the results to be predictable. For example, if you are playing an on-line game of <link xlink:type="simple" xlink:href="../981/3981.xml">
blackjack</link> that shuffles its deck using a <link xlink:type="simple" xlink:href="../524/45524.xml">
pseudorandom number generator</link>, a clever gambler might guess precisely the numbers the generator will choose and so determine the entire contents of the deck ahead of time, allowing him to cheat; for example, the Software Security Group at Reliable Software Technologies was able to do this for an implementation of Texas Hold 'em Poker that is distributed by ASF Software, Inc, allowing them to consistently predict the outcome of hands ahead of time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> Similar problems arise in <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptography</link>, where private keys are often generated using such a generator. This sort of problem is generally avoided using a <link xlink:type="simple" xlink:href="../249/182249.xml">
cryptographically secure pseudo-random number generator</link>.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
Gary McGraw and John Viega. Make your software behave: Playing the numbers: How to cheat in online gambling. http://www.ibm.com/developerworks/library/s-playing/#h4</entry>
</reflist>
</p>


</sec>
</bdy>
</article>
