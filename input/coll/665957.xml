<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:30:26[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Nondeterministic algorithm</title>
<id>665957</id>
<revision>
<id>242685870</id>
<timestamp>2008-10-03T06:18:08Z</timestamp>
<contributor>
<username>Radagast83</username>
<id>668752</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
<category>Discrete mathematics</category>
<category>Theory of computation</category>
</categories>
</header>
<bdy>

"Nondeterministic" redirects here. For other uses, see <link xlink:type="simple" xlink:href="../922/47922.xml">
Deterministic</link>.<p>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b><link xlink:type="simple" xlink:href="../198/452198.xml">
nondeterministic</link> algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> with one or more choice points where multiple different <link xlink:type="simple" xlink:href="../189/505189.xml">
continuations</link> are possible, without any specification of which one will be taken.</p>

<sec>
<st>
 Use </st>

<p>

In the standard theory of computation, the term <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> stands for a <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic algorithm</link>.  However, it employs models of computation, such as the <link xlink:type="simple" xlink:href="../406/653406.xml">
nondeterministic finite state machine</link>, that use nondeterminism.</p>
<p>

In algorithm design, nondeterministic algorithms are often used as specifications.  This is natural when the problem solved by the algorithm inherently allows multiple outcomes, or when there is a single outcome but there are multiple ways to get there and we simply don't care which of them is chosen.  What these cases have in common is that the nondeterministic algorithm always arrives at a valid solution, no matter which choices are made at the choice points encountered underway.</p>
<p>

Another use of nondeterministic algorithms is made in <link xlink:type="simple" xlink:href="../132/6132.xml">
complexity theory</link>.  There, it is customary to define nondeterministic algorithms that do <it>not</it> always arrive at a correct solution, but are guaranteed to arrive at a correct solution if the right choices are made underway.  The choices are effectively <link xlink:type="simple" xlink:href="../574/846574.xml">
guess</link>es in a <link xlink:type="simple" xlink:href="../149/19386149.xml">
search</link> process.  It turns out that a large amount of real-life problems can be naturally stated in this way, and <link xlink:type="simple" xlink:href="../115/6115.xml">
the most famous unresolved question in computing theory</link> is about such problems.</p>

</sec>
<sec>
<st>
 Turning nondeterministic algorithms into deterministic ones </st>

<p>

One way to simulate a nondeterministic algorithm <it>N</it> using a deterministic algorithm <it>D</it> is to treat sets of states of <it>N</it> as states of <it>D</it>.  This means that <it>D</it> simultaneously traces all the possible execution paths of <it>N</it> (see <link xlink:type="simple" xlink:href="../167/1163167.xml">
Powerset construction</link> for this technique in use for <link xlink:type="simple" xlink:href="../931/10931.xml">
finite automata</link>).</p>
<p>

Another is <link xlink:type="simple" xlink:href="../383/495383.xml">
randomization</link>, which consists of letting all choices be determined by a <link xlink:type="simple" xlink:href="../939/2736939.xml">
random number generator</link>.  The result is called a <link xlink:type="simple" xlink:href="../934/22934.xml">
probabilistic</link> deterministic algorithm.</p>


</sec>
<sec>
<st>
 Examples </st>



<ss1>
<st>
 Example 1: Shopping list </st>

<p>

A shopping list can be viewed as a very simple nondeterministic algorithm.  Every item on the list is a directive to find the indicated product, but the order in which to find them is not indicated.</p>


</ss1>
<ss1>
<st>
 Example 2: Merge sort </st>

<p>

Suppose we have a finite collection of things (say, 300 student exams) that we need to sort (say, by student number).</p>
<p>

One algorithm to do this (called <link xlink:type="simple" xlink:href="../039/20039.xml">
merge sort</link>):
<list>
<entry level="1" type="bullet">

 split the collection in two approximately equal parts</entry>
<entry level="1" type="bullet">

 sort the two halves <link xlink:type="simple" xlink:href="../407/25407.xml">
with merge sort</link></entry>
<entry level="1" type="bullet">

 merge the results</entry>
</list>
</p>
<p>

Items can only be uniquely sorted if the sorting criterion chosen always defines a <link xlink:type="simple" xlink:href="../330/30330.xml">
total order</link>; e.g. student numbers are probably unique, but if we sort exams by <link xlink:type="simple" xlink:href="../814/10814.xml">
family name</link> and two students happen to have the same name, the order in which their exams get sorted is left undefined.  Merge sort is guaranteed to arrive at any one of the possible valid results.</p>

</ss1>
<ss1>
<st>
 Example 3: Spanning tree </st>

<p>

The input is an undirected <link xlink:type="simple" xlink:href="../492/1614492.xml">
connected</link> <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link>.  An undirected graph is a set of nodes that may or may not be pairwise connected with edges.  A <link>
subgraph</link> of a graph consists of a subset of its nodes and/or edges.  A graph connects two nodes if we can walk over its edges from one to the other.  A <link xlink:type="simple" xlink:href="../889/638889.xml">
path</link> in a graph is a minimal subgraph connecting two of its nodes.
A graph is <link xlink:type="simple" xlink:href="../492/1614492.xml">
connected</link> if it connects all of its nodes.</p>
<p>

The algorithm: while an edge can be removed such that the graph is still connected, remove such an edge.</p>
<p>

The output: a <link xlink:type="simple" xlink:href="../770/455770.xml">
spanning tree</link>, that is, a minimal <link xlink:type="simple" xlink:href="../875/18955875.xml">
tree</link> connecting all the nodes.</p>
<p>

Every graph (that is connected and not a tree) has multiple spanning trees, so we once again have an example where the problem itself allows multiple possible outcomes, and the algorithm chosen can arrive at any one of them, but will never arrive at something else.</p>
<p>

This is, again, an algorithm that always arrives at a correct solution to the problem.</p>


</ss1>
<ss1>
<st>
 Example 4: Primality testing </st>

<p>

The problem: given a natural number, determine whether it is <link xlink:type="simple" xlink:href="../666/23666.xml">
prime</link>.</p>
<p>

A nondeterministic algorithm for this problem is the following:
<list>
<entry level="1" type="number">

 Pick any integer <it>k</it> such that 2 &amp;le; <it>k</it> &amp;le; sqrt(<it>n</it>).</entry>
<entry level="1" type="number">

 If <it>k</it> is a divisor of <it>n</it>, stop with answer <b>no</b>; otherwise stop with answer <b>don't know</b>.</entry>
</list>

It is seen that the algorithm doesn't always give a useful answer, but never gives a wrong answer.  Also, it is possible, although statistically improbable, that the algorithm would give a correct useful <link xlink:type="simple" xlink:href="../642/642.xml">
answer</link> faster than a deterministic primality algorithm.</p>
<p>

This algorithm is as nondeterministic as the previous ones, but its relationship to the stated problem is different: it does <it>not</it> always arrive at a valid solution, but only with certain combinations of choices.  This is an example of the <it>search</it> type of nondeterministic algorithm.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../935/21935.xml">
Non-deterministic Turing machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../406/653406.xml">
Nondeterministic finite state machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
</list>
</p>


</sec>
</bdy>
</article>
