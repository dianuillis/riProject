<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:29:12[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Cycle detection</title>
<id>670279</id>
<revision>
<id>240079315</id>
<timestamp>2008-09-21T20:55:18Z</timestamp>
<contributor>
<username>Svick</username>
<id>4576738</id>
</contributor>
</revision>
<categories>
<category>Articles with example Python code</category>
<category>Combinatorial algorithms</category>
<category>Fixed points</category>
</categories>
</header>
<bdy>

<b>Cycle detection</b> is the <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>ic problem of finding a cycle of the following type:<p>

In <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematics</link>, for any <link xlink:type="simple" xlink:href="../427/185427.xml">
function</link> &amp;fnof; that maps a <link xlink:type="simple" xlink:href="../742/11742.xml">
finite set</link> <it>S</it> to itself, and any initial value <it>x</it>0 in <it>S</it>, the <link xlink:type="simple" xlink:href="../838/27838.xml">
sequence</link> of <link xlink:type="simple" xlink:href="../702/1448702.xml">
iterated function</link> values
<indent level="1">

<math>\displaystyle x_0,\ x_1=f(x_0),\ x_2=f(x_1),\ \dots,\ x_i=f(x_{i-1}),\ \dots</math>
</indent>
must eventually use the same value twice: there must be some <it>i</it> ≠ <it>j</it> such that <it>xi</it> = <it>xj</it>. Once this happens, the sequence must continue by repeating the <link xlink:type="simple" xlink:href="../394/2539394.xml">
cycle</link> of values from <it>xi</it> to <it>xj</it>&amp;minus;1.</p>

<sec>
<st>
Example</st>
<p>

<image width="240px" src="Functional_graph.svg" type="thumb">
<caption>

A function from and to the set {0,1,2,3,4,5,6,7,8} and the corresponding functional graph.
</caption>
</image>

The figure shows a function &amp;fnof; that maps the set <it>S</it> = {0,1,2,3,4,5,6,7,8} to itself. If one starts from <it>x</it>0 = 2 and repeatedly applies &amp;fnof;, one sees the sequence of values
<indent level="1">

2, 0, 6, 3, 1, 6, 3, 1, 6, 3, 1, ...
</indent>
The cycle to be detected is the repeating subsequence of values 6, 3, 1 in this sequence.</p>

</sec>
<sec>
<st>
Definitions</st>

<p>

Let <it>S</it> be any finite set, &amp;fnof; be any function from <it>S</it> to itself, and <it>x</it>0 be any element of <it>S</it>. For any <it>i</it> &amp;gt; 0, let <it>xi</it> = &amp;fnof;(<it>xi</it>&amp;minus;1). Let &amp;mu; be the smallest index such that the value <it>x</it>&amp;mu; reappears infinitely often within the sequence of values <it>xi</it>, and let &amp;lambda; (the loop length) be the smallest positive integer such that <it>x</it>&amp;mu; = <it>x</it>&amp;lambda;+&amp;mu;. The cycle detection problem is the task of finding &amp;lambda; and &amp;mu;.</p>
<p>

One can view the same problem <link xlink:type="simple" xlink:href="../401/12401.xml">
graph-theoretically</link>, by constructing a <link xlink:type="simple" xlink:href="../542/13511542.xml">
functional graph</link> (that is, a <link xlink:type="simple" xlink:href="../986/19721986.xml">
directed graph</link> in which each vertex has a single outgoing edge) the vertices of which are the elements of <it>S</it> and the edges of which map an element to the corresponding function value, as shown in the figure. The set of vertices <link xlink:type="simple" xlink:href="../097/2833097.xml">
reachable</link> from any starting vertex <it>x</it>0 form a <link>
subgraph</link> with a shape resembling the <creation wordnetid="103129123" confidence="0.8">
<text wordnetid="106387980" confidence="0.8">
<document wordnetid="103217458" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<letter wordnetid="106624161" confidence="0.8">
<representation wordnetid="104076846" confidence="0.8">
<link xlink:type="simple" xlink:href="../440/421440.xml">
Greek letter rho</link></representation>
</letter>
</artifact>
</document>
</text>
</creation>
 (&amp;rho;): a path of length &amp;mu; from <it>x</it>0 to a <graph wordnetid="107000195" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../962/878962.xml">
cycle</link></graph>
 of &amp;lambda; vertices.</p>

</sec>
<sec>
<st>
Computer representation</st>
<p>

Generally, &amp;fnof; will not be specified as a table of values, as we have given it in the figure above. Rather, we may be given access either to the sequence of values <it>xi</it>, or to a subroutine for calculating &amp;fnof;. The task is to find &amp;lambda; and &amp;mu; while examining as few values from the sequence or performing as few subroutine calls as possible. Typically, also, the <link>
space complexity</link> of an algorithm for the cycle detection problem is of importance: we wish to solve the problem while using an amount of memory significantly smaller than it would take to store the entire sequence.</p>
<p>

In some applications, and in particular in <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for <link xlink:type="simple" xlink:href="../491/15491.xml">
integer factorization</link>, the algorithm has much more limited access to <it>S</it> and to &amp;fnof;. In Pollard's rho algorithm, for instance, <it>S</it> is the set of integers modulo an unknown prime factor of the number to be factorized, so even the size of <it>S</it> is unknown to the algorithm. We may view a cycle detection algorithm for this application as having the following capabilities: it initially has in its memory an object representing a pointer to the starting value <it>x</it>0. At any step, it may perform one of three actions: it may copy any pointer it has to another object in memory, it may apply &amp;fnof; and replace any of its pointers by a pointer to the next object in the sequence, or it may apply a subroutine for determining whether two of its pointers represent equal values in the sequence. The equality test action may involve some nontrivial computation: in Pollard's rho algorithm, it is implemented by testing whether the difference between two stored values has a nontrivial <link xlink:type="simple" xlink:href="../354/12354.xml">
gcd</link> with the number to be factored. In this context, we will call an algorithm that only uses pointer copying, advancement within the sequence, and equality tests a <it>pointer algorithm</it>.</p>

</sec>
<sec>
<st>
Algorithms</st>

<p>

If the input is given as a subroutine for calculating &amp;fnof;, the cycle detection problem may be trivially solved using only &amp;lambda;+&amp;mu; function applications, simply by computing the sequence of values <it>xi</it> and using a <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link> such as a <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link> to store these values and test whether each subsequent value has already been stored. However, the space complexity of this algorithm is &amp;lambda;+&amp;mu;, unnecessarily large. Additionally, to implement this method as a pointer algorithm would require applying the equality test to each pair of values, resulting in quadratic time overall. Thus, research in this area has concentrated on two goals: using less space than this naive algorithm, and finding pointer algorithms that use fewer equality tests.</p>

<ss1>
<st>
Tortoise and hare</st>
<p>

<image width="300px" src="Tortoise_and_hare_algorithm.svg" type="thumb">
<caption>

Floyd's "tortoise and hare" cycle detection algorithm, applied to the sequence 2, 0, 6, 3, 1, 6, 3, 1, ...
</caption>
</image>

<b>Floyd's cycle-finding algorithm</b>, also called the "<link xlink:type="simple" xlink:href="../936/628936.xml">
tortoise and the hare</link>" algorithm, is a pointer algorithm that uses only two pointers, which move through the sequence at different speeds. The algorithm is named for <link xlink:type="simple" xlink:href="../900/301900.xml">
Robert W. Floyd</link>, who invented it  in the late 1960s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

The key insight in the algorithm is that, whenever <it>i</it> &amp;gt; 0 is a multiple of &amp;lambda; that is greater than &amp;mu;, <it>xi</it> = <it>x</it>2<it>i</it> (and conversely).  
The algorithm will find the smallest such "i".
Thus, we need only check for repeated values of this special form to find a period &amp;nu; of a repetition that is a multiple of &amp;lambda;.
Once &amp;nu; is found, we may retrace the sequence from its start to find the first repetition of length &amp;nu;; since &amp;lambda; divides &amp;nu;, <it>x</it>&amp;nu; + &amp;mu; = <it>x</it>&amp;mu;, the start of the first repetition.  Finally, from <it>x</it>&amp;mu; it is trivial to find the length of the shortest repeating cycle, <it>x</it>&amp;mu; + &amp;lambda; = <it>x</it>&amp;mu;.</p>
<p>

The algorithm thus maintains two pointers into the given sequence, one (the tortoise) at <it>xi</it>, and the other (the hare) at <it>x</it>2<it>i</it>. At each step of the algorithm, it increases <it>i</it> by one, moving the tortoise one step forward and the hare two steps forward in the sequence, and then compares the sequence values at these two pointers. The smallest value of <it>i</it> &amp;gt; 0 for which the tortoise and hare point to equal values is the desired value &amp;nu;.</p>
<p>

The following <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 code shows how this idea may be implemented as an algorithm.</p>



<p>

def floyd(f, x0):
<list>
<entry level="1" type="number">

 The main phase of the algorithm, finding a repetition x_nu = x_2nu</entry>
<entry level="1" type="number">

 The hare moves twice as quickly as the tortoise</entry>
</list>

tortoise, hare = f(x0), f(f(x0))
while tortoise != hare:
tortoise = f(tortoise)
hare = f(f(hare))</p>
<p>

<list>
<entry level="1" type="number">

 Find the position of the first repetition of length nu</entry>
<entry level="1" type="number">

 The hare and tortoise move at the same speeds</entry>
</list>

mu = 0
tortoise, hare = x0, tortoise
while tortoise != hare:
tortoise = f(tortoise)
hare = f(hare)
mu += 1</p>
<p>

<list>
<entry level="1" type="number">

 Find the length of the shortest cycle starting from x_mu</entry>
<entry level="1" type="number">

 The hare moves while the tortoise stays still</entry>
</list>

lam = 1
hare = f(tortoise)
while tortoise != hare:
hare = f(hare)
lam += 1</p>
<p>

return lam, mu</p>

<p>

Note that this code only accesses the sequence by storing and copying pointers, function evaluations, and equality tests; therefore, it qualifies as a pointer algorithm. The algorithm uses O(&amp;lambda;+&amp;mu;) operations of these types, and O(1) storage space.</p>

</ss1>
<ss1>
<st>
Brent's algorithm</st>

<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../484/872484.xml">
Richard P. Brent</link></associate>
</mathematician>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 described an alternative cycle detection algorithm that, like the tortoise and hare algorithm, requires only two pointers into the sequence.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> However, it is based on a different principle: searching for the smallest <link xlink:type="simple" xlink:href="../948/376948.xml">
power of two</link> 2<it>i</it> that is larger than both &amp;lambda; and &amp;mu;. For <it>i</it> = 0, 1, 2, etc., the algorithm compares <it>x</it>2<it>i</it>&amp;minus;1 with each subsequent sequence value up to the next power of two, stopping when it finds a match. It has two advantages compared to the tortoise and hare algorithm: it finds the correct length &amp;lambda; of the cycle directly, rather than needing to search for it in a subsequent stage, and its steps involve only one evaluation of &amp;fnof; rather than three.</p>
<p>

The following Python code shows how this technique works in more detail.</p>
<p>

def brent(f, x0):
<list>
<entry level="1" type="number">

 main phase: search successive powers of two</entry>
</list>

power = lam = 1
tortoise, hare = x0, f(x0)
while tortoise != hare:
if power == lam:   # time to start a new power of two?
tortoise = hare
power *= 2
lam = 0
hare = f(hare)
lam += 1</p>
<p>

<list>
<entry level="1" type="number">

 Find the position of the first repetition of length lambda</entry>
</list>

mu = 0
tortoise = hare = x0
for i in range(lam):
hare = f(hare)
while tortoise != hare:
tortoise = f(tortoise)
hare = f(hare)
mu += 1</p>
<p>

return lam, mu</p>

<p>

Like the tortoise and hare algorithm, this is a pointer algorithm that uses O(&amp;lambda;+&amp;mu;) tests and function evaluations and O(1) storage space. 
It is not difficult to show that the number of function evaluations can never be higher than for Floyd's algorithm.
Brent claims that, on average, his cycle finding algorithm runs around 36% more quickly than Floyd's and that it speeds up the Pollard rho algorithm by around 24%. He also performs an <link xlink:type="simple" xlink:href="../956/37956.xml">
average case analysis</link> for a randomized version of the algorithm in which the sequence of indices traced by the slower of the two pointers is not the powers of two themselves, but rather a randomized multiple of the powers of two. Although his main intended application was in integer factorization algorithms, Brent also discusses applications in testing pseudorandom number generators.</p>

</ss1>
<ss1>
<st>
Time-space tradeoffs</st>
<p>

A number of authors have studied techniques for cycle detection that use more memory than Floyd's and Brent's methods, but detect cycles more quickly. In general these methods store several previously-computed sequence values, and test whether each new value equals one of the previously-computed values. In order to do so quickly, they typically use a hash table or similar data structure for storing the previously-computed values, and therefore are not pointer algorithms: in particular, they usually cannot be applied to Pollard's rho algorithm. Where these methods differ is in how they determine which values to store. Following Nivasch,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> we survey these techniques briefly.</p>
<p>

<list>
<entry level="1" type="bullet">

Brent<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> already describes variations of his technique in which the indices of saved sequence values are powers of a number <it>R</it> other than two. By choosing <it>R</it> to be a number close to one, and storing the sequence values at indices that are near a sequence of consecutive powers of <it>R</it>, a cycle detection algorithm can use a number of function evaluations that is within an arbitrarily small factor of the optimum &amp;lambda;+&amp;mu;.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Sedgewick, Szymanski, and Yao<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>  provide a method that uses <it>M</it> memory cells and requires in the worst case only <math>(\lambda+\mu)(1+cM^{-1/2})</math> function evaluations, for some constant <it>c</it>, which they show to be optimal. The technique involves maintaining a numerical parameter <it>d</it>, storing in a table only those positions in the sequence that are multiples of <it>d</it>, and clearing the table and doubling <it>d</it> whenever too many values have been stored.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Several authors have described <it>distinguished point</it> methods that store function values in a table based on a criterion involving the values, rather than (as in the method of Sedgewick et al.) based on their positions. For instance, values equal to zero modulo some value <it>d</it> might be stored.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> More simply, Nivasch<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> credits D. P. Woodruff with the suggestion of storing a random sample of previously seen values, making an appropriate random choice at each step so that the sample remains random.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

Nivasch<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> describes an algorithm that does not use a fixed amount of memory, but for which the expected amount of memory used (under the assumption that the input function is random) is logarithmic in the sequence length. An item is stored in the memory table, with this technique, when no later item has a smaller value. As Nivasch shows, the items with this technique can be maintained using a <link xlink:type="simple" xlink:href="../993/273993.xml">
stack data structure</link>, and each successive sequence value need be compared only to the top of the stack. The algorithm terminates when the repeated sequence element with smallest value is found. Running the same algorithm with multiple stacks, using random permutations of the values to reorder the values within each stack, allows a time-space tradeoff similar to the previous algorithms. However, even the version of this algorithm with a single stack is not a pointer algorithm, due to the comparisons needed to determine which of two values is smaller.</entry>
</list>
</p>
<p>

Any cycle detection algorithm that stores at most <it>M</it> values from the input sequence must perform at least <math>\scriptstyle (\lambda+\mu)(1+\frac{1}{M-1})</math> function evaluations.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref></p>

</ss1>
</sec>
<sec>
<st>
Applications</st>

<p>

Cycle detection has been used in many applications.
<list>
<entry level="1" type="bullet">

Determining the cycle length of a <link xlink:type="simple" xlink:href="../524/45524.xml">
pseudorandom number generator</link> is one measure of its strength. This is the application cited by Knuth in describing Floyd's method. Brent<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> describes the results of testing a <link xlink:type="simple" xlink:href="../527/45527.xml">
linear congruential generator</link> in this fashion; its period turned out to be significantly smaller than advertised. For more complex generators, the sequence of values in which the cycle is to be found may not represent the output of the generator, but rather its internal state.</entry>
<entry level="1" type="bullet">

Several <link xlink:type="simple" xlink:href="../527/21527.xml">
Number-theoretic</link> algorithms are based on cycle detection, including <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for integer factorization<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref> and his related <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../899/12928899.xml">
lambda algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for the <link xlink:type="simple" xlink:href="../334/181334.xml">
discrete logarithm</link> problem<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref>.</entry>
<entry level="1" type="bullet">

In <link xlink:type="simple" xlink:href="../432/18934432.xml">
cryptographic</link> applications, the ability to find two distinct values <it>x</it>&amp;mu;&amp;minus;-1 and <it>x</it>&amp;lambda;+&amp;mu;&amp;minus;-1 mapped by some cryptographic function &amp;fnof; to the same value <it>x</it>&amp;mu; may indicate a weakness in &amp;fnof;. For instance, Quisquater and Delescaille<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> apply cycle detection algorithms in the search for a message and a pair of <cipher wordnetid="106254239" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../978/7978.xml">
Data Encryption Standard</link></cipher>
 keys that map that message to the same encrypted value; Kaliski, Rivest, and Sherman<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> also use cycle detection algorithms to attack DES. When applied to find a <link xlink:type="simple" xlink:href="../344/45344.xml">
hash collision</link> in a <link xlink:type="simple" xlink:href="../526/439526.xml">
cryptographic hash function</link>, cycle detection algorithms may help establish the <link xlink:type="simple" xlink:href="../326/2982326.xml">
collision resistance</link> of the function.</entry>
<entry level="1" type="bullet">

Cycle detection may be helpful as a way of discovering <link xlink:type="simple" xlink:href="../273/45273.xml">
infinite loop</link>s in certain types of <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link>s.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></entry>
<entry level="1" type="bullet">

<structure wordnetid="105726345" confidence="0.8">
<form wordnetid="105930736" confidence="0.8">
<link xlink:type="simple" xlink:href="../941/1001941.xml">
Periodic configurations</link></form>
</structure>
 in <link xlink:type="simple" xlink:href="../342/54342.xml">
cellular automaton</link> simulations may be found by applying cycle detection algorithms to the sequence of automaton states.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../291/8086291.xml">
Shape analysis</link> of <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link> data structures is a technique for verifying the correctness of an algorithm using those structures. If a node in the list incorrectly points to an earlier node in the same list, the structure will form a cycle that can be detected by these algorithms.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref></entry>
<entry level="1" type="bullet">

Teske<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> describes applications in <link xlink:type="simple" xlink:href="../584/618584.xml">
computational group theory</link>: determining the structure of an <possession wordnetid="100032613" confidence="0.8">
<property wordnetid="113244109" confidence="0.8">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
Abelian group</link></property>
</possession>
 from a set of its generators. The cryptographic algorithms of Kaliski et al.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> may also be viewed as attempting to infer the structure of an unknown group.</entry>
<entry level="1" type="bullet">

Fich<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> briefly mentions an application to <link xlink:type="simple" xlink:href="../416/375416.xml">
computer simulation</link> of <link xlink:type="simple" xlink:href="../182/102182.xml">
celestial mechanics</link>, which she attributes to <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../413/303413.xml">
William Kahan</link></scientist>
</person>
. In this application, cycle detection in the <link xlink:type="simple" xlink:href="../101/191101.xml">
phase space</link> of an orbital system may be used to determine whether the system is <link xlink:type="simple" xlink:href="../728/821728.xml">
periodic</link> to within the accuracy of the simulation.</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Floyd describes algorithms for listing all simple cycles in a <link xlink:type="simple" xlink:href="../986/19721986.xml">
directed graph</link> in a 1967 paper:  <cite id="CITEREFFloyd1967" style="font-style:normal"><link>
Floyd, R.W.</link>&#32;(1967),&#32;"<weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/321420.321422">
Non-deterministic Algorithms</weblink>",&#32;<it>J. ACM</it>&#32;<b>14</b>(4):  636–644, </cite>&nbsp;. However this paper does not describe the cycle-finding problem in functional graphs that is the subject of this article. An early description of the tortoise and hare algorithm appears in  <cite id="CITEREFKnuth1969" style="font-style:normal"><link>
Knuth, Donald E.</link>&#32;(1969),&#32;<it>The Art of Computer Programming, vol. II: Seminumerical Algorithms</it>, Addison-Wesley</cite>&nbsp;, exercises 6 and 7, page 7. Knuth (p.4) credits Floyd for the algorithm, without citation.</entry>
<entry id="2">
 <cite id="CITEREFBrent1980" style="font-style:normal"><link>
Brent, R. P.</link>&#32;(1980),&#32;"<weblink xlink:type="simple" xlink:href="http://wwwmaths.anu.edu.au/~brent/ftp/rpb051a.ps.gz">
An improved Monte Carlo factorization algorithm</weblink>",&#32;<it>BIT</it>&#32;<b>20</b>:  176–184, </cite>&nbsp;.</entry>
<entry id="3">
 <cite id="CITEREFNivasch2004" style="font-style:normal">Nivasch, Gabriel&#32;(2004),&#32;"Cycle detection using a stack",&#32;<it>Information Processing Letters</it>&#32;<b>90</b>:  135–140, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2Fj.ipl.2004.01.016">
10.1016/j.ipl.2004.01.016</weblink></cite>&nbsp;.</entry>
<entry id="4">
 <cite id="CITEREFSchnorrLenstra1984" style="font-style:normal"><link>
Schnorr, Claus P.</link>&#32;&amp;&#32;<link>
Lenstra, Hendrik W.</link>&#32;(1984),&#32;"<weblink xlink:type="simple" xlink:href="http://www.jstor.org/view/00255718/di970591/97p0460c/0">
A Monte Carlo Factoring Algorithm With Linear Storage</weblink>",&#32;<it>Mathematics of Computation</it>&#32;<b>43</b>(167):  289–311, </cite>&nbsp;.</entry>
<entry id="5">
 <cite id="CITEREFTeske1998" style="font-style:normal">Teske, Edlyn&#32;(1998),&#32;"<weblink xlink:type="simple" xlink:href="http://www.jstor.org/view/00255718/di011579/01p0117e/0">
A space-efficient algorithm for group structure computation</weblink>",&#32;<it>Mathematics of Computation</it>&#32;<b>67</b>(224):  1637–1663, </cite>&nbsp;.</entry>
<entry id="6">
 <cite id="CITEREFSedgewickSzymanskiYao1982" style="font-style:normal"><link>
Sedgewick, Robert</link>; Szymanski, Thomas G.&#32;&amp;&#32;<link>
Yao, Andrew C.-C.</link>&#32;(1982),&#32;"The complexity of finding cycles in periodic functions",&#32;<it>SIAM Journal on Computing</it>&#32;<b>11</b>(2):  376–390, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1137%2F0211030">
10.1137/0211030</weblink></cite>&nbsp;.</entry>
<entry id="7">
 <cite id="CITEREFvan_OorschotWiener1999" style="font-style:normal">van Oorschot, Paul C.&#32;&amp;&#32;Wiener, Michael J.&#32;(1999),&#32;"Parallel collision search with cryptanalytic applications",&#32;<it>Journal of Cryptology</it>&#32;<b>12</b>(1):  1–28, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FPL00003816">
10.1007/PL00003816</weblink></cite>&nbsp;.</entry>
<entry id="8">
 <cite id="CITEREFQuisquaterDelescaille" style="font-style:normal">Quisquater, J.-J.&#32;&amp;&#32;Delescaille, J.-P.,&#32;<weblink xlink:type="simple" xlink:href="http://www.springerlink.com/content/0wnq56dava5nnm17/">
"How easy is collision search? Application to DES"</weblink>,&#32;<it>Advances in Cryptology – EUROCRYPT '89, Workshop on the Theory and Application of of Cryptographic Techniques</it>, Lecture Notes in Computer Science, <b>434</b>, Springer-Verlag, pp. 429–434, </cite>&nbsp;.</entry>
<entry id="9">
 <cite id="CITEREFFich1981" style="font-style:normal">Fich, Faith Ellen&#32;(1981),&#32;"Lower bounds for the cycle detection problem",&#32;<it>Proc. 13th ACM Symp. Theory of Computation</it>, pp. 96–105, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F800076.802462">
10.1145/800076.802462</weblink></cite>&nbsp;.</entry>
<entry id="10">
 <cite id="CITEREFAllenderKlawe1985" style="font-style:normal"><link>
Allender, Eric W.</link>&#32;&amp;&#32;<link>
Klawe, Maria M.</link>&#32;(1985),&#32;"Improved lower bounds for the cycle detection problem",&#32;<it>Theoretical Computer Science</it>&#32;<b>36</b>(2–3):  231–237</cite>&nbsp;.</entry>
<entry id="11">
 <cite id="CITEREFPollard1975" style="font-style:normal">Pollard, J. M.&#32;(1975),&#32;"A Monte Carlo method for factorization",&#32;<it>BIT</it>&#32;<b>15</b>:  331–334</cite>&nbsp;.</entry>
<entry id="12">
 <cite id="CITEREFPollard1978" style="font-style:normal">Pollard, J. M.&#32;(1978),&#32;"Monte Carlo methods for index computation (mod p)",&#32;<it>Math. Comp.</it>&#32;<b>32</b>(143):  918–924</cite>&nbsp;.</entry>
<entry id="13">
 <cite id="CITEREFKaliskiRivestSherman1988" style="font-style:normal">Kaliski, Burton S., Jr.; <link>
Rivest, Ronald L.</link>&#32;&amp;&#32;Sherman, Alan T.&#32;(1988),&#32;"Is the Data Encryption Standard a group? (Results of cycling experiments on DES)",&#32;<it>Journal of Cryptology</it>&#32;<b>1</b>(1):  3–36, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FBF00206323">
10.1007/BF00206323</weblink></cite>&nbsp;.</entry>
<entry id="14">
 <cite id="CITEREFVan_Gelder1987" style="font-style:normal">Van Gelder, Allen&#32;(1987),&#32;"Efficient loop detection in Prolog using the tortoise-and-hare technique",&#32;<it>Journal of Logic Programming</it>&#32;<b>4</b>(1):  23–31, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0743-1066%2887%2990020-3">
10.1016/0743-1066(87)90020-3</weblink></cite>&nbsp;.</entry>
<entry id="15">
 <cite id="CITEREFAugustonHon1997" style="font-style:normal">Auguston, Mikhail&#32;&amp;&#32;Hon, Miu Har&#32;(1997),&#32;<weblink xlink:type="simple" xlink:href="http://www.ep.liu.se/ea/cis/1997/009/04/">
"Assertions for Dynamic Shape Analysis of List Data Structures"</weblink>,&#32;<it>AADEBUG '97, Proceedings of the Third International Workshop on Automatic Debugging</it>, Linköping Electronic Articles in Computer and Information Science, <link>
Linköping University</link>, pp. 37–42, </cite>&nbsp;.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

Gabriel Nivasch, <weblink xlink:type="simple" xlink:href="http://yucs.org/~gnivasch/stackalg/index.html">
The Cycle Detection Problem and the Stack Algorithm</weblink>.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://c2.com/cgi/wiki/Curry?TortoiseAndHare">
Tortoise and Hare</weblink>, Portland Pattern Repository</entry>
</list>



</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
