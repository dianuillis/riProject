<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:23:43[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<message  confidence="0.8" wordnetid="106598915">
<subject  confidence="0.8" wordnetid="106599788">
<language  confidence="0.8" wordnetid="106282651">
<header>
<title>Context-free grammar</title>
<id>6759</id>
<revision>
<id>241596237</id>
<timestamp>2008-09-28T19:35:37Z</timestamp>
<contributor>
<username>Camembert</username>
<id>3113</id>
</contributor>
</revision>
<categories>
<category>Compiler theory</category>
<category>Programming language topics</category>
<category>Formal languages</category>
<category>Wikipedia articles with ASCII art</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language theory</link>, a <b>context-free grammar</b> (<b>CFG</b>) is a <link xlink:type="simple" xlink:href="../716/18020716.xml">
grammar</link> in which every <link xlink:type="simple" xlink:href="../904/12800904.xml">
production</link> rule is of the form
<indent level="1">

<it>V</it> &amp;rarr; <it>w</it>
</indent>
where <it>V</it> is a single <link xlink:type="simple" xlink:href="../061/7689061.xml">
nonterminal</link> symbol, and <it>w</it> is a string of <link xlink:type="simple" xlink:href="../061/7689061.xml">
terminal</link>s and/or nonterminals (possibly empty). The term "context-free" expresses the fact that nonterminals can be rewritten without regard to the context in which they occur.  A <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link> is <link xlink:type="simple" xlink:href="../867/6867.xml">
context-free</link> if some context-free grammar generates it.<p>

Context-free grammars play a central role in the description and design of <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s and <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link>s. They are also used for analyzing the <link xlink:type="simple" xlink:href="../860/26860.xml">
syntax</link> of <link xlink:type="simple" xlink:href="../173/21173.xml">
natural language</link>s.</p>

<sec>
<st>
 Background </st>
<p>

Since the time of <link>
Pāṇini</link>, at least, linguists have described the <link xlink:type="simple" xlink:href="../569/12569.xml">
grammar</link>s of languages in terms of their <link xlink:type="simple" xlink:href="../414/922414.xml">
block structure</link>, and described how sentences are <link xlink:type="simple" xlink:href="../407/25407.xml">
recursively</link> built up from smaller phrases, and eventually individual words or word elements.</p>
<p>

The context-free grammar (or "phrase-structure grammar"  as Chomsky called it) formalism developed by <person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../566/21566.xml">
Noam Chomsky</link></philosopher>
</person>
,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
in the mid-1950s, took the manner in which linguistics had described this grammatical structure, and then turned it into rigorous mathematics.  A context-free grammar provides a simple and precise mechanism for describing the methods by which phrases in some natural language are built from smaller blocks, capturing the "block structure" of sentences in a natural way.  Its simplicity makes the formalism amenable to rigorous mathematical study, but it comes at a price: important features of natural language syntax such as <link xlink:type="simple" xlink:href="../860/2329860.xml">
agreement</link> and <link xlink:type="simple" xlink:href="../717/49717.xml">
reference</link> cannot be expressed in a natural way, or not at all.</p>
<p>

Block structure was introduced into computer <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>s by the <link xlink:type="simple" xlink:href="../453/1453.xml">
Algol</link> project, which, as a consequence, also featured a context-free grammar to describe the resulting Algol syntax.  This became a standard feature of computer languages, and the notation for grammars used in concrete descriptions of computer languages came to be known as <link xlink:type="simple" xlink:href="../247/62247.xml">
Backus-Naur Form</link>, after two members of the Algol language design committee.</p>
<p>

The "block structure" aspect that context-free grammars capture is so fundamental to grammar that the terms syntax and grammar are often identified with context-free grammar rules, especially in computer science.  Formal constraints not captured by the grammar are then considered to be part of the "semantics" of the language.</p>
<p>

Context-free grammars are simple enough to allow the construction of efficient <link xlink:type="simple" xlink:href="../568/18568.xml#xpointer(//*[./st=%22Parsing%22])">
parsing algorithm</link>s which, for a given string, determine whether and how it can be generated from the grammar. An <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../685/9685.xml">
Earley parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is an example of such an algorithm, while the widely used <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/58045.xml">
LL parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s are more efficient algorithms that deal only with more restrictive subsets of context-free grammars.</p>

</sec>
<sec>
<st>
 Formal definitions </st>
<p>

A context-free grammar <it>G</it> is a 4-<link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link>:</p>
<p>

<math>G = (V\,, \Sigma\,, R\,, S\,)</math>
where</p>
<p>

1. <math>V\,</math> is a finite set of <it>non-terminal</it> characters or variables. They represent different types of phrase or clause in the sentence.</p>
<p>

2. <math>\Sigma\,</math> is a finite set of <it>terminal</it>s, disjoint with <math>V\,</math>, which make up the actual content of the sentence.</p>
<p>

3. <math>R\,</math> is a relation from <math>V\,</math> to <math>(V\cup\Sigma)^{*}</math> such that <math>\exist\, w\in (V\cup\Sigma)^{*}: (S,w)\in R</math>.</p>
<p>

4. <math>S\,</math> is the start variable, used to represent the whole sentence (or program). It must be an element of <math>V\,</math>.</p>
<p>

In addition, <math>R\,</math> is a finite set. The members of <math>R\,</math> are called the <it>rule</it>s or <it>production</it>s of the grammar. The asterisk represents the <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../750/16750.xml">
Kleene star</link></language>
 operation.</p>
<p>

<b><it>Additional Definition 1</it></b></p>
<p>

For any strings <math>u, v\in (V\cup\Sigma)^{*}</math>, we say <math>u\,</math> yields <math>v\,</math>, written as <math>u\Rightarrow v\,</math>, if <math>\exists (\alpha, \beta)\in R, u_{1}, u_{2}\in (V\cup\Sigma)^{*}</math> such that <math>u\,=u_{1}\alpha u_{2}</math> and <math>v\,=u_{1}\beta u_{2}</math>. Thus, <math>\! v</math> is the result of applying the rule <math>\! (\alpha, \beta)</math> to <math>\! u</math>.</p>
<p>

<b><it>Additional Definition 2</it></b></p>
<p>

For any <math>u, v\in (V\cup\Sigma)^{*}, u\stackrel{*}{\Rightarrow} v</math> (or <math>u\Rightarrow\Rightarrow v\,</math> in some textbooks) if <math>\exists u_{1}, u_{2}, \cdots u_{k}\in (V\cup\Sigma)^{*}, k\geq 0</math> such that <math>u\Rightarrow u_{1}\Rightarrow u_{2}\cdots\Rightarrow u_{k}\Rightarrow v</math> </p>
<p>

<b><it>Additional Definition 3</it></b></p>
<p>

The language of a grammar <math>G = (V\,, \Sigma\,, R\,, S\,)</math> is the set</p>
<p>

<indent level="1">

<math>L(G) = \{ w\in\Sigma^{*} : S\stackrel{*}{\Rightarrow} w\}</math>
</indent>

<b><it>Additional Definition 4</it></b></p>
<p>

A language <math>L\,</math> is said to be a context-free language (CFL) if there exists a CFG,  <math>G\,</math> such that <math>L\,=\,L(G)</math>.</p>
<p>

<b><it>Additional Definition 5</it></b></p>
<p>

A context-free grammar is said to be proper if it has:
<list>
<entry level="1" type="bullet">

no useless symbols (<link>
inaccesible symbols</link> or <link>
unproductive symbols</link>) </entry>
<entry level="1" type="bullet">

no ε-productions</entry>
<entry level="1" type="bullet">

no cycles</entry>
</list>
</p>

</sec>
<sec>
<st>
 Examples </st>

<ss1>
<st>
 Example 1 </st>
<p>

<indent level="1">

S &amp;rarr; a
</indent>
:S &amp;rarr; aS
<indent level="1">

S &amp;rarr; bS
</indent>

The terminals here are <it>a</it> and <it>b</it>, while the only non-terminal is S.
The language described is all nonempty strings of <math>a</math>s and <math>b</math>s that end in <math>a</math>.</p>
<p>

This grammar is <link xlink:type="simple" xlink:href="../855/25855.xml">
regular</link>: no rule has more than one nonterminal in its right-hand side, and each of these nonterminals is at the same end of the right-hand side.</p>
<p>

Every regular grammar corresponds directly to a <link xlink:type="simple" xlink:href="../406/653406.xml">
nondeterministic finite automaton</link>, so we know that this is a <link xlink:type="simple" xlink:href="../723/25723.xml">
regular language</link>.</p>
<p>

It is common to list all right-hand sides for the same left-hand side on the same line, using | to separate them, like this:</p>
<p>

<indent level="1">

S &amp;rarr; a | aS | bS
</indent>

Technically, this is the same grammar as above.</p>

</ss1>
<ss1>
<st>
 Example 2 </st>
<p>

In a context-free grammar, we can pair up characters the way we do with <link xlink:type="simple" xlink:href="../hem/Ledringhem.xml">
bracket</link>s.  The simplest example:</p>
<p>

<indent level="1">

S &amp;rarr; aSb
</indent>
:S &amp;rarr; ab</p>
<p>

This grammar generates the language <math> \{ a^n b^n : n \ge 1 \} </math>, which is not <link xlink:type="simple" xlink:href="../723/25723.xml">
regular</link>.</p>
<p>

The special character  ε stands for the empty string. By changing the above grammar to :S → aSb | ε
we obtain a grammar generating the language <math> \{ a^n b^n : n \ge 0 \} </math> instead. This differs only in that it contains the empty string while the original grammar did not.</p>

</ss1>
<ss1>
<st>
 Example 3 </st>
<p>

Here is a context-free grammar for syntactically correct <link xlink:type="simple" xlink:href="../014/199014.xml">
infix</link> algebraic expressions in the variables x, y and z:
<indent level="1">

S &amp;rarr; x | y | z | S + S | S - S | S * S | S/S | (S)
</indent>

This grammar can, for example, generate the string "( x + y ) * x - z * y / ( x + x )" as follows:
"S" is the initial string.
"S - S" is the result of applying the fifth transformation [S → S - S] to the nonterminal S.
"S * S - S / S" is the result of applying the sixth transform to the first S and the seventh one to the second S.
"(   S   ) * S -   S   / (   S   )" is the result of applying the final transform to certain of the nonterminals.
"( S + S ) * S - S * S / ( S + S )" is the result of the fourth and fifth transforms to certain nonterminals.
"( x + y ) * x - z * y / ( x + x )" is the final result, obtained by using the first three transformations to turn the S nonterminals into the terminals x, y, and z.</p>
<p>

This grammar is <link xlink:type="simple" xlink:href="../729/647729.xml">
ambiguous</link>, meaning that one can generate the same string with more than one <link xlink:type="simple" xlink:href="../404/118404.xml">
parse tree</link>. For example, "x + y * z" might have either the + or the * parsed first; presumably these will produce different results.
However, the language being described is not itself ambiguous: a different, unambiguous grammar can be written for it.</p>

</ss1>
<ss1>
<st>
 Example 4 </st>
<p>

A context-free grammar for the language consisting of all strings over {a,b} for which the number of a's and b's are different is
<indent level="1">

S &amp;rarr; U | V
</indent>
:U &amp;rarr; TaU | TaT
<indent level="1">

V &amp;rarr; TbV | TbT
</indent>
:T &amp;rarr; aTbT | bTaT | &amp;epsilon;
Here, the nonterminal T can generate all strings with the same number of a's as b's, the nonterminal U generates all strings with more a's than b's and the nonterminal V generates all strings with fewer a's than b's.</p>

</ss1>
<ss1>
<st>
 Example 5 </st>
<p>

Another example of a non-regular language is <math> \{ b^n a^m b^{2n} : n \ge 0, m \ge 0 \} </math>.  It is context-free as it can be generated by the following context-free grammar:
<indent level="1">

S &amp;rarr; bSbb | A
</indent>
:A &amp;rarr; aA   | &amp;epsilon;</p>

</ss1>
<ss1>
<st>
 Other examples </st>
<p>

Context-free grammars are not limited in application to mathematical ("formal") languages.
For example, it has been suggested that  a class of <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../919/29919.xml">
Tamil</link></language>
 poetry called <link xlink:type="simple" xlink:href="../175/634175.xml">
Venpa</link> is described by a context-free grammar.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>

</ss1>
<ss1>
<st>
 Derivations and syntax trees </st>

<p>

There are two common ways to describe how a given string can be derived from the start symbol of a given grammar. The simplest way is to list the consecutive strings of symbols, beginning with the start symbol and ending with the string, and the rules that have been applied. If we introduce a strategy such as "always replace the left-most nonterminal first" then for context-free grammars the list of applied grammar rules is by itself sufficient. This is called the <it>leftmost derivation</it> of a string. For example, if we take the following grammar:</p>
<p>

<indent level="1">

 (1) S &amp;rarr; S + S
</indent>
: (2) S &amp;rarr; 1
<indent level="1">

 (3) S &amp;rarr; a
</indent>

and the string "1 + 1 + a" then a left derivation of this string is the list [ (1), (1), (2), (2), (3) ].
Analogously the <it>rightmost derivation</it> is defined as the list that we get if we always replace the rightmost nonterminal first. In this case this could be the list [ (1), (3), (1), (2), (2)].</p>
<p>

The distinction between leftmost derivation and rightmost derivation is important because in most <link xlink:type="simple" xlink:href="../015/310015.xml">
parser</link>s the transformation of the input is defined by giving a piece of code for every grammar rule that is executed whenever the rule is applied. Therefore it is important to know whether the parser determines a leftmost or a rightmost derivation because this determines the order in which the pieces of code will be executed. See for an example <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/58045.xml">
LL parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s.</p>
<p>

A derivation also imposes in some sense a hierarchical structure on the string that is derived. For example, if the string "1 + 1 + a" is derived according to the leftmost derivation:</p>
<p>

<indent level="1">

S &amp;rarr; S + S   (1)
</indent>
:&nbsp;&nbsp; &amp;rarr; S + S + S (1)
<indent level="1">

&nbsp;&nbsp; &amp;rarr; 1 + S + S (2)
</indent>
:&nbsp;&nbsp; &amp;rarr; 1 + 1 + S (2)
<indent level="1">

&nbsp;&nbsp; &amp;rarr; 1 + 1 + a (3)
</indent>

the structure of the string would be:</p>
<p>

<indent level="1">

 { { { 1 }S + { 1 }S }S + { a }S }S
</indent>
where { ... }S indicates a substring recognized as belonging to S. This hierarchy can also be seen as a tree:</p>
<p>

S
/|\
/ | \
/  |  \
S  '+'  S
/|\      |
/ | \     |
S '+' S   'a'
|     |
'1'   '1'</p>
<p>

This tree is called a <it>concrete syntax tree</it> (see also <link xlink:type="simple" xlink:href="../629/75629.xml">
abstract syntax tree</link>) of the string. In this case the presented leftmost and the rightmost derivations define the same syntax tree; however, there is another (leftmost) derivation of the same string</p>
<p>

<indent level="1">

S &amp;rarr; S + S      (1)
</indent>
:&nbsp;&nbsp; &amp;rarr; 1 + S      (2)
<indent level="1">

&nbsp;&nbsp; &amp;rarr; 1 + S + S  (1)
</indent>
:&nbsp;&nbsp; &amp;rarr; 1 + 1 + S  (2) 
<indent level="1">

&nbsp;&nbsp; &amp;rarr; 1 + 1 + a  (3)
</indent>

and this defines the following syntax tree:</p>
<p>

S 
/|\
/ | \
/  |  \
S  '+'  S
|      /|\
|     / | \
'1'   S '+' S
|     |
'1'   'a'</p>
<p>

If, for certain strings in the language of the grammar, there is more than one parsing tree, then the grammar is said to be an <it><link xlink:type="simple" xlink:href="../729/647729.xml">
ambiguous grammar</link></it>. Such grammars are usually hard to parse because the parser cannot always decide which grammar rule it has to apply. Usually, ambiguity is a feature of the grammar, not the language, and an unambiguous grammar can be found which generates the same context-free language. However, there are certain languages which can only be generated by ambiguous grammars; such languages are called inherently ambiguous.</p>

</ss1>
</sec>
<sec>
<st>
 Normal forms </st>
<p>

Every context-free grammar that does not generate the empty string can be transformed into one in which no rule has the empty string as a product [a rule with ε as a product is called an ε-production]. If it does generate the empty string, it will be necessary to include the rule <math>S \rarr \epsilon</math>, but there need be no other ε-rule. Every context-free grammar with no ε-production has an equivalent grammar in <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../850/7850.xml">
Chomsky normal form</link></language>
 or <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../928/53928.xml">
Greibach normal form</link></language>
. "Equivalent" here means that the two grammars generate the same language.</p>
<p>

Because of the especially simple form of production rules in Chomsky Normal Form grammars, this normal form has both theoretical and practical implications. For instance, given a context-free grammar, one can use the Chomsky Normal Form to construct a polynomial-time algorithm which decides whether a given string is in the language represented by that grammar or not (the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/53929.xml">
CYK algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
).</p>

</sec>
<sec>
<st>
 Undecidable problems </st>
<p>

Although some operations on context-free grammars are decidable due to their limited power, CFGs do have interesting undecidable problems. One of the simplest and most cited is the problem of deciding whether a CFG accepts the language of all strings. A reduction can be demonstrated to this problem from the well-known undecidable problem of determining whether a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 accepts a particular input. The reduction uses the concept of a <it><link xlink:type="simple" xlink:href="../568/7620568.xml">
computation history</link></it>, a string describing an entire computation of a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
. We can construct a CFG that generates all strings that are not accepting computation histories for a particular Turing machine on a particular input, and thus it will accept all strings only if the machine does not accept that input.</p>
<p>

As a consequence of this, it is also undecidable whether two CFGs describe the same language, since we can't even decide whether a CFG is equivalent to the trivial CFG deciding the language of all strings.</p>
<p>

Another point worth mentioning is that the problem of determining if a <link xlink:type="simple" xlink:href="../211/6211.xml">
context-sensitive grammar</link> describes a context-free language is undecidable.</p>

</sec>
<sec>
<st>
 Extensions </st>
<p>

An obvious way to extend the context-free grammar formalism is to allow nonterminals to have arguments, the values of which are passed along within the rules.  This allows natural language features such as <link xlink:type="simple" xlink:href="../117/217117.xml">
agreement</link> and <link xlink:type="simple" xlink:href="../717/49717.xml">
reference</link>, and programming language analogs such as the correct use and definition of identifiers, to be expressed in a natural way.  E.g. we can now easily express that in English sentences, the subject and verb must agree in number.</p>
<p>

In computer science, examples of this approach include <link xlink:type="simple" xlink:href="../989/16110989.xml">
affix grammar</link>s,  <link xlink:type="simple" xlink:href="../975/479975.xml">
attribute grammar</link>s, <link xlink:type="simple" xlink:href="../637/12656637.xml">
indexed grammar</link>s, and Van Wijngaarden <link xlink:type="simple" xlink:href="../990/479990.xml">
two-level grammar</link>s.</p>
<p>

Similar extensions exist in linguistics.</p>
<p>

Another extension is to allow additional symbols to appear at the left hand side of rules, constraining their application.  This produces the formalism of <link xlink:type="simple" xlink:href="../211/6211.xml">
context-sensitive grammar</link>s.</p>

</sec>
<sec>
<st>
Linguistic applications</st>

<p>

<person wordnetid="100007846" confidence="0.9508927676800064">
<philosopher wordnetid="110423589" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../566/21566.xml">
Chomsky</link></philosopher>
</person>
 initially hoped to overcome the limitations of context-free grammars by adding <link xlink:type="simple" xlink:href="../439/58439.xml">
transformation rules</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

Such rules are another standard device in traditional linguistics; e.g. <link xlink:type="simple" xlink:href="../931/12931.xml">
passivization</link> in English.  However, arbitrary transformations must be disallowed, since they are much too powerful (<link xlink:type="simple" xlink:href="../621/30621.xml">
Turing complete</link>).  Much of <link xlink:type="simple" xlink:href="../515/444515.xml">
generative grammar</link> has been devoted to finding ways of refining the descriptive mechanisms of phrase-structure grammar and transformation rules such that exactly the kinds of things can be expressed that natural language actually allows.</p>
<p>

His general position regarding the non-context-freeness of natural language has held up since then<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>, although his specific examples regarding the inadequacy of context free grammars (CFGs) in terms of their weak generative capacity were later disproved.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<linguist wordnetid="110264437" confidence="0.8">
<link xlink:type="simple" xlink:href="../194/2019194.xml">
Gerald Gazdar</link></linguist>
</scientist>
</causal_agent>
</person>
</physical_entity>
 and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<linguist wordnetid="110264437" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../228/1000228.xml">
Geoffrey Pullum</link></associate>
</linguist>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 have argued that despite a few non-context-free constructions in natural language (such as <link>
cross-serial dependencies</link> in <link xlink:type="simple" xlink:href="../184/27184.xml">
Swiss German</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> and <link xlink:type="simple" xlink:href="../408/171408.xml">
reduplication</link> in <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../565/4565.xml">
Bambara</link></language>
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>), the vast majority of forms in natural language are indeed context-free.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref></p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../211/6211.xml">
Context-sensitive grammar</link></language>
</entry>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../716/18020716.xml">
Formal grammar</link></language>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/310015.xml">
Parsing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../899/892899.xml">
Parsing expression grammar</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</language>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../329/299329.xml">
Stochastic context-free grammar</link></language>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../986/19282986.xml">
Algorithms for context-free grammar generation</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>

<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">Chomsky, Noam&#32;(Sep 1956).&#32;"<weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/iel5/18/22738/01056813.pdf?isnumber=22738&amp;prod=STD&amp;arnumber=1056813&amp;arnumber=1056813&amp;arSt=+113&amp;ared=+124&amp;arAuthor=+Chomsky%2C+N.">
Three models for the description of language</weblink>". <it>Information Theory, IEEE Transactions</it>&#32;<b>2</b>&#32;(3): 113–124. Retrieved on <link>
2007-06-18</link>.</cite>&nbsp;</entry>
<entry id="2">
 <cite style="font-style:normal">L, BalaSundaraRaman;&#32;Ishwar.S, Sanjeeth Kumar Ravindranath&#32;(2003-08-22). "<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/balasundararaman03context.html">
Context Free Grammar for Natural Language Constructs - An implementation for Venpa Class of Tamil Poetry</weblink>".&#32;<it>Proceedings of Tamil Internet, Chennai, 2003</it>: 128-136, International Forum for Information Technology in Tamil. Retrieved on <link>
2006-08-24</link>.</cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal">Shieber, Stuart&#32;(1985).&#32;"<weblink xlink:type="simple" xlink:href="http://www.eecs.harvard.edu/~shieber/Biblio/Papers/shieber85.pdf">
Evidence against the context-freeness of natural language</weblink>". <it>Linguistics and Philosophy</it>&#32;<b>8</b>: 333–343. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FBF00630917">
10.1007/BF00630917</weblink>.</cite>&nbsp;</entry>
<entry id="4">
 <cite style="font-style:normal">Pullum, Geoffrey K.; Gerald Gazdar&#32;(1982).&#32;"Natural languages and context-free languages". <it>Linguistics and Philosophy</it>&#32;<b>4</b>: 471–504. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FBF00360802">
10.1007/BF00360802</weblink>.</cite>&nbsp;</entry>
<entry id="5">
 <cite style="font-style:normal">Culy, Christopher&#32;(1985).&#32;"The Complexity of the Vocabulary of Bambara". <it>Linguistics and Philosophy</it>&#32;<b>8</b>: 345–351. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FBF00630918">
10.1007/BF00630918</weblink>.</cite>&nbsp;</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Chomsky, Noam (Sept. 1956). "Three models for the description of language". Information Theory, IEEE Transactions 2 (3).</entry>
</list>
</p>

</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/3644015.xml">
Michael Sipser</link></mathematician>
</scientist>
</causal_agent>
</person>
</physical_entity>
&#32;(1997). Introduction to the Theory of Computation.&#32;PWS Publishing. ISBN 0-534-94728-X.</cite>&nbsp; Section 2.1: Context-Free Grammars, pp.91–101. Section 4.1.2: Decidable problems concerning context-free languages, pp.156–159. Section 5.1.1: Reductions via computation histories: pp.176–183.</entry>
</list>
</p>

<p>

<table style=";width:auto;" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../356/103356.xml">
Automata theory</link>: <link xlink:type="simple" xlink:href="../939/10939.xml">
formal language</link>s and <link xlink:type="simple" xlink:href="../716/18020716.xml">
formal grammar</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style="width:100%;padding:0px;;;background:transparent;color:inherit;" class="navbox-list navbox-odd">
<table style="text-align:left;width:100%;" class="navbox-columns-table" cellspacing="0">
<row>
<col colspan="1" style="" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../011/6011.xml">
Chomsky
hierarchy</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../716/18020716.xml">
Grammars</link></language>
</b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b><link xlink:type="simple" xlink:href="../939/10939.xml">
Languages</link></b></col>
<col colspan="1" style="border-left:2px solid #fdfdfd;" class="navbox-abovebelow">
<b>Minimal
<link xlink:type="simple" xlink:href="../931/10931.xml">
automaton</link></b></col>
</row>
<row style="height:2px;">

</row>
<row style="vertical-align:top;">
<col style="padding:0px;text-align: center;;;;width:10em;">
Type-0 n/a Type-1 n/a n/a Type-2 n/a Type-3 n/a</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../174/4906174.xml">
Unrestricted</link></language>
(no common name) <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../211/6211.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/12656637.xml">
Indexed</link></language>
<model wordnetid="105890249" confidence="0.8">
<idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<hypothesis wordnetid="105888929" confidence="0.8">
<link xlink:type="simple" xlink:href="../555/567555.xml">
Tree-adjoining</link></hypothesis>
</concept>
</idea>
</model>
 etc.<message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../759/6759.xml">
Context-free</link></language>
</subject>
</message>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../024/10609024.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../855/25855.xml">
Regular</link></language>
n/a</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../789/54789.xml">
Recursively enumerable</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../874/53874.xml">
Recursive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/6212.xml">
Context-sensitive</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../284/7324284.xml">
Indexed</link></language>
(<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/13026226.xml">
Mildly context-sensitive</link></language>
)<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/6867.xml">
Context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../589/7962589.xml">
Deterministic context-free</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../723/25723.xml">
Regular</link></language>
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../792/4922792.xml">
Star-free</link></language>
</p>
</col>
<col style="border-left:2px solid #fdfdfd;padding:0px;text-align: center;;;;width:10em;"><p>

<invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../564/1352564.xml">
Decider</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../962/1811962.xml">
Linear-bounded</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../447/9791447.xml">
Nested stack</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../961/14345961.xml">
Embedded pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../510/24510.xml">
Nondeterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../656/3972656.xml">
Deterministic pushdown</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
<link xlink:type="simple" xlink:href="../931/10931.xml">
Finite</link><language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../149/17995149.xml">
Aperiodic finite</link></language>
</p>
</col>
</row>
</table>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
Each category of languages or grammars is a <link xlink:type="simple" xlink:href="../631/27631.xml">
proper subset</link>of the category directly above it; and any automaton in each category has an equivalent automaton in the category directly above it.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</language>
</subject>
</message>
</article>
