<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:30:58[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9511911446218017" wordnetid="105847438">
<header>
<title>Boyer–Moore string search algorithm</title>
<id>684709</id>
<revision>
<id>240639705</id>
<timestamp>2008-09-24T08:32:27Z</timestamp>
<contributor>
<username>DocWatson42</username>
<id>38455</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Articles with example C code</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

"Boyer-Moore" redirects here. For the Boyer-Moore theorem prover, see <link xlink:type="simple" xlink:href="../803/8818803.xml">
Nqthm</link>.
<p>

The <b>Boyer–Moore string search algorithm</b> is a particularly efficient <link xlink:type="simple" xlink:href="../648/28648.xml">
string searching algorithm</link>, and it has been the standard benchmark for the practical string search literature.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> It was developed by <link xlink:type="simple" xlink:href="../637/4384637.xml">
Bob Boyer</link> and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/1472637.xml">
J Strother Moore</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
 in 1977.  The <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> <link xlink:type="simple" xlink:href="../971/81971.xml">
preprocesses</link> the target <link xlink:type="simple" xlink:href="../701/27701.xml">
string</link> (key) that is being searched for, but not the string being searched (unlike some algorithms that preprocess the string to be searched and can then <link xlink:type="simple" xlink:href="../322/265322.xml">
amortize</link> the expense of the preprocessing by searching repeatedly).  The execution time of the Boyer-Moore algorithm can be sub-linear: it doesn't need to check every character of the string to be searched, but rather skips over some of them.  Generally the algorithm gets faster as the key being searched for becomes longer.  Its efficiency derives from the fact that with each unsuccessful attempt to find a match between the search string and the text it's searching, it uses the information gained from that attempt to rule out as many positions of the text as possible where the string cannot match. </p>

<sec>
<st>
 How the algorithm works </st>



<p>

<table>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
X</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
</row>
</table>

The X in position 8 excludes
all 8 of the possible starting positions shown.</p>


<p>

What people frequently find surprising about the Boyer-Moore algorithm when they first encounter it is that its verifications—its attempts to check whether a match exists at a particular position—work backwards.  If it starts a search at the beginning of a text for the word "ANPANMAN", for instance, it checks the eighth position of the text to see if it contains an "N".  If it finds the "N", it moves to the seventh position to see if that contains the last "A" of the word, and so on until it checks the first position of the text for a "A".</p>
<p>

Why Boyer-Moore takes this backward approach is clearer when we consider what happens if the verification fails—for instance, if instead of an "N" in the eighth position, we find an "X".  The "X" doesn't appear anywhere in "ANPANMAN", and this means there is no match for the search string at the very start of the text—or at the next seven positions following it, since those would all fall across the "X" as well.  After checking just one character, we're able to skip ahead and start looking for a match starting at the ninth position of the text, just after the "X".</p>
<p>

This explains why the best-case performance of the algorithm, for a text of length N and a fixed pattern of length M, is N/M:  in the best case, only one in M characters needs to be checked.  This also explains the somewhat counter-intuitive result that the longer the pattern we are looking for, the faster the algorithm will be usually able to find it.</p>
<p>

The algorithm precomputes two tables to process the information it obtains in each failed verification:  one table calculates how many positions ahead to start the next search based on the identity of the character that caused the match attempt to fail; the other makes a similar calculation based on how many characters were matched successfully before the match attempt failed.  (Because these two tables return results indicating how far ahead in the text to "jump", they are sometimes called "jump tables", which should not be confused with the more common meaning of <link xlink:type="simple" xlink:href="../800/6894800.xml">
jump table</link>s in computer science.)</p>

<ss1>
<st>
 The first table </st>


<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../472/1753472.xml">
Boyer-Moore-Horspool algorithm</link></it>
</indent>

The first table is easy to calculate:  Start at the last character of the sought string and move towards the first character. Each time you move left, if the character you are on is not in the table already, add it; its Shift value is its distance from the rightmost character.  All other characters receive a count equal to the length of the search string.</p>
<p>

<b><it>Example</it></b><it>: For the string ANPANMAN, the first table would be as shown (for clarity, entries are shown in the order they would be added to the table):</it>
(The N which is supposed to be zero is based on the 2nd N from the right because we only calculate from letters m-1)</p>
<p>

<table class="wikitable">
<header>
Character</header>
<row>
<col>
Shift</col>
</row>
<row align="right">
<col>
A</col>
<col>
1</col>
</row>
<row align="right">
<col>
M</col>
<col>
2</col>
</row>
<row align="right">
<col>
N</col>
<col>
3</col>
</row>
<row align="right">
<col>
P</col>
<col>
5</col>
</row>
<row align="right">
<col>
all other characters</col>
<col>
8</col>
</row>
</table>
</p>
<p>

The amount of shift calculated by the first table is sometimes called the "bad character shift"<weblink xlink:type="simple" xlink:href="http://www.movsd.com/bm.htm">
http://www.movsd.com/bm.htm</weblink>.</p>

</ss1>
<ss1>
<st>
 The second table </st>



<p>

<table>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
<col>
-</col>
</row>
<row>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
-</col>
<col>
A</col>
<col>
N</col>
<col>
P</col>
<col>
A</col>
<col>
N</col>
<col>
M</col>
<col>
A</col>
<col>
N</col>
<col>
-</col>
</row>
</table>
</p>
<p>

The mismatch "A" in position 5 (3 back from the last letter of the needle) excludes the first 6 of the possible starting positions shown.</p>


<p>

The second table is slightly more difficult to calculate:  for each value of <it>i</it> less than the length of the search string, we must first calculate the pattern consisting of the last <it>i</it> characters of the search string, preceded by a <it>mis</it>-match for the character before it; then we
initially line it up with the search pattern and determine the least number of characters the partial pattern must be shifted left before the two patterns match.  For instance, for the search string ANPANMAN, the table would be as follows: (N signifies any character that is not N)</p>
<p>

<table class="wikitable">
<header>
i</header>
<row>
<col>
Pattern</col>
<col>
Shift</col>
</row>
<row align="right">
<col>
0</col>
<col>
N</col>
<col>
1</col>
</row>
<row align="right">
<col>
1</col>
<col>
AN</col>
<col>
8</col>
</row>
<row align="right">
<col>
2</col>
<col>
MAN</col>
<col>
3</col>
</row>
<row align="right">
<col>
3</col>
<col>
NMAN</col>
<col>
8</col>
</row>
<row align="right">
<col>
4</col>
<col>
ANMAN</col>
<col>
8</col>
</row>
<row align="right">
<col>
5</col>
<col>
PANMAN</col>
<col>
8</col>
</row>
<row align="right">
<col>
6</col>
<col>
NPANMAN</col>
<col>
8</col>
</row>
<row align="right">
<col>
7</col>
<col>
ANPANMAN</col>
<col>
8</col>
</row>
</table>
</p>
<p>

The amount of shift calculated by the second table is sometimes called the "good suffix shift"<weblink xlink:type="simple" xlink:href="http://www.movsd.com/bm.htm">
http://www.movsd.com/bm.htm</weblink> or "(strong) good suffix rule".  The original published Boyer-Moore algorithm<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> uses a simpler, weaker, version of the good suffix rule in which each entry in the above table did not require a <it>mis</it>-match for the left-most character.  This is sometimes called the "weak good suffix rule" and is not sufficient for proving that Boyer-Moore runs in linear worst-case time.</p>

</ss1>
</sec>
<sec>
<st>
 Performance of the Boyer-Moore string search algorithm </st>

<p>

The worst-case to find all occurrences in a text needs approximately 3*N comparisons, hence the complexity is O(n), regardless whether the text contains a match or not. The proof is due to Richard Cole, see R. COLE, <it>Tight bounds on the complexity of the Boyer-Moore algorithm,</it> Proceedings of the 2nd Annual ACM-SIAM Symposium on Discrete Algorithms, (1991) for details. This proof took some years to determine. In the year the algorithm was devised, 1977, the maximum number of comparisons was shown to be no more than 6*N; in 1980 it was shown to be no more than 4*N, until Cole's result in 1991.</p>

</sec>
<sec>
<st>
Example implementation</st>
<p>

Here is an example implementation of the Boyer-Moore algorithm, written in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C99</link></programming_language>
.</p>
<p>

Note: The method of constructing the good-match table (skip) in this example is slower than it needs to be (for simplicity of implementation). It does not make a fair comparison to other algorithms, should you try to compare their speed. A faster method should be used instead.</p>
<p>

<list>
<entry level="1" type="number">

include </entry>
<entry level="1" type="number">

include </entry>
</list>
</p>
<p>

/* Same suffix at offset as at nlen, but the preceding character differs
<list>
<entry level="1" type="bullet">

 (if that position is still within needle)</entry>
<entry level="1" type="bullet">

/</entry>
</list>

static int suffix_match(const unsigned char *needle, size_t nlen, size_t offset, size_t suffixlen) {
if (offset &amp;gt; suffixlen)
return needle[offset - suffixlen - 1] != needle[nlen - suffixlen - 1] &amp;&amp;
memcmp(needle + nlen - suffixlen, needle + offset - suffixlen, suffixlen) == 0;
else
return memcmp(needle + nlen - suffixlen, needle, offset) == 0;
}</p>
<p>

static ssize_t max(ssize_t a, ssize_t b)
{
return a &amp;gt; b ? a : b; 
}</p>
<p>

/* Returns a pointer to the first occurrence of "needle"
<list>
<entry level="1" type="bullet">

 within "haystack", or NULL if not found.</entry>
<entry level="1" type="bullet">

/</entry>
</list>

const unsigned char* memmem_boyermoore
(const unsigned char* haystack, size_t hlen,
const unsigned char* needle,   size_t nlen)
{
size_t skip[nlen]; /* Array of shifts with self-substring match check */
ssize_t occ[UCHAR_MAX + 1]; /* Array of last occurrence of each character */</p>
<p>

if(nlen &amp;gt; hlen || nlen = 0 || !haystack || !needle) 
return NULL;</p>
<p>

/* Preprocess #1: init occ*/</p>
<p>

/* Initialize the table to default value */
for(size_t a=0; a</p>

</sec>
<sec>
<st>
Variants</st>
<p>

The <b>Turbo Boyer-Moore algorithm</b> takes an additional constant amount of space to complete a search within <it>2n</it> comparisons (as opposed to <it>3n</it> for Boyer-Moore).  (<it>n</it> is the number of characters in the text to be searched). <weblink xlink:type="simple" xlink:href="http://www-igm.univ-mlv.fr/~lecroq/string/node15.html">
http://www-igm.univ-mlv.fr/~lecroq/string/node15.html</weblink></p>
<p>

The <link xlink:type="simple" xlink:href="../472/1753472.xml">
Boyer-Moore-Horspool algorithm</link> is a simplification of the Boyer-Moore algorithm that leaves out the "second table".
The Boyer-Moore-Horspool algorithm requires (in the worst case) M*N comparisons, while the Boyer-Moore algorithm requires (in the worst case) only 3*N comparisons.</p>

</sec>
<sec>
<st>
Uses</st>
<p>

Wikipedia uses a patched version of PHP which uses an implementation of Boyer-Moore to speed up page loading.  Wikipedia database developer Domas Mituzas discussed Wikipedia's use of the Boyer-Moore algorithm in a 2007 presentation:</p>
<p>

"Fast String Search" is a replacement module for PHP’s strtr() function, which uses a Commentz-Walter–style algorithm for multiple search terms, or the Boyer-Moore algorithm for single search terms. License collisions (GPL code was used for it) do not allow its inclusion in PHP.  Using a proper algorithm instead of foreach loops is an incredible boost for some applications.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Knuth–Morris–Pratt algorithm</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
Hume and Sunday (1991) <it>[Fast String Searching]</it> SOFTWARE—PRACTICE AND EXPERIENCE, VOL. 21(11), 1221–1248 (NOVEMBER 1991)</entry>
<entry id="2">
 <cite style="font-style:normal"><link xlink:type="simple" xlink:href="../637/4384637.xml">
R. S. Boyer</link>; <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/1472637.xml">
J. S. Moore</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
&#32;(1977).&#32;"A fast string searching algorithm". <it>Comm. ACM</it>&#32;<b>20</b>: 762–772. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F359842.359859">
10.1145/359842.359859</weblink>.</cite>&nbsp;</entry>
<entry id="3">
D. Mituzas, "Wikipedia: Site internals, configuration, code examples and management issues", http://dammit.lt/uc/workbook2007.pdf</entry>
</reflist>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf">
Original article</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-sr.informatik.uni-tuebingen.de/~buehler/BM/BM1.html">
Animation</weblink> of the Boyer-Moore algorithm</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/fstrpos-example.html">
An example of the Boyer-Moore algorithm</weblink> from the homepage of <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../637/1472637.xml">
J Strother Moore</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, co-inventor of the algorithm</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www-igm.univ-mlv.fr/%7Elecroq/string/node14.html">
An explanation of the algorithm (with sample C code)</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.nyu.edu/cs/faculty/cole/papers/CHPZ95.ps">
Cole et al, Tighter lower bounds on the exact complexity of string matching</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</article>
