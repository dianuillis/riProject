<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:36:10[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Luhn mod N algorithm</title>
<id>6870554</id>
<revision>
<id>219784728</id>
<timestamp>2008-06-16T21:27:57Z</timestamp>
<contributor>
<username>Tikiwont</username>
<id>2435746</id>
</contributor>
</revision>
<categories>
<category>Modular arithmetic</category>
<category>Articles with example code</category>
<category>Checksum algorithms</category>
</categories>
</header>
<bdy>

The <b>Luhn mod N algorithm</b> is an extension to the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../440/582440.xml">
Luhn algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 (also known as mod 10 algorithm) that allows it to work with sequences of non-numeric characters. This can be useful when a check digit is required to validate an identification string composed of letters, a combination of letters and digits or even any arbitrary set of characters.
<sec>
<st>
 Informal explanation </st>

<p>

The Luhn mod N algorithm generates a check digit (more precisely, a check character) within the same range of valid characters as the input string. For example, if the algorithm is applied to a string of lower-case letters (<it>a</it> to <it>z</it>), the check character will also be a lower-case letter. Apart from this distinction, it resembles very closely the original algorithm.</p>
<p>

The main idea behind the extension is that the full set of valid input characters is mapped to a list of code-points (i.e., sequential integers beginning with zero). The algorithm processes the input string by converting each character to its associated code-point and then performing the computations in mod N (where N is the number of valid input characters). Finally, the resulting check code-point is mapped back to obtain its corresponding check character.</p>

</sec>
<sec>
<st>
 Mapping characters to code-points </st>

<p>

Initially, a mapping between valid input characters and code-points must be created. For example, consider that the valid characters are the lower-case letters from <it>a</it> to <it>f</it>. Therefore, a suitable mapping would be:</p>
<p>

<table style="width:300px;" class="wikitable">
<row align="center">
<col>
<b>Character</b></col>
<col>
<it>a''</it></col>
<col>
<it>b''</it></col>
<col>
<it>c''</it></col>
<col>
<it>d''</it></col>
<col>
<it>e''</it></col>
<col>
<it>f''</it></col>
</row>
<row align="center">
<col>
<b>Code-point</b></col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
</row>
</table>
</p>
<p>

Note that the order of the characters is completely irrelevant. This other mapping would also be acceptable (although possibly more cumbersome to implement):</p>
<p>

<table style="width:300px;" class="wikitable">
<row align="center">
<col>
<b>Character</b></col>
<col>
<it>c''</it></col>
<col>
<it>e''</it></col>
<col>
<it>a''</it></col>
<col>
<it>f''</it></col>
<col>
<it>b''</it></col>
<col>
<it>d''</it></col>
</row>
<row align="center">
<col>
<b>Code-point</b></col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
</row>
</table>
</p>
<p>

It is also possible to intermix letters and digits (and possibly even other characters). For example, this mapping would be appropriate for lower-case hexadecimal digits:</p>
<p>

<table style="width:500px;" class="wikitable">
<row align="center">
<col>
<b>Character</b></col>
<col>
<it>0''</it></col>
<col>
<it>1''</it></col>
<col>
<it>2''</it></col>
<col>
<it>3''</it></col>
<col>
<it>4''</it></col>
<col>
<it>5''</it></col>
<col>
<it>6''</it></col>
<col>
<it>7''</it></col>
<col>
<it>8''</it></col>
<col>
<it>9''</it></col>
<col>
<it>a''</it></col>
<col>
<it>b''</it></col>
<col>
<it>c''</it></col>
<col>
<it>d''</it></col>
<col>
<it>e''</it></col>
<col>
<it>f''</it></col>
</row>
<row align="center">
<col>
<b>Code-point</b></col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
6</col>
<col>
7</col>
<col>
8</col>
<col>
9</col>
<col>
10</col>
<col>
11</col>
<col>
12</col>
<col>
13</col>
<col>
14</col>
<col>
15</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Algorithm </st>

<p>

Assuming the following functions are defined:</p>
<p>


function int CodePointFromCharacter(char character) {...}

function char CharacterFromCodePoint(int codePoint) {...}

function int NumberOfValidInputCharacters() {...}
</p>
<p>

The function to generate a check character is:</p>
<p>


function char GenerateCheckCharacter(string input) {

	int factor = 2;
	int sum = 0;
	int n = NumberOfValidInputCharacters();

	// Starting from the right and working leftwards is easier since 
	// the initial "factor" will always be "2" 
	for (int i = input.Length - 1; i &amp;gt;= 0; i--) {
		int codePoint = CodePointFromCharacter(input[i]);
		int addend = factor * codePoint;

		// Alternate the "factor" that each "codePoint" is multiplied by
		factor = (factor == 2) ? 1 : 2;

		// Sum the digits of the "addend" as expressed in base "n"
		addend = (addend / n) + (addend % n);
		sum += addend;
	}

	// Calculate the number that must be added to the "sum" 
	// to make it divisible by "n"
	int remainder = sum % n;
	int checkCodePoint = n - remainder;
	checkCodePoint %= n;

	return CharacterFromCodePoint(checkCodePoint);
}
</p>
<p>

And the function to validate a string (with the check character as the last character) is:</p>
<p>


function bool ValidateCheckCharacter(string input) {

	int factor = 1;
	int sum = 0;
	int n = NumberOfValidInputCharacters();

	// Starting from the right, work leftwards
	// Now, the initial "factor" will always be "1" 
	// since the last character is the check character
	for (int i = input.Length - 1; i &amp;gt;= 0; i--) {
		int codePoint = CodePointFromCharacter(input[i]);
		int addend = factor * codePoint;

		// Alternate the "factor" that each "codePoint" is multiplied by
		factor = (factor == 2) ? 1 : 2;

		// Sum the digits of the "addend" as expressed in base "n"
		addend = (addend / n) + (addend % n);
		sum += addend;
	}

	int remainder = sum % n;

	return (remainder == 0);
}
</p>

</sec>
<sec>
<st>
 Example </st>

<ss2>
<st>
 Generation </st>
<p>

Consider the above set of valid input characters and the example input string <it>abcdef</it>. To generate the check character, start with the last character in the string and move left doubling every other  code-point. The "digits" of the code-points as written in base 6 (since there are 6 valid input characters) should then be summed up:</p>
<p>

<table style="width:500px;" class="wikitable">
<row align="center">
<col>
<it>Character''</it></col>
<col>
<it>a''</it></col>
<col>
<it>b''</it></col>
<col>
<it>c''</it></col>
<col>
<it>d''</it></col>
<col>
<it>e''</it></col>
<col>
<it>f''</it></col>
</row>
<row align="center">
<col>
<it>Code-point''</it></col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
</row>
<row align="center">
<col>
<it>Double''</it></col>

<col>
2</col>

<col>
6 (base 10)  10 (base 6)</col>

<col>
10 (base 10)  14 (base 6)</col>
</row>
<row align="center">
<col>
<it>Reduce''</it></col>
<col>
0</col>
<col>
2</col>
<col>
2</col>
<col>
1 + 0</col>
<col>
4</col>
<col>
1 + 4</col>
</row>
<row align="center">
<col>
<it>Sum of digits''</it></col>
<col>
0</col>
<col>
2</col>
<col>
2</col>
<col>
1</col>
<col>
4</col>
<col>
5</col>
</row>
</table>
</p>
<p>

The total sum of digits is <b>14</b> (0 + 2 + 2 + 1 + 4 + 5). The number that must be added to obtain the next multiple of 6 (in this case, <b>18</b>) is <b>4</b>. This is the resulting check code-point. The associated check character is <b>e</b>.</p>

</ss2>
<ss2>
<st>
 Validation </st>
<p>

The resulting string <it>abcdefe</it> can then be validated by using a similar procedure:</p>
<p>

<table style="width:500px;" class="wikitable">
<row align="center">
<col>
<it>Character''</it></col>
<col>
<it>a''</it></col>
<col>
<it>b''</it></col>
<col>
<it>c''</it></col>
<col>
<it>d''</it></col>
<col>
<it>e''</it></col>
<col>
<it>f''</it></col>
<col>
<it>e''</it></col>
</row>
<row align="center">
<col>
<it>Code-point''</it></col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col>
3</col>
<col>
4</col>
<col>
5</col>
<col>
4</col>
</row>
<row align="center">
<col>
<it>Double''</it></col>

<col>
2</col>

<col>
6 (base 10)  10 (base 6)</col>

<col>
10 (base 10)  14 (base 6)</col>

</row>
<row align="center">
<col>
<it>Reduce''</it></col>
<col>
0</col>
<col>
2</col>
<col>
2</col>
<col>
1 + 0</col>
<col>
4</col>
<col>
1 + 4</col>
<col>
4</col>
</row>
<row align="center">
<col>
<it>Sum of digits''</it></col>
<col>
0</col>
<col>
2</col>
<col>
2</col>
<col>
1</col>
<col>
4</col>
<col>
5</col>
<col>
4</col>
</row>
</table>
</p>
<p>

The total sum of digits is <b>18</b>. Since it is divisible by 6, the check character is <b>valid</b>.</p>

</ss2>
</sec>
<sec>
<st>
 Implementation </st>

<p>

The mapping of characters to code-points and back can be implemented in a number of ways. The simplest approach (akin to the original Luhn algorithm) is to use ASCII code arithmetic. For example, given an input set of <it>0</it> to <it>9</it>, the code-point can be calculated by subtracting the ASCII code for '0' from the ASCII code of the desired character. The reverse operation will provide the reverse mapping. Additional ranges of characters can be dealt with by using conditional statements.</p>
<p>

Non-sequential sets can be mapped both ways using a hard-coded <it>switch/case</it> statement. A more flexible approach is to use something similar to an <link>
Associative Array</link>. For this to work, a pair of arrays is required to provide the two-way mapping.</p>
<p>

An additional possibility is to use an array of characters where the array indexes are the code-points associated with each character. The mapping from character to code-point can then be performed with a linear or binary search. In this case, the reverse mapping is just a simple array lookup.</p>

</sec>
<sec>
<st>
 Weakness </st>

<p>

This extension shares the same weakness as the original algorithm, namely, that it can't detect the transposition of the sequence <b>' to </b>' (or vice-versa). This is equivalent to the transposition of <it>09</it> to <it>90</it> (assuming a set of valid input characters from <it>0</it> to <it>9</it> in order). On a positive note, the larger the set of valid input characters, the smaller the impact of the weakness.</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://modp.com/release/checkdigits/">
Implementation in Java, JavaScript</weblink> at modp.com</entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
