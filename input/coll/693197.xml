<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:31:39[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Μ operator</title>
<id>693197</id>
<revision>
<id>234857758</id>
<timestamp>2008-08-28T21:00:34Z</timestamp>
<contributor>
<username>CBM</username>
<id>1108292</id>
</contributor>
</revision>
<categories>
<category>Recursion theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../414/155414.xml">
computability theory</link>, the <b>μ operator</b>, <b>minimization operator</b>, or <b>unbounded search operator</b> searches for the least natural number with a given property.
<sec>
<st>
 Definition </st>
<p>

Suppose that R( y, x1 , . . ., xk ) is a fixed <it>k+1</it>-ary relation on the natural numbers. The mu operator "μy", in either the unbounded or bounded form, is a "number theoretic function" defined from the natural numbers { 0, 1, 2, . . . }. to the natural numbers. However, "μy" contains a <it><link xlink:type="simple" xlink:href="../336/7178336.xml">
predicate</link></it> over the natural numbers that delivers <it>true</it> when the predicate is satisfied and <it>false</it> when it is not.</p>
<p>

The <it>bounded</it> mu operator appears earlier in Kleene (1952) <it>Chapter IX Primitive Recursive Functions, |45 Predicates, prime factor representation</it>, as:
<indent level="1">

"<math>\mu y_{y&amp;lt;z} R(y). \ \ \mbox{The least} \ y&amp;lt;z \ \mbox{such that} \ R(y), \ \mbox{if} \ (\exists y)_{y&amp;lt;z} R(y); \ \mbox{otherwise}, \ z.</math>" (p. 255)
</indent>

Kleene notes that any of the 6 inequality restrictions on the range of the variable y is permitted, i.e. "y  z", "y ≤ z", "w  y  z", "w  y ≤ z", "w ≤ y  z", "w ≤ y ≤ z". "When the indicated range contains no y such that R(y) [is "true"], the value of the "μy" expression is the cardinal number of the range"(p. 226); this is why the default "z" appears in the definition above. As shown below, the bounded mu operator "μyy" is defined in terms of two primitive recursive functions called the finite sum Σ and finite product Π, a predicate function that "does the test" and a <link xlink:type="simple" xlink:href="../790/240790.xml">
representing function</link> that converts { t, f } to { 0, 1 }.  </p>
<p>

In Chapter XI |57 General Recursive Functions, Kleene defines the <it>unbounded</it> μ-operator over the variable y in the following manner, 
<indent level="1">

"<math>(\exists y) \mu y R(y) = \{ \mbox{the least (natural number)}\ y \ \mbox{such that} \ R(y)\}</math>" (p. 279, where "<math>(\exists y)</math>" means "There exists a <it>y</it> such that..."
</indent>

In this instance R itself, or its <link xlink:type="simple" xlink:href="../790/240790.xml">
representing function</link>, delivers 0 when it is satisfied (i.e. delivers <it>true</it>); the function then delivers the number y. No upper bound exists on y, hence no inequality expressions appear in its definition. </p>
<p>

For a given R(y) the unbounded mu operator μyR(y) (note no requirement for "(Ey)" ) can result in a <link xlink:type="simple" xlink:href="../577/23577.xml">
total function</link> or <link xlink:type="simple" xlink:href="../577/23577.xml">
partial function</link>. Kleene writes this potentially-partial function in a different way (cf. p. 317):
<indent level="1">

εyR(x, y) =
</indent>
::* the least y such that R(x,y) [is true], if (Ey)R(x,y)
<list>
<entry level="3" type="bullet">

 0, otherwise.</entry>
</list>
</p>


</sec>
<sec>
<st>
 Properties </st>

<p>

(i) In context of the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive functions</link>, where the search variable y of the μ-operator is bounded, e.g. yy R( y, x1,..., xn ) is a primitive recursive function.</p>
<p>

(ii) In the context of the (total) <link xlink:type="simple" xlink:href="../264/5987264.xml">
recursive functions</link>: Where the search variable y is <it>unbounded</it> but guaranteed to exist for <it>all</it> values xi of the total recursive predicate R's parameters,
<indent level="1">

(x1), ..., (xn) (Ey) R( y, xi, ... xn ) implies that μyR(y, xi, ... xn) is a <link xlink:type="simple" xlink:href="../338/1139338.xml">
total recursive function</link>.
</indent>
:: here (xi) means "for all xi" and Ey means "there exists at least one value of y such that..." (cf Kleene (1952) p. 279.) </p>
<p>

then the five primitive recursive operators plus the unbounded-but-total μ-operator give rise to what Kleene called the "general" recursive functions (i.e. total functions defined by the six recursion operators). </p>
<p>

(iii) In the context of the <link xlink:type="simple" xlink:href="../338/1139338.xml">
partial recursive function</link>s: Suppose that the relation <it>R</it> holds if and only if a partial recursive function converges to zero. And suppose that that partial recursive function converges (to something, not necessarily zero) whenever <math>\mu y R(y,x_1,\ldots,x_k)</math> is defined and <it>y</it> is <math>\mu y R(y,x_1,\ldots,x_k)</math> or smaller. Then the function <math>\mu y R(y,x_1,\ldots,x_k)</math> is also a partial recursive function.</p>

<p>

The μ operator is used in the characterization of the computable functions as the  <link xlink:type="simple" xlink:href="../469/26469.xml">
μ recursive function</link>s.</p>

</sec>
<sec>
<st>
 Examples </st>

<ss1>
<st>
 Example #1: The bounded μ-operator is a primitive recursive function </st>

<p>

<indent level="1">

<it>In the following, to save space the bold-face x i.e. </it>'x<b> will represent the string xi, . . ., xn.</b></indent>

The <it>bounded</it> μ-operator  can be expressed rather simply in terms of two primitive recursive functions (hereafter "prf") that also are used to define the CASE function -- the product-of-terms Π and the sum-of-terms Σ (cf Kleene #B page 224). (As needed, any boundary for the variable such as s≤t or ts≤t fs (<b>x</b>, s) = f0(<b>x</b>, 0) * f1(<b>x</b>, 1) * . . . * ft(<b>x</b>, t)
<list>
<entry level="2" type="bullet">

Σt gt ( <b>x</b>, t ) = g0( <b>x</b>, 0 ) + g1(<b>x</b>, 1 ) + . . . + gz-1(<b>x</b>, z-1 )   </entry>
</list>
</p>
<p>

Before we proceed we need to introduce a function ψ called "the <link xlink:type="simple" xlink:href="../790/240790.xml">
representing function</link>" of predicate R. Function ψ is defined from inputs ( t= "truth", f="falsity" ) to outputs ( 0, 1 ) (<it>Observe the order!</it>). In this case the input to ψ i.e. { t, f } is coming from the output of R:
<list>
<entry level="2" type="bullet">

 ψ( R = t ) = 0</entry>
<entry level="2" type="bullet">

 ψ( R = f ) = 1</entry>
</list>
</p>
<p>

Kleene demonstrates that μyy R(y) is defined as follows; we see the product function Π is acting like a Boolean AND operator, and the sum Σ is acting somewhat like a Boolean OR but is producing { Σ≠0, Σ=0 }  rather than just { 1, 0 }: 
<indent level="1">

  μy y R(y) = Σt Πs≤t ψ( R( <b>x</b> ,t ,s )) =
</indent>
:* [ ψ( '''x''', 0, 0 ) ] <b>+</b> 
<list>
<entry level="2" type="bullet">

 [ ψ( '''x''', 1, 0 ) * ψ( '''x''', 1, 1 ) ] <b>+</b></entry>
<entry level="2" type="bullet">

 [ ψ( '''x''', 2, 0 ) * ψ( '''x''', 2, 1 ) * ψ( '''x''', 2, 2 ) ] <b>+</b> </entry>
<entry level="2" type="bullet">

  . . . . . . <b>+</b></entry>
<entry level="2" type="bullet">

 [ ψ( '''x''', z-1, 0 ) * ψ( '''x''', z-1, 1 ) * ψ( '''x''', z-1, 2 ) + . . . + ψ ( '''x''', z-1, z-1 ) ]</entry>
</list>
</p>
<p>

<indent level="1">

<it>Σ is actually a primitive recursion with the base Σ(</it>'x<b>, 0) = 0 and the induction step Σ(</b>x<b>, y+1 )  = Σ( </b>x<b>, y ) + Π( </b>x<b>, y ). The product Π is also a primitive recursion Π with base step Π( </b>x<b>, 0 ) = ψ( </b>x<b>, 0 ) and induction step Π( </b>x<b>, y+1 ) = Π( </b>x<b>, y )*ψ( </b>x<b>, y+1 ).
</b></indent>

The equation is easier if observed with an example, as given by Kleene. He just made up the entries for the representing function ψ(R(y)). He designated the representing functions χ(y) rather than ψ( <b>x</b>, y ):  
<table style="text-align: center; vertical-align: bottom;" class="wikitable">
<row>
<col width="209">
y</col>
<col width="24">
0</col>
<col width="24">
1</col>
<col width="24">
2</col>
<col style="background-color:#C0C0C0;" width="24">
<b>3</b></col>
<col width="24">
4</col>
<col width="24">
5</col>
<col width="24">
6</col>
<col width="25.2">
7=z</col>
</row>
<row>
<col>
χ(y)</col>
<col>
1</col>
<col>
1</col>
<col>
1</col>
<col style="background-color:#C0C0C0;font-weight:bold">
0</col>
<col>
1</col>
<col>
0</col>
<col>
0</col>

</row>
<row>
<col>
π(y) = Πs≤y χ(s)</col>
<col>
1</col>
<col>
1</col>
<col>
1</col>
<col style="background-color:#C0C0C0;font-weight:bold">
0</col>
<col>
0</col>
<col>
0</col>
<col>
0</col>
<col>
0</col>
</row>
<row>
<col>
σ(y) = Σt π(t)</col>
<col>
0</col>
<col>
1</col>
<col>
2</col>
<col style="background-color:#C0C0C0;">
<b>3</b></col>
<col>
3</col>
<col>
3</col>
<col>
3</col>
<col>
3</col>
</row>
<row>
<col>
least yy R(y)</col>



<col style="background-color:#C0C0C0;font-weight:bold">
3</col>




</row>
</table>
</p>

</ss1>
<ss1>
<st>
 Example #2: The unbounded μ-operator is not primitive-recursive </st>
<p>
      
The unbounded μ operator -- the function μy -- is the one commonly defined in the texts. But the reader may wonder why -- the modern texts do not state the reason -- the unbounded μ-operator is searching for a function R(<b>x</b>, y) to yield <it>zero</it>, rather than some other natural number. 
<indent level="1">

<it>In a footnote Minsky does allow his operator to terminate when the function inside produces a match to the parameter "k"; this example is also useful because it shows another author's format:</it>
</indent>
::" For μt[ φ(t) = k ] "(p. 210)</p>
<p>

The reason for <it>zero</it> is that the unbounded operator μy will be defined in terms of the function "product" Π with its index y allowed to "grow" as the μ operator searches. As noted in the example above, the product Π x of a string of numbers ψ(<b>x</b>, 0) *, . . ., * ψ(<b>x</b>, y) yields zero whenever one of its members ψ(<b>x</b>, i) is zero:
<indent level="1">

 Πs = ψ(<b>x</b>, 0) * , . . ., * ψ(<b>x</b>, y) = 0 
</indent>

if any ψ(<b>x</b>, i)=0 where 0 ≤ i ≤ s. Thus the Π is acting like a Boolean AND.      </p>
<p>

The function μy produces as "output" a single natural number y = { 0, 1, 2, 3 ... }. However, inside the operator one of a couple "situations" can appear: (a) a "number-theoretic function" χ that produces a single natural number, or (b) a "predicate" R that produces either { t= true, f = false }. (And, in the context of <it>partial</it> recursive functions Kleene later admits a third outcome: "μ = undecided", pp. 332ff ).</p>
<p>

Kleene splits his definition of the unbounded μ operator to handle the two situations (a) and (b). For situation (b), before the predicate R(<b>x</b>, y) can serve in an arithmetic capacity in the product Π, its output { t, f } must first be "operated on" by its <it>representing function χ</it>  to yield { 0, 1 }. And for situation (a) if one definition is to be used then the <it>number theoretic function χ</it> must produce zero to "satisfy" the μ operator. With this matter settled, he demonstrates with single "Proof III" that either types (a) or (b) together with the five primitive recursive operators yield the (total) <link xlink:type="simple" xlink:href="../264/5987264.xml">
recursive function</link>s ... with this proviso for a <link xlink:type="simple" xlink:href="../445/244445.xml">
total</link> function:
<indent level="1">

 <it>That for all parameters </it>'x<b>, a demonstration that must be provided to show that a y exists that satisfies (a) μy ψ(</b>x<b>, y) or (b) μy R(</b>x<b>,y).</b></indent>
::<it>Kleene also a third situation (c) that does not require the demonstration of "for all </it>'x<b> a y exists such that ψ(</b>x<b>, y). He uses this in his proof that more total recursive functions exist than can be enumerated;<it> cf footnote <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Total+function+demonstration%22])">
Total function demonstration</link>.</it></b></p>
<p>

Kleene's proof is informal and uses an example similar to the first example. Fbut first he casts the μ-operator into a different form that uses the "product-of-terms" Π operating on function χ that yields a natural number n where n can be any natural number, and 0 in the instance when the u operator's test is "satisfied".</p>
<p>

<indent level="1">

The definition recast with the Π-function:
</indent>
:μy yχ(y) =  
<list>
<entry level="2" type="bullet">

(i):  π(<b>x</b>, y) = Πs χ( <b>x</b>, s)</entry>
<entry level="3" type="bullet">

(ii): φ(<b>x</b>) = τ( π(<b>x</b>, y), π( <b>x</b>, y' ), y)</entry>
<entry level="3" type="bullet">

(iii): τ(z', 0, y) = y ;τ( u, v, w ) is undefined for u = 0 or v &amp;gt; 0.</entry>
</list>
</p>
<p>

This is subtle. At first glance the equations seem to be using primitive recursion. But Kleene has not provided us with a base step and an induction step of the general form:
<list>
<entry level="2" type="bullet">

 base step: φ( 0,<b>x</b> ) = φ( <b>x</b> )</entry>
<entry level="2" type="bullet">

 induction step: φ( 0,<b>x</b> ) = ψ( y, φ(0,<b>x</b>), <b>x</b> )</entry>
</list>
</p>
<p>

What is going on? First, we have to remind ourselves that we have assigned a parameter (a natural number) to every variable xi. Second, we do see a successor-operator at work iterating y (i.e. the y'). And third, we see that the function μy yχ(y, <b>x</b>) is just producing instances of χ(y,<b>x</b>) i.e. χ(0,<b>x</b>), χ(1,<b>x</b>), ... until an instance yields 0. Fourth, when an instance χ(n,<b>x</b>) yields 0 it causes the middle term of τ, i.e. v = π( <b>x</b>, y' ) to yield 0. Finally, when the middle term v = 0, μy yχ(y) executes line (iii) and "exits". Kleene's presentation of equations (ii) and (iii) have been exchanged to make this point that line (iii) represents  an <it>exit</it>  -- an exit taken only when the search successfully finds a y to satisfy χ(y) and the middle product-term π(<b>x</b>, y' ) is 0; the operator then terminates its search with τ(z', 0, y) = y.   
<indent level="1">

 τ( π(<b>x</b>, y), π( <b>x</b>, y' ), y), i.e.:
</indent>
:* τ( π(<b>x</b>, 0), π( <b>x</b>, 1 ), 0),  
<list>
<entry level="2" type="bullet">

 τ( π(<b>x</b>, 1), π( <b>x</b>, 2 ), 1)</entry>
<entry level="2" type="bullet">

 τ( π(<b>x</b>, 2), π( <b>x</b>, 3 ), 2) </entry>
<entry level="2" type="bullet">

 τ( π(<b>x</b>, 3), π( <b>x</b>, 4 ), 3) </entry>
<entry level="2" type="bullet">

 . . . . . until a match occurs at y=n and then:</entry>
<entry level="2" type="bullet">

 τ(z', 0, y) = τ(z', 0, n) = n and the μ operator's search is done.</entry>
</list>
</p>
<p>

For the example Kleene "...consider[s] any fixed values of xi, ... xn) and write[s] simply "χ(y)" for "χ(xi, ... xn),y)":
<table style="text-align: center; vertical-align: bottom;" class="wikitable">
<row>
<col width="208.8">
y</col>
<col width="24">
0</col>
<col width="24">
1</col>
<col width="24">
2</col>
<col style="background-color:#C0C0C0;" width="24">
<b>3</b></col>
<col width="24">
4</col>
<col width="24">
5</col>
<col width="24">
6</col>
<col width="25.2">
7</col>
<col width="25.2">
etc</col>
</row>
<row>
<col>
χ(y)</col>
<col>
3</col>
<col>
1</col>
<col>
2</col>
<col style="background-color:#C0C0C0;">
<b>0</b></col>
<col>
9</col>
<col>
0</col>
<col>
1</col>
<col>
5</col>
<col style="font-weight:bold">
. . .</col>
</row>
<row>
<col>
π(y) = Π s≤y χ(s)</col>
<col>
1</col>
<col>
3</col>
<col>
3</col>
<col style="background-color:#C0C0C0;">
<b>6</b></col>
<col>
0</col>
<col>
0</col>
<col>
0</col>
<col>
0</col>
<col style="font-weight:bold">
. . .</col>
</row>
<row>




<col style="background-color:#C0C0C0">
<b>↑</b></col>





</row>
<row>
<col>
least y1, r2, z)</col>
<col style="text-align:center;">
none</col>
<col style="text-align:center;">
 IF [ r1 ] = [ r2 ] THEN z → IR ELSE [ IR ]+1 → IR</col>
</row>
<row>
<col>
Halt</col>
<col>
H</col>
<col style="text-align:center;">
none</col>
<col style="text-align:center;">
 [ IR ]→ IR</col>
</row>
</table>
</p>
<p>

The algorithm for the minimization operator μy [φ( '''x''', y )] will, in essence, create a sequence of instances of the function φ( <b>x</b>, y ) as the value of parameter y (a natural number) increases; the process will continue (see Note † below) until a match occurs between the output of function φ( <b>x</b>, y ) and some pre-established number (usually 0). Thus the evaluation of φ(<b>x</b>, y) requires, at the outset, assignment of a natural number to each of its variables <b>x</b> and an assignment of a "match-number" (usually 0) to a register "w", and a number (usually 0) to register y.</p>
<p>

<indent level="1">

<it>Note †: The </it>unbounded<it> μ operator will continue this attempt-to-match process ad infinitum or until a match occurs. Thus the "y" register must be unbounded -- it must be able to "hold" a number of arbitrary size. Unlike a "real" computer model, abstract machine models allow this. In the case of a </it>bounded<it> μ operator, a lower-bounded μ operator would start with the contents of y set to a number other than zero. An upper-bounded μ operator would require an additional register "ub" to contain the number that represents the upper bound plus an additional comparison operation; an algorithm could provide for both lower- and upper bounds.</it>
</indent>

In the following we are assuming that the Instruction Register (IR) encounters the μy "routine" at instruction number "n". Its first action will be to establish a number in a dedicated "w" register -- an "example of" the number that function φ( <b>x</b>, y ) must produce before the algorithm can terminate (classically this is the number zero, but see the footnote about the use of numbers other than zero). The algorithm's next action at instructiton "n+1" will be to clear the "y" register -- "y" will act as an "up-counter" that starts from 0. Then at instruction "n+2" the algorithm evaluates its function φ( <b>x</b>, y ) -- we assume this takes j instructions to accomplish -- and at the end of its evaluation φ( <b>x</b>, y ) deposits its output in register "φ". At the n+j+3rd instruction the algorithm compares the number in the "w" register (e.g. 0) to the number in the "φ" register -- if they are the same the algorithm has succeeded and it escapes through <it>exit</it>; otherwise it increments the contents of the "y" register and <it>loops</it> back with this new y-value to test function φ( <b>x</b>, y ) again.</p>
<p>

<table style="vertical-align: bottom;" class="wikitable">
<row>
<header>
IR</header>

<header>
Instruction</header>
<header>
Action on register</header>
<header>
Action on Instruction Register IR</header>
</row>
<row>
<col>
n</col>
<col>
 μy[ φ( '''x''', y ) ]:</col>
<col>
CLR ( w )</col>
<col style="text-align:center;">
0 → w</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+1</col>

<col>
CLR ( y )</col>
<col style="text-align:center;">
0 → y</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+2</col>
<col>
<it>loop:''</it></col>
<col>
φ ( <b>x</b>, y )</col>
<col style="text-align:center;">
 φ( ['''x'''], [y]) → φ</col>
<col>
 [ IR ]+j+1 → IR</col>
</row>
<row>
<col>
n+j+3</col>

<col>
JE (φ, w, exit)</col>
<col style="text-align:center;">
none</col>
<col>
 CASE: { IF [φ]=[w] THEN <it>exit</it> → IR ELSE [IR]+1 → IR }</col>
</row>
<row>
<col>
n+j+4</col>

<col>
INC ( y )</col>
<col style="text-align:center;">
 [ y ]+1 → y</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+j+5</col>

<col>
JE (0, 0, loop)</col>
<col style="text-align:center;">
Unconditional jump</col>
<col>
 CASE: { IF [r0] =[r0]THEN <it>loop</it> → IR ELSE <it>loop</it> → IR }</col>
</row>
<row>
<col>
n+j+6</col>
<col>
<it>exit:''</it></col>
<col>
<it>etc.''</it></col>


</row>
</table>
</p>

</ss1>
</sec>
<sec>
<st>
 Footnotes </st>

<ss1>
<st>
 Total function demonstration </st>

<p>

What is <it>mandatory</it> if the function is to be a <link xlink:type="simple" xlink:href="../577/23577.xml">
total function</link> is a demonstration <it>by some other method</it> (e.g. <link xlink:type="simple" xlink:href="../877/14877.xml">
induction</link>) that for each and every combination of values of its parameters xi some natural number y will satisfy the μ-operator so that the algorithm that represents the calculation can terminate:
<indent level="1">

"...we must always hesitate to assume that a system of equations really defines a general-recursive [i.e. total] function. We normally require auxiliary evidence for this, e.g. in the form of an inductive proof that, for each argument value, the computation terminates with a unique value." (Minsky (1967) p. 186)
</indent>

<indent level="1">

"In other words, we should not claim that a function is effectively calculable on the ground that it has been shown to be general [i.e. total] recursive, unless the demonstration that it is general recursive is effective."(Kleene (1952) p. 319)
</indent>

For an example of what this means in practice see the examples at <link xlink:type="simple" xlink:href="../469/26469.xml">
mu recursive function</link>s -- even the simplest ("improper") subtraction algorithm "x - y = d" can yield, for the undefined cases when x  y, (1) no termination, (2) no numbers (i.e. something wrong with the format so the yield is not considered a natural number), or (3) deceit: wrong numbers in the correct format. The "proper" subtraction algorithm requires careful attention to all the "cases" 
<indent level="1">

(x, y) = { (0, 0), (a, 0), (0, b), (a≥b, b), (a=b, b), (aj, rk, z) }      
</indent>

<table style="text-align:center; " class="wikitable">
<row>
<header>
IR</header>

<header>
Instruction</header>
<header>
Action on register</header>
<header>
Action on Instruction Register, IR</header>
</row>
<row>
<col>
n</col>
<col>
<b>μy φ( x ):</b></col>
<col style="text-align:left;">
CLR ( w )</col>
<col>
0 → w</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+1</col>

<col style="text-align:left;">
CLR ( t )</col>
<col>
0 → t</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+2</col>
<col>
<it>loop:''</it></col>
<col style="text-align:left;">
φ ( y, x )</col>
<col>
 φ( [ t ], [ x ]) → φ</col>
<col>
 [ IR ]+j+1 → IR</col>
</row>
<row>
<col>
n+j+3</col>

<col style="text-align:left;">
INC ( t )</col>
<col>
 [ t ]+1 → t</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+j+4</col>

<col style="text-align:left;">
JNE (φ, w, loop)</col>
<col>
none</col>
<col>
 CASE: {  IF [φ] ≠ [w] THEN "exit" → IR  ELSE [IR]+1 → IR }</col>
</row>
<row>
<col>
n+j+5</col>

<col style="text-align:left;">
INC ( t )</col>
<col>
 [ t ]+1 → t</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+j+6</col>
<col>
<it>exit:''</it></col>
<col>
<it>etc</it>.</col>


</row>
</table>
</p>
<p>

The unbounded μ operator is also defined by Boolos-Burgess-Jeffrey (2002) p. 60-61 for a counter machine with an instruction set equivalent to the following:
<indent level="1">

 { CLR (r), INC (r), DEC (r), JZ (r, z), H }
</indent>

In this version the counter "y" is called "r2", and the function f( <b>x</b>, r2 ) deposits its number in register "r3". Perhaps the reason Boolos-Burgess-Jeffrey clear r3 is to facilitate an unconditional jump to <it>loop</it>; this is often done by use of a dedicated register "0" that contains "0":</p>
<p>

<table style="text-align:center; vertical-align:bottom;" class="wikitable">
<row>
<header>
IR</header>

<header>
Instruction</header>
<header>
Action on register</header>
<header>
Action on Instruction Register, IR</header>
</row>
<row>
<col>
n</col>
<col>
 <b>μr2[f(x, r2)]:</b></col>
<col style="text-align:left;">
CLR ( r2 )</col>
<col>
0 → r2</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+1</col>
<col>
loop:</col>
<col style="text-align:left;">
f( y, x )</col>
<col>
 f( [ t ], [ x ]) →r3</col>
<col>
 [ IR ]+j+1 → IR</col>
</row>
<row>
<col>
n+2</col>

<col style="text-align:left;">
JZ ( r3, exit )</col>
<col>
none</col>
<col>
 IF [ r3 ] = 0 THEN exit → IR ELSE [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+j+3</col>

<col style="text-align:left;">
CLR ( r3 )</col>
<col>
0 → r3</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+j+4</col>

<col style="text-align:left;">
INC ( r2 )</col>
<col>
 [ r2  ]+1 → r2</col>
<col>
 [ IR ]+1 → IR</col>
</row>
<row>
<col>
n+j+5</col>

<col style="text-align:left;">
JZ ( r3, loop)</col>

<col>
 CASE: {  IF [ r3 ] =0 THEN loop → IR ELSE [IR]+1 → IR }</col>
</row>
<row>
<col>
n+j+6</col>
<col>
<it>exit:''</it></col>
<col>
<it>etc</it>.</col>


</row>
</table>
</p>

</ss1>
</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../805/28805.xml">
Stephen Kleene</link> (1952) <it>Introduction to Metamathematics</it>, North-Holland Publishing Company, New York, 11th reprint 1971: (2nd edition notes added on 6th reprint).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../639/19639.xml">
Marvin L. Minsky</link> (1967), <it>Computation: Finite and Infinite Machines</it>, Prentice-Hall, Inc. Englewood Cliffs, N.J. </entry>
<entry level="1" type="indent">

On pages 210-215 Minsky shows how to create the μ-operator using the register machine model, thus demonstrating its equivalence to the general recursive functions.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

<person wordnetid="100007846" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../621/340621.xml">
George Boolos</link></person>
, <link xlink:type="simple" xlink:href="../094/14386094.xml">
John Burgess</link>, <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<logician wordnetid="110269785" confidence="0.8">
<link xlink:type="simple" xlink:href="../354/4294354.xml">
Richard Jeffrey</link></logician>
</causal_agent>
</person>
</expert>
</physical_entity>
 (2002), <it>Computability and Logic: Fourth Edition</it>, Cambridge University Press, Cambridge, UK. Cf pp. 70-71.</entry>
</list>
</p>


</sec>
</bdy>
</article>
