<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:50:49[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Simple LR parser</title>
<id>70104</id>
<revision>
<id>235627555</id>
<timestamp>2008-09-01T17:21:51Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Parsing algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>Simple LR parser</b> or <b>SLR parser</b> is created by an SLR parser generator which reads a <link xlink:type="simple" xlink:href="../247/62247.xml">
BNF grammar</link> and constructs an <link xlink:type="simple" xlink:href="../030/18030.xml">
LR(0)</link> state machine and computes the look-aheads sets for each reduction in a state by examining the Follow Set for the nonterminal associated with the reduction.  The Follow Set for each nonterminal symbol is computed by seeing which terminal symbols follow the nonterminal symbol in the rules of the BNF grammar.  It is useful to have the First Set already computed when creating the Follow Set. <p>

At runtime, the SLR parser will perform a reduction based on a grammar rule <it>A</it> → <it>w</it> if the next symbol in the input stream is in the Follow Set of <it>A</it> (see <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/58045.xml">
LL parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for a definition  of Follow Set, and <weblink xlink:type="simple" xlink:href="http://www.jambe.co.nz/UNI/FirstAndFollowSets.html">
http://www.jambe.co.nz/UNI/FirstAndFollowSets.html</weblink>).</p>
<p>

The problem with SLR parsers is that the computation of the look-ahead sets is too simplistic, using only the rules of the grammar to determine look-ahead sets.  The more accurate way to determine look-ahead sets is to examine the nonterminal transitions in each state within the LR(0) state machine.  These more accurate look-ahead sets are called the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/18004.xml">
LALR(1)</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 look-ahead sets.</p>
<p>

An SLR parser will typically have more conflict states than an <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/18004.xml">
LALR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.  For real-world computer languages, an SLR parser is usually not adequate, but for student projects in a compiler class it is a good learning tool. </p>
<p>

A grammar that has no conflicts reported by an SLR parser generator is an <it>SLR grammar</it>.</p>

<sec>
<st>
 Algorithm </st>

<p>

The SLR parsing algorithm</p>
<p>

Initialize the stack with S
Read input symbol
while (true)
if Action(top(stack), input) = S
NS - Goto(top(stack),input)
push NS
Read next symbol
else if Action(top(stack), input) = Rk
output k
pop |RHS| of production k from stack
NS - Goto(top(stack), LHS_k)
push NS
else if Action(top(stack),input) = A
output valid, return
else
output invalid, return</p>

</sec>
<sec>
<st>
 Example </st>

<p>

A grammar that can be parsed by an SLR parser but not by an LR(0) parser is the following:</p>
<p>

<indent level="1">

 (1) E → 1 E
</indent>
: (2) E → 1</p>
<p>

Constructing the action and goto table as is done for LR(0) parsers would give the following item sets and tables:</p>
<p>

<indent level="1">

 <b>Item set 0</b>
</indent>
: S → • E
<indent level="1">

 + E → • 1 E
</indent>
: + E → • 1</p>
<p>

<indent level="1">

 <b>Item set 1</b>
</indent>
: E → 1 • E
<indent level="1">

 E → 1 •
</indent>
: + E → • 1 E
<indent level="1">

 + E → • 1
</indent>

<indent level="1">

 <b>Item set 2</b>
</indent>
: S → E •</p>
<p>

<indent level="1">

 <b>Item set 3</b>
</indent>
: E → 1 E •</p>
<p>

The action and goto tables:</p>

<p>

<table align="center" border="1">
<row align="center">

<col colspan="2">
<it>action''</it></col>
<col>
<it>goto''</it></col>
</row>
<row align="center">
<col>
<it>state''</it></col>
<col>
<b>1</b></col>
<col>
<b>$</b></col>
<col>
<b>E</b></col>
</row>
<row align="center">
<col>
<b>0</b></col>
<col>
s1</col>

<col>
2</col>
</row>
<row align="center">
<col>
<b>1</b></col>
<col>
s1/r2</col>
<col>
r2</col>
<col>
3</col>
</row>
<row align="center">
<col>
<b>2</b></col>

<col>
acc</col>

</row>
<row align="center">
<col>
<b>3</b></col>
<col>
r1</col>
<col>
r1</col>

</row>
</table>
</p>

<p>

As can be observed there is a shift-reduce conflict for state 1 and terminal '1'. However, the follow set of E is { $ } so the reduce actions r1 and r2 are only valid in the column for $. The result are the following conflict-less action and goto table:</p>

<p>

<table align="center" border="1">
<row align="center">

<col colspan="2">
<it>action''</it></col>
<col>
<it>goto''</it></col>
</row>
<row align="center">
<col>
<it>state''</it></col>
<col>
<b>1</b></col>
<col>
<b>$</b></col>
<col>
<b>E</b></col>
</row>
<row align="center">
<col>
<b>0</b></col>
<col>
s1</col>

<col>
2</col>
</row>
<row align="center">
<col>
<b>1</b></col>
<col>
s1</col>
<col>
r2</col>
<col>
3</col>
</row>
<row align="center">
<col>
<b>2</b></col>

<col>
acc</col>

</row>
<row align="center">
<col>
<b>3</b></col>

<col>
r1</col>

</row>
</table>
</p>


</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../030/18030.xml">
LR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../045/58045.xml">
LL parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../004/18004.xml">
LALR parser</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
