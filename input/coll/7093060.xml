<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:46:36[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<artifact  confidence="0.8" wordnetid="100021939">
<instrumentality  confidence="0.8" wordnetid="103575240">
<apparatus  confidence="0.8" wordnetid="102727825">
<generator  confidence="0.8" wordnetid="103434188">
<equipment  confidence="0.8" wordnetid="103294048">
<header>
<title>Ziggurat algorithm</title>
<id>7093060</id>
<revision>
<id>240746163</id>
<timestamp>2008-09-24T20:42:36Z</timestamp>
<contributor>
<username>Neo-Jay</username>
<id>561624</id>
</contributor>
</revision>
<categories>
<category>Pseudorandom number generators</category>
</categories>
</header>
<bdy>

The <b>ziggurat algorithm</b> is an algorithm to generate random numbers from a non-<link xlink:type="simple" xlink:href="../835/5509835.xml">
uniform distribution</link>.  It belongs to the class of <link xlink:type="simple" xlink:href="../022/502022.xml">
rejection sampling</link> algorithms and can be used for choosing values from a <link xlink:type="simple" xlink:href="../260/48260.xml">
monotone decreasing</link> <link xlink:type="simple" xlink:href="../543/23543.xml">
probability distribution</link>.  It can also be applied to <link xlink:type="simple" xlink:href="../460/364460.xml">
symmetric</link> <link xlink:type="simple" xlink:href="../087/1432087.xml">
unimodal distribution</link>s such as the <link xlink:type="simple" xlink:href="../462/21462.xml">
normal distribution</link> by choosing a point from one half and then randomly choosing a half.  It was developed by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<teacher wordnetid="110694258" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../043/2167043.xml">
George Marsaglia</link></educator>
</mathematician>
</professional>
</teacher>
</adult>
</scientist>
</causal_agent>
</person>
</physical_entity>
 and Wai Wan Tsang.<p>

Like most such algorithms, it assumes an underlying source of uniformly-distributed random numbers, typically a <link xlink:type="simple" xlink:href="../524/45524.xml">
pseudo-random number generator</link>.  In the common case (97.5% of the time for normal and <link xlink:type="simple" xlink:href="../906/45906.xml">
exponential distribution</link>s with typical table sizes), the algorithm consists of generating a random floating-point value, a random table index, performing one table lookup, one multiply and one comparison.  This is considerably faster than the two more commonly used methods to generate normally distributed random numbers, the <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../655/11310655.xml">
Marsaglia polar method</link></equipment>
</method>
</generator>
</apparatus>
</know-how>
</instrumentality>
</artifact>
 or the <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../758/60758.xml">
Box-Muller transform</link></method>
</know-how>
, which require at least a logarithm and a square root.</p>
<p>

On the other hand, the ziggurat algorithm is more complex to implement and requires precomputed tables, so it is best used when large quantities of random numbers are required.</p>
<p>

The ziggurat algorithm is so named because it covers the probability distribution with rectangular segments stacked in decreasing size order, resembling a <link xlink:type="simple" xlink:href="../746/81746.xml">
ziggurat</link>.</p>
<p>

<image width="300px" src="ziggurat.gif" type="thumb">
<caption>

The Ziggurat algorithm used to generate sample values with a <link xlink:type="simple" xlink:href="../462/21462.xml">
normal distribution</link>. (Only positive values are shown for simplicity.) The pink dots are initially uniform-distributed random numbers. The desired distribution function is first segmented into equal areas "A".  One layer <it>i</it> is selected at random by the uniform source at the left. Then a random value from the top source is multipled by the width of the chosen layer, and the result is <it>x</it> tested to see which region of the slice it falls into with 3 possible outcomes: 1) (left, solid black region) the sample clearly under the curve and is passed directly to output, 2) (right, vertically striped region) the sample value may lie under the curve, and must be tested further.  In that case, a random <it>y</it> value within the chosen layer is generated and compared to <it>f(x)</it>.  If less, the point is under the curve and the value <it>x</it> is output.  If not, (the third case), the chosen point <it>x</it> is rejected and the algorithm is restarted from the beginning.
</caption>
</image>
</p>

<sec>
<st>
Theory of operation</st>
<p>

The ziggurat algorithm is a rejection sampling algorithm; it randomly generates a point in a distribution slightly larger than the desired distribution, then tests whether the generated point is inside the desired distribution.  If not, it tries again.  Given a random point underneath a probability distribution curve, its <it>x</it> coordinate is a random number with the desired distribution.</p>
<p>

The distribution the ziggurat algorithm chooses from is made up of <it>n</it> equal-area regions; <it>n</it>−1 rectangles that cover the bulk of the desired distribution, on top of a non-rectangular base that includes the tail of the distribution.</p>
<p>

Given a monotone decreasing probability distribution function <it>f</it>(<it>x</it>), defined for all <it>x</it>≥0, the base of the ziggurat is defined as all points inside the distribution and below <it>y</it>1 = <it>f</it>(<it>x</it>1).  This consists of a rectangular region from (0, 0) to (<it>x</it>1, <it>y</it>1), and the (typically infinite) tail of the distribution, where <it>x</it> &amp;gt; <it>x</it>1 (and <it>y</it>  <it>y</it>1).</p>
<p>

This layer has area <it>A</it>.  On top of this, add a rectangular layer of width <it>x</it>1 and height <it>A</it>/<it>x</it>1, so it also has area <it>A</it>.  The top of this layer is at height <it>y</it>2 = <it>y</it>1 + <it>A</it>/<it>x</it>1, and intersects the distribution function at a point (<it>x</it>2, <it>y</it>2), where <it>y</it>2 = <it>f</it>(<it>x</it>2).  This layer includes every point in the distibution function between <it>y</it>1 and <it>y</it>2, but (unlike the base layer) also includes points such as (<it>x</it>1, <it>y</it>2) which are not in the desired distribution.</p>
<p>

Further layers are then stacked on top.  To use a precomputed table of size <it>n</it> (<it>n</it>=256 is typical), one chooses <it>x</it>1 such that <it>xn</it>=0, meaning that the top box, box <it>n</it>, reaches the distribution's peak at (0, <it>f</it>(0)) exactly.</p>
<p>

Layer <it>i</it> extends vertically from <it>yi</it> to <it>yi</it>+1, and can be divided into two regions horizontally: the (generally larger) portion from 0 to <it>xi</it>+1 which is entirely contained within the desired distribution, and the (small) portion from <it>xi</it>+1 to <it>xi</it>, which is only partially contained.</p>
<p>

Ignoring for a moment the problem of layer 0, and given uniform random variables <it>U</it>0 and <it>U</it>1&nbsp;∈ [0,1), the ziggurat algorithm can be described as:

# Choose a random layer 0 ≤ ''i''  ''n''. 
# Let ''x'' = ''U''0''x''''i''.
# If ''x''  ''x''''i''+1, return ''x''.
# Let ''y'' = ''y''''i'' + ''U''1(''y''''i''+1−''y''''i'').
# Compute ''f''(''x'').  If ''y''  ''f''(''x''), return ''x''.
# Otherwise, choose new random numbers and go back to step 1.

Step 1 amounts to choosing a low-resolution ''y'' coordinate.  Step 3 tests if the ''x'' coordinate is clearly within the desired distribution function without knowing more about the y coordinate.  If it is not, step 4 chooses a high-resolution y coordinate and step 5 does the rejection test.

With closely spaced layers, the algorithm terminates at step 3 a very large fraction of the time.  Note that for the top layer ''n''−1, however, this test always fails, because ''x''''n'' = 0.

Layer 0 can also be divided into a central region and an edge, but the edge is an infinite tail.  To use the same algorithm to check if the point is in the central region, generate a fictitious ''x''0 = ''A''/''y''''1''.  This will generate points with ''x''  ''x''''1'' with the correct frequency, and in the rare case that layer 0 is selected and ''x'' ≥ ''x''''1'', use a special fallback algorithm to select a point at random from the tail.  Because the fallback algorithm is used less than one time in a thousand, speed is not essential.

Thus, the full ziggurat algorithm for one-sided distributions is:

# Choose a random layer 0 ≤ ''i''  ''n''.
# Let ''x'' = ''U''0''x''''i''
# If ''x''  ''x''''i''+1, return ''x''.
# If ''i''=0, generate a point from the tail using the fallback algorithm.
# Let ''y'' = ''y''''i'' + ''U''1(''y''''i''+1−''y''''i'').
# Compute ''f''(''x'').  If ''y''  ''f''(''x''), return ''x''.
# Otherwise, choose new random numbers and go back to step 1.

For a two-sided distribution, of course, the result must be negated 50% of the time.  This can often be done conveniently by choosing ''U''0 ∈ (−1,1) and, in step 3, testing if |''x''|  ''x''''i''+1.

===Fallback algorithms for the tail===
Because the ziggurat algorithm only generates ''most'' outputs very rapidly, and requires a fallback algorithm for outliers, it is always more complex than a more direct implementation.  The fallback algorithm, of course, depends on the distribution.

For an exponential distribution, the tail looks just like the body of the distribution.  One way is to fall back to the most elementary algorithm ''E''=−ln(''U''1) and let ''x''=''x''''1''−ln(''U''1).  Another is to call the ziggurat algorithm [[recursion|recursively]].

For a normal distribution, Marsaglia suggests a compact algorithm:

# Let ''x'' = −ln(''U''1)/''x''1
# Let ''y'' = −ln(''U''2)
# If 2''y'' &amp;gt; x², return ''x''+''x''1
# Otherwise, go back to step 1.

Since ''x''''1'' ≈ 3.5 for typical table sizes, the test in step 3 is almost always successful.  Note also that −ln(''U'') is just a simple way to generate an exponentially distributed random number; if you have a ziggurat exponential distribution generator available, you can use it instead.

===Optimizations===
The algorithm can be performed efficiently with precomputed tables of ''x''''i'' and ''y''''i'' = ''f''(''x''''i''), but there are some modifications to make it even faster:
* Nothing in the ziggurat algorithm depends on the probability distribution function being normalized (integral under the curve equal to 1); removing [[normalizing constant]]s can speed up the computation of ''f''(''x'').
* Most uniform random number generators are based on integer random number generators which return an integer in the range [0,&nbsp;232−1].  A table of 2−32<it>x</it>i lets you use such numbers directly for <it>U</it>0.
<list>
<entry level="1" type="bullet">

 When computing two-sided distributions using a two-sided <it>U</it>0 as described earlier, the random integer can be interpreted as a signed number in the range [−231,&nbsp;231−1] and a scale factor of 2−31 can be used.</entry>
<entry level="1" type="bullet">

 Rather than comparing the result of the multiplication in step 3, it is possible to precompute <it>xi</it>+1/<it>xi</it> and compare <it>U</it>0 with that directly.  If <it>U</it>0 is an integer random number generator, these limits may be premultiplied by 232 (or 231, as appropriate) so an integer comparison can be used.</entry>
<entry level="1" type="bullet">

 With the above two changes, the table of unmodified <it>xi</it> values is no longer needed and may be deleted.</entry>
<entry level="1" type="bullet">

 When generating <link xlink:type="simple" xlink:href="../039/405039.xml">
IEEE 754</link> single-precision floating point values, which only have a 24-bit mantissa (including the implicit leading 1), the least-significant bits of a 32-bit integer random number are not used.  These bits may be used to select the layer number.  (See the references below for a detailed discussion of this.)</entry>
<entry level="1" type="bullet">

 The first three steps may be put into an <link xlink:type="simple" xlink:href="../330/428330.xml">
inline function</link>, which can call an out-of-line implementation of the less frequently needed steps.</entry>
</list>
</p>

<ss1>
<st>
Generating the tables</st>
<p>

It is possible to store the entire table precomputed, or just include the values <it>n</it>, <it>y1</it>, <it>A</it>, and an implementation of <it>f</it>&amp;thinsp;−1(<it>x</it>) in the source code, and compute the remaining values when initializing the random number generator.</p>
<p>

As previously described, you can find <it>xi</it> = <it>f</it>&amp;thinsp;−1(<it>yi</it>) and <it>yi+1</it> = <it>yi</it>−<it>A</it>/<it>xi</it>.  Repeat <it>n</it>−1 times for the layers of the ziggurat.  At the end, you should have <it>yn</it>=<it>f</it>(0).  There will, of course, be some <link xlink:type="simple" xlink:href="../450/432450.xml">
round-off error</link>, but it is a useful <link xlink:type="simple" xlink:href="../893/39893.xml">
sanity test</link> to see that it is acceptably small.</p>
<p>

When actually filling in the table values, just assume that <it>xn</it>=0 and <it>yn</it>=<it>f</it>(0), and accept the slight difference in layer <it>n</it>−1's area as rounding error.</p>

</ss1>
<ss1>
<st>
Finding <it>x</it>1 and <it>A''</it></st>
<p>

Given an initial (guess at) <it>x</it>1, you need a way to compute the area <it>t</it> of the tail for which <it>x</it>&amp;gt;<it>x</it>1.  For the exponential distribution,  this is just <it>e</it>−<it>x</it>1, while for the normal distribution, assuming you are using the unnormalized <it>f</it>(<it>x</it>) = <it>e</it>−<it>x</it>²/2, this is √(π/2)<link xlink:type="simple" xlink:href="../111/177111.xml">
erfc</link>(<it>x</it>/√2).  For more awkward distributions, <link xlink:type="simple" xlink:href="../089/170089.xml">
numerical integration</link> may be required.</p>
<p>

With this in hand, from <it>x</it>1, you can find <it>y1</it> = <it>f</it>(<it>x</it>1), the area <it>t</it> in the tail, and the area of the base layer <it>A</it> = <it>x</it>1<it>y</it>1 + t.</p>
<p>

The compute the series <it>yi</it> and <it>xi</it> as above.  If <it>yi</it> &amp;gt; <it>f</it>(0) for any <it>i</it>  <it>n</it>, then the initial estimate <it>x</it>0 was too low, leading to too large an area <it>A</it>.  If <it>yn</it>  <it>f</it>(0), then the initial estimate <it>x</it>0 was too high.</p>
<p>

Given this, use a <link xlink:type="simple" xlink:href="../299/153299.xml">
root-finding algorithm</link> (such as the <link xlink:type="simple" xlink:href="../651/646651.xml">
bisection method</link>) to find the value <it>x</it>1 which produces <it>yn</it>−1 as close to <it>f</it>(0) as possible.  Alternatively, look for the value which makes the area of the topmost layer, <it>xn</it>−1(<it>f</it>(0)−<it>yn</it>−1), as close to the desired value <it>A</it> as possible.  This saves one evaluation of <it>f</it>&amp;thinsp;−1(<it>x</it>) and is actually the condition of greatest interest.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../758/60758.xml">
Box-Muller transform</link></method>
</know-how>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../939/2736939.xml">
Random number generator</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

  <cite style="font-style:normal"><physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<adult wordnetid="109605289" confidence="0.8">
<teacher wordnetid="110694258" confidence="0.8">
<professional wordnetid="110480253" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<educator wordnetid="110045713" confidence="0.8">
<link xlink:type="simple" xlink:href="../043/2167043.xml">
George Marsaglia</link></educator>
</mathematician>
</professional>
</teacher>
</adult>
</scientist>
</causal_agent>
</person>
</physical_entity>
; Wai Wan Tsang&#32;(2000).&#32;"<weblink xlink:type="simple" xlink:href="http://www.jstatsoft.org/v05/i08/paper">
The Ziggurat Method for Generating Random Variables</weblink>". <it>Journal of Statistical Software</it>&#32;<b>5</b>&#32;(8). Retrieved on <link>
2007-06-20</link>.</cite>&nbsp;  Note that this paper numbers the layers from 1 starting at the top, and makes layer 0 at the bottom a special case, while the explanation above numbers layers from 0 at the bottom.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.jstatsoft.org/v05/i08/supp/1">
C implementation of the ziggurat method for the normal density function and the exponential density function</weblink>, that is essentially a copy of the code in the paper.</entry>
<entry level="1" type="bullet">

 Jurgen A. Doornik&#32;(2005).&#32;"<it><weblink xlink:type="simple" xlink:href="http://www.doornik.com/research/ziggurat.pdf">
An Improved Ziggurat Method to Generate Normal Random Samples</weblink></it>". &#32;Nuffield College, Oxford.&#32;Retrieved on <link>
2007-06-20</link>.  Describes the hazards of using the least-significant bits of the integer random number generator to choose the layer number.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.mathworks.com/company/newsletters/news_notes/clevescorner/spring01_cleve.html">
Ziggurat algorithm generates normally distributed random numbers</weblink> describing the ziggurat algorithm introduced in <software wordnetid="106566077" confidence="0.9508927676800064">
<programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../412/20412.xml">
MATLAB</link></programming_language>
</software>
 version 5.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal">David B. Thomas; Philip G.W. Leong; Wayne Luk; John D. Villasenor&#32;(2007).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cse.cuhk.edu.hk/~phwl/mt/public/archives/papers/grng_acmcs07.pdf">
Gaussian Random Number Generators</weblink>". <it>ACM Computing Surveys</it>&#32;<b>39</b>&#32;(to appear). Retrieved on <link>
2007-06-20</link>.</cite>&nbsp;  Tests many algorithms for generating normal (a.k.a. <link xlink:type="simple" xlink:href="../462/21462.xml">
Gaussian</link>) random numbers, and concludes that "when maintaining extremely high noise quality is the first priority, and subject to that constraint, speed is also desired, the Ziggurat method will often be the most appropriate choice."</entry>
</list>
</p>


</sec>
</bdy>
</equipment>
</generator>
</apparatus>
</instrumentality>
</artifact>
</article>
