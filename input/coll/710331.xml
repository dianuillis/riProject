<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:32:56[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Force-based algorithms</title>
<id>710331</id>
<revision>
<id>244571854</id>
<timestamp>2008-10-11T14:16:09Z</timestamp>
<contributor>
<username>Darth Panda</username>
<id>580942</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>

<b>Force-based</b> or <b>force-directed</b> algorithms are a class of <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s for <link xlink:type="simple" xlink:href="../813/325813.xml">
drawing graphs</link> in an aesthetically pleasing way. Their purpose is to position the nodes of a <link xlink:type="simple" xlink:href="../806/325806.xml">
graph</link> in two dimensional or three dimensional space so that all the edges are of more or less equal length and there are as few crossing edges as possible.<p>

The force-directed algorithms achieve this by assigning forces amongst the set of edges and the set of nodes; the most straightforward method is to assign forces as if the edges were <link xlink:type="simple" xlink:href="../617/316617.xml">
springs</link> (see <link xlink:type="simple" xlink:href="../553/229553.xml">
Hooke's law</link>) and the nodes were <link xlink:type="simple" xlink:href="../804/9804.xml">
electrically charged</link> particles (see <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../060/179060.xml">
Coulomb's law</link></concept>
</idea>
). The entire graph is then simulated as if it were a physical system. The forces are applied to the nodes, pulling them closer together or pushing them further apart. This is repeated iteratively until the system comes to an equilibrium state; i.e., their relative positions do not change anymore from one iteration to the next. At that moment, the graph is drawn. The physical interpretation of this equilibrium state is that all the forces are in <link xlink:type="simple" xlink:href="../290/92290.xml">
mechanical equilibrium</link>.</p>
<p>

An alternative model considers a spring-like force for every pair of nodes <math>(i,j)</math> where the ideal length <math>\delta_{ij}</math> of each spring is proportional to the graph-theoretic distance between nodes <it>i</it> and <it>j</it>.  In this model there is no need for a separate repulsive force.  Note that minimizing the difference (usually the squared difference) between <link xlink:type="simple" xlink:href="../932/53932.xml">
euclidean</link> and ideal distances between nodes is then equivalent to a metric <link xlink:type="simple" xlink:href="../786/398786.xml">
multidimensional scaling</link> problem.  <link xlink:type="simple" xlink:href="../608/10274608.xml">
Stress majorization</link> gives a very well-behaved (i.e. monotonically <link xlink:type="simple" xlink:href="../773/285773.xml">
convergent</link>) and mathematically elegant way to <link xlink:type="simple" xlink:href="../033/52033.xml">
minimise</link> these differences and hence find a good layout for the graph. </p>
<p>

A force-directed graph can involve forces other than mechanical springs and electrical repulsion; examples include logarithmic springs (as opposed to linear springs) and magnetic or gravitational fields.</p>
<p>

The results of this class of algorithm often look very good. In the case of spring-and-charged-particle graphs, the edges tend to have uniform length (because of the spring forces), and nodes that are not connected by an edge tend to be drawn further apart (because of the electrical repulsion).</p>
<p>

While <link xlink:type="simple" xlink:href="../813/325813.xml">
graph drawing</link> is a difficult problem, force-directed algorithms, being physical simulations, usually require no special knowledge about graph theory such as <link xlink:type="simple" xlink:href="../314/24314.xml">
planarity</link>.</p>
<p>

It is also possible to employ mechanisms that search more directly for energy minima, either instead of or in conjunction with physical simulation. Such mechanisms, which are examples of general <link xlink:type="simple" xlink:href="../854/563854.xml">
global optimization</link> methods, include <link xlink:type="simple" xlink:href="../244/172244.xml">
simulated annealing</link> and <link xlink:type="simple" xlink:href="../254/40254.xml">
genetic algorithm</link>s.</p>

<sec>
<st>
Advantages</st>
<p>

The following are among the most important advantages of force-directed algorithms:</p>
<p>

<list>
<entry level="1" type="bullet">

 Good quality results: at least for graphs of medium size (up to 50-100 vertices), the results obtained have usually very good aesthetic properties. In particular, they are good at achieving the following aesthetic criteria: uniform edge length, uniform vertex distribution and showing symmetry. This last criterion is among the most important ones and is hard to achieve with any other type of algorithm.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Flexibility: force-directed algorithms can be easily adapted and extended to fulfill additional aesthetic criteria. This makes them the most versatile class of graph drawing algorithms. Examples of existing extensions include the ones for directed graphs, 3D graph drawing, cluster graph drawing, constrained graph drawing and dynamic graph drawing.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Intuitive: since they are based on physical analogies of common objects, like springs, the behavior of the algorithms is relatively easy to predict and understand. This is not the case with other types of graph-drawing algorithms.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Simplicity: typical force-directed algorithms are simple and can be implemented in a few lines of code. Other classes of graph-drawing algorithms, like the ones for orthogonal layouts, are usually much more involved.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Interactivity: another advantage of this class of algorithm is the interactive aspect. By drawing the intermediate stages of the graph, the user can follow how the graph evolves, seeing it unfold from a tangled mess into a good-looking configuration. In some interactive graph drawing tools, the user can pull one or more nodes out of their equilibrium state and watch them migrate back into position. This makes them a preferred choice for dynamic and online graph drawing systems.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Strong theoretical foundations: while simple <it>ad-hoc</it> force-directed algorithms (such as the one given in pseudo-code in this article) often appear in the literature and in practice (because they are relatively easy to understand), more reasoned approaches are starting to gain traction.  Statisticians have been solving similar problems in <link xlink:type="simple" xlink:href="../786/398786.xml">
multidimensional scaling</link> (MDS) since the 1930s and physicists also have a long history of working with related <link xlink:type="simple" xlink:href="../686/4917686.xml">
n-body</link> problems - so extremely mature approaches exist.  As an example, the <link xlink:type="simple" xlink:href="../608/10274608.xml">
stress majorization</link> approach to metric MDS can be applied to graph drawing as described above.  This has been proven to converge monotonically<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.  Monotonic convergence, the property that the algorithm will at each iteration decrease the stress or cost of the layout, is important because it guarantees that the layout will eventually reach a local minimum and stop.  Damping schedules such as the one used in the pseudo-code below, cause the algorithm to stop, but cannot guarantee that a true local minimum is reached.</entry>
</list>
</p>

</sec>
<sec>
<st>
Disadvantages</st>
<p>

The main disadvantages of force-directed algorithms include the following:
<list>
<entry level="1" type="bullet">

 High <link xlink:type="simple" xlink:href="../ury/23rd_century.xml">
running time</link>: the typical force-directed algorithms are generally <it>considered</it> to have a running time equivalent to O(V3), where V is the number of nodes of the input graph. This is because the number of iterations is estimated to be O(V), and in every iteration, all pairs of nodes need to be visited and their mutual repulsive forces computed. This is related to the <link xlink:type="simple" xlink:href="../187/102187.xml">
N-body problem</link> in physics. However, since repulsive forces are local in nature the graph can be partitioned such that only neighboring vertices are considered. Common techniques used by algorithms for determining the layout of large graphs include high-dimensional embedding<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>, multi-layer drawing and other methods related to <link xlink:type="simple" xlink:href="../686/4917686.xml">
N-body simulation</link>. For example the <link xlink:type="simple" xlink:href="../772/9394772.xml">
Barnes-Hut simulation</link> based method FADE<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>  can improve running time to n*log(n) per iteration. Using the paper "<weblink xlink:type="simple" xlink:href="http://www.cs.ucd.ie/staff/aquigley/home/downloads/aq-gd2000.pdf">
FADE: Graph Drawing, Clustering, and Visual Abstraction</weblink>" as a rough guide, in a few seconds you can expect to draw at most 1,000 nodes with a standard n² per iteration technique, and 100,000 with a n*log(n) per iteration technique. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Poor local minima: it is easy to see that force-directed algorithms produce a graph with minimal energy, in particular one whose total energy is only a <link>
local minimum</link>. The local minimum found can be, in many cases, considerably worse than a global minimum, which is translated into a low-quality drawing. For many algorithms, especially the ones that allow only <it>down-hill</it> moves of the vertices, the final result can be strongly influenced by the initial layout, that in most cases is randomly generated. The problem of poor local minima becomes more important as the number of vertices of the graph increases. A combined application of different algorithms is helpful to solve this problem (e.g. Kamada-Kawai<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> for quickly generating an advantageous initial layout and Fruchterman-Reingold<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> for a visually more significant placement of neighbored nodes).</entry>
</list>
</p>

</sec>
<sec>
<st>
Pseudocode</st>

<p>

Each node has x,y position and dx,dy velocity and mass m. There is usually a spring constant, s, and <link xlink:type="simple" xlink:href="../563/495563.xml">
damping</link>: 0  damping  1. The force toward and away from nodes is calculated according to <link xlink:type="simple" xlink:href="../553/229553.xml">
Hooke's Law</link> and <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../060/179060.xml">
Coulomb's law</link></concept>
</idea>
 or similar as discussed above.</p>

<p>

set up initial node velocities to (0,0)
set up initial node positions randomly <it>// make sure no 2 nodes are in exactly the same position
loop
total_kinetic_energy := 0 </it>// running sum of total kinetic energy over all particles
for each node
net-force := (0, 0) <it>// running sum of total force on this particular node
</it>
for each other node
net-force := net-force + Coulomb_repulsion( this_node, other_node )
next node
<it>
for each spring connected to this node
net-force := net-force + Hooke_attraction( this_node, spring )
next spring
</it>
// without damping, it moves forever
this_node.velocity := (this_node.velocity + timestep * net-force) * damping
this_node.position := this_node.position + timestep * this_node.velocity
total_kinetic_energy := total_kinetic_energy + this_node.mass * (this_node.velocity)^2
next node
until total_kinetic_energy is less than some small number <it> //the simulation has stopped moving</it></p>


</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
de Leeuw, J. "Convergence of the majorization method for multidimensional scaling", Journal of Classification 5(2), Springer New York, pp. 163--180, 1988</entry>
<entry id="2">
Harel D., Koren Y., Graph Drawing by High-Dimensional Embedding, Proceedings of the 9th International Symposium on Graph Drawing, 207 - 219</entry>
<entry id="3">
Quigley A., Eades P. (2001), FADE: Graph Drawing, Clustering, and Visual Abstraction, Proceedings of the 8th International Symposium on Graph Drawing, 197--210</entry>
<entry id="4">
Kamada, T. &amp; Kawai, S. (1989). An algorithm for drawing general undirected graphs. Information Processing Letters, 31, 7-15.</entry>
<entry id="5">
Fruchterman, T. M. J., &amp; Reingold, E. M. (1991). Graph Drawing by Force-Directed Placement. Software: Practice and Experience, 21(11).</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 Giuseppe Di Battista, Peter Eades, Roberto Tamassia, Ioannis G. Tollis. Graph Drawing: Algorithms for the Visualization of Graphs. Prentice Hall, 1999.</entry>
<entry level="1" type="bullet">

 Michael Kaufmann and Dorothea Wagner, editors. Drawing graphs: methods and models, volume 2025 of Lecture Notes in Computer Science. Springer-Verlag, 2001.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.usyd.edu.au/~aquigley/3dfade/">
Aaron Quigley's page on large-scale force-directed layout</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://search.cpan.org/~pasky/Graph-Layderer-0.02/lib/Graph/Layouter/Spring.pm">
Graph Layderer's spring algorithm: Perl source code</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.aisee.com/cgi-bin/examples?topic=2">
Examples of spring-based layouts</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.aisee.com/manual/unix/56.htm">
aiSee's force-directed layout</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.usyd.edu.au/%7Eaquigley/avi/spring.avi">
Video of Spring Algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cercia.ac.uk/our_services/software/">
Colin Frayn's Force-Based Visualisation Suite at Cercia.ac.uk</weblink></entry>
<entry level="1" type="bullet">

[https://nwb.slis.indiana.edu/community/?n=VisualizeData.Kamada-Kawaii Short explanation of the Kamada-Kawai spring-based graph layout algorithm featuring a picture]</entry>
<entry level="1" type="bullet">

[https://nwb.slis.indiana.edu/community/?n=VisualizeData.Fruchterman-Rheingold Short explanation of Fruchterman-Reingold algorithm. The algorithm implements a variable step width (“temperature”) to guarantee that the system reaches equilibrium state]</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cs.cmu.edu/~quixote/#Graph%20Layout">
Daniel Tunkelang's dissertation (with source code) on force-directed graph layout</weblink></entry>
</list>


</p>
</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
