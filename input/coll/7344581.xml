<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:48:18[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Great Deluge algorithm</title>
<id>7344581</id>
<revision>
<id>199265912</id>
<timestamp>2008-03-19T03:55:09Z</timestamp>
<contributor>
<username>Xnatedawgx</username>
<id>4789380</id>
</contributor>
</revision>
<categories>
<category>Optimization algorithms</category>
</categories>
</header>
<bdy>

The <b>Great Deluge algorithm</b> (GD) is a generic algorithm applied to <link xlink:type="simple" xlink:href="../033/52033.xml">
optimization</link> problems. It is similar in many ways to the <link xlink:type="simple" xlink:href="../002/364002.xml">
hill-climbing</link> and <link xlink:type="simple" xlink:href="../244/172244.xml">
simulated annealing</link> algorithms.<p>

The name comes from the analogy that in a great deluge a person climbing a hill will try to move in any direction that does not get his/her feet wet in the hope of finding a way up as the water level rises.</p>
<p>

In a typical implementation of the GD, the algorithm starts with a poor approximation, <it>S</it>, of the optimum solution. A numerical value called the <it>badness</it> is computed based on <it>S</it> and it measures how undesirable the initial approximation is. The higher the value of <it>badness</it> the more undesirable is the approximate solution. Another numerical value called the <it>tolerance</it> is calculated based on a number of factors, often including the initial badness.</p>
<p>

A new approximate solution <it> S' </it>, called a neighbour of <it>S</it>, is calculated based on <it>S</it>. The badness of <it> S' </it>, <it> b' </it>, is computed and compared with the tolerance. If <it> b' </it> is better than tolerance, then the algorithm is recursively  restarted with <it>S</it> : = <it> S' </it>, and <it>tolerance</it> := <it>decay(tolerance)</it> where <it>decay</it> is a function that lowers the tolerance (representing a rise in water levels). If <it> b' </it> is worse than tolerance, a different neighbour <it> S* </it> of <it>S</it> is chosen and the process repeated. If all the neighbours of <it>S</it> produce approximate solutions beyond <it>tolerance</it>, then the algorithm is terminated and <it>S</it> is put forward as the best approximate solution obtained.</p>

<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Gunter Dueck: "New Optimization Heuristics: The Great Deluge Algorithm and the Record-to-Record Travel", Technical report, IBM Germany, Heidelberg Scientific Center, 1990.</entry>
<entry level="1" type="bullet">

 Gunter Dueck: "New Optimization Heuristics The Great Deluge Algorithm and the Record-to-Record Travel", Journal of Computational Physics, Volume 104, Issue 1, p. 86-92, 1993</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://de.wikipedia.org/wiki/Gunter_Dueck">
de:Gunter Dueck</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
