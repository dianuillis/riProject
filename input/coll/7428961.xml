<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:52:53[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Hadamard code</title>
<id>7428961</id>
<revision>
<id>220512718</id>
<timestamp>2008-06-20T06:05:38Z</timestamp>
<contributor>
<username>Sander123</username>
<id>26068</id>
</contributor>
</revision>
<categories>
<category>Error detection and correction</category>
<category>Coding theory</category>
</categories>
</header>
<bdy>

<image location="right" width="200 px" src="Hadamard-Code.png" type="thumb">
<caption>

Matrix of the Hadamard code (32, 6, 16) for the Reed-Muller Code (1, 5) of the NASA space probe Mariner 9
</caption>
</image>

The <b>Hadamard code</b>, named after <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../675/312675.xml">
Jacques Hadamard</link></scientist>
</person>
, is a system used for signal <link xlink:type="simple" xlink:href="../375/10375.xml">
error detection and correction</link>.  It is one of the family of [2''n'',&nbsp;''n''&nbsp;+&nbsp;1,&nbsp;2''n''&nbsp;&amp;minus;&nbsp;1] codes. Especially for large <it>n</it> it has a poor rate but it is capable of correcting many errors. 
<sec>
<st>
Construction</st>
<p>

The code is based on <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../553/507553.xml">
Hadamard matrices</link></difficulty>
</problem>
</state>
</condition>
. If <it>H</it> is an <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../553/507553.xml">
Hadamard matrix</link></difficulty>
</problem>
</state>
</condition>
 of order 2<it>n</it> the codewords are constructed by taking the rows of <it>H</it> and &amp;minus;<it>H</it> as codewords, where each &amp;minus;1 is replaced by 0. In this way 2<it>n</it>&nbsp;+&nbsp;1 code words are constructed that each have a length of 2<it>n</it>. Since the rows of a Hadamard matrix are orthogonal the minimum distance is 2<it>n</it>&nbsp;-&nbsp;1. In this way a [2''n'',&nbsp;''n''&nbsp;+&nbsp;1,&nbsp;2''n''&nbsp;&amp;minus;&nbsp;1] code is constructed.</p>
<p>

The code can also be constructed by creating the <link xlink:type="simple" xlink:href="../570/10557570.xml">
parity-check matrix</link> which consists of all 2<it>n</it>&nbsp;&amp;minus;&nbsp;1 vectors containing an odd number of 1s, or by using a recursive encoding process.</p>

</sec>
<sec>
<st>
Decoding</st>
<p>

The code has minimum distance 2<it>n</it>&nbsp;&amp;minus;&nbsp;1 and hence can correct at most <it>t</it> = 2<it>n</it>&nbsp;&amp;minus;&nbsp;2&nbsp;&amp;minus;&nbsp;1 errors. The algorithm below achieves this.</p>
<p>

When a code word is received it is first transformed to a 1/&amp;minus;1 vector <it>v</it> by changing all 0s to &amp;minus;1. Compute 
(<it>v</it>&nbsp;<it>H</it>T). The entry with the maximum absolute value corresponds to the row taken as a code word. If it is positive the code word came from <it>H</it>, if it is negative the code word came from &amp;minus;<it>H</it>.</p>
<p>

<it>Proof:</it> If there were
no errors the product (<it>v</it>&nbsp;<it>H</it>T) would consist of only zero's and one entry of  +/&amp;minus;2<it>n</it>. If there are errors in <it>v</it> then, in absolute value, some of the zeros become larger and the maximum becomes smaller. Each error that occurs can change a zero with 2. So the zeros can become at most 0 + 2<it>t</it> = <it>2n</it>&nbsp;&amp;minus;&nbsp;1&nbsp;&amp;minus;&nbsp;2. The maximum
can decrease at most to 2<it>n</it>&nbsp;&amp;minus;&nbsp;2<it>t</it> = 2<it>n</it>&nbsp;&amp;minus;&nbsp;2<it>n</it>&nbsp;&amp;minus;&nbsp;1&nbsp;+&nbsp;2 = 2<it>n</it>&nbsp;&amp;minus;&nbsp;1&nbsp;+&nbsp;2. So the maximum that points to the correct row will always be larger in absolute value than the other values in the row.</p>

</sec>
<sec>
<st>
History</st>
<p>

A Hadamard code was used during the <link xlink:type="simple" xlink:href="../748/34748.xml">
1971</link> <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<mission wordnetid="108403225" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<nongovernmental_organization wordnetid="108009834" confidence="0.8">
<probe wordnetid="105800611" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../449/37449.xml">
Mariner 9</link></higher_cognitive_process>
</probe>
</nongovernmental_organization>
</problem_solving>
</mission>
</thinking>
</inquiry>
</process>
 mission to correct for picture transmission error. 
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
The data words used during this mission were 6 bits long, which represented 64 <link xlink:type="simple" xlink:href="../061/463061.xml">
grayscale</link> values.  Because of limitations of the quality of the alignment of the transmitter the maximum useful data length was about 30 bits. Instead of using a <link xlink:type="simple" xlink:href="../949/3473949.xml">
repetition code</link>, a [32, 6, 16] Hadamard code was used. Errors of up to 7 bits per word could be corrected using this scheme. Compared to a 5-<link xlink:type="simple" xlink:href="../949/3473949.xml">
repetition code</link>, the error correcting properties of this Hadamard code are much better, yet its rate is comparable. The efficient decoding algorithm was an important factor in the decision to use this code.  The circuitry used was called the "Green Machine".
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. It employed the Fast Fourier Transform which can increase the decryption speed with a factor of 3.</p>

</sec>
<sec>
<st>
Optimality</st>
<p>

For value of n = 6 the Hadamard codes have been proven optimal. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</sec>
<sec>
<st>
 Notes </st>

<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www-math.cudenver.edu/~wcherowi/courses/m4410/m5410cd1.html">
http://www-math.cudenver.edu/~wcherowi/courses/m4410/m5410cd1.html</weblink>. Part of <it>Math 4410 - Mathematics of Coding Theory''</it></entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www-math.cudenver.edu/~wcherowi/courses/m6409/mariner9talk.pdf">
http://www-math.cudenver.edu/~wcherowi/courses/m6409/mariner9talk.pdf</weblink> Combinatorics in Space
The Mariner 9 Telemetry System</entry>
<entry id="3">
<it>Optimal binary linear codes of dimension at most seven</it>, David B. Jaffe, Iliya Bouyukliev. <weblink xlink:type="simple" xlink:href="http://www.math.unl.edu/~djaffe2/papers/sevens.html">
http://www.math.unl.edu/~djaffe2/papers/sevens.html</weblink></entry>
</reflist>
</p>




</sec>
</bdy>
</article>
