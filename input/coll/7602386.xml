<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:56:32[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Index (search engine)</title>
<id>7602386</id>
<revision>
<id>243535607</id>
<timestamp>2008-10-06T22:50:29Z</timestamp>
<contributor>
<username>Ezhiki</username>
<id>48143</id>
</contributor>
</revision>
<categories>
<category>Internet search algorithms</category>
<category>Information retrieval</category>
<category>Indexing</category>
<category>Searching</category>
</categories>
</header>
<bdy>

<link xlink:type="simple" xlink:href="../023/4059023.xml">
Search engine</link> <link xlink:type="simple" xlink:href="../763/1603763.xml">
indexing</link> collects, parses, and stores <link xlink:type="simple" xlink:href="../333/2234333.xml">
data</link> to facilitate fast and accurate information retrieval. Index design incorporates interdisciplinary concepts from linguistics, cognitive psychology, mathematics, <link xlink:type="simple" xlink:href="../625/4964625.xml">
informatics</link>, physics and computer science.  An alternate name for the process in the context of search engines designed to find web pages on the Internet is <b>Web indexing</b>.<p>

Popular engines focus on the full-text indexing of online, natural language documents.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> <link xlink:type="simple" xlink:href="../420/20420.xml">
Media types</link> such as video and audio<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> and graphics<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> are also searchable.</p>
<p>

<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../297/548297.xml">
Meta search engines</link></machine>
</device>
</motor>
</engine>
</instrumentality>
</artifact>
 reuse the indices of other services and do not store a local index, whereas cache-based search engines permanently store the index along with the  <link xlink:type="simple" xlink:href="../887/53887.xml">
corpus</link>. Unlike full-text indices, partial-text services restrict the depth indexed to reduce index size. Larger services typically perform indexing at a predetermined time interval due to the required time and processing costs, while <link xlink:type="simple" xlink:href="../317/2711317.xml">
agent</link>-based search engines index in <link xlink:type="simple" xlink:href="../130/2728130.xml">
real time</link>.</p>
<p>

<work wordnetid="100575741" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<service wordnetid="100577525" confidence="0.8">
<word wordnetid="106286395" confidence="0.8">
<part wordnetid="113809207" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<neologism wordnetid="106294441" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<language_unit wordnetid="106284225" confidence="0.8">
<link xlink:type="simple" xlink:href="../389/7581389.xml">
Web 3.0</link></language_unit>
</activity>
</neologism>
</psychological_feature>
</act>
</part>
</word>
</service>
</event>
</work>
 based on technologies of <link xlink:type="simple" xlink:href="../123/29123.xml">
Semantic web</link>, <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../890/16863890.xml">
Website Parse Template</link></format>
, etc. hopes to provide the next generation <link xlink:type="simple" xlink:href="../023/4059023.xml">
search engines</link> with more intelligent parsing and indexing technologies. </p>

<sec>
<st>
Indexing</st>
<p>

The purpose of storing an index is to optimize speed and performance in finding relevant documents for a search query. Without an index, the search engine would <link xlink:type="simple" xlink:href="../251/81251.xml">
scan</link> every document in the corpus, which would require considerable time and computing power.  For example, while an index of 10,000 documents can be queried within milliseconds, a sequential scan of every word in 10,000 large documents could take hours. The additional computer storage required to store the index, as well as the considerable increase in the time required for an update to take place, are traded off for the time saved during information retrieval.</p>

<ss1>
<st>
Index Design Factors</st>
<p>

Major factors in designing a search engine's architecture include:</p>
<p>

<list>
<entry level="1" type="definition">

 Merge factors : How data enters the index, or how words or subject features are added to the index during text corpus traversal, and whether multiple indexers can work asynchronously. The indexer must first check whether it is updating old content or adding new content. Traversal typically correlates to the <link xlink:type="simple" xlink:href="../120/33120.xml">
data collection</link> policy. Search engine index merging is similar in concept to the <link xlink:type="simple" xlink:href="../931/4347931.xml">
SQL Merge</link> command and other merge algorithms.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref></entry>
<entry level="1" type="definition">

 Storage techniques : How to store the index <link xlink:type="simple" xlink:href="../040/18985040.xml">
data</link>, that is, whether information should be data compressed or filtered.</entry>
<entry level="1" type="definition">

 Index size : How much computer storage is required to support the index.</entry>
<entry level="1" type="definition">

 Lookup speed : How quickly a word can be found in the inverted index. The speed of finding an entry in a data structure, compared with how quickly it can be updated or removed, is a central focus of computer science.</entry>
<entry level="1" type="definition">

 Maintenance : How the index is maintained over time<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>.</entry>
<entry level="1" type="definition">

Fault tolerance : How important it is for the service to be reliable. Issues include dealing with index corruption, determining whether bad data can be treated in isolation, dealing with bad hardware, <link xlink:type="simple" xlink:href="../101/1983101.xml">
partitioning</link>, and schemes such as <link xlink:type="simple" xlink:href="../790/13790.xml">
hash-based</link> or composite partitioning<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>, as well as <link xlink:type="simple" xlink:href="../905/2722905.xml">
replication</link>.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Index Data Structures</st>

<p>

Search engine architectures vary in the way indexing is performed and in methods of index storage to meet the various design factors. Types of indices include:</p>
<p>

<list>
<entry level="1" type="definition">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../679/794679.xml">
Suffix tree</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 : Figuratively structured like a tree, supports linear time lookup. Built by storing the suffixes of words. The suffix tree is a type of <link xlink:type="simple" xlink:href="../274/31274.xml">
trie</link>. Tries support extendable hashing, which is important for search engine indexing.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref> Used for searching for patterns in <link xlink:type="simple" xlink:href="../955/7955.xml">
DNA</link> sequences and clustering. A major drawback is that the storage of a word in the tree may require more storage than storing the word itself.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> An alternate representation is a <link xlink:type="simple" xlink:href="../494/1303494.xml">
suffix array</link>, which is considered to require less virtual memory and supports data compression such as the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../777/36777.xml">
BWT</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 algorithm.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

Tree : An <link xlink:type="simple" xlink:href="../806/30806.xml">
ordered tree data structure</link> that is used to store an associative array where the keys are <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/27701.xml">
strings</link></kind>
</type>
</language>
</category>
</concept>
</idea>
. Regarded as faster than a hash table but less <link xlink:type="simple" xlink:href="../300/5300.xml">
space</link>-efficient. </entry>
<entry level="1" type="definition">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../116/3125116.xml">
Inverted index</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 : Stores a list of occurrences of each atomic search criterion<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref>, typically in the form of a <link xlink:type="simple" xlink:href="../833/13833.xml">
hash table</link> or <link xlink:type="simple" xlink:href="../321/4321.xml">
binary tree</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

<link xlink:type="simple" xlink:href="../362/423362.xml">
Citation index</link> : Stores citations or hyperlinks between documents to support citation analysis, a subject of <link xlink:type="simple" xlink:href="../245/1223245.xml">
Bibliometrics</link>.</entry>
<entry level="1" type="definition">

Ngram index : Stores sequences of length of data to support other types of retrieval or text mining.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref></entry>
<entry level="1" type="definition">

Term document matrix : Used in latent semantic analysis, stores the occurrences of words in documents in a two-dimensional <link xlink:type="simple" xlink:href="../015/341015.xml">
sparse matrix</link>.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
Challenges in Parallelism</st>
<p>

A major challenge in the design of search engines is the management of parallel computing processes. There are many opportunities for <link xlink:type="simple" xlink:href="../661/98661.xml">
race conditions</link> and coherent faults. For example, a new document is added to the corpus and the index must be updated, but the index simultaneously needs to continue responding to search queries. This is a collision between two competing tasks. Consider that authors are producers of information, and a web crawler is the consumer of this information, grabbing the text and storing it in a cache (or <link xlink:type="simple" xlink:href="../887/53887.xml">
corpus</link>). The forward index is the consumer of the information produced by the corpus, and the inverted index is the consumer of information produced by the forward index. This is commonly referred to as a <b>producer-consumer model</b>. The indexer is the producer of searchable information and users are the consumers that need to search.  The challenge is magnified when working with distributed storage and distributed processing. In an effort to scale with larger amounts of indexed information, the search engine's architecture may involve <link xlink:type="simple" xlink:href="../501/8501.xml">
distributed computing</link>, where the search engine consists of several machines operating in unison. This increases the possibilities for incoherency and makes it more difficult to maintain a fully-synchronized, distributed, parallel architecture.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref></p>

</ss1>
<ss1>
<st>
Inverted indices</st>
<p>

Many search engines incorporate an <link xlink:type="simple" xlink:href="../116/3125116.xml">
inverted index</link> when evaluating a <link xlink:type="simple" xlink:href="../372/11525372.xml">
search query</link> to quickly locate documents containing the words in a query and then rank these documents by relevance. Because the inverted index stores a list of the documents containing each word, the search engine can use direct <link xlink:type="simple" xlink:href="../612/25612.xml">
access</link> to find the documents associated with each word in the query in order to retrieve the matching documents quickly. The following is a simplified illustration of an inverted index:</p>
<p>

<table align="center" class="wikitable">
<caption>
Inverted Index</caption>
<row>
<header>
Word</header>
<header>
Documents</header>
</row>
<row>
<col>
the</col>
<col>
Document 1, Document 3, Document 4, Document 5</col>
</row>
<row>
<col>
cow</col>
<col>
Document 2, Document 3, Document 4</col>
</row>
<row>
<col>
says</col>
<col>
Document 5</col>
</row>
<row>
<col>
moo</col>
<col>
Document 7</col>
</row>
</table>
</p>
<p>

This index can only determine whether a word exists within a particular document, since it stores no information regarding the frequency and position of the word; it is therefore considered to be a <link xlink:type="simple" xlink:href="../065/1162065.xml">
boolean</link> index. Such an index determines which documents match a query but does not rank matched documents. In some designs the index includes additional information such as the frequency of each word in each document or the positions of a word in each document.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref> Position information enables the search algorithm to identify word proximity to support searching for phrases; frequency can be used to help in ranking the relevance of documents to the query. Such topics are the central research focus of <link xlink:type="simple" xlink:href="../271/15271.xml">
information retrieval</link>.</p>
<p>

The inverted index is a <link xlink:type="simple" xlink:href="../015/341015.xml">
sparse matrix</link>, since not all words are present in each document. To reduce computer storage memory requirements, it is stored differently from a two dimensional <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>. The index is similar to the <link xlink:type="simple" xlink:href="../327/1234327.xml">
term document matrices</link> employed by <link xlink:type="simple" xlink:href="../427/689427.xml">
latent semantic analysis</link>. The inverted index can be considered a form of a hash table. In some cases the index is a form of a <link xlink:type="simple" xlink:href="../321/4321.xml">
binary tree</link>, which requires additional storage but may reduce the lookup time. In larger indices the architecture is typically a distributed hash table.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2216%22])">16</ref></p>
<p>

Inverted indices can be programmed in several computer programming languages.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2217%22])">17</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2218%22])">18</ref></p>

</ss1>
<ss1>
<st>
Index Merging</st>
<p>

The inverted index is filled via a merge or rebuild. A rebuild is similar to a merge but first deletes the contents of the inverted index. The architecture may be designed to support incremental indexing<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2219%22])">19</ref>, where a merge identifies the document or documents to be added or updated and then parses each document into words. For technical accuracy, a merge conflates newly indexed documents, typically residing in virtual memory, with the index cache residing on one or more computer hard drives. </p>
<p>

After parsing, the indexer adds the referenced document to the document list for the appropriate words. In a larger search engine, the process of finding each word in the inverted index (in order to report that it occurred within a document) may be too time consuming, and so this process is commonly split up into two parts, the development of a forward index and a process which sorts the contents of the forward index into the inverted index. The inverted index is  so named because it is an inversion of the forward index.</p>

</ss1>
<ss1>
<st>
The Forward Index</st>
<p>

The forward index stores a list of words for each document. The following is a simplified form of the forward index:</p>
<p>

<table align="center" class="wikitable">
<caption>
Forward Index</caption>
<row>
<header>
Document</header>
<header>
Words</header>
</row>
<row>
<col>
Document 1</col>
<col>
the,cow,says,moo</col>
</row>
<row>
<col>
Document 2</col>
<col>
the,cat,and,the,hat</col>
</row>
<row>
<col>
Document 3</col>
<col>
the,dish,ran,away,with,the,spoon</col>
</row>
</table>
</p>
<p>

The rationale behind developing a forward index is that as documents are parsing, it is better to immediately store the words per document.  The delineation enables Asynchronous system processing, which partially circumvents the inverted index update <link xlink:type="simple" xlink:href="../718/191718.xml">
bottleneck</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2220%22])">20</ref> The forward index is <link xlink:type="simple" xlink:href="../442/28442.xml">
sorted</link> to transform it to an inverted index. The forward index is essentially a list of pairs consisting of a document and a word, collated by the document. Converting the forward index to an inverted index is only a matter of sorting the pairs by the words. In this regard, the inverted index is a word-sorted forward index.</p>

</ss1>
<ss1>
<st>
Compression</st>
<p>

Generating or maintaining a large-scale search engine index represents a significant storage and processing challenge. Many search engines utilize a form of compression to reduce the size of the indices on <link xlink:type="simple" xlink:href="../300/5300.xml">
disk</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2221%22])">21</ref> Consider the following scenario for a full text, Internet search engine.</p>
<p>

<list>
<entry level="1" type="bullet">

 An estimated 2,000,000,000 different web pages exist as of the year 2000<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2222%22])">22</ref></entry>
<entry level="1" type="bullet">

 Suppose there are 250 words on each webpage (based on the assumption they are similar to the pages of a novel.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2223%22])">23</ref></entry>
<entry level="1" type="bullet">

 It takes 8 bits (or 1 <link xlink:type="simple" xlink:href="../365/3365.xml">
byte</link>) to store a single character. Some <link xlink:type="simple" xlink:href="../295/5295.xml">
encodings</link> use 2 bytes per character<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2224%22])">24</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2225%22])">25</ref></entry>
<entry level="1" type="bullet">

 The average number of characters in any given word on a page may be estimated at 5 ()</entry>
<entry level="1" type="bullet">

 The average <link xlink:type="simple" xlink:href="../137/18457137.xml">
personal computer</link> comes with 100 to 250 <link xlink:type="simple" xlink:href="../570/12570.xml">
gigabyte</link>s of usable space<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2226%22])">26</ref></entry>
</list>
</p>
<p>

Given this scenario, an uncompressed index (assuming a non-<link xlink:type="simple" xlink:href="../499/1220499.xml">
conflated</link>, simple, index) for 2 billion web pages would need to store 500 billion word entries. At 1 byte per character, or 5 bytes per word, this would require 2500 gigabytes of storage space alone, more than the average free disk space of 25 personal computers. This space requirement may be even larger for a fault-tolerant distributed storage architecture. Depending on the compression technique chosen, the index can be reduced to a fraction of this size. The tradeoff is the time and processing power required to perform compression and decompression.</p>
<p>

Notably, large scale search engine designs incorporate the cost of storage as well as the costs of electricity to power the storage. Thus compression is a measure of cost.</p>

</ss1>
</sec>
<sec>
<st>
Document Parsing</st>
<p>

Document parsing breaks apart the components (words) of a document or other form of media for insertion into the forward and inverted indices. The words found are called <it>tokens</it>, and so, in the context of search engine indexing and <link xlink:type="simple" xlink:href="../652/21652.xml">
natural language processing</link>, parsing is more commonly referred to as <link>
tokenization</link>. It is also sometimes called <link>
word boundary disambiguation</link>, <link xlink:type="simple" xlink:href="../912/746912.xml">
tagging</link>, <link xlink:type="simple" xlink:href="../339/4274339.xml">
text segmentation</link>, <link xlink:type="simple" xlink:href="../317/473317.xml">
content analysis</link>, text analysis, <link xlink:type="simple" xlink:href="../439/318439.xml">
text mining</link>, <relationship wordnetid="113780719" confidence="0.8">
<link xlink:type="simple" xlink:href="../860/2329860.xml">
concordance</link></relationship>
 generation, <link xlink:type="simple" xlink:href="../403/4273403.xml">
speech segmentation</link>, <link xlink:type="simple" xlink:href="../251/81251.xml">
lexing</link>, or <link xlink:type="simple" xlink:href="../251/81251.xml">
lexical analysis</link>. The terms 'indexing', 'parsing', and 'tokenization' are used interchangeably in corporate slang.</p>
<p>

Natural language processing, as of 2006, is the subject of continuous research and technological improvement. Tokenization presents many challenges in extracting the necessary information from documents for indexing to support quality searching. Tokenization for indexing involves multiple technologies, the implementation of which are commonly kept as corporate secrets.</p>

<ss1>
<st>
 Challenges in Natural Language Processing </st>
<p>

<list>
<entry level="1" type="definition">

 Word Boundary Ambiguity : Native <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../916/8569916.xml">
English</link></language>
 speakers may at first consider tokenization to be a straightforward task, but this is not the case with designing a <link xlink:type="simple" xlink:href="../983/1570983.xml">
multilingual</link> indexer.  In digital form, the texts of other languages such as <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../751/5751.xml">
Chinese</link></language>
, <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../606/15606.xml">
Japanese</link></language>
 or <language wordnetid="106282651" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../803/803.xml">
Arabic</link></language>
 represent a greater challenge, as words are not clearly delineated by <link xlink:type="simple" xlink:href="../700/2956700.xml">
whitespace</link>. The goal during tokenization is to identify words for which users will search. Language-specific logic is employed to properly identify the boundaries of words, which is often the rationale for designing a parser for each language supported (or for groups of languages with similar boundary markers and syntax).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Language Ambiguity : To assist with properly ranking matching documents, many search engines collect additional information about each word, such as its <link xlink:type="simple" xlink:href="../524/17524.xml">
language</link> or <link xlink:type="simple" xlink:href="../059/45059.xml">
lexical category</link> (<link xlink:type="simple" xlink:href="../059/45059.xml">
part of speech</link>). These techniques are language-dependent, as the syntax varies among languages. Documents do not always clearly identify the language of the document or represent it accurately. In tokenizing the document, some search engines attempt to automatically identify the language of the document.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Diverse File Formats : In order to correctly identify which bytes of a document represent characters, the file format must be correctly handled. Search engines which support multiple file formats must be able to correctly open and access the document and be able to tokenize the characters of the document.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 Faulty Storage : The quality of the natural language data may not always be perfect.  An unspecified number of documents, particular on the Internet, do not closely obey proper file protocol.  <link xlink:type="simple" xlink:href="../702/920702.xml">
binary</link> characters may be mistakenly encoded into various parts of a document. Without recognition of these characters and appropriate handling, the index quality or indexer performance could degrade.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Tokenization </st>
<p>

Unlike <link xlink:type="simple" xlink:href="../456/18456.xml">
literate</link> humans, computers do not understand the structure of a natural language document and cannot automatically recognize words and sentences. To a computer, a document is only a sequence of bytes. Computers do not 'know' that a space character separates words in a document. Instead, humans must program the computer to identify what constitutes an individual or distinct word, referred to as a token. Such a program is commonly called a <link>
tokenizer</link> or <link xlink:type="simple" xlink:href="../015/310015.xml">
parser</link> or <link xlink:type="simple" xlink:href="../251/81251.xml">
lexer</link>. Many search engines, as well as other natural language processing software, incorporate <link xlink:type="simple" xlink:href="../734/3959734.xml">
specialized programs</link> for parsing, such as <link xlink:type="simple" xlink:href="../358/34358.xml">
YACC</link> or <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<tool wordnetid="104451818" confidence="0.8">
<apparatus wordnetid="102727825" confidence="0.8">
<generator wordnetid="103434188" confidence="0.8">
<implement wordnetid="103563967" confidence="0.8">
<equipment wordnetid="103294048" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/105985.xml">
Lex</link></equipment>
</implement>
</generator>
</apparatus>
</tool>
</instrumentality>
</artifact>
.</p>
<p>

During tokenization, the parser identifies sequences of characters which represent words and other elements, such as punctuation, which are represented by numeric codes, some of which are non-printing control characters. The parser can also identify <link xlink:type="simple" xlink:href="../608/1906608.xml">
entities</link> such as <link xlink:type="simple" xlink:href="../738/9738.xml">
email</link> addresses, phone numbers, and <link xlink:type="simple" xlink:href="../277/32277.xml">
URL</link>s. When identifying each token, several characteristics may be stored, such as the token's case (upper, lower, mixed, proper), language or encoding, lexical category (part of speech, like 'noun' or 'verb'), position, sentence number, sentence position, length, and line number.</p>

</ss1>
<ss1>
<st>
 Language Recognition </st>
<p>

If the search engine supports multiple languages, a common initial step during tokenization is to identify each document's language; many of the subsequent steps are language dependent (such as <link xlink:type="simple" xlink:href="../964/475964.xml">
stemming</link> and <link xlink:type="simple" xlink:href="../059/45059.xml">
part of speech</link> tagging). <link xlink:type="simple" xlink:href="../650/2995650.xml">
Language recognition</link> is the process by which a computer program attempts to automatically identify, or categorize, the <link xlink:type="simple" xlink:href="../524/17524.xml">
language</link> of a document. Other names for language recognition include language classification, language analysis, language identification, and language tagging. Automated language recognition is the subject of ongoing research in <link xlink:type="simple" xlink:href="../652/21652.xml">
natural language processing</link>. Finding which language the words belongs to may involve the use of a <link xlink:type="simple" xlink:href="../776/11573776.xml">
language recognition chart</link>.</p>

</ss1>
<ss1>
<st>
 Format Analysis </st>
<p>

If the search engine supports multiple <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../600/18933600.xml">
document formats</link></format>
</information>
</message>
, documents must be prepared for tokenization. The challenge is that many document formats contain formatting information in addition to textual content.  For example, <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../191/13191.xml">
HTML</link></format>
 documents contain HTML tags, which specify formatting information such as new line starts, <b>bold</b> emphasis, and <link xlink:type="simple" xlink:href="../659/3329659.xml">
font</link> size or <link xlink:type="simple" xlink:href="../105/64105.xml">
style</link>.  If the search engine were to ignore the difference between content and 'markup', extraneous information would be included in the index, leading to poor search results. Format analysis is the identification and handling of the formatting content embedded within documents which controls the way the document is rendered on a computer screen or interpreted by a software program. Format analysis is also referred to as structure analysis, format parsing, tag stripping, format stripping, text normalization, text cleaning, and text preparation. The challenge of format analysis is further complicated by the intricacies of various file formats. Certain file formats are proprietary with very little information disclosed, while others are well documented. Common, well-documented file formats that many search engines support include:</p>
<p>

<list>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../287/20287.xml">
Microsoft Word</link></software>
</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../268/20268.xml">
Microsoft Excel</link></format>
</software>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../229/77229.xml">
Microsoft Powerpoint</link></entry>
<entry level="1" type="bullet">

 IBM <link xlink:type="simple" xlink:href="../408/60408.xml">
Lotus Notes</link></entry>
<entry level="1" type="bullet">

 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../191/13191.xml">
HTML</link></format>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<representation wordnetid="105926676" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<link xlink:type="simple" xlink:href="../586/586.xml">
ASCII</link></rule>
</direction>
</representation>
</protocol>
</message>
 text files (a text document without any formatting)</entry>
<entry level="1" type="bullet">

 <company wordnetid="108058098" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../955/1955.xml">
Adobe</link></company>
's Portable Document Format (<link xlink:type="simple" xlink:href="../077/24077.xml">
PDF</link>)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../080/24080.xml">
PostScript</link> (PS)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../195/18195.xml">
LaTex</link></entry>
<entry level="1" type="bullet">

 The <link xlink:type="simple" xlink:href="../994/18588994.xml">
UseNet</link> archive (NNTP) and other deprecated bulletin board formats</entry>
<entry level="1" type="bullet">

 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../138/34138.xml">
XML</link></format>
 and derivatives like <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../489/93489.xml">
RSS</link></format>
</entry>
<entry level="1" type="bullet">

 <link>
SGML</link> (this is more of a general protocol)</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../420/20420.xml">
Multimedia</link> <link xlink:type="simple" xlink:href="../632/18933632.xml">
meta data</link> formats like <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../915/539915.xml">
ID3</link></format>
</information>
</message>
</entry>
</list>

Options for dealing with various formats include using a publicly available commercial parsing tool that is offered by the organization which developed, maintains, or owns the format, and writing a custom <link xlink:type="simple" xlink:href="../015/310015.xml">
parser</link>.</p>
<p>

Some search engines support inspection of files that are stored in a <software wordnetid="106566077" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../871/3947871.xml">
compressed</link></software>
 or encrypted file format.  When working with a compressed format, the indexer first decompresses the document; this step may result in one or more files, each of which must be indexed separately. Commonly supported <link xlink:type="simple" xlink:href="../460/519460.xml">
compressed file format</link>s include:</p>
<p>

<list>
<entry level="1" type="bullet">

 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../488/188488.xml">
ZIP</link></format>
 - Zip File</entry>
<entry level="1" type="bullet">

 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../819/311819.xml">
RAR</link></format>
 - Archive File</entry>
<entry level="1" type="bullet">

 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../678/322678.xml">
CAB</link></format>
 - <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> Cabinet File</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../783/12783.xml">
Gzip</link></format>
</software>
 - Gzip file</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.9508927676800064">
<format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../255/66255.xml">
BZIP</link></format>
</software>
 - Bzip file</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<information wordnetid="106634376" confidence="0.8">
<format wordnetid="106636806" confidence="0.8">
<link xlink:type="simple" xlink:href="../694/151694.xml">
TAR</link></format>
</information>
</message>
, and TAR.GZ - <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
Unix</link></family>
 Gzip'ped Archives</entry>
</list>
</p>
<p>

Format analysis can involve quality improvement methods to avoid including 'bad information' in the index.  Content can manipulate the formatting information to include additional content. Examples of abusing document formatting for <link xlink:type="simple" xlink:href="../651/43651.xml">
spamdexing</link>:</p>
<p>

<list>
<entry level="1" type="bullet">

 Including hundreds or thousands of words in a section which is hidden from view on the computer screen, but visible to the indexer, by use of formatting (e.g. hidden <link xlink:type="simple" xlink:href="../154/3212154.xml">
"div" tag</link> in <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../191/13191.xml">
HTML</link></format>
, which may incorporate the use of <link xlink:type="simple" xlink:href="../013/164013.xml">
CSS</link> or <link xlink:type="simple" xlink:href="../845/9845.xml">
Javascript</link> to do so).</entry>
<entry level="1" type="bullet">

 Setting the foreground font color of words to the same as the background color, making words hidden on the computer screen to a person viewing the document, but not hidden to the indexer.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Section Recognition </st>
<p>

Some search engines incorporate section recognition, the identification of major parts of a document, prior to tokenization. Not all the documents in a corpus read like a well-written book, divided into organized chapters and pages.  Many documents on the <link xlink:type="simple" xlink:href="../539/14539.xml">
web</link>, such as newsletters and corporate reports, contain erroneous content and side-sections which do not contain primary material (that which the document is about). For example, this article displays a side menu with links to other web pages. Some file formats, like HTML or PDF, allow for content to be displayed in columns. Even though the content is displayed, or rendered, in different areas of the view, the raw markup content may store this information sequentially. Words that appear sequentially in the raw source content are indexed sequentially, even though these sentences and paragraphs are rendered in different parts of the computer screen. If search engines index this content as if it were normal content, the quality of the index and search quality may be degraded due to the mixed content and improper word proximity. Two primary problems are noted:</p>
<p>

<list>
<entry level="1" type="bullet">

 Content in different sections is treated as related in the index, when in reality it is not</entry>
<entry level="1" type="bullet">

 Organizational 'side bar' content is included in the index, but the side bar content does not contribute to the meaning of the document, and the index is filled with a poor representation of its documents.</entry>
</list>
</p>
<p>

Section analysis may require the search engine to implement the rendering logic of each document, essentially an abstract representation of the actual document, and then index the representation instead. For example, some content on the Internet is rendered via Javascript. If the search engine does not render the page and evaluate the Javascript within the page, it would not 'see' this content in the same way and would index the document incorrectly. Given that some search engines do not bother with rendering issues, many web page designers avoid displaying content via Javascript or use the <link>
Noscript tag</link> to ensure that the web page is indexed properly.  At the same time, this fact can also be <link xlink:type="simple" xlink:href="../651/43651.xml">
exploited</link> to cause the search engine indexer to 'see' different content than the viewer.</p>

</ss1>
<ss1>
<st>
 Meta Tag Indexing </st>
<p>

Specific documents often contain embedded meta information such as author, keywords, description, and language. For HTML pages, the <link xlink:type="simple" xlink:href="../556/20556.xml">
meta tag</link> contains keywords which are also included in the index. Earlier Internet search engine technology would only index the keywords in the meta tags for the forward index; the full document would not be parsed. At that time full-text indexing was not as well established, nor was the <link xlink:type="simple" xlink:href="../615/13615.xml">
hardware</link> able to support such technology.  The design of the HTML markup language initially included support for meta tags for the very purpose of being properly and easily indexed, without requiring tokenization.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2227%22])">27</ref></p>
<p>

As the Internet grew through the 1990s, many <link xlink:type="simple" xlink:href="../029/2232029.xml">
brick-and-mortar corporations</link> went 'online' and established corporate websites. The keywords used to describe webpages (many of which were corporate-oriented webpages similar to product brochures) changed from descriptive to marketing-oriented keywords designed to drive sales by placing the webpage high in the search results for specific search queries. The fact that these keywords were subjectively-specified was leading to <link xlink:type="simple" xlink:href="../651/43651.xml">
spamdexing</link>, which drove many search engines to adopt full-text indexing technologies in the 1990s. Search engine designers and companies could only place so many 'marketing keywords' into the content of a webpage before draining it of all interesting and useful information.  Given that conflict of interest with the business goal of designing user-oriented websites which were 'sticky', the customer lifetime value equation was changed to incorporate more useful content into the website in hopes of retaining the visitor. In this sense, full-text indexing was more objective and increased the quality of search engine results, as it was one more step away from subjective control of search engine result placement, which in turn furthered research of full-text indexing technologies.</p>
<p>

In <link xlink:type="simple" xlink:href="../156/1274156.xml">
Desktop search</link>, many solutions incorporate meta tags to provide a way for authors to further customize how the search engine will index content from various files that is not evident from the file content. Desktop search is more under the control of the user, while Internet search engines which must focus more on the full text index.</p>

</ss1>
</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../245/257245.xml">
Concordance</link></entry>
<entry level="1" type="bullet">

 <know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../317/473317.xml">
Content analysis</link></method>
</know-how>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../719/1850719.xml">
Controlled vocabulary</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../156/1274156.xml">
Desktop search</link></entry>
<entry level="1" type="bullet">

 <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../640/731640.xml">
Document Retrieval</link></writing>
</written_communication>
</document>
</entry>
<entry level="1" type="bullet">

 <format wordnetid="106636806" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../890/16863890.xml">
Website Parse Template</link></format>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../162/383162.xml">
Information extraction</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../271/15271.xml">
Information retrieval</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../908/41908.xml">
Keyword In Context Indexing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../427/689427.xml">
Latent Semantic Indexing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../700/429700.xml">
List of search engines</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../652/21652.xml">
Natural language processing</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../023/4059023.xml">
Search engine</link></entry>
<entry level="1" type="bullet">

 <work wordnetid="100575741" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<service wordnetid="100577525" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<link xlink:type="simple" xlink:href="../123/29123.xml">
Semantic Web</link></activity>
</psychological_feature>
</act>
</service>
</event>
</work>
</entry>
<entry level="1" type="bullet">

 <software wordnetid="106566077" confidence="0.8">
<application wordnetid="106570110" confidence="0.8">
<program wordnetid="106568978" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106359877" confidence="0.8">
<code wordnetid="106355894" confidence="0.8">
<coding_system wordnetid="106353757" confidence="0.8">
<link xlink:type="simple" xlink:href="../439/318439.xml">
Text mining</link></coding_system>
</code>
</writing>
</written_communication>
</program>
</application>
</software>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../640/731640.xml">
Text Retrieval</link></entry>
<entry level="1" type="bullet">

 <artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<engine wordnetid="103287733" confidence="0.8">
<motor wordnetid="103789946" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<machine wordnetid="103699975" confidence="0.8">
<link xlink:type="simple" xlink:href="../995/5560995.xml">
Vertical search</link></machine>
</device>
</motor>
</engine>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

 <work wordnetid="100575741" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<service wordnetid="100577525" confidence="0.8">
<word wordnetid="106286395" confidence="0.8">
<part wordnetid="113809207" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<neologism wordnetid="106294441" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<language_unit wordnetid="106284225" confidence="0.8">
<link xlink:type="simple" xlink:href="../389/7581389.xml">
Web 3.0</link></language_unit>
</activity>
</neologism>
</psychological_feature>
</act>
</part>
</word>
</service>
</event>
</work>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../242/4047242.xml">
Windows indexing service</link><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2228%22])">28</ref></entry>
</list>
</p>

</sec>
<sec>
<st>
Further reading</st>
<p>

<list>
<entry level="1" type="bullet">

R. Bayer and E. McCreight. Organization and maintenance of large ordered indices. Acta Informatica, 173-189, 1972.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald E. Knuth</link>. The art of computer programming, volume 1 (3rd ed.): fundamental algorithms, Addison Wesley Longman Publishing Co. Redwood City, CA, 1997.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald E. Knuth</link>. The art of computer programming, volume 3: (2nd ed.) sorting and searching, Addison Wesley Longman Publishing Co. Redwood City, CA, 1998.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../624/509624.xml">
Gerald Salton</link>. Automatic text processing, Addison-Wesley Longman Publishing Co., Inc., Boston, MA, 1988.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../624/509624.xml">
Gerard Salton</link></associate>
</creator>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
. Michael J. McGill, Introduction to Modern Information Retrieval, McGraw-Hill, Inc., New York, NY, 1986.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../624/509624.xml">
Gerard Salton</link></associate>
</creator>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
. Lesk, M.E.: Computer evaluation of indexing and text processing. Journal of the ACM. January 1968.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../624/509624.xml">
Gerard Salton</link></associate>
</creator>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
. The SMART Retrieval System - Experiments in Automatic Document Processing. Prentice Hall Inc., Englewood Cliffs, 1971.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<pioneer wordnetid="110434725" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<originator wordnetid="110383816" confidence="0.8">
<creator wordnetid="109614315" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../624/509624.xml">
Gerard Salton</link></associate>
</creator>
</originator>
</scientist>
</causal_agent>
</colleague>
</pioneer>
</person>
</peer>
</physical_entity>
. The Transformation, Analysis, and Retrieval of Information by Computer, Addison-Wesley, Reading, Mass., 1989.</entry>
<entry level="1" type="bullet">

Baeza-Yates, R., Ribeiro-Neto, B.: Modern Information Retrieval. Chapter 8. ACM Press 1999.</entry>
<entry level="1" type="bullet">

G. K. Zipf. Human Behavior and the Principle of Least Effort. Addison-Wesley, 1949.</entry>
<entry level="1" type="bullet">

Adelson-Velskii, G.M., Landis, E. M.: An information organization algorithm. DANSSSR, 146, 263-266 (1962).</entry>
<entry level="1" type="bullet">

Edward H. Sussenguth, Jr., Use of tree structures for processing files, Communications of the ACM, v.6 n.5, p.272-279, May 1963</entry>
<entry level="1" type="bullet">

Harman, D.K., et al: Inverted files. In Information Retrieval: Data Structures and Algorithms, Prentice-Hall, pp 28-43, 1992.</entry>
<entry level="1" type="bullet">

Lim, L., et al: Characterizing Web Document Change, LNCS 2118, 133–146, 2001.</entry>
<entry level="1" type="bullet">

Lim, L., et al: Dynamic Maintenance of Web Indexes Using Landmarks. Proc. of the 12th W3 Conference, 2003.</entry>
<entry level="1" type="bullet">

Moffat, A., Zobel, J.: Self-Indexing Inverted Files for Fast Text Retrieval. ACM TIS, 349–379, October 1996, Volume 14, Number 4.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../749/15692749.xml">
Mehlhorn, K.</link></associate>
</research_worker>
</scholar>
</scientist>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</peer>
</physical_entity>
: Data Structures and Efficient Algorithms, Springer Verlag, EATCS Monographs, 1984.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../749/15692749.xml">
Mehlhorn, K.</link></associate>
</research_worker>
</scholar>
</scientist>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</peer>
</physical_entity>
, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/1177516.xml">
Overmars, M.H.</link></research_worker>
</scientist>
</causal_agent>
</person>
</physical_entity>
: Optimal Dynamization of Decomposable Searching Problems. IPL 12, 93–98, 1981.</entry>
<entry level="1" type="bullet">

<physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<alumnus wordnetid="109786338" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<scholar wordnetid="110557854" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../749/15692749.xml">
Mehlhorn, K.</link></associate>
</research_worker>
</scholar>
</scientist>
</causal_agent>
</alumnus>
</colleague>
</intellectual>
</person>
</peer>
</physical_entity>
: Lower Bounds on the Efficiency of Transforming Static Data Structures into Dynamic Data Structures. Math. Systems Theory 15, 1–16, 1981. </entry>
<entry level="1" type="bullet">

Koster, M.: ALIWEB: Archie-Like indexing in the Web. Computer Networks and ISDN Systems, Vol. 27, No. 2 (1994) 175-182 (also see Proc. First Int'l World Wide Web Conf., Elsevier Science, Amsterdam, 1994, pp. 175-182)</entry>
<entry level="1" type="bullet">

Serge Abiteboul and Victor Vianu. <weblink xlink:type="simple" xlink:href="http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&amp;doc=1996-20&amp;format=text&amp;compression=&amp;name=1996-20.text">
Queries and Computation on the Web</weblink>. Proceedings of the International Conference on Database Theory. Delphi, Greece 1997.</entry>
<entry level="1" type="bullet">

Ian H Witten, Alistair Moffat, and Timothy C. Bell. Managing Gigabytes: Compressing and Indexing Documents and Images. New York: Van Nostrand Reinhold, 1994.</entry>
<entry level="1" type="bullet">

A. Emtage and P. Deutsch, "Archie--An Electronic Directory Service for the Internet." Proc. Usenix Winter 1992 Tech. Conf., Usenix Assoc., Berkeley, Calif., 1992, pp. 93-110.</entry>
<entry level="1" type="bullet">

M. Gray, <weblink xlink:type="simple" xlink:href="http://www.mit.edu/people/mkgray/net/">
World Wide Web Wanderer</weblink>.</entry>
<entry level="1" type="bullet">

D. Cutting and J. Pedersen. "Optimizations for Dynamic Inverted Index Maintenance." Proceedings of the 13th International Conference on Research and Development in Information Retrieval, pp. 405-411, September 1990.</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.trackindexing.com">
Search Engine Indexing Tool</weblink></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<reflist>
<entry id="1">
Clarke, C., Cormack, G.: Dynamic Inverted Indexes for a Distributed Full-Text Retrieval System. TechRep MT-95-01, University of Waterloo, February 1995.</entry>
<entry id="2">
Stephen V. Rice, Stephen M. Bailey. <weblink xlink:type="simple" xlink:href="http://www.comparisonics.com/SearchingForSounds.html">
Searching for Sounds</weblink>. Comparisonics Corporation. May 2004. Verified Dec 2006</entry>
<entry id="3">
Charles E. Jacobs, Adam Finkelstein, David H. Salesin. <weblink xlink:type="simple" xlink:href="http://grail.cs.washington.edu/projects/query/mrquery.pdf">
Fast Multiresolution Image Querying</weblink>. Department of Computer Science and Engineering, University of Washington. 1995. Verified Dec 2006</entry>
<entry id="4">
Lee, James. <weblink xlink:type="simple" xlink:href="http://www.technologyreview.com/read_article.aspx?id=17772&amp;ch=infotech">
Software Learns to Tag Photos</weblink>. MIT Technology Review. November 09, 2006. Pg 1-2. Verified Dec 2006. Commercial external link</entry>
<entry id="5">
Brown, E.W.: Execution Performance Issues in Full-Text Information Retrieval. Computer Science Department, University of Massachusetts at Amherst, Technical Report 95-81, October 1995.</entry>
<entry id="6">
Cutting, D., Pedersen, J.: Optimizations for dynamic inverted index maintenance. Proceedings of SIGIR, 405-411, 1990.</entry>
<entry id="7">
<weblink xlink:type="simple" xlink:href="http://dev.mysql.com/doc/refman/5.1/en/partitioning-linear-hash.html">
Linear Hash Partitioning</weblink>. MySQL 5.1 Reference Manual. Verified Dec 2006</entry>
<entry id="8">
<weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/trie.html">
trie</weblink>, [http://www.nist.gov/dads Dictionary of Algorithms and Data Structures, <weblink xlink:type="simple" xlink:href="http://www.nist.gov">
U.S. National Institute of Standards and Technology</weblink>.</entry>
<entry id="9">
 <cite id="Reference-Gusfield-1999" style="font-style:normal" class="book">Gusfield, Dan&#32;[1997]&#32;(1999). Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology.&#32;USA:&#32;Cambridge University Press. ISBN 0-521-58519-8.</cite>&nbsp;.
</entry>
<entry id="10">
Black, Paul E., [http://www.nist.gov/dads/HTML/invertedIndex.html inverted index, [http://www.nist.gov/dads Dictionary of Algorithms and Data Structures, <weblink xlink:type="simple" xlink:href="http://www.nist.gov">
U.S. National Institute of Standards and Technology</weblink> Oct 2006. Verified Dec 2006.</entry>
<entry id="11">
C. C. Foster, Information retrieval: information storage and retrieval using AVL trees, Proceedings of the 1965 20th national conference, p.192-205, August 24-26, 1965, Cleveland, Ohio, United States </entry>
<entry id="12">
Landauer, W. I.: The balanced tree and its utilization in information retrieval. IEEE Trans. on Electronic Computers, Vol. EC-12, No. 6, December 1963.</entry>
<entry id="13">
<weblink xlink:type="simple" xlink:href="http://www.ldc.upenn.edu/Catalog/CatalogEntry.jsp?catalogId=LDC2006T13">
Google Ngram Datasets</weblink> for sale at <weblink xlink:type="simple" xlink:href="http://www.ldc.upenn.edu/">
LDC</weblink> Catalog</entry>
<entry id="14">
Jeffrey Dean and Sanjay Ghemawat. MapReduce: Simplified Data Processing on Large Clusters. Google, Inc. OSDI. 2004.</entry>
<entry id="15">
Grossman, Frieder, Goharian. <weblink xlink:type="simple" xlink:href="http://www.eng.auburn.edu/~gilbert/Comp7120/Concept-50/IR-Basics-of-Inverted-Index.pdf">
IR Basics of Inverted Index</weblink>. 2002. Verified Dec 2006.</entry>
<entry id="17">
<weblink xlink:type="simple" xlink:href="http://www.kimbly.com/code/invidx/haskell/InvIdx.lhs">
http://www.kimbly.com/code/invidx/haskell/InvIdx.lhs</weblink> - inverted index written in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../630/13630.xml">
Haskell</link></programming_language>
</entry>
<entry id="16">
Tang, Hunqiang. Dwarkadas, Sandhya. "Hybrid Global Local Indexing for Efficient
Peer to Peer Information Retrieval". University of Rochester. Pg 1. http://ftp.cs.rochester.edu/~sarrmor/publications/eSearch-NSDI04.pdf</entry>
<entry id="19">
Tomasic, A., et al: Incremental Updates of Inverted Lists for Text Document Retrieval. Short Version of Stanford University Computer Science Technical Note STAN-CS-TN-93-1, December, 1993.</entry>
<entry id="18">
<weblink xlink:type="simple" xlink:href="http://www.kimbly.com/code/invidx/lisp/invidx.cl">
http://www.kimbly.com/code/invidx/lisp/invidx.cl</weblink> - inverted index written in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../016/18016.xml">
Lisp</link></programming_language>
</entry>
<entry id="21">
H.S. Heaps. Storage analysis of a compression coding for a document database. 1NFOR, I0(i):47-61, February 1972.  </entry>
<entry id="20">
Sergey Brin and Lawrence Page. <weblink xlink:type="simple" xlink:href="http://infolab.stanford.edu/~backrub/google.html">
The Anatomy of a Large-Scale Hypertextual Web Search Engine</weblink>. <university wordnetid="108286163" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../977/26977.xml">
Stanford University</link></university>
. 1998. Verified Dec 2006.</entry>
<entry id="23">
Blair Bancroft. <weblink xlink:type="simple" xlink:href="http://www.blairbancroft.com/word_count.htm">
Word Count:A Highly Personal-and Probably Controversial-Essay on Counting Words</weblink>. Personal Website. Verified Dec 2006.</entry>
<entry id="22">
Murray, Brian H. <weblink xlink:type="simple" xlink:href="http://www.cyveillance.com/web/downloads/Sizing_the_Internet.pdf">
Sizing the Internet</weblink>. Cyveillance, Inc. Pg 2. July 2000. Verified Dec 2006.</entry>
<entry id="25">
<weblink xlink:type="simple" xlink:href="http://www.uplink.freeuk.com/data.html">
Storage estimates</weblink>. Verified Dec 2006.</entry>
<entry id="24">
<weblink xlink:type="simple" xlink:href="http://www.unicode.org/faq/basic_q.html#15">
The Unicode Standard - Frequently Asked Questions</weblink>. Verified Dec 2006.</entry>
<entry id="27">
Berners-Lee, T., "Hypertext Markup Language - 2.0", RFC 1866, Network Working Group, November 1995.</entry>
<entry id="26">
<weblink xlink:type="simple" xlink:href="http://www.pcpitstop.com/research/regionaltech.asp">
Average Total Hard Drive Size by Global Region</weblink>, February 2008. Verified May 2008.</entry>
<entry id="28">
Krishna Nareddy. <weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/ms951558.aspx">
Indexing with Microsoft Index Server</weblink>. MSDN Library. Microsoft Corporation. January 30, 1998. Verified Dec 2006. Note that this is a commercial, external link.</entry>
</reflist>
</p>
<p>

[Anatomy of a search engine http://infolab.stanford.edu/~backrub/google.html]
[Google n-gram information retriever http://n-gram-patterns.sourceforge.net/]</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
