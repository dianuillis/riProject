<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 22:56:48[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<physical_entity  confidence="0.8" wordnetid="100001930">
<person  confidence="0.8" wordnetid="100007846">
<model  confidence="0.8" wordnetid="110324560">
<assistant  confidence="0.8" wordnetid="109815790">
<worker  confidence="0.8" wordnetid="109632518">
<causal_agent  confidence="0.8" wordnetid="100007347">
<header>
<title>Counter machine reference model</title>
<id>7613849</id>
<revision>
<id>237165796</id>
<timestamp>2008-09-08T23:21:35Z</timestamp>
<contributor>
<username>Akldawgs</username>
<id>4758334</id>
</contributor>
</revision>
<categories>
<category>Computational models</category>
</categories>
</header>
<bdy>

The <b>Counter machine's reference model</b> is a set of choices and conventions to be used with the <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 and other model variants of the <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../218/505218.xml">
Register machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 concept. It permits comparisons between models, and serves a didactic function with regards to examples and descriptions.<p>

It is based on conventional models, labels and terminology. The <it>reference (base) model</it> is intended to preserve consistency between articles.</p>

<sec>
<st>
 Introduction </st>
<p>

In <link xlink:type="simple" xlink:href="../249/7599249.xml">
counter machine models</link> the reader will observe, and may be bewildered by, the plethora of instruction sets defined by their authors. This reference will use the symbolism defined below to provide a standarized presentation format (syntax) to facilitate comparison of the sets and help give them definition.</p>
<p>

The base model is derived from Minsky (1967), Lambek (1961) and in particular Shepherdson-Sturgis (1963 p. 225).</p>

</sec>
<sec>
<st>
 Formal Definition </st>
<p>

The <it>Counter machine reference model</it> consists of a finite set of registers r1 ... rn, each of which can hold a non-negative integer, r0  (always zero), and a finite list of instructions I1 ... Im. Each of the instructions in this list is one of the following:</p>
<p>

<list>
<entry level="1" type="bullet">

 INC(<it>j</it>) &mdash; increment the value of register <it>rj</it> by 1; go to the successor instruction (e.g. instruction that is numerically next-in-sequence). </entry>
<entry level="1" type="bullet">

 DEC(<it>j</it>) &mdash; If the contents of r is not 0 (not empty) then decrement the value of register <it>rj</it> by 1, else the contents of r=0; go to the successor instruction. </entry>
<entry level="1" type="bullet">

 JZ (<it>j</it>, <it>z</it>) &mdash; If the contents of register <it>rj</it> equals Zero then Jump to instruction <it>Iz</it> else go to the successor instruction.</entry>
<entry level="1" type="bullet">

 HALT &mdash; halts the computation.</entry>
</list>
</p>
<p>

<b>Formal Semantic</b>:</p>
<p>

<table class="wikitable">
<header>
Instruction</header>
<header>
Effect on register</header>
<header>
Effect on Instruction Counter (IC)</header>
<row>
<col>
INC ( j )</col>
<col>
 [ j ]+ 1 → j</col>
<col>
 [IC]+ 1 → IC</col>
</row>
<row>
<col>
DEC ( j )</col>
<col>
 IF [ j ] &amp;gt; 0 THEN [ j ]- 1 → j ELSE 0 → j</col>
<col>
 [ IC ]+ 1 → IC</col>
</row>
<row>
<col>
JZ ( j, z )</col>

<col>
 IF [ j ] =0 THEN Iz → IC ELSE [ IC ]+ 1 ) → IC</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Reference Library (RefLib)</st>
<p>

The "Counter machine reference model" library, or <b>RefLib</b>, is a set of conventions chosen to:
<list>
<entry level="1" type="bullet">

 Specify the "instruction labels";</entry>
<entry level="1" type="bullet">

 Specify the syntax (effective symbol-strings) of these labels;</entry>
<entry level="1" type="bullet">

 Specify the semantics (meaning, content) of the labels and demonstrate equivalences.</entry>
</list>
</p>
<p>

Through the <it>RefLib</it> other instruction sets from similar <link xlink:type="simple" xlink:href="../218/505218.xml">
register machine</link> models can be <link xlink:type="simple" xlink:href="../937/18943937.xml">
emulated</link>. In a sense the new instructions become "subroutines" of the "base" instructions -- Shepherdson-Sturgis (1963) used this strategy in their demonstration that the three base instructions form a set that is equivalent to the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s. The RefLib may be seen also as a <link xlink:type="simple" xlink:href="../999/19999.xml">
microcoded implementation strategy</link>: the same <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> is augmented by new instructions from instruction set; it is not a new machine. </p>
<p>

The RefLib scripts (instruction implementations) are "near to formal". For a precise demonstration imagine the use of a <language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../835/231835.xml">
C preprocessor</link></language>
 to expand the RefLib script templates into standard instructions.</p>

<ss1>
<st>
 Counter machine instructions </st>
<p>

The various <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 instruction sets are like "ultra-<class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../201/26201.xml">
RISC</link></group>
</collection>
</class>
 instruction sets". And, as is the case for different RISC machine builders, even for very similar machines, different authors have used different instruction sets. The "basic instructions" are used map these differences on the relevant <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 variant models.</p>
<p>

<table class="wikitable">
<header>
Emulated instruction</header>
<header>
Implementation (script)</header>
<header>
Comments</header>
<row>
<col>
<b>J</b>  (i)</col>
<col>
JZ (r0,i)</col>
<col>
Go to i (unconditional jump); register #0 must contain 0.</col>
</row>
<row>
<col>
<b>JZ</b>(rX, i1,i2)</col>
<col>
<list>
<entry level="1" type="number">

JZ (rX,i1)</entry>
<entry level="1" type="number">

JZ (r0,i2)</entry>
</list>
</col>
<col>
IF rX=0 THEN i1 ELSE i2</col>
</row>
<row>
<col>
<b>DECJZ</b>(r,i)</col>
<col>
<list>
<entry level="1" type="number">

JZ (r,*i)</entry>
<entry level="1" type="number">

DEC(r)</entry>
</list>
</col>
<col>
Test r=0; if r = 0 then DEC</col>
</row>
<row>
<col>
<b>INCJ</b>(r,i)</col>
<col>
<list>
<entry level="1" type="number">

INC(r)</entry>
<entry level="1" type="number">

J  (i)</entry>
</list>
</col>
<col>
INC and J.</col>
</row>
<row>
<col>
<b>CLR</b>(r)</col>
<col>
<list>
<entry level="1" type="number">

 JZ (r,*+3)</entry>
<entry level="1" type="number">

 DEC(r)</entry>
<entry level="1" type="number">

 J (*-2)</entry>
</list>
</col>
<col>
If r=0 goto *+3; if not then DEC and goto *-2</col>
</row>
<row>
<col>
<b>MOV</b>(rX,rY)</col>
<col>

1 CLR(rY)
2 JZ (rX,*+4)
3 INC(rY)
4 DEC(rX)         
5 J  (*-4)
6 CONTINUE
</col>
<col>
Move rX to rY, clearing contents of rX.</col>
</row>
<row>
<col>
<b>CPY</b>(rX,rY)</col>
<col>

1 CLR(rY)            9 JZ (rW,13) 
2 CLR(rW)           10 INC(rX)   
3 JZ (rX,8)         11 DEC(rW)   
4 INC(rY)           12 J (9) 
5 INC(rW)	    13 CONTINUE
6 DEC(rX)          
7 J  (3)
8 ??
</col>
<col>
Copy rX into rY, rW must be free (at end rW=0).</col>
</row>
<row>
<col>
<b>CPY</b> (k,r)</col>
<col>
<list>
<entry level="1" type="number">

 CLR (r)</entry>
<entry level="1" type="number">

 ( INC (r) )k</entry>
</list>
</col>
<col>
Immediate (explicit) copy constant k from instructions into R: Clear R and ( INC(r) )1 ,..., ( INC(r) )k i.e. do k times. Alternatively: put constant in register #K: CPY (K, r1)</col>
</row>
<row>
<col>
<b>CMP</b>(rX,rY,r)</col>
<col>

1 CPY(rX,r) 	  6 JZ(r0,3) 
2 CPY(rY,rW) 	  7 JZ(rW,9) 
3 JZ(r,7) 	  8 INC(r) 
4 DEC(r) 	  9 CONTINUE
5 DEC(rW)</col>
<col>
Compare rX with rY and returns on r (r=0 if rX equal rY).</col>
</row>
<row>
<col>
<b>ADD</b>(rX,rX,r)</col>
<col>
... in terms of JZ, DEC, J, CLR, INC, CPY.</col>
<col>
r=rX+rY; perhaps preserving the contents of rX and rY.</col>
</row>
<row>
<col>
<b>MUL</b>(rX,rY,r)</col>
<col>
... in terms of JZ, DEC, J, CLR, INC, CPY, ADD.</col>
<col>
MULtiply, r=rX*rY; perhaps preserving the contents of rX and rY.</col>
</row>
<row>
<col>
<b>SUB</b>(rX,rY,r)</col>
<col>
... in terms of ...</col>
<col>
SUBtract, r=rX-rY; perhaps preserving the contents of rX and rY.</col>
</row>
</table>
</p>

</ss1>
<ss1>
<st>
 Complex instructions </st>
<p>

The <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 analysis on instruction sets preceded, and was a "theoretical laboratory" for, the RISC vs CISC features. </p>
<p>

Many authors have augmented the <link xlink:type="simple" xlink:href="#xpointer(//*[./st=%22Formal+Definition%22])">
basic counter machine model</link> instruction set, with a more complex instructions, for this kind of studies.</p>
<p>

<table class="wikitable">
<header>
Emulated instruction</header>
<header>
Implementation (script)</header>
<header>
Comments</header>
<row>
<col>
<b>EXP</b>(rX,rY,r)</col>
<col>
... in terms of JZ, DEC, J, CLR, INC, CPY, ADD, MUL.</col>
<col>
EXPonential, r=rX**rY; perhaps preserving the contents of rX and rY.</col>
</row>
<row>
<col>
...</col>

<col>
... other "complex instrucions".</col>
</row>
</table>
</p>

</ss1>
<ss1>
<st>
 Overloading </st>
<p>

See Talk page.</p>

</ss1>
</sec>
<sec>
<st>
 NOTES </st>

<ss1>
<st>
 Reference Table Syntax </st>

<p>

The symbols { [ ], → } and the syntax can be found in Boolos-Burgess-Jeffrey (2002) (pp.45ff). The meaning of the symbol → is derived from Melzak (1961) and used by Boolos-Burgess-Jeffrey (2002). For a discussion of the <b>if-then-else</b> construction see <b>Footnote|IF-THEN-ELSE operator</b>:</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>[ ]</b> =def the phrase "the <it>contents</it> of"</entry>
<entry level="1" type="bullet">

 <b>r</b>  =def register with address/name/number "r". A "register" includes both an address/name/number and a contents [ ]: </entry>
<entry level="2" type="indent">

Example: [ 3 ] =def "contents of register with address/name/number '3' " </entry>
<entry level="1" type="bullet">

  →  =def  the "arrow" denotes "replaces" in the sense of "delete/empty/zero present contents then copy into". </entry>
<entry level="2" type="indent">

 <it>This is different from, for example "add to" (as in: throw a pebble into a hole) and "pick up and move to". For example: the two-variable instruction INC (rj, rj) might be defined as [ rj ] +1 → [ rk ], to be read as, "The contents of register rj plus one replaces the original contents of register rk, and the contents of register rj remains the same. This is different from [ rj ] +1 → [ rk ], and 0 → [ rj ] which signifies that the contents of register rj was actually taken from rj and moved into register rk, thus cleaning out rj, and then 1 added to rk.</it>       </entry>
<entry level="1" type="bullet">

 <b>IC</b> =def Instruction Counter-Register, the finite-state machine's state-register</entry>
<entry level="2" type="indent">

Example: "[ IR ] + 1 → IR " is read in prose: "The contents of the finite-state machine's Instruction Register plus 1 is 'replaces the (previous) contents of' the Instruction Counter Register (ICR) ".</entry>
<entry level="2" type="indent">

Example: " Iz → IR " means "Instruction number Iz replaces the (previous) contents of the Instruction Register."</entry>
<entry level="1" type="bullet">

 <b>+1</b> =def successor function S(a) = a' = a+1 (See Footnote|Successor model) </entry>
<entry level="1" type="bullet">

 <b>-1</b> =def predecessor function pd(a') = a (See Footnote|Successor model)</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Choice of "Reference (Base) model" </st>
<p>

<indent level="1">

<it>This model does not use indirect addressing; see <link>
Random Access Machine reference model</link>.</it>
</indent>

From either of two 3-instruction base sets all the other <link xlink:type="simple" xlink:href="../543/7583543.xml">
counter machine</link> instructions can be derived. Both have advantages and disadvantages. </p>
<p>

The model {INC, DEC, JZ} was chosen because a survey of the literature indicates it is more common, and its use is (arguably) easier.</p>
<p>

In a historical and theoretical sense the second (the so-called "successor"-model) is arguably "more basic" because it closely resembles the Peano axioms, the operators of the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s, and the <link xlink:type="simple" xlink:href="../818/7667818.xml">
McCarthy Formalism</link>. For more, see <b>Footnote|Successor model</b>; this footnote shows how the DECrement and JZ (Jump-if-Zero) instruction can be derived from the "successor" model.</p>

</ss1>
<ss1>
<st>
 Choice of instruction mnemonics </st>
<p>

There is no conventional set of instruction names (mnemonics). Boolos-Burgess-Jeffrey (2002) do not bother with mnemonics at all. Minsky 1967 uses symbols such as " [ ' ] ". For the conditional and unconditional instructions, some authors such as Stone (1972) use "branch" in place of "jump". Branch sometimes is used "relatively" ('branch back three instructions') as opposed to "absolutely" ('jump to instruction #5'). Most authors use "goto" interchangeably with "jump". This reference will follow Knuth (1971) and use "Jump" (Jx, where x indicates the type of test)</p>
<p>

Knuth's abbreviations-as-mnemonics are of particular interest to this reference model. Even without their definition, the reader may be able to guess the rough meaning of the mnemonics/abbreviations. 
<indent level="1">

 In Knuth's following list, n is actually a parameter specifying a particular register e.g. LD2, ST3, INC1. Their formation-principle seems to be (i) the use of English, (ii) no more than 3-4 letters, (iii) preferably not vowels (N_OPeration, MOVE are exceptions). "A" appended indicates a specific "accumulator register" e.g. LDA, STA, CMPA, INCA.  
</indent>
:: { NOP, ADD, SUB, LDA, LDAN, LDn,  STA, STn, J, CMP, CMPA, IN, OUT, MUL, DIV, HLT, MOVE, JMP, INCA, INCn }.</p>
<p>

Note that DECrement (DEC), nor CoPY (CPY) are on in the list { DEC, DECA, CPY }. These will be added. A few more { JZ, JNZ, JE, JNE } will necessary and are formed using the initials <b>J</b>ump, <b>Z</b>, <b>N</b>ot, <b>E</b>quals. </p>
<p>

Compound instructions e.g. "JZDEC" will be the concatenation of the two simpler mnemonics.</p>

</ss1>
</sec>
<sec>
<st>
 Footnotes </st>
<p>

<b>Footnote|Successor model:</b></p>
<p>

Some readers may argue that the "successor model" -- counter machine with instructions, where "JE" means "Jump if Equal", i.e. 
<indent level="1">

{ CLR (r), INC(r), JE (rj, rk, z) } 
</indent>

is "more basic", because it closely resembles the <process wordnetid="105701363" confidence="0.8">
<maxim wordnetid="107152948" confidence="0.8">
<speech wordnetid="107109196" confidence="0.8">
<saying wordnetid="107151380" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<auditory_communication wordnetid="107109019" confidence="0.8">
<explanation wordnetid="105793000" confidence="0.8">
<theory wordnetid="105989479" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/25005.xml">
Peano axioms</link></higher_cognitive_process>
</theory>
</explanation>
</auditory_communication>
</thinking>
</saying>
</speech>
</maxim>
</process>
 and the operators of the<link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s. Indeed the model can be found in Minsky (1967) (p. 192ff) in his discussion of a <link xlink:type="simple" xlink:href="../406/3246406.xml">
Turing equivalent</link> set of operators called the <link xlink:type="simple" xlink:href="../818/7667818.xml">
McCarthy Formalism</link>.</p>
<p>

Minsky shows how to derive DEC (r) from the three-instruction successor-set (cf. p. 211) -- JZ is trivial --and he proceeds to use this second model in his discussion of its equivalence to the <link xlink:type="simple" xlink:href="../829/24829.xml">
primitive recursive function</link>s and the general-<link xlink:type="simple" xlink:href="../264/5987264.xml">
recursive functions</link> (cf p. 212ff).</p>
<p>

With this "successor" set the problem of the first set { INC, DEC, JZ } around what happens when DEC occurs on an empty register does not occur; however, the model requires JE to have a 3-parameter format: JE(r1, r2, z). </p>
<p>

<b>Formal Syntax</b>:</p>
<p>

<indent level="1">

In the following, the letter "r" will be put in front of a register number e.g. r0 in place of "0" to avoid confusion of "zero" with the register named "0", for example to avoid ambiguous symbolism such as "0 → 3". "z" is a number of an instruction Iz. 
</indent>
<table class="wikitable">
<row style="background-color:#C0C0C0;font-size:9pt;font-weight:bold" align="center" valign="bottom">
<col width="60" Height="12">
Instruction</col>
<col width="171.6">
Effect on register</col>
<col width="366.6">
Effect on state-machine's Instruction Counter Register ICR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
CLR ( r )</col>
<col align="center" valign="bottom">
0 → r</col>
<col align="center" valign="bottom">
 [ IR ]+ 1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
INC (  r )</col>
<col align="center" valign="bottom">
 [ r ]+ 1 → r</col>
<col align="center" valign="bottom">
 [ IR ]+ 1 → IR</col>
</row>
<row style="font-size:9pt">
<col Height="11.4" valign="bottom">
JE ( rj, rk, z)</col>
<col align="center" valign="bottom"></col>
<col align="center" valign="bottom">
 If [ rj ] = [ rk ] THEN z → IR ELSE [IR]+ 1 → IR</col>
</row>
</table>
</p>
<p>

The following shows how the successor set { CLR (r), INC (r), JE (rj, rk, z) } creates the instruction set { INC (r), DEC (r), JZ (r, z) }. A similar treatment can be found in Minsky (p. 211) excepting that Minsky uses JNE -- Jump if Not Equal --rather than JE. </p>
<p>

<list>
<entry level="1" type="bullet">

(1) INC (r) is the same for both sets.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

(2) JZ (rk, z) = JE (r0, rk, z) ; contents of register "r0" must be 0</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

(3) DEC (r5) requires the use of two scratch-pad registers #r2 &amp; #r3. The algorithm proceeds by first clearing a scratch pad and testing input #r5 for 0, then (ii) clearing scratchpad #r3 and then, while contents of #r2 ≠ contents of #r5, incrementing #r2 so that #r3 is always one behind #r3, (iii) when #r2 is equal to #r5 (#r3 is one less than both), then clearing #r5 and copying #r3 back into #r5, (v) cleaning up the mess leaving only #r5 with contents.</entry>
</list>
</p>
<p>

NOTE: In the following example of "DEC (r5), rather than use a "free_variable" such as "r", we declare explicit register #r5. This emphasizes the point that each instance of DEC must be built separately with its own explicit register declared. This is because "DEC (r5)" is not "calling a subroutine" called DEC and "passing 5" to it, but rather "DEC (r5)" is its own little piece of 14-line "code" to be inserted (by hand or compiler) wherever it is desired (DEC (r4) would be <it>its</it> own piece of code, etc). This example emphasizes the fact that, once fixed, an instruction set such as { CLR, INC, JE } for a counter machine specifies <it>hardware</it> of the state machine, not "software patches". In the case of a RAM or RASP, indirect addressing would allow for true subroutines.   
<table class="wikitable">
<row style="font-size:9pt;font-weight:bold" align="center" valign="bottom">
<col width="66.6" Height="12">
Label:</col>
<col width="41.4">
Instr. #:</col>
<col width="54.6">
Instruction:</col>
<col width="259.8">
Formal equivalence:</col>
<col width="165">
Comment</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="12" valign="bottom">
DEC (5):</col>
<col style="font-weight:bold" align="center" valign="bottom"></col>
<col style="font-weight:bold" align="center" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom">
target register #5 contains <it>n</it> or 0</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="9.6" valign="bottom">
initialize:</col>
<col align="center" valign="bottom">
1</col>
<col valign="bottom">
CLR (r2)</col>
<col valign="bottom">
0 →  r2</col>
<col valign="bottom">
clear scratch-pad register #r2</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="9.6" valign="bottom">
test_for zero:</col>
<col align="center" valign="bottom">
r2</col>
<col valign="bottom">
JE (r5,r2,13)</col>
<col valign="bottom">
 If [ r5 ] = [ r2 ] then 13 → IR else [ IR ]+1 → ICR</col>
<col valign="bottom">
If contents of target register=0 then done</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="3" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
3</col>
<col valign="bottom">
CLR (r3)</col>
<col valign="bottom">
Ø →  r3</col>
<col valign="bottom">
clear scratch-pad register #3</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="9.6" valign="bottom">
increment_loop:</col>
<col align="center" valign="bottom">
4</col>
<col valign="bottom">
INC (r2)</col>
<col valign="bottom">
 [ r2 ]+1  →  2</col>
<col valign="bottom">
Increment register #2 until contents of #2= contents of #5</col>
</row>
<row style="font-size:9pt">
<col Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
5</col>
<col valign="bottom">
JE (r5,r2,8)</col>
<col valign="bottom">
 If [ r5 ] = [ r2 ] then 8→ IR else [ IR ]+1 → IR</col>
<col align="center" valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
6</col>
<col valign="bottom">
INC (r3)</col>
<col valign="bottom">
 [ r3 ]+1  →  r3</col>
<col valign="bottom">
Contents of #3 will be one less than contents of #2</col>
</row>
<row style="font-size:9pt">
<col Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
7</col>
<col valign="bottom">
JE (r5,r5,4)</col>
<col valign="bottom">
 If [ r5 ] = [ r5 ] then 4 → ICR else [ ICR ]+1  = ICR</col>
<col valign="bottom">
Unconditional jump</col>
</row>
<row style="font-size:9pt">
<col Height="3" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="10.2" valign="bottom">
move(3,1):</col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
8</col>
<col valign="bottom">
CLR (r5)</col>
<col valign="bottom">
0 →  r5</col>
<col valign="bottom">
clear target register #5</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="9.6" valign="bottom">
move(3,1)_loop:</col>
<col align="center" valign="bottom">
9</col>
<col valign="bottom">
JE (r5,r3, 12)</col>
<col valign="bottom">
 If [ r5 ] = [ r3 ] then 12 → IR else [ IR ]+1 → IR</col>
<col valign="bottom">
clear scratch-pad register #2</col>
</row>
<row style="font-size:9pt">
<col align="center" Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
10</col>
<col valign="bottom">
INC (r5)</col>
<col valign="bottom">
 [ r5 ]+1  →  r5</col>
<col valign="bottom">
Increment contents of register #5</col>
</row>
<row style="font-size:9pt">
<col Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
11</col>
<col valign="bottom">
JE (r5,r5,9)</col>
<col valign="bottom">
 If [ r5 ] = [ r5 ] then 9→ IR else [ IR ]+1 → IR</col>
<col valign="bottom">
Unconditional jump to instruction 9</col>
</row>
<row style="font-size:9pt">
<col Height="9.6" valign="bottom"></col>
<col align="center" valign="bottom">
12</col>
<col valign="bottom">
JE (r5,r5,10)</col>
<col valign="bottom">
 If [ r5 ] = [ r5 ] then 10 → IR else [ IR ]+1 → IR</col>
<col valign="bottom">
Unconditional jump to instruction 10</col>
</row>
<row style="font-size:9pt">
<col Height="3" valign="bottom"></col>
<col align="center" valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
<col valign="bottom"></col>
</row>
<row style="font-size:9pt">
<col Height="9" valign="bottom"></col>
<col align="center" valign="bottom">
13</col>
<col valign="bottom">
CLR (r2)</col>
<col valign="bottom">
0 →  r2</col>
<col valign="bottom">
clear scratch-pad register #2</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="9.6" valign="bottom">
clean_up:</col>
<col align="center" valign="bottom">
14</col>
<col valign="bottom">
CLR (r3)</col>
<col valign="bottom">
0 →  r3</col>
<col valign="bottom">
clear scratch-pad register #3</col>
</row>
<row style="font-size:9pt">
<col style="font-style:Italic" Height="9.6" valign="bottom">
done:</col>
<col align="center" valign="bottom">
15</col>
<col valign="bottom">
etc.</col>
<col valign="bottom">
etc.</col>
<col valign="bottom">
target register #5 contains <it>n-1</it> or <it>Ø''</it></col>
</row>
</table>
</p>
<p>

<b>Footnote|IF-THEN-ELSE operator</b>:</p>
<p>

From Minsky (1967):
<indent level="1">

 " f = (<b>if</b> p1 <b>then</b> e1 <b>else</b> e1)
</indent>
: "This expression means
<indent level="2">

"See if p1 is true; if so the value of f is given by e1. If p1 is false, the value of f is given by e2." (Minsky 1967 pp. 192ff: <it>Conditional Expressions; The McCarthy Formalism</it>)
</indent>

This type of operator can also be found as the CASE function defined in Kleene (1952) p. 229 #F ("mutually-exclusive predicates").</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../543/7583543.xml">
Counter machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 the "main user" of RefLib.</entry>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../218/505218.xml">
Register machine</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
 the "hub article" for other models. There are another "augmented models", and the respectives "reference models":</entry>
<entry level="2" type="bullet">

  (or RAMrefModel): augment the indirect addressing and the RefLib for it. Is used also on the <link xlink:type="simple" xlink:href="../421/7179421.xml">
Random access program machine</link>.</entry>
<entry level="2" type="bullet">

 : base on the RAMrefModel.</entry>
</list>
</p>

</sec>
</bdy>
</causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</article>
