<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:39:59[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Marzullo&apos;s algorithm</title>
<id>776615</id>
<revision>
<id>206416743</id>
<timestamp>2008-04-18T03:30:48Z</timestamp>
<contributor>
<username>Gregbard</username>
<id>1193764</id>
</contributor>
</revision>
<categories>
<category>Agreement algorithms</category>
</categories>
</header>
<bdy>

<b>Marzullo's algorithm</b>, invented by <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../862/14411862.xml">
Keith Marzullo</link></scientist>
</causal_agent>
</person>
</physical_entity>
 for his Ph.D. dissertation in 1984, is an <link>
agreement algorithm</link> used to select sources for estimating accurate time from a number of <link xlink:type="simple" xlink:href="../415/41415.xml">
noisy</link> time sources. A refined version of it, renamed the "<link xlink:type="simple" xlink:href="../240/1266240.xml">
intersection algorithm</link>", forms part of the modern <message wordnetid="106598915" confidence="0.8">
<protocol wordnetid="106665108" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<direction wordnetid="106786629" confidence="0.8">
<rule wordnetid="106652242" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../886/159886.xml">
Network Time Protocol</link></system_of_measurement>
</rule>
</direction>
</standard>
</protocol>
</message>
.
<sec>
<st>
Purpose</st>

<p>

Marzullo's algorithm is efficient in terms of time for producing an optimal value from a set of estimates with <link xlink:type="simple" xlink:href="../911/280911.xml">
confidence interval</link>s where the actual value may be outside the confidence interval for some sources.  In this case the best estimate is taken to be the smallest interval <link xlink:type="simple" xlink:href="../802/75802.xml">
consistent</link> with the largest number of sources.</p>
<p>

If we have the estimates 10&nbsp;&amp;plusmn;&nbsp;2, 12&nbsp;&amp;plusmn;&nbsp;1 and 11&nbsp;&amp;plusmn;&nbsp;1 then these intervals are [8,12], [11,13] and [10,12] which intersect to form [11,12] or 11.5&nbsp;&amp;plusmn;&nbsp;0.5 as consistent with all three values. 
<image location="center" width="600x600px" src="Marzullo_example-1.jpg">
<caption>

Marzullo's algorithm, example#1
</caption>
</image>
</p>
<p>

If instead the ranges are [8,12], [11,13] and [14,15] then there is no interval consistent with all these values but [11,12] is consistent with the largest number of sources &mdash; namely, two of them. 
<image location="center" width="600x600px" src="Marzullo_example-2.jpg">
<caption>

Marzullo's algorithm, example#2
</caption>
</image>
</p>
<p>

Finally, if the ranges are [8,9], [8,12] and [10,12] then both the intervals [8,9] and [10,12] are consistent with the largest number of sources.
<image location="center" width="600x600px" src="Marzullo_example-3.jpg">
<caption>

Marzullo's algorithm, example#3
</caption>
</image>
</p>
<p>

This procedure determines an interval. If the desired result is a best value from that interval then a naive approach would be to take the center of the interval as the value, which is what was specified in the original Marzullo algorithm. A more sophisticated approach would recognize that this could be throwing away useful information from the confidence intervals of the sources and that a <link xlink:type="simple" xlink:href="../576/27576.xml">
probabilistic model</link> of the sources could return a value other than the center.</p>
<p>

Note that the computed value is probably better described as "optimistic" rather than  "optimal". For example, consider three intervals [10,12], [11, 13] and [11.99,13]. The algorithm described below computes [11.99, 12] or 11.995&nbsp;&amp;plusmn;&nbsp;0.005 which is a very precise value. If we suspect that one of the estimates might be incorrect, then at least two of the estimates must be correct.  Under  this condition, the best estimate is [11,13] since this is the largest interval that always intersects at least two estimates. The algorithm described below is easily parameterized with the maximum number of incorrect estimates.</p>

</sec>
<sec>
<st>
Method</st>

<p>

Marzullo's algorithm begins by preparing a table of the sources, sorting it and then searching (efficiently) for the intersections of intervals.  For each source there is a range [c&amp;minus;r,c+r] defined by c&nbsp;&amp;plusmn;&nbsp;r. For each range the table will have two <link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link>s of the form . One tuple will represent the beginning of the range, marked with type &amp;minus;1 as  and the other will represent the end with type +1 as .</p>
<p>

The description of the algorithm uses the following variables: best (largest number of overlapping intervals found), cnt (current number of overlapping intervals), beststart and bestend (the beginning and end of best interval found so far), i (an index), and the table of tuples.</p>
<p>

0) Build the table of tuples.</p>
<p>

1) <link xlink:type="simple" xlink:href="../442/28442.xml">
Sort</link> the table by the offset.  (If two tuples with the same offset but opposite types exist, indicating that one interval ends just as another begins, then a method of deciding which comes first is necessary.  Such an occurrence can be considered an overlap with no duration, which can be found by the algorithm by putting type &amp;minus;1 before type +1. If such pathological overlaps are considered objectionable they can be avoided by putting type +1 before &amp;minus;1 in this case.)</p>
<p>

2) [initialize] best=0 cnt=0 </p>
<p>

3) [loop] go through each tuple in the table in ascending order</p>
<p>

<indent level="1">

4) [current number of overlapping intervals] cnt=cnt-type[i]
</indent>

<indent level="1">

5) if cnt&amp;gt;best then best=cnt  beststart=offset[i] bestend=offset[i+1]
</indent>

<indent level="1">

<it>commentary: the next tuple, at [i+1], will either be an end of an interval (type=+1) in which case it ends this best interval, or it will be a beginning of an interval (type=&amp;minus;1) and in the next step will replace best.</it>
</indent>

<indent level="1">

<it>ambiguity: unspecified is what to do if best=cnt.  This is a condition of a tie for greatest overlap.  The decision can either be made to take the smaller of bestend&amp;minus;beststart or offset[i+1]&amp;minus;offset[i] or just take an arbitrary one of the two equally good entries.</it>
</indent>

6) [end loop] return [beststart,bestend] as optimal interval.  The number of <it>false</it> sources (ones which do not overlap the optimal interval returned) is the number of sources minus the value of best.</p>

</sec>
<sec>
<st>
Efficiency</st>
<p>

Marzullo's algorithm is efficient in both space and time.  The <link xlink:type="simple" xlink:href="../503/3469503.xml">
asymptotic</link> space usage is <link xlink:type="simple" xlink:href="../578/44578.xml">
O(m)</link>, where m is the number of sources.  In considering the asymptotic time requirement the algorithm can be considered to consist of building the table, sorting it and searching it.  Sorting can be done in O(m log m) time, and this dominates the building and searching phases which can be performed in <link xlink:type="simple" xlink:href="../591/91591.xml">
linear</link> time.  Therefore the time efficiency of Marzullo's algorithm is <link xlink:type="simple" xlink:href="../578/44578.xml">
O(m log m)</link>.</p>
<p>

Once the table has been built and sorted it is possible to update the interval for one source (when new information is received) in linear time.  Therefore, updating data for one source and finding the best interval can be done in O(m) time.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 K. A. Marzullo. Maintaining the Time in a Distributed System: An Example of a Loosely-Coupled Distributed Service. Ph.D. dissertation, Stanford University, Department of Electrical Engineering, February 1984.</entry>
</list>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 David L. Mills, <weblink xlink:type="simple" xlink:href="http://www.eecis.udel.edu/~mills/database/papers/history.pdf">
A Brief History of NTP Time: Confessions of an Internet Timekeeper</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cse.ucsd.edu/users/marzullo/">
Keith Marzullo's homepage</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
