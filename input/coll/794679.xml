<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:40:22[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Suffix tree</title>
<id>794679</id>
<revision>
<id>233125577</id>
<timestamp>2008-08-20T15:13:55Z</timestamp>
<contributor>
<username>RomanPszonka</username>
<id>6689446</id>
</contributor>
</revision>
<categories>
<category>Trees (structure)</category>
<category>Algorithms on strings</category>
</categories>
</header>
<bdy>

<image location="right" width="250px" src="Suffix_tree_BANANA.svg" type="thumb">
<caption>

Suffix tree for the string BANANA padded with $. The six paths from the root to a leaf (shown as boxes) correspond to the six suffixes A$, NA$, ANA$, NANA$, ANANA$ and BANANA$. The numbers in the boxes give the start position of the corresponding suffix. Suffix links drawn dashed.
</caption>
</image>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, a <b>suffix tree</b> (also called <b>suffix trie</b>, <b>PAT tree</b> or, in an earlier form, <b>position tree</b>) is a data structure that presents the <link xlink:type="simple" xlink:href="../028/4557028.xml">
suffixes</link> of a given <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<category wordnetid="105838765" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<type wordnetid="105840188" confidence="0.8">
<kind wordnetid="105839024" confidence="0.8">
<link xlink:type="simple" xlink:href="../701/27701.xml">
string</link></kind>
</type>
</language>
</category>
</concept>
</idea>
 in a way that allows for a particularly fast implementation of many important string operations.<p>

The suffix tree for a string <math>S</math> is a <link xlink:type="simple" xlink:href="../806/30806.xml">
tree</link> whose edges are labeled with strings, and such that each suffix of <math>S</math> corresponds to exactly one path from the tree's root to a leaf. It is thus a <link xlink:type="simple" xlink:href="../659/1481659.xml">
radix tree</link> (more specifically, a <link xlink:type="simple" xlink:href="../659/1481659.xml">
Patricia trie</link>) for the suffixes of <math>S</math>. </p>
<p>

Constructing such a tree for the string <math>S</math> takes time and space linear in the length of <math>S</math>. Once constructed, several operations can be performed quickly, for instance locating a <link xlink:type="simple" xlink:href="../560/2696560.xml">
substring</link> in <math>S</math>, locating a substring if a certain number of mistakes are allowed, locating matches for a <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link> pattern etc. Suffix trees also provided one of the first linear-time solutions for the <link xlink:type="simple" xlink:href="../401/2167401.xml">
longest common substring problem</link>. These speedups come at a cost: storing a string's suffix tree typically requires significantly more space than storing the string itself.</p>

<sec>
<st>
History</st>
<p>
 
The concept was first introduced as a <it>position tree</it> by  Weiner in 1973<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> in a paper which <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
 subsequently characterized as "Algorithm of the Year 1973".  The construction was greatly simplified by McCreight in 1976
<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>
, and also by Ukkonen in 1995<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>.  Ukkonen provided the first linear-time online-construction of suffix trees, now known as <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../031/4067031.xml">
Ukkonen's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>

</sec>
<sec>
<st>
Definition</st>
<p>

The suffix tree for the string <math>S</math> of length <math>n</math> is defined as a tree such that (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 90): 
<list>
<entry level="1" type="bullet">

 the paths from the root to the leaves have a one-to-one relationship with the suffixes of <math>S</math>, </entry>
<entry level="1" type="bullet">

 edges spell non-empty strings, </entry>
<entry level="1" type="bullet">

 and all internal nodes (except perhaps the root) have at least two children. </entry>
</list>
</p>
<p>

Since such a tree does not exist for all strings, <math>S</math> is padded with a terminal symbol not seen in the string (usually denoted $). This ensures that no suffix is a prefix of another, and that there will be <math>n</math> leaf nodes, one for each of the <math>n</math> suffixes of <math>S</math>. Since all internal non-root nodes are branching, there can be at most <math>n-1</math> such nodes, and <math>n+(n-1)+1=2n</math> nodes in total.</p>
<p>

<b>Suffix links</b> are a key feature for linear-time construction of the tree. In a complete suffix tree, all internal non-root nodes have a suffix link to another internal node. If the path from the root to a node spells the string <math>\chi\alpha</math>, where <math>\chi</math> is a single character and <math>\alpha</math> is a string (possibly empty), it has a suffix link to the internal node representing <math>\alpha</math>. See for example the suffix link from the node for ANA to the node for NA in the figure above. Suffix links are also used in some algorithms running on the tree.</p>

</sec>
<sec>
<st>
Functionality</st>

<p>

A suffix tree for a string <math>S</math> of length <math>n</math> can be built in <math>\Theta(n)</math> time, if the alphabet is <link>
constant</link> or <link>
integer</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>. Otherwise, the construction time depends on the implementation. The costs below are given under the assumption that the alphabet is constant. If it is not, the cost depends on the implementation (see below).</p>
<p>

Assume that a suffix tree has been built for the string <math>S</math> of length <math>n</math>, or that a <link xlink:type="simple" xlink:href="../847/3142847.xml">
generalised suffix tree</link> has been built for the set of strings <math>D=\{S_1,S_2,...,S_K\}</math> of total length <math>n=|n_1|+|n_2|+...+|n_K|</math>.
You can:</p>
<p>

<list>
<entry level="1" type="bullet">

 Search for strings:</entry>
<entry level="2" type="bullet">

 Check if a string <math>P</math> of length <math>m</math> is a substring in <math>O(m)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 92).</entry>
<entry level="2" type="bullet">

 Find the first occurrence of the patterns <math>P_1,...,P_q</math> of total length <math>m</math> as substrings in <math>O(m)</math> time, when the suffix tree is built using <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../031/4067031.xml">
Ukkonen's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</entry>
<entry level="2" type="bullet">

 Find all <math>z</math> occurrences of the patterns <math>P_1,...,P_q</math> of total length <math>m</math> as substrings in <math>O(m + z)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 123).</entry>
</list>
</p>
<p>

<list>
<entry level="2" type="bullet">

 Search for a <link xlink:type="simple" xlink:href="../717/25717.xml">
regular expression</link> <it>P</it> in time expected <link xlink:type="simple" xlink:href="../541/1750541.xml">
sublinear</link> in <math>n</math> (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>).</entry>
<entry level="2" type="bullet">

 Find for each suffix of a pattern <math>P</math>, the length of the longest match between a prefix of <math>P[i...m]</math> and a substring in <math>D</math> in <math>\Theta(m)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 132). This is termed the <b>matching statistics</b> for <math>P</math>.</entry>
<entry level="1" type="bullet">

 Find properties of the strings:</entry>
<entry level="2" type="bullet">

 Find the <link xlink:type="simple" xlink:href="../401/2167401.xml">
longest common substrings</link> of the string <math>S_i</math> and <math>S_j</math> in <math>\Theta(n_i + n_j)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 125). </entry>
<entry level="2" type="bullet">

 Find all <link xlink:type="simple" xlink:href="../178/7818178.xml">
maximal pair</link>s, maximal repeats or supermaximal repeats in <math>\Theta(n + z)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 144).</entry>
<entry level="2" type="bullet">

 Find the <link xlink:type="simple" xlink:href="../854/75854.xml">
Lempel-Ziv</link> decomposition in <math>\Theta(n)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 166). </entry>
<entry level="2" type="bullet">

 Find the <link xlink:type="simple" xlink:href="../340/3980340.xml">
longest repeated substrings</link> in <math>\Theta(n)</math> time.</entry>
<entry level="2" type="bullet">

 Find the most frequently occurring substrings of a minimum length in <math>\Theta(n)</math> time.</entry>
<entry level="2" type="bullet">

 Find the shortest strings from <math>\Sigma</math> that do not occur in <math>D</math>, in <math>O(n + z)</math> time, if there are <math>z</math> such strings.</entry>
<entry level="2" type="bullet">

 Find the shortest substrings occurring only once in <math>\Theta(n)</math> time.</entry>
<entry level="2" type="bullet">

 Find, for each <math>i</math>, the shortest substrings of <math>S_i</math> not occurring elsewhere in <math>D</math> in <math>\Theta(n)</math> time.</entry>
</list>
</p>
<p>

The suffix tree can be prepared for constant time <link xlink:type="simple" xlink:href="../522/7196522.xml">
lowest common ancestor</link> retrieval between nodes in <math>\Theta(n)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> chapter 8). You can then also:
<list>
<entry level="1" type="bullet">

 Find the longest common prefix between the suffixes <math>S_i[p..n_i]</math> and <math>S_j[q..n_j]</math> in <math>\Theta(1)</math> (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 196). </entry>
<entry level="1" type="bullet">

 Search for a pattern <math>P</math> of length <math>m</math> with at most <math>k</math> mismatches in <math>O(k n + z)</math> time, where <math>z</math> is the number of hits (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 200).</entry>
<entry level="1" type="bullet">

 Find all <math>z</math> maximal <link xlink:type="simple" xlink:href="../147/24147.xml">
palindrome</link>s in <math>\Theta(n)</math>(<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 198), or <math>\Theta(g n)</math> time if gaps of length <math>g</math> are allowed, or <math>\Theta(k n)</math> if <math>k</math> mismatches are allowed (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 201).</entry>
<entry level="1" type="bullet">

 Find all <math>z</math> <link>
tandem repeats</link> in <math>O(n \log n + z)</math>, and k-mismatch tandem repeats in <math>O(k n \log (n/k) + z)</math> (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 204).</entry>
<entry level="1" type="bullet">

 Find the <link xlink:type="simple" xlink:href="../401/2167401.xml">
longest substrings common</link> to at least <math>k</math> strings in <math>D</math> for <math>k=2..K</math> in <math>\Theta(n)</math> time (<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> page 205).</entry>
</list>
</p>

</sec>
<sec>
<st>
Uses</st>
<p>

Suffix trees are often used in <link xlink:type="simple" xlink:href="../214/4214.xml">
bioinformatics</link> applications, where they are used for searching for patterns in <link xlink:type="simple" xlink:href="../955/7955.xml">
DNA</link> or <link xlink:type="simple" xlink:href="../634/23634.xml">
protein</link> sequences, which can be viewed as long strings of characters. The ability to search efficiently with mismatches might be the suffix tree's greatest strength. It is also used in <link xlink:type="simple" xlink:href="../013/8013.xml">
data compression</link>, where on the one hand it is used to find repeated data and on the other hand it can be used for the sorting stage of the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../777/36777.xml">
Burrows-Wheeler transform</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. Variants of the <link xlink:type="simple" xlink:href="../854/75854.xml">
LZW</link> compression schemes use it (<link xlink:type="simple" xlink:href="../441/2211441.xml">
LZSS</link>). A suffix tree is also used in <link>
suffix tree clustering</link>, a <link xlink:type="simple" xlink:href="../675/669675.xml">
data clustering</link> algorithm used in some search engines (first introduced in <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref>).</p>

</sec>
<sec>
<st>
Implementation</st>
<p>

If each node and edge can be represented in <math>\Theta(1)</math> space, the entire tree can be represented in <math>\Theta(n)</math> space. The total length of the edges in the tree is <math>O(n^2)</math>, but each edge can be stored as the position and length of a substring of <it>S</it>, giving a total space usage of <math>\Theta(n)</math> computer words. The worst-case space usage of a suffix tree is seen with a <link>
fibonacci string</link>, giving the full <math>2n</math> nodes.</p>
<p>

An important choice when making a suffix tree implementation is the parent-child relationships between nodes. The most common is using <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link>s called <b>sibling lists</b>. Each node has pointer to its first child, and to the next node in the child list it is a part of. <link xlink:type="simple" xlink:href="../833/13833.xml">
Hash map</link>s, sorted/unsorted <link xlink:type="simple" xlink:href="../052/2052.xml">
array</link>s (with <link xlink:type="simple" xlink:href="../434/1456434.xml">
array doubling</link>), and <plant wordnetid="100017222" confidence="0.8">
<tree wordnetid="113104059" confidence="0.8">
<vascular_plant wordnetid="113083586" confidence="0.8">
<woody_plant wordnetid="113103136" confidence="0.8">
<link>
balanced search tree</link></woody_plant>
</vascular_plant>
</tree>
</plant>
s may also be used, giving different running time properties. We are interested in: 
<list>
<entry level="1" type="bullet">

 The cost of finding the child on a given character.</entry>
<entry level="1" type="bullet">

 The cost of inserting a child.</entry>
<entry level="1" type="bullet">

 The cost of enlisting all children of a node (divided by the number of children in the table below).</entry>
</list>
</p>
<p>

Let <math>\sigma</math> be the size of the alphabet. Then you have the following costs:</p>
<p>

<table>

<header>
Lookup</header>
<header>
Insertion</header>
<header>
Traversal</header>
<row>
<header>
Sibling lists / unsorted arrays</header>
<col>
<math>O(n)</math></col>
<col>
<math>\Theta(1)</math></col>
<col>
<math>\Theta(1)</math></col>
</row>
<row>
<header>
Hash maps</header>
<col>
<math>\Theta(1)</math></col>
<col>
<math>\Theta(1)</math></col>
<col>
<math>O(n)</math></col>
</row>
<row>
<header>
Balanced search tree</header>
<col>
<math>O(\log n)</math></col>
<col>
<math>O(\log n)</math></col>
<col>
<math>O(1)</math></col>
</row>
<row>
<header>
Sorted arrays</header>
<col>
<math>O(\log n)</math></col>
<col>
<math>O(n)</math></col>
<col>
<math>O(1)</math></col>
</row>
<row>
<header>
Hash maps + sibling lists</header>
<col>
<math>O(1)</math></col>
<col>
<math>O(1)</math></col>
<col>
<math>O(1)</math></col>
</row>
</table>
</p>
<p>

Note that the insertion cost is amortised, and that the costs for hashing are given perfect hashing.</p>
<p>

The large amount of information in each edge and node makes the suffix tree very expensive, consuming about ten to twenty times the memory size of the source text in good implementations. The <link xlink:type="simple" xlink:href="../494/1303494.xml">
suffix array</link> reduces this requirement to a factor of four, and researchers have continued to find smaller indexing structures.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../494/1303494.xml">
Suffix array</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
 <cite style="font-style:normal">P. Weiner&#32;(1973). "Linear pattern matching algorithm".&#32;<it>14th Annual IEEE Symposium on Switching and Automata Theory</it>: 1-11.</cite>&nbsp;</entry>
<entry id="2">
 <cite style="font-style:normal">Edward M. McCreight&#32;(1976).&#32;"<weblink xlink:type="simple" xlink:href="http://doi.acm.org/10.1145/321941.321946">
A Space-Economical Suffix Tree Construction Algorithm</weblink>". <it>Journal of the ACM</it>&#32;<b>23</b>&#32;(2): 262--272. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F321941.321946">
10.1145/321941.321946</weblink>.</cite>&nbsp;</entry>
<entry id="3">
 <cite style="font-style:normal">E. Ukkonen&#32;(1995).&#32;"<weblink xlink:type="simple" xlink:href="http://www.cs.helsinki.fi/u/ukkonen/SuffixT1withFigs.pdf">
On-line construction of suffix trees</weblink>". <it>Algorithmica</it>&#32;<b>14</b>&#32;(3): 249--260. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FBF01206331">
10.1007/BF01206331</weblink>.</cite>&nbsp;</entry>
<entry id="4">
 <cite style="font-style:normal">R. Giegerich and S. Kurtz&#32;(1997).&#32;"<weblink xlink:type="simple" xlink:href="http://www.zbh.uni-hamburg.de/staff/kurtz/papers/GieKur1997.pdf">
From Ukkonen to McCreight and Weiner: A Unifying View of Linear-Time Suffix Tree Construction</weblink>". <it>Algorithmica</it>&#32;<b>19</b>&#32;(3): 331--353. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1007%2FPL00009177">
10.1007/PL00009177</weblink>.</cite>&nbsp;
</entry>
<entry id="5">
 <cite id="Reference-Gusfield-1999" style="font-style:normal" class="book">Gusfield, Dan&#32;[1997]&#32;(1999). Algorithms on Strings, Trees and Sequences: Computer Science and Computational Biology.&#32;USA:&#32;Cambridge University Press. ISBN 0-521-58519-8.</cite>&nbsp;
</entry>
<entry id="6">
 <cite style="font-style:normal">Martin Farach&#32;(1997). "<weblink xlink:type="simple" xlink:href="ftp://dimacs.rutgers.edu/pub/dimacs/TechnicalReports/TechReports/1996/96-48.ps.gz">
Optimal suffix tree construction with large alphabets</weblink>".&#32;<it>Foundations of Computer Science, 38th Annual Symposium on</it>: 137--143.</cite>&nbsp;
</entry>
<entry id="7">
 <cite style="font-style:normal">Ricardo A. Baeza-Yates and Gaston H. Gonnet&#32;(1996).&#32;"Fast text searching for regular expressions or automaton searching on tries". <it>Journal of the ACM</it>&#32;<b>43</b>: 915--936.&#32;ACM Press. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F235809.235810">
10.1145/235809.235810</weblink>. <symbol wordnetid="106806469" confidence="0.8">
<standard wordnetid="107260623" confidence="0.8">
<signal wordnetid="106791372" confidence="0.8">
<identifier wordnetid="107270601" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../930/234930.xml">
ISSN</link></system_of_measurement>
</identifier>
</signal>
</standard>
</symbol>
 <weblink xlink:type="simple" xlink:href="http://worldcat.org/issn/0004-5411">
0004-5411</weblink>.</cite>&nbsp;
</entry>
<entry id="8">
 <cite style="font-style:normal">Oren Zamir and Oren Etzioni&#32;(1998). "Web document clustering: a feasibility demonstration".&#32;<it>SIGIR '98: Proceedings of the 21st annual international ACM SIGIR conference on Research and development in information retrieval</it>: 46--54, ACM.</cite>&nbsp;
</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cise.ufl.edu/~sahni/dsaaj/enrich/c16/suffix.htm">
Suffix Trees</weblink> by Dr. Sartaj Sahni (CISE Department Chair at University of Florida)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.allisons.org/ll/AlgDS/Tree/Suffix/">
Suffix Trees</weblink> by Lloyd Allison</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://datacompression.info/SuffixTrees.shtml">
Suffix Trees</weblink> links collection by Mark Nelson</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/suffixtree.html">
NIST's Dictionary of Algorithms and Data Structures: Suffix Tree</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cl.cam.ac.uk/~cpk25/libstree/">
libstree</weblink>, a generic suffix tree library written in C</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/dist/Tree-Suffix/">
Tree::Suffix</weblink>, a Perl binding to libstree</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.ucdavis.edu/~gusfield/strmat.html">
Strmat</weblink> a faster generic suffix tree library written in C (uses arrays instead of linked lists)</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://hkn.eecs.berkeley.edu/~dyoo/python/suffix_trees/">
SuffixTree</weblink> a Python binding to Strmat</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.balkenhol.net/papers/t1043.pdf.gz">
Universal Data Compression Based on the Burrows-Wheeler Transformation: Theory and Practice</weblink>, application of suffix trees in the BWT</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.helsinki.fi/group/suds/">
Theory and Practice of Succinct Data Structures</weblink>, C++ implementation of a compressed suffix tree]</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://video.google.com/videoplay?docid=3849716474680225865">
Google video on constructing a suffix tree</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
