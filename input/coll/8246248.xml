<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:09:22[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Memory-mapped file</title>
<id>8246248</id>
<revision>
<id>242980950</id>
<timestamp>2008-10-04T16:02:29Z</timestamp>
<contributor>
<username>Mifter</username>
<id>6362721</id>
</contributor>
</revision>
<categories>
<category>Virtual memory</category>
</categories>
</header>
<bdy>

A <b>memory-mapped file</b> is a segment of <link xlink:type="simple" xlink:href="../354/32354.xml">
virtual memory</link> which has been assigned a direct byte-for-byte correlation with some portion of a file or file-like resource.  This resource is typically a file that is physically present on-disk, but can also be a device, shared memory object, or other resource that the <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link> can reference through a <link xlink:type="simple" xlink:href="../754/608754.xml">
file descriptor</link>.  Once present, this correlation between the file and the memory space permits applications to treat the mapped portion as if it were <link>
primary memory</link>.
<sec>
<st>
Benefits</st>
<p>

The primary benefit of memory mapping a file is increased I/O performance, especially when used on small files. Accessing memory mapped files is faster than using direct read and write operations for two reasons. Firstly, a system call is orders of magnitude slower than a simple change of program's local memory. Secondly, in most operating systems the memory region mapped actually <it>is</it> the kernel's file cache, meaning that no copies need to be created in user space. Using system calls would inevitably involve the time consuming operation of memory copying.</p>
<p>

Certain application level memory-mapped file operations also perform better than their physical file counterparts.  Applications can access and update data in the file directly and in-place, as opposed to seeking from the start of the file or rewriting the entire edited contents to a temporary location.  Since the memory-mapped file is handled internally in pages, linear file access (as seen, for example, in <link>
flat file</link> data storage or configuration files) requires disk access only when a new page boundary is crossed, and can write larger sections of the file to disk in a single operation.</p>
<p>

A possible benefit of memory-mapped files is a "lazy loading", thus using small amounts of RAM even for a very large file.  Trying to load the entire contents of a file that is significantly larger than the amount of memory available can cause severe <link xlink:type="simple" xlink:href="../891/665891.xml">
thrashing</link> as the operating system reads from disk into memory and simultaneously pages from memory back to disk.  Memory-mapping may not only bypass the page file completely, but the system only needs to load the smaller page-sized sections as data is being edited, similarly to <link xlink:type="simple" xlink:href="../997/1310997.xml">
demand paging</link> scheme used for programs.</p>
<p>

The memory mapping process is handled by the <link xlink:type="simple" xlink:href="../924/66924.xml">
virtual memory manager</link>, which is the same subsystem responsible for dealing with the <link xlink:type="simple" xlink:href="../193/311193.xml">
page file</link>. Memory mapped files are loaded into memory one entire <link xlink:type="simple" xlink:href="../911/11254911.xml">
page</link> at a time.  The page size is selected by the operating system for maximum performance.  Since page file management is one of the most critical elements of a virtual memory system, loading page sized sections of a file into physical memory is typically a very highly optimized system function<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
Drawbacks</st>
<p>

The major reason to choose memory mapped file I/O is for performance.  One should nevertheless keep in mind the tradeoff that is being made.  The standard I/O approach is costly due to system call overhead and memory copying.  The memory mapped approach has its cost in page faults - when a piece of data isn't actually loaded by the operating system - and this cost can be high.  Depending on the circumstances, memory mapped file I/O can actually be substantially slower than standard file I/O.  For example: when reading in very large files, most of the data will not be cached by the kernel, meaning many page faults will occur when reading uncached data.</p>
<p>

Another drawback of memory mapped files relates to a given architecture's <link xlink:type="simple" xlink:href="../018/568018.xml">
address space</link>: a file larger than the addressable space can only have portions mapped at a time, complicating reading it. For example, a <link xlink:type="simple" xlink:href="../733/80733.xml">
32-bit</link> architecture such as Intel's <link xlink:type="simple" xlink:href="../046/15046.xml">
IA-32</link> can only directly address 4 <link xlink:type="simple" xlink:href="../000/147000.xml">
GiB</link> files. This drawback is avoided in the case of devices addressing memory when an <link xlink:type="simple" xlink:href="../181/5313181.xml">
IOMMU</link> is present.</p>

</sec>
<sec>
<st>
Common uses</st>
<p>

Perhaps the most common use for a memory-mapped file is the process loader in most modern operating systems (including <link xlink:type="simple" xlink:href="../890/18890.xml">
Microsoft Windows</link> and <link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link>-like systems.)  When a process is started, the operating system uses a memory mapped file to bring the executable file, along with any loadable modules, into memory for execution.  Most memory-mapping systems use a technique called <link xlink:type="simple" xlink:href="../997/1310997.xml">
demand paging</link>, where the file is loaded into physical memory in subsets (one page each), and only when that page is actually referenced. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>.  In the specific case of executable files, this permits the OS to selectively load only those portions of a process image that actually need to execute.</p>
<p>

Another common use for memory-mapped files is to share memory between multiple processes.  In modern <link xlink:type="simple" xlink:href="../596/167596.xml">
protected mode</link> operating systems, processes are generally not permitted to access memory space that is allocated for use by another process.  (A program's attempt to do so causes <link xlink:type="simple" xlink:href="../143/1157143.xml">
invalid page faults</link> or <link xlink:type="simple" xlink:href="../803/28803.xml">
segmentation violation</link>s.)  There are a number of techniques available to safely share memory, and memory-mapped file I/O is one of the most popular.  Two or more applications can simultaneously map a single physical file into memory and access this memory.  For example, the Microsoft Windows operating system provides a mechanism for applications to memory-map a shared segment of the system's page file itself and share data via this section.</p>

</sec>
<sec>
<st>
Platform support</st>

<p>

Most modern operating systems or runtime environments support some form of memory-mapped file access.    The function <link xlink:type="simple" xlink:href="../709/608709.xml">
mmap</link>()<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>, which creates a mapping of a file given a file descriptor, starting location in the file, and a length, is part of the <standard wordnetid="107260623" confidence="0.8">
<system_of_measurement wordnetid="113577171" confidence="0.8">
<link xlink:type="simple" xlink:href="../305/23305.xml">
POSIX</link></system_of_measurement>
</standard>
 specification, so the wide variety of POSIX-compliant systems, such as <family wordnetid="108078020" confidence="0.8">
<link xlink:type="simple" xlink:href="../642/31642.xml">
UNIX</link></family>
, <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../297/6097297.xml">
Linux</link></O>
, <link xlink:type="simple" xlink:href="../640/20640.xml">
Mac OS X</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> or <O wordnetid="106832680" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../736/32736.xml">
OpenVMS</link></O>
, support a common mechanism for memory mapping files.  The Microsoft Windows operating systems also support a group of <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link> functions for this purpose, such as CreateFileMapping() <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>.</p>
<p>

The <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java programming language</link></request>
</message>
 provide classes and methods to access memory mapped files, such as <b><weblink xlink:type="simple" xlink:href="http://java.sun.com/javase/6/docs/api/java/nio/channels/FileChannel.html">
FileChannel</weblink></b>.</p>
<p>

<physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link></causal_agent>
</physical_entity>
 has a gem (library) called Mmap, which implements memory-mapped file objects.</p>
<p>

The Microsoft .NET runtime environment does not natively include managed access to memory mapped files, but there are third-party libraries which do so <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
http://msdn2.microsoft.com/en-us/library/ms810613.aspx, "What Do Memory-Mapped Files Have to Offer?".</entry>
<entry id="2">
http://www.linux-tutorial.info/modules.php?name=Tutorial&amp;pageid=89, "Demand Paging"</entry>
<entry id="3">
<weblink xlink:type="simple" xlink:href="http://www.ecst.csuchico.edu/~beej/guide/ipc/mmap.html">
Memory Mapped Files</weblink></entry>
<entry id="4">
<weblink xlink:type="simple" xlink:href="http://www.apple.com/macosx/technology/unix.html">
Apple - Mac OS X Leopard - Technology - UNIX</weblink></entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://msdn2.microsoft.com/en-us/library/aa366537.aspx">
CreateFileMapping Function (Windows)</weblink></entry>
<entry id="6">
<weblink xlink:type="simple" xlink:href="http://www.winterdom.com/dev/dotnet/index.html">
DotNet</weblink></entry>
</reflist>
</p>

</sec>
</bdy>
</article>
