<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:41:57[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<statement  confidence="0.8" wordnetid="106722453">
<message  confidence="0.8" wordnetid="106598915">
<equation  confidence="0.8" wordnetid="106669864">
<mathematical_statement  confidence="0.8" wordnetid="106732169">
<header>
<title>Verlet integration</title>
<id>825735</id>
<revision>
<id>227051048</id>
<timestamp>2008-07-21T19:11:57Z</timestamp>
<contributor>
<username>Selket</username>
<id>15822</id>
</contributor>
</revision>
<categories>
<category>Numerical differential equations</category>
</categories>
</header>
<bdy>

<b>Verlet integration</b> (IPA:&nbsp;) is a method used to <link xlink:type="simple" xlink:href="../829/272829.xml">
integrate</link> <link xlink:type="simple" xlink:href="../627/14627.xml">
Newton's</link> <link xlink:type="simple" xlink:href="../913/65913.xml">
equations of motion</link>.  It is frequently used to calculate <link xlink:type="simple" xlink:href="../115/200115.xml">
trajectories</link> of particles in <link xlink:type="simple" xlink:href="../608/198608.xml">
molecular dynamics</link> simulations and <link xlink:type="simple" xlink:href="../363/5363.xml">
video game</link>s. The verlet integrator offers greater <link xlink:type="simple" xlink:href="../807/233807.xml">
stability</link> than the much simpler <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../098/3011098.xml">
Euler method</link></mathematical_statement>
</method>
</know-how>
</equation>
</message>
</statement>
, as well as other properties that are important in physical systems such as time-reversibility and <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link>
area preserving properties</link></mathematical_statement>
</equation>
</message>
</statement>
. At first it may seem natural to simply calculate trajectories using <link xlink:type="simple" xlink:href="../098/3011098.xml">
Euler integration</link>. However, this kind of integration suffers from many problems, as discussed at <link xlink:type="simple" xlink:href="../098/3011098.xml">
Euler integration</link>. Stability of the technique depends fairly heavily upon either a uniform update rate, or the ability to accurately identify positions at a small time delta into the past.  The method was developed by French physicist <physical_entity wordnetid="100001930" confidence="0.8">
<physicist wordnetid="110428004" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<link xlink:type="simple" xlink:href="../788/5230788.xml">
Loup Verlet</link></scientist>
</causal_agent>
</person>
</physicist>
</physical_entity>
 in 1967.
<sec>
<st>
Basic Verlet</st>
<p>

The Verlet algorithm <weblink xlink:type="simple" xlink:href="http://www.fisica.uniud.it/~ercolessi/md/md/node21.html">
http://www.fisica.uniud.it/~ercolessi/md/md/node21.html</weblink> reduces the level of errors introduced into the integration by calculating the position at the next time step from the positions at the previous and current time steps, without using the velocity. It is derived by writing two <link>
Taylor expansion</link>s of the position vector <math>\vec{x}(t)</math> in different time directions.</p>
<p>

<indent level="1">

<math>\vec{x}(t + \Delta t) = \vec{x}(t) + \vec{v}(t)\Delta t + \frac{\vec{a}(t) \Delta t^2}{2} + \frac{\vec{b}(t) \Delta t^3}{6} + O(\Delta t^4)\,</math>
</indent>
:<math>\vec{x}(t - \Delta t) = \vec{x}(t) - \vec{v}(t)\Delta t + \frac{\vec{a}(t) \Delta t^2}{2} - \frac{\vec{b}(t) \Delta t^3}{6} + O(\Delta t^4).\,</math></p>
<p>

Where <math>\vec{x}</math> is the position, <math>\vec{v}</math> the velocity, <math>\vec{a}</math> the acceleration and <math>\vec{b}</math> the <link xlink:type="simple" xlink:href="../290/16290.xml">
jerk</link> (third derivative of the position with respect to the time) <math>t</math>.
Adding these two expansions gives</p>
<p>

<indent level="1">

<math>\vec{x}(t + \Delta t) = 2\vec{x}(t) - \vec{x}(t - \Delta t) + \vec{a}(t) \Delta t^2 + O(\Delta t^4).\,</math>
</indent>

This offers the advantage that the first and third-order term from the Taylor expansion cancels out, thus making the Verlet integrator an order more accurate than integration by simple Taylor expansion alone. Note that if using this equation at <math>t = 0</math>, one needs the position at time <math>-\Delta t</math>, <math>\vec{x}(-\Delta t)</math>. At first sight this could give problems, because the initial conditions are known only at the initial time. This can be solved by doing the first time step using the equation</p>
<p>

<indent level="1">

<math>\vec{x}(\Delta t) \approx \vec{x}(0) + \vec{v}(0)\Delta t + \frac{\vec{a}(0)\Delta t^2}{2} + O(\Delta t^3).\,</math>
</indent>

The error on the first time step calculation then is of <math>\Delta t^3</math> order. This is not considered as a problem because on a simulation of over a large amount of timesteps, the error on the first timestep is only a negligible small amount of the total error.
As also can be seen in the basic verlet formula, the velocities are not explicitly given in the Basic Verlet equation, but often they are necessary for the calculation of certain physical quantities.  This can create technical challenges in <link xlink:type="simple" xlink:href="../608/198608.xml">
molecular dynamics</link> simulations, because kinetic energy and instantaneous temperatures at time <math>t</math> cannot be calculated for a system until the positions are known at time <math>t + \Delta t</math>.  This deficiency can either be dealt with using the Velocity Verlet algorithm, or estimating the velocity using the position terms and the <link xlink:type="simple" xlink:href="../662/19662.xml">
mean value theorem</link>:</p>
<p>

<indent level="1">

<math>\vec{v}(t) = \frac{\vec{x}(t + \Delta t) - \vec{x}(t - \Delta t)}{2\Delta t} + O(\Delta t^2).</math>
</indent>

Note that this velocity term is for the velocity at time <math>t</math>, not <math>t + \Delta t</math>, meaning that the velocity term is a step behind the position term.  You can shorten the interval to approximate the velocity at time <math>t + \Delta t</math> at the cost of accuracy:</p>
<p>

<indent level="1">

<math>\vec{v}(t + \Delta t) = \frac{\vec{x}(t + \Delta t) - \vec{x}(t)}{\Delta t} + O(\Delta t).</math>
</indent>

</p>
</sec>
<sec>
<st>
 Velocity Verlet </st>
<p>

A related, and more commonly used, algorithm is the <b>Velocity Verlet</b> algorithm <weblink xlink:type="simple" xlink:href="http://www.fisica.uniud.it/~ercolessi/md/md/node21.html">
http://www.fisica.uniud.it/~ercolessi/md/md/node21.html</weblink>. This uses a similar approach but explicitly incorporates velocity, solving the first-timestep problem in the Basic Verlet algorithm:</p>
<p>

<indent level="1">

<math>\vec{x}(t + \Delta t) = \vec{x}(t) + \vec{v}(t)\, \Delta t + \frac{1}{2} \vec{a}(t) (\Delta t)^2  \,</math>
</indent>
:<math>\vec{v}(t + \Delta t) = \vec{v}(t) + \frac{\vec{a}(t) + \vec{a}(t + \Delta t)}{2} \Delta t  \,</math></p>
<p>

It can be shown that the error on the Velocity Verlet is of the same order as the Basic Verlet. Note that the Velocity algorithm is not necessarily more memory consuming, because it's not necessary to keep track of the velocity at every timestep during the simulation. The standard implementation scheme of this algorithm is:
<list>
<entry level="1" type="number">

 Calculate: <math>\vec{x}(t + \Delta t) = \vec{x}(t) + \vec{v}(t)\, \Delta t + \frac{1}{2} \vec{a}(t) (\Delta t)^2  \,</math></entry>
<entry level="1" type="number">

 Calculate: <math>\vec{v}(t + \frac{\Delta t}{2}) = \vec{v}(t) + \frac{\vec{a}(t)\Delta t}{2} \,</math></entry>
<entry level="1" type="number">

 Derive <math>\vec{a}(t + \Delta t)</math> from the interaction potential.</entry>
<entry level="1" type="number">

 Calculate: <math>\vec{v}(t + \Delta t) = \vec{v}(t + \frac{\Delta t}{2}) + \frac{\vec{a}(t + \Delta t)\Delta t}{2} \,</math></entry>
</list>

The derivation of the acceleration comes from the relation
<indent level="1">

<math>\vec{F} = - \vec{\nabla}V = m \vec{a}\, </math>
</indent>

Note, however, that this algorithm assumes that acceleration at time <math>\vec{a}(t + \Delta t)</math> only depends on position <math>\vec{r}(t + \Delta t)</math>, and does not depend on velocity <math>\vec{v}(t + \Delta t)</math></p>

</sec>
<sec>
<st>
Error terms</st>

<p>

The local error in position of the Verlet integrator is <math>O(\Delta t^4)</math> as described above, and the local error in velocity is <math>O(\Delta t^2)</math>.</p>
<p>

The global error in position, in contrast, is <math>O(\Delta t^2)</math> and the global error in velocity is <math>O(\Delta t^2)</math>. These can be derived by noting the following:</p>
<p>

<indent level="1">

<math>\mathrm{error}\bigl(x(t_0 + \Delta t)\bigr) = O(\Delta t^4)</math>
</indent>

and</p>
<p>

<indent level="1">

<math>x(t_0 + 2\Delta t) = 2x(t_0 + \Delta t) - x(t_0) + \Delta t^2 x''(t_0 + \Delta t) + O(\Delta t^4) \, </math>
</indent>

Therefore:</p>
<p>

<indent level="1">

<math>\mathrm{error}\bigl(x(t_0 + 2\Delta t)\bigr) = 2\mathrm{error}\bigl(x(t_0 + \Delta t)\bigr) + O(\Delta t^4) = 3\,O(\Delta t^4)</math>
</indent>

Similarly:</p>
<p>

<indent level="1">

<math>\mathrm{error}\bigl(x(t_0 + 3\Delta t)\bigl) = 6\,O(\Delta t^4)</math>
</indent>
:<math>\mathrm{error}\bigl(x(t_0 + 4\Delta t)\bigl) = 10\,O(\Delta t^4)</math>
<indent level="1">

<math>\mathrm{error}\bigl(x(t_0 + 5\Delta t)\bigl) = 15\,O(\Delta t^4)</math>
</indent>

Which can be generalized to (it can be shown by induction, but it is given here without proof):</p>
<p>

<indent level="1">

<math>\mathrm{error}\bigl(x(t_0 + n\Delta t)\bigr) = \frac{n(n+1)}{2}\,O(\Delta t^4)</math>
</indent>

If we consider the global error in position between <math>x(t)</math> and <math>x(t+T)</math>, where <math>T = n\Delta t</math>, it is clear that:</p>
<p>

<indent level="1">

<math>\mathrm{error}\bigl(x(t_0 + T)\bigr) = \left(\frac{T^2}{2\Delta t^2} + \frac{T}{2\Delta t}\right) O(\Delta t^4)</math>
</indent>

And therefore, the global (cumulative) error over a constant interval of time is given by:</p>
<p>

<indent level="1">

<math>\mathrm{error}\bigr(x(t_0 + T)\bigl) = O(\Delta t^2)</math>
</indent>

Because the velocity is determined in a non-cumulative way from the positions in the Verlet integrator, the global error in velocity is also <math>O(\Delta t^2)</math>.</p>
<p>

In molecular dynamics simulations, the global error is typically far more important than the local error, and the Verlet integrator is therefore known as a second-order integrator.</p>

</sec>
<sec>
<st>
Constraints</st>

<p>

<indent level="1">

<it>Main article: <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../898/9357898.xml">
Constraint algorithm</link></mathematical_statement>
</equation>
</message>
</statement>
</it>
</indent>
The most notable thing that is now easier due to using Verlet integration rather than Eulerian is that constraints between particles are very easy to do.  A constraint is a connection between multiple points that limits them in some way, perhaps setting them at a specific distance or keeping them apart, or making sure they are closer than a specific distance. Often physics systems use springs between the points in order to keep them in the locations they are supposed to be.  However, using springs of infinite stiffness between two points usually gives the best results coupled with the verlet algorithm.  Here's how:</p>
<p>

<indent level="1">

<math>d_1=x_2^{(t)}-x_1^{(t)}\,</math>
</indent>

<indent level="1">

<math>d_2=\sqrt{d_1^2}\,</math>
</indent>

<indent level="1">

<math>d_3=\frac{d_2-r}{d_2}\,</math>
</indent>

<indent level="1">

<math>x_1^{(t+\Delta t)}=\tilde{x}_1^{(t+\Delta t)}+\frac{1}{2}d_1d_3\,</math>
</indent>

<indent level="1">

<math>x_2^{(t+\Delta t)}=\tilde{x}_2^{(t+\Delta t)}-\frac{1}{2}d_1d_3\,</math>
</indent>

The <math>x_i^{(t)}</math> variables are the positions of the points <it>i</it> at time <it>t</it>, the <math>\tilde{x}_i^{(t)}</math> are the <it>unconstrained</it> positions (<it>i.e.</it> the point positions before applying the constraints) of the points <it>i</it> at time <it>t</it>, the d variables are temporary (they are added for  as the results of their expressions are needed multiple times), and <it>r</it> is the distance that is supposed to be between the two points. Currently this is in one dimension; however, it is easily expanded to two or three.  Simply find the delta (first equation) of each dimension, and then add the deltas squared to the inside of the square root of the second equation (<link xlink:type="simple" xlink:href="../016/23016.xml">
Pythagorean theorem</link>).  Then, duplicate the last two equations for the number of dimensions there are.  This is where verlet makes constraints simple - instead of say, applying a velocity to the points that would eventually satisfy the constraint, you can simply position the point where it should be and the verlet integrator takes care of the rest.</p>
<p>

Problems, however, arise when multiple constraints position a vertex. One way to solve this is to loop through all the vertices in a simulation in a criss cross manner, so that at every vertex the constraint relaxation of the last vertex is already used speed up the spread of the information. Either use fine time steps for the simulation, use a fixed number of constraint solving steps per time step, or solve constrains until they are met by a specific deviation.</p>
<p>

When approximating the constraints locally to first order this is the same as the <link>
Gauss–Seidel method</link>. For small <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrices</link> it is known that <link xlink:type="simple" xlink:href="../993/6243993.xml">
LU decomposition</link> is faster. Large systems can be divided into clusters (for example: each <link xlink:type="simple" xlink:href="../499/797499.xml">
ragdoll</link>=cluster). Inside clusters the LU method is used, between clusters the <link>
Gauss–Seidel method</link> is used. The matrix code can be reused: The dependency of the forces on the positions can be approximated locally to first order, and the verlet integration can be made more implicit.</p>
<p>

For big matrices sophisticated solvers (look especially for "The sizes of these
small dense matrices can be tuned to match the sweet spot" in <weblink xlink:type="simple" xlink:href="http://crd.lbl.gov/~xiaoye/SuperLU/superlu_ug.pdf">
http://crd.lbl.gov/~xiaoye/SuperLU/superlu_ug.pdf</weblink>) for sparse matrices exist, any self made Verlet integration has to compete with these. The usage of (clusters of) matrices is not generally more precise or stable, but addresses the specific problem, that a force on one vertex of a sheet of cloth should reach any other vertex in a low number of time steps even if a fine grid is used for the cloth <weblink xlink:type="simple" xlink:href="http://www.cs.cmu.edu/~baraff/papers/index.html">
http://www.cs.cmu.edu/~baraff/papers/index.html</weblink> (link needs refinement) and not form a <link xlink:type="simple" xlink:href="../179/5786179.xml">
sound wave</link>.</p>
<p>

Another way to solve <link xlink:type="simple" xlink:href="../067/9777067.xml">
Holonomic constraints</link> is to use <link xlink:type="simple" xlink:href="../898/9357898.xml">
constraint algorithm</link>s.</p>

</sec>
<sec>
<st>
Collision reactions</st>
<p>

One way of reacting to collisions is to use a penalty-based system which basically applies a set force to a point upon contact.  The problem with this is that it is very difficult to choose the force imparted.  Use too strong a force and objects will become unstable, too weak and the objects will penetrate each other.  Another way is to use projection collision reactions which takes the offending point and attempts to move it the shortest distance possible to move it out of the other object.</p>
<p>

The Verlet integration would automatically handle the velocity imparted via the collision in the latter case, however note that this is not guaranteed to do so in a way that is consistent with <link xlink:type="simple" xlink:href="../898/40898.xml">
collision physics</link> (that is, changes in momentum are not guaranteed to be realistic).  Instead of implicitly changing the velocity term, you would need to explicitly control the final velocities of the objects colliding (by changing the recorded position from the previous time step).</p>
<p>

The two simplest methods for deciding on a new velocity are perfectly <link xlink:type="simple" xlink:href="../907/65907.xml">
elastic collision</link>s and <link xlink:type="simple" xlink:href="../908/65908.xml">
inelastic collision</link>s.  A slightly more complicated strategy that offers more control would involve using the <link xlink:type="simple" xlink:href="../503/3659503.xml">
coefficient of restitution</link>.</p>

</sec>
<sec>
<st>
Applications</st>
<p>

The Verlet equations can also be modified to create a very simple damping effect (for instance, to emulate air friction in computer games):</p>
<p>

<indent level="1">

<math>x(t + \Delta t) = (2-f) x(t) -(1-f) x(t - \Delta t) + a(t)(\Delta t)^2.\,</math>
</indent>

Where f is a number representing the fraction of the velocity per update that is lost to friction (0-1).</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

<link>
Courant–Friedrichs–Lewy condition</link></entry>
<entry level="1" type="bullet">

<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/2063558.xml">
Symplectic integrator</link></mathematical_statement>
</equation>
</message>
</statement>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.teknikus.dk/tj/gdc2001.htm">
Advanced Character Physics by Thomas Jakobsen</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.dhteumeuleu.com/dhtml/v-grid.html">
Clothlike demo using the Verlet algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ophyr.nl/java/verlet.html">
Physics demo using the Verlet algorithm (Java applet)</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.fisica.uniud.it/~ercolessi/md/md/node21.html">
The Verlet algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.ch.embnet.org/MD_tutorial/pages/MD.Part1.html">
Theory of Molecular Dynamics Simulations</weblink> - bottom of page</entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible autocollapse " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/272829.xml">
Numerical integration</link></mathematical_statement>
</equation>
</message>
</statement>
</header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/272829.xml#xpointer(//*[./st=%22Consistency+and+order%22])">
First order methods</link></mathematical_statement>
</equation>
</message>
</statement>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;line-height:1.4em; padding:0.33em 0;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../098/3011098.xml">
Euler's method</link>&nbsp;·  <link xlink:type="simple" xlink:href="../829/272829.xml#xpointer(//*[./st=%22The+backward+Euler+method+%22])">
 Backward Euler</link>&nbsp;·  <link>
Semi–implicit Euler</link></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/272829.xml#xpointer(//*[./st=%22Consistency+and+order%22])">
Second order methods</link></mathematical_statement>
</equation>
</message>
</statement>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;line-height:1.4em; padding:0.33em 0;;;" class="navbox-list navbox-even"><p>

<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../735/825735.xml">
Verlet integration</link></mathematical_statement>
</equation>
</message>
</statement>
&nbsp;·  <link>
Velocity Verlet</link>&nbsp;·  <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../261/4077261.xml">
Beeman's algorithm</link></mathematical_statement>
</equation>
</message>
</statement>
&nbsp;·  <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../680/1404680.xml">
Midpoint method</link></mathematical_statement>
</method>
</know-how>
</equation>
</message>
</statement>
&nbsp;·  <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../125/11754125.xml">
Heun's method</link></mathematical_statement>
</method>
</know-how>
</equation>
</message>
</statement>
&nbsp;·  <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../588/1013588.xml">
Newmark-beta method</link></mathematical_statement>
</equation>
</message>
</statement>
&nbsp;·  <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../189/15066189.xml">
Leapfrog integration</link></mathematical_statement>
</equation>
</message>
</statement>
</p>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<equation wordnetid="106669864" confidence="0.8">
<mathematical_statement wordnetid="106732169" confidence="0.8">
<link xlink:type="simple" xlink:href="../829/272829.xml#xpointer(//*[./st=%22Consistency+and+order%22])">
Higher order methods</link></mathematical_statement>
</equation>
</message>
</statement>
</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;line-height:1.4em; padding:0.33em 0;;;" class="navbox-list navbox-odd"><p>

<link>
Runge–Kutta methods</link>&nbsp;·  <link xlink:type="simple" xlink:href="../825/13454825.xml">
List of Runge-Kutta methods</link></p>
</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</mathematical_statement>
</equation>
</message>
</statement>
</article>
