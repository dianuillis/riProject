<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:17:28[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Chan&apos;s algorithm</title>
<id>8320430</id>
<revision>
<id>225825819</id>
<timestamp>2008-07-15T16:03:56Z</timestamp>
<contributor>
<username>Nilfanion</username>
<id>1196752</id>
</contributor>
</revision>
<categories>
<category>Convex geometry</category>
<category>Geometric algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../927/176927.xml">
computational geometry</link>, <b>Chan's algorithm</b> is an optimal <link xlink:type="simple" xlink:href="../990/12127990.xml">
output-sensitive algorithm</link> to compute the <link xlink:type="simple" xlink:href="../634/40634.xml">
convex hull</link> of a set <it>P</it> of <it>n</it> points, in 2 or 3 dimensional space. The algorithm takes O(<it>n</it> log <it>h</it>) time, where <it>h</it> is the number of points in the output (the convex hull). In the planar case, the algorithm combines an O(<it>n</it> log <it>n</it>) algorithm (<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../372/393372.xml">
Graham scan</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, for example) with <link xlink:type="simple" xlink:href="../318/393318.xml">
Jarvis march</link>, in order to obtain an optimal O(<it>n</it> log <it>h</it>) time. Chan's algorithm is notable because it is much simpler than the <link xlink:type="simple" xlink:href="../089/11699089.xml">
ultimate planar convex hull algorithm</link>, and it naturally extends to 3-dimensional space.
<sec>
<st>
Algorithm</st>

<p>

Initially, we assume that the value of <it>h</it> is known and make a parameter <it>m</it>=<it>h</it>. This assumption is not realistic, but we remove it later. The algorithm starts by arbitrarily partitioning <it>P</it> into at most 1+<it>n</it>/<it>m</it> subsets <it>Q</it> with at most <it>m</it> points each. Then, it computes the convex hull of each subset <it>Q</it> using an O(<it>n</it> log <it>n</it>) algorithm. Note that, as there are O(<it>n</it>/<it>m</it>) subsets of O(<it>m</it>) points each, this phase takes O(<it>n/m</it>)O(<it>m</it> log <it>m</it>) = O(<it>n</it> log <it>m</it>) time.</p>
<p>

The second phase consists of executing Jarvis march and using the precomputed convex hulls to speed up the execution. At each step in the Jarvis march algorithm, we have a point <it>pi</it> in the convex hull, and need to find a point pi+1 = <it>f(pi,P)</it> such that all other points of <it>P</it> are to the right of the line <it>pi pi+1</it>. If we know the convex hull of a set <it>Q</it> of <it>m</it> points, then we can compute <it>f(pi,Q)</it> in O(log <it>m</it>) time, by using <link xlink:type="simple" xlink:href="../266/4266.xml">
binary search</link>. We can compute <it>f(pi,P')</it> for all the O(<it>n</it>/<it>m</it>) subsets <it>Q</it> in O(<it>n</it>/<it>m</it> log <it>m</it>) time. Then, we can determine <it>f(pi,P)</it> using the same technique as normally used in <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../318/393318.xml">
Jarvis March</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, but only considering the points that are <it>f(pi,Q)</it> for some subset <it>Q</it>. As the Jarvis march algorithm repeats this process O(<it>h</it>) times, the second phase also takes O(<it>n</it> log <it>m</it>) time, and if <it>m=h</it>, O(<it>n</it> log <it>h</it>) time.</p>
<p>

By running the two phases described above, we can compute the convex hull of <it>n</it> points in O(<it>n</it> log <it>h</it>) time, assuming that we know the value of <it>h</it>. If we make <it>mh</it>, in which case we obtain the convex hull as a result.</p>
<p>

If we increase the value of <it>m</it> too slowly, we may need to repeat the steps mentioned before too many times, and the execution time will be large. On the other hand, if we increase the value of <it>m</it> too quickly, we risk making <it>m</it> much larger than <it>h</it>, also increasing the execution time. Chan's algorithm squares the value of <it>m</it> at each iteration, and make sure that <it>m</it> is never larger than <it>n</it>. In other words, at iteration <it>t</it> (starting at 0), we have <math>m = \min(n,2^{2^t})</math>. The total running time of the algorithm is</p>
<p>

<math> \sum_{t=0}^{O(\log\log h)} O\left(n \log(2^{2^t})\right) =  n \sum_{t=0}^{O(\log\log h)} O(2^t) = O(n \log h).</math></p>
<p>

To generalize this construction for the 3-dimensional case, an O(<it>n</it> log <it>n</it>) algorithm to compute the 3-dimensional convex hull should be used instead of Graham scan, and a 3-dimensional version of Jarvis march needs to be used. The time complexity remains O(<it>n</it> log <it>h</it>).</p>

</sec>
<sec>
<st>
Implementation</st>

<p>

Chan's paper contains several suggestions that may improve the practical performance of the algorithm, for example:</p>
<p>

<list>
<entry level="1" type="bullet">

 When computing the convex hulls of the subsets, eliminate the points that are not in the convex hull from consideration in subsequent executions.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 The convex hulls of larger point sets can be obtained by merging previously calculated convex hulls, instead of recomputing from scratch.</entry>
</list>
</p>



</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 Timothy M. Chan. "<weblink xlink:type="simple" xlink:href="http://citeseer.ist.psu.edu/181154.html">
Optimal output-sensitive convex hull algorithms in two and three dimensions</weblink>". <it>Discrete and Computational Geometry</it>, Vol. 16, pp.361&ndash;368. 1996.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
