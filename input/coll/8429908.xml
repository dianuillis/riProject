<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:21:31[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Fault injection</title>
<id>8429908</id>
<revision>
<id>234378421</id>
<timestamp>2008-08-26T16:16:18Z</timestamp>
<contributor>
<username>Hike395</username>
<id>11639</id>
</contributor>
</revision>
<categories>
<category>Software testing</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../090/29090.xml">
software testing</link>, <b>fault injection</b> is a technique for improving the <link xlink:type="simple" xlink:href="../030/7030.xml">
coverage</link> of a test by introducing faults in order to test code paths, in particular <link xlink:type="simple" xlink:href="../231/59231.xml">
error handling</link> code paths, that might otherwise rarely be followed.  It is often used with <link xlink:type="simple" xlink:href="../554/214554.xml">
stress testing</link> and is widely considered to be an important part of developing <link xlink:type="simple" xlink:href="../849/926849.xml">
robust</link> software<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>.<p>

The propagation of a fault through to an observable failure follows a well defined cycle. When executed, a fault may cause an error, which is an invalid state within a system boundary. An error may cause further errors within the system boundary, therefore each new error acts as a fault, or it may propagate to the system boundary and be observable. When error states are observed at the system boundary they are termed failures. This mechanism is termed the <link>
fault-error-failure cycle</link> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> and is a key mechanism in <link xlink:type="simple" xlink:href="../384/661384.xml">
dependability</link>.</p>
<p>

<table style="background:#f9f9f9; font-size:85%; line-height:110%; ">
<row>
<col>
 <image width="32x28px" src="Portal.svg">
</image>
</col>
<col style="padding:0 0.2em;">
 <b><it>
Software Testing&#32;portal</it></b></col>
</row>
</table>
</p>

<sec>
<st>
 History </st>

<p>

The technique of fault injection dates back to the 1970s <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> when it was first used to induce faults at a hardware level. This type of fault injection is called Hardware Implemented Fault Injection (HWIFI) and attempts to simulate hardware failures within a system. The first experiments in hardware fault injection involved nothing more than shorting connections on circuit boards and observing the effect on the system (bridging faults). It was used primarily as a test of the dependability of the hardware system. Later specialised hardware was developed to extend this technique, such as devices to bombard specific areas of a circuit board with heavy radiation. It was soon found that faults could be induced by software techniques and that aspects of this technique could be useful for assessing software systems. Collectively these techniques are known as Software Implemented Fault Injection (SWIFI).</p>

</sec>
<sec>
<st>
 Software Implemented Fault Injection </st>

<p>

SWIFI techniques can be categorised into two types: Compile-Time Injection and Runtime Injection.</p>
<p>

Compile-Time Injection is an injection technique where source code is modified to inject simulated faults into a system. One method is called Code Mutation which changes existing lines of code so that they contain faults. A simple example of this technique could be changing </p>

<p>

a = a + 1
to
a = a – 1</p>

<p>

Code mutation produces faults which are very similar to those unintentionally added by programmers.</p>
<p>

A refinement of code mutation is Code Insertion Fault Injection which adds code, rather than modifies existing code. This is usually done through the use of perturbation functions which are simple functions which take an existing value and perturb it via some logic into another value, for example</p>

<p>

int pFunc(int value) {
return value + 20;
}
int main(int argc, char * argv) {
int a = pFunc(aFunction(atoi(argv[1])));
if (a &amp;gt; 20) {
/* do something */
} else {
/* do something else */
}
}</p>

<p>

In this case pFunc is the perturbation function and it is applied to the return value of the function that has been called introducing a fault into the system.</p>
<p>

Runtime Injection techniques use a software trigger to inject a fault into a running software system. Faults can be injected via a number of physical methods and triggers can be implemented in a number of ways, such as: Time base triggers (When the timer reaches a specified time an interrupt is generated and the interrupt handler associated with the timer can inject the fault. ); Interrupt Based Triggers (Hardware exceptions and software trap mechanisms are used to generate an interrupt at a specific place in the system code or on a particular event within the system, for instance access to a specific memory location).</p>
<p>

Runtime injection techniques can use a number of different techniques to insert faults into a system via a trigger.</p>
<p>

<list>
<entry level="1" type="bullet">

 Corruption of memory space: This technique consists of corrupting RAM, processor registers, and I/O map. </entry>
<entry level="1" type="bullet">

 Syscall interposition techniques: This is concerned with the fault propagation from operating system kernel interfaces to executing systems software. This is done by intercepting operating system calls made by user-level software and injecting faults into them. </entry>
<entry level="1" type="bullet">

 Network Level fault injection: This technique is concerned with the corruption, loss or reordering of network packets at the network interface. </entry>
</list>
</p>
<p>

These techniques are often based around the debugging facilities provided by computer processor architectures.</p>

</sec>
<sec>
<st>
 Fault Injection Tools </st>

<p>

Although these types of faults can be injected by hand the possibility of introducing an unintended fault is high, so tools exist to parse a program automatically and insert faults.</p>

<ss1>
<st>
 Research Tools </st>

<p>

A number of SWIFI Tools have been developed and a selection of these tools is given here. Six commonly used fault injection tools are Ferrari, FTAPE , Doctor, Orchestra, Xception and Grid-FIT.</p>
<p>

<list>
<entry level="1" type="bullet">

 Ferrari (Fault and Error Automatic Real-Time Injection) is based around software traps that  inject errors into a system. The traps are activated by either a call to a specific memory location or a timeout. When a trap is called the handler injects a fault into the system. The faults can either be transient or permanent.  Research conducted with Ferrari shows that error detection is dependent on the fault type and where the fault is inserted <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>.</entry>
<entry level="1" type="bullet">

 FTAPE (Fault Tolerance and Performance Evaluator) can inject faults, not only into memory and registers, but into disk accesses as well. This is achieved by inserting a special disk driver into the system that can inject faults into data sent and received from the disk unit. FTAPE also has a synthetic load unit that can simulate specific amounts of load for robustness testing purposes <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref>.</entry>
<entry level="1" type="bullet">

 DOCTOR (IntegrateD SOftware Fault InjeCTiOn EnviRonment) allows injection of memory and register faults, as well as network communication faults. It uses a combination of time-out, trap and code modification. Time-out triggers  inject  transient memory faults and traps  inject transient emulated hardware failures, such as register corruption. Code modification is used to inject permanent faults <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref>.</entry>
<entry level="1" type="bullet">

 Orchestra is a script driven fault injector which is based around Network Level Fault Injection. Its primary use is the evaluation and validation of the fault-tolerance and timing characteristics of distributed protocols. Orchestra was initially developed for the Mach Operating System and uses certain features of this platform to compensate for latencies introduced by the fault injector. It has also been successfully ported to other operating systems<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref>.</entry>
<entry level="1" type="bullet">

 Xception is designed to take advantage of the advanced debugging features available on many modern processors. It is written to require no modification of system source and no insertion of software traps, since the processor's exception handling capabilities  trigger fault injection. These triggers are based around accesses to specific memory locations. Such accesses could be either for data or fetching instructions. It is therefore possible to accurately reproduce test runs because triggers can be tied to specific events, instead of timeouts <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref>.</entry>
<entry level="1" type="bullet">

 Grid-FIT (Grid – Fault Injection Technology) <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> is a dependability assessment method and tool for assessing Grid services by fault injection. Grid-FIT is derived from an earlier fault injector WS-FIT <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2210%22])">10</ref> which was targeted towards Java Web Services implemented using Apache Axis transport. Grid-FIT utilises a novel fault injection mechanism that allows network level fault injection to be used to give a level of control similar to Code Insertion fault injection whilst being less invasive <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2211%22])">11</ref>.</entry>
</list>
</p>

</ss1>
<ss1>
<st>
 Commercial Tools </st>

<p>

<list>
<entry level="1" type="bullet">

 ExhaustiF is a commercial software tool used for <link>
grey box</link> testing based on software fault injection (SWIFI) to improve reliability of software intensive systems.  The tool can be used during system integration and system testing phases of any software development lifecycle, complementing other testing tools as well. ExhaustiF is able to inject faults into both software and hardware. When injecting simulated faults in software, ExhaustiF offers the following fault types: Variable Corruption and Procedure Corruption.  The catalogue for hardware fault injections includes faults in Memory (I/O, RAM) and CPU (Integer Unit, Floating Unit). There are different versions available for RTEMS/ERC32, RTEMS/Pentium, Linux/Pentium and MS-Windows/Pentium. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2212%22])">12</ref></entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 Xception<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2213%22])">13</ref> is a commercial software tool developed by Critical Software SA<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2214%22])">14</ref> used for <link>
black box</link> and <link>
white box</link> testing based on software fault injection (SWIFI) and Scan Chain fault injection (SCIFI). Xception allows users to test the robustness of their systems or just part of them, allowing both Software fault injection and Hardware fault injection for a specific set of architectures. The tool has been used in the market since 1999 and has customers in the American, Asian and European markets, especially in the critical market of aerospace and the telecom market. The full Xception™ product family includes: a) The main Xception™ tool, a state-of-the-art leader in Software Implemented Fault Injection (SWIFI) technology; b) The Easy Fault Definition (EFD) and Xtract (Xception Analysis Tool) add-on tools; c) The extended Xception™ tool (eXception), with the fault injection extensions for Scan Chain and pin-level forcing.</entry>
</list>
</p>

</ss1>
</sec>
<sec>
<st>
 Application of Fault Injection </st>

<p>

Fault injection can take many forms. In the testing of <link xlink:type="simple" xlink:href="../194/22194.xml">
operating system</link>s for example, fault injection is often performed by a <it>driver</it> (<link xlink:type="simple" xlink:href="../394/50394.xml">
kernel</link>-mode software) that intercepts <it>system calls</it> (calls into the kernel) and randomly returning a failure for some of the calls.  This type of fault injection is useful for testing low level user mode software.  For higher level software, various methods  inject faults.  In <link xlink:type="simple" xlink:href="../801/1750801.xml">
managed code</link>, it is common to use <link xlink:type="simple" xlink:href="../531/11171531.xml">
instrumentation</link>. Although fault injection can be undertaken by hand a number of fault injection tools exist to automate the process of fault injection <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%2215%22])">15</ref>.</p>
<p>

Depending on the complexity of the <link xlink:type="simple" xlink:href="../ury/24th_century.xml">
API</link> for the level where faults are injected, fault injection tests often must be carefully designed to minimise the number of false positives.  Even a well designed fault injection test can sometimes produce situations that are impossible in the normal operation of the software.  For example, imagine there are two API <link xlink:type="simple" xlink:href="../988/40988.xml">
functions</link>, Commit and PrepareForCommit, such that alone, each of these functions can possibly fail, but if PrepareForCommit is called and succeeds, a subsequent call to Commit is guaranteed to succeed.  Now consider the following code:</p>

<p>

error = PrepareForCommit();
if (error == SUCCESS) {
error = Commit();
assert(error == SUCCESS);
}</p>

<p>

Often, it will be infeasible for the fault injection implementation to keep track of enough state to make the guarantee that the API functions make.  In this example, a fault injection test of the above code might hit the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../018/234018.xml">
assert</link></method>
</know-how>
</concept>
</idea>
, whereas this would never happen in normal operation.</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../708/12086708.xml">
Bebugging</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../840/2362840.xml">
Mutation testing</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
J. Voas, "Fault Injection for the Masses," Computer, vol. 30, pp. 129-130, 1997.</entry>
<entry id="2">
A. Avizienis, J.-C. Laprie, B. Randell, and C. Landwehr, "Basic Concepts and Taxonomy of Dependable and Secure Computing," Dependable and Secure Computing, vol. 1, pp. 11-33, 2004.</entry>
<entry id="3">
J. V. Carreira, D. Costa, and S. J. G, "Fault Injection Spot-Checks Computer System Dependability," IEEE Spectrum, pp. 50-55, 1999.</entry>
<entry id="4">
G. A. Kanawati, N. A. Kanawati, and J. A. Abraham, "FERRARI: A Flexible Software-Based Fault and Error Injection System," IEEE Transactions on Computers, vol. 44, pp. 248, 1995.</entry>
<entry id="5">
T. Tsai and R. Iyer, "FTAPE: A Fault Injection Tool to Measure Fault Tolerance," presented at Computing in aerospace, San Antonio; TX, 1995.</entry>
<entry id="6">
S. Han, K. G. Shin, and H. A. Rosenberg, "DOCTOR: An IntegrateD SOftware Fault InjeCTiOn EnviRonment for Distributed Real-time Systems," presented at International Computer Performance and Dependability Symposium, Erlangen; Germany, 1995.</entry>
<entry id="7">
S. Dawson, F. Jahanian, and T. Mitton, "ORCHESTRA: A Probing and Fault Injection Environment for Testing Protocol Implementations," presented at International Computer Performance and Dependability Symposium, Urbana-Champaign, USA, 1996.</entry>
<entry id="8">
J. V. Carreira, D. Costa, and S. J. G, "Fault Injection Spot-Checks Computer System Dependability," IEEE Spectrum, pp. 50-55, 1999.</entry>
<entry id="9">
<weblink xlink:type="simple" xlink:href="http://wiki.grid-fit.org/">
Grid-FIT Web-site</weblink></entry>
<entry id="10">
N. Looker, B. Gwynne, J. Xu, and M. Munro, "An Ontology-Based Approach for Determining the Dependability of Service-Oriented Architectures," in the proceedings of the 10th IEEE International Workshop on Object-oriented Real-time Dependable Systems, USA, 2005.</entry>
<entry id="11">
N. Looker, M. Munro, and J. Xu, "A Comparison of Network Level Fault Injection with Code Insertion," in the proceedings of the 29th IEEE International Computer Software and Applications Conference, Scotland, 2005.</entry>
<entry id="12">
<weblink xlink:type="simple" xlink:href="http://www.exhaustif.es">
ExhaustiF SWIFI Tool Site</weblink></entry>
<entry id="13">
<weblink xlink:type="simple" xlink:href="http://www.xception.org">
Xception Web Site</weblink></entry>
<entry id="14">
<weblink xlink:type="simple" xlink:href="http://www.criticalsoftware.com">
Critical Software SA</weblink></entry>
<entry id="15">
N. Looker, M. Munro, and J. Xu, "Simulating Errors in Web Services," International Journal of Simulation Systems, Science &amp; Technology, vol. 5, 2004.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.colostate.edu/casi/REPORTS/Bieman95.pdf">
Using Fault Injection to Test Software Recovery Code</weblink> by Colorado Advanced Software Institute.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.certess.com/product/">
Certitude Software from Certess Inc.</weblink></entry>
</list>
</p>

</sec>
</bdy>
</article>
