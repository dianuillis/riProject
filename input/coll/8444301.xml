<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:20:47[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Algorithmics of sudoku</title>
<id>8444301</id>
<revision>
<id>241900466</id>
<timestamp>2008-09-30T00:34:07Z</timestamp>
<contributor>
<username>Lithiumflash</username>
<id>4323510</id>
</contributor>
</revision>
<categories>
<category>Sudoku</category>
</categories>
</header>
<bdy>

<p>

The <link xlink:type="simple" xlink:href="../696/20696.xml">
class</link> of <b><link xlink:type="simple" xlink:href="../807/1365807.xml">
Sudoku</link></b> <link xlink:type="simple" xlink:href="../368/86368.xml">
puzzle</link>s consists of a partially completed row-column grid of cells partitioned into <it>N</it> <it>regions</it> or <it>zones</it> each of size <it>N</it> cells, to be filled in using a prescribed set of <it>N</it> distinct symbols (typically the numbers {1, ..., <it>N</it>}), so that each row, column and region contains exactly one of each element of the set. The puzzle can be solved using a variety of algorithms. This page provides algorithms only.</p>

<ss1>
<st>
Solving sudokus by backtracking</st>

<p>

The basic <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link> algorithm can be adapted to solve sudokus. This is straightforward. Say a <it>zone</it> is a subset of <it>N</it> boxes of an <it>N x N</it> grid, which must contain the numbers from 1 to <it>N</it>. A standard sudoku contains 27 zones, namely 9 rows, 9 columns and 9 squares that are 3 x 3. In a jigsaw sudoku, the square zones are replaced by zones having irregular boundaries, like a jigsaw piece. </p>
<p>

One possible algorithm that uses backtracking to solve such sudokus constructs a graph on <math>N^2</math> vertices, one vertex for each box of the grid. Two vertices are connected by an edge if there exists a zone containing the two boxes. The problem is then equivalent to coloring this graph with <it>N</it> colors, where adjacent vertices may not have the same color. This is done by starting with an empty assignment of colors and assigning colors to vertices one after another, using some fixed order of the vertices. Whenever a color is being assigned, we check whether it is compatible with the existing assignments, i.e. whether the new color occurs among the neighbors of that vertex. If it doesn't, then we may assign it to the vertex and try to process another vertex. We backtrack once all <it>N</it> colors have been tried for a given vertex. If all vertices have been assigned a color, then we have found a solution. There are of course much more sophisticated algorithms to solve <link xlink:type="simple" xlink:href="../743/426743.xml">
graph coloring</link>. If the sudoku contains initial data, i.e. some boxes have already been filled, then these go into the color assignment before backtracking begins and the vertex sequence includes only the empty boxes.</p>
<p>

The above algorithm was used to solve a 10x10 jigsaw sudoku that was proposed on <it>Les-Mathematiques.net</it>  A link to the proposal may be found in the section for <link xlink:type="simple" xlink:href="../301/8444301.xml#xpointer(//*[./st=%22External+links%22])">
external links</link>. The first section of the program defines the 10 jigsaw pieces (zones), the second the row and column zones. Thereafter the graph is constructed as an adjacency list. The search procedure prints completed solutions (when all 100 boxes have been assigned). Otherwise it computes the set of colors present among the neighbors of the next vertex to be processed, and recursively tries those assignments that do not conflict with this set. The search starts with an empty assignment.</p>

</ss1>
<sec>
<st>
 Exact Cover in solving sudokus </st>

<p>

Sudoku can be described as an <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../651/2828651.xml">
Exact cover</link></difficulty>
</problem>
</state>
</condition>
 problem. This allows both for a very elegant description
of the problem and an efficient backtrack algorithm for solving the problem.</p>
<p>

In an exact cover problem, there is given a universe <it>U</it> of elements and a collection 
<math>\mathcal{S}</math> of subsets of <it>U</it>. The task is to find a <link xlink:type="simple" xlink:href="../631/27631.xml">
subcollection</link> <math>\mathcal{S}^*</math>  of <math>\mathcal{S}</math> such that every element in <it>U</it> is an <link xlink:type="simple" xlink:href="../629/682629.xml">
element</link> of exactly one set in <math>\mathcal{S}^*</math>.</p>
<p>

The challenge in applying the exact cover problem to sudoku is to find a definition for the elements of <it>U</it> such that every valid sudoku solution must contain every element of <it>U</it> exactly once, and to find a definition for the elements of <math>\mathcal{S}</math> (subsets of <it>U</it>) such that if the union of a disjoint collection of these elements gives <it>U</it>, then the elements specify a completely filled-in sudoku grid which satisfies every constraint.</p>
<p>

Let <it>S</it> = {<it>s11</it>, <it>s12</it>, …, <it>s19</it>, <it>s21</it>, …, <it>s99</it>} be the set of squares of the sudoku grid.</p>
<p>

Let <it>ri</it> = {<it>si1</it>, <it>si2</it>, …, <it>si9</it>} ⊆ <it>S</it> be the set of squares belonging to row <it>i</it>, and let <it>R</it> = {<it>r1</it>, <it>r2</it>, …, <it>r9</it>} be the set of rows.</p>
<p>

Let <it>cj</it> = {<it>s1j</it>, <it>s2j</it>, …, <it>s9j</it>} ⊆ <it>S</it> be the set of squares belonging to column <it>j</it>, and let <it>C</it> = {<it>c1</it>, <it>c2</it>, …, <it>c9</it>} be the set of columns.</p>
<p>

Clearly, for each row <it>i</it> and column <it>j</it>, {<it>sij</it>} = <it>ri ∩ cj</it>.</p>
<p>

Let <it>bk</it> be the set of squares belonging to block <it>k</it>, and let <it>B</it> = {<it>b1</it>, <it>b2</it>, …, <it>b9</it>} be the set of blocks.</p>
<p>

Thus, <it>b1</it> is the intersection of rows 1 to 3 with columns 1 to 3, <it>b2</it> is the intersection of rows 1 to 3 with columns 4 to 6, …, and <it>b9</it> is the intersection of rows 7 to 9 with columns 7 to 9.  For example, </p>
<p>

<indent level="1">

<it>b2</it> = {<it>s14, s15, s16, s24, s25, s26, s34, s35, s36</it>}.
</indent>

Finally, we are ready to define a universe <it>U</it> and a collection <math>\mathcal{S}</math> of subsets of <it>U</it> which exactly mirror the required constraints on the placement of values in the squares of the sudoku grid.  A solution to the exact cover problem is a collection <math>\mathcal{S}^*</math> of disjoint subsets of <it>U</it> whose union is exactly <it>U</it>:  each element of <it>U</it> appears in exactly one element of <math>\mathcal{S}^*</math>.  How can this be applied to sudoku?  We need to find a set of objects each of which appears exactly once in every finished sudoku puzzle.  Every square of the grid must appear exactly once.  Every row, column, and square must contain each value exactly once.  Each of these constraints involves pairs:  pairs of rows and columns, pairs of rows and values, pairs of columns and values, and pairs of blocks and values.  Our universe is going to be made up of pairs.</p>
<p>

Consider the <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../795/5795.xml">
Cartesian product</link></concept>
</idea>
s <it>R×C</it>, <it>R×V</it>, <it>C×V</it>, and <it>B×V</it>.  Each contains 81 pairs.  For example <it>R×C</it> = {<it>(r1, c1), ..., (r9, c9)</it>}.
The universe <it>U</it> is the 324 element union of these four Cartesian products.  As it happens, every valid sudoku solution contains exactly these 324 pairs, no more, no less.  But this set of pairs does not represent a specific solution.  It represents <it>every</it> valid solution to the blank sudoku grid.</p>
<p>

To represent a specific solution, we need to assign a specific value to each square.  Let <it>Sijkl</it> denote the subset of <it>U</it> containing <it>(ri, cj), (ri, vl), (cj, vl), and (bk, vl)</it>.  This subset denotes the assignment of value <it>l</it> to square <it>sij</it>.  The collection <math>\mathcal{S}</math> contains exactly those subsets <it>Sijkl</it> of <it>U</it> in which square <it>ij</it> is an element of block <it>k</it>, i.e., <it>sij</it> ∈ <it>bk</it>.  Since <it>k</it> is completely dependent on <it>i</it> and <it>j</it>, there are 9×9×9 = 729 such subsets in <math>\mathcal{S}</math>.</p>
<p>

An incomplete sudoku grid is represented by a disjoint collection <math>\mathcal{S}'</math> of subsets 
<it>Sijkl</it> of <it>U</it> which does not specify a value for every square.  Since the collection is disjoint (each element of <it>U</it> appears in at most one subset), we know it does not violate any of the sudoku constraints.</p>
<p>

Now, applying the exact cover problem, we find members of <math>\mathcal{S}</math> disjoint from each other and from each member of <math>\mathcal{S}'</math>, resulting in the collection <math>\mathcal{S}^*</math> of 81 disjoint four-element subsets of <it>U</it> whose union is exactly the 324 element set <it>U</it>.</p>
<p>

This representation of the sudoku problem eliminates all mention of rows, columns, blocks, and values from the implementation.  Instead, we always work with the same collection of 729 four-element subsets of a 324 element universe.  These can be represented by the integers 0 to 728, together with a function <it>f(i,j)</it> which is true if the subsets corresponding to i and j are disjoint.  <it>f</it> might be implemented using a 7292 = 531441 element (66431 byte) constant bit vector.  A specific puzzle is a set of fewer than 81 integers with <it>f(i,j)</it> true for each pair <it>i,j</it>.  Solving the puzzle involves repeatedly finding a new integer <it>k</it> which passes <it>f(i,k)</it> for each <it>i</it> in the partially completed puzzle, and backtracking when no such <it>k</it> can be found.</p>
<p>

Obviously, once we find that a specific <it>k</it> fails <it>f(i,k)</it> for some <it>i</it>, we need not consider it again so long as <it>i</it> remains in the proposed solution.  So we keep a list of <it>k</it> values which have not yet failed.  The length of this list estimates the amount of work required to discover that the current proposed solution fails.   So at each level of recursion, we can look ahead one level to estimate how much work each proposed <it>k</it> will involve, and choose the <it>k</it> which returns failure in the shortest time.</p>
<p>

Although the size of the complete search tree is fixed for a given puzzle, this representation of the problem gives a fast test for failure at each level, and a way of ordering the search so that the smallest subtrees are searched first.  </p>
<p>

With this approach and an efficient library for solving exact cover problems, one can solve 9&amp;times;9 sudokus in such a short time on a modern PC that measuring the computation time becomes challenging.</p>

</sec>
<sec>
<st>
 Solving sudokus by a brute-force algorithm </st>

<p>

Some hobbyists have developed computer programs that will solve sudoku puzzles using a brute force algorithm.  Although it has been established that approximately 6.67 x 1021 final grids exist, using a brute force algorithm can be a practical method to solve puzzles using a computer program if the code is well designed.</p>
<p>

An advantage of this method is that if the puzzle is valid, a solution is guaranteed.  There is not a strong relation between the solving time and the degree of difficulty of the puzzle; generating a solution is just a matter of waiting until the algorithm advances to the set of numbers that satisfies the puzzle.  The disadvantage of this method is that it may be comparatively slow when compared to computer solution methods modeled after human-style deductive methods.</p>
<p>

Briefly, a brute force program would solve a puzzle by placing the digit "1" in the first cell and checking if it is allowed to be there.  If there are no violations (checking row, column, and box constraints) then the algorithm advances to the next cell, and places a "1" in that cell.  When checking for violations, it is discovered that the "1" is not allowed, so the value is advanced to a "2".  If a cell is discovered where none of the 9 digits is allowed, then the algorithm leaves that cell blank and moves back to the previous cell.  The value in that cell is then incremented by one.  The algorithm is repeated until the allowed value in the 81st cell is discovered.  The construction of 81 numbers is parsed to form the 9 x 9 solution matrix.</p>
<p>

Most Sudoku puzzles will be solved in just a few seconds with this method, but there are exceptions.  The following puzzle was  designed to be a near worst case situation for solution by brute force (although it is not regarded as a difficult puzzle when solved by other methods).</p>
<p>

<image location="right" width="180px" src="Sudoku_puzzle_hard_for_brute_force.jpg" type="thumb">
<caption>

"Near worst case" sudoku puzzle for brute force solver.
</caption>
</image>
</p>
<p>

Solving this puzzle by brute-force requires a large number of iterations because it has a low number of clues (17), the top row has no clues at all, and the solution has "987654321" as its first row.  Thus a brute-force solver will spend an enormous amount of time "counting" upward before it arrives at the final grid which satisfies the puzzle.   If one iteration is defined as one attempt to place one value in one cell, then this puzzles requires 641,580,843 iterations to solve.  These iterations do not include the work involved at each step to learn if each digit entered  is valid or not (required for every iteration).  Based on the specific construction of the computer code, programmers have found the solution time for this puzzle to be between 30 and 45 minutes with a computer processor running at 3&nbsp;GHz.  Many programmers have developed variations of the brute force algorithm which will solve this puzzle in a minute or less with a 3&nbsp;GHz computer processor.</p>
<p>

One programmer has created charts of the progression of a pointer as it advances through the 81 positions of a sudoku using a brute force algorithm.  An example is the chart for the solution to a sudoku "Star Burst Leo" shown here.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></p>
<p>

<image location="left" width="180px" src="Star_Burst_Leo_Sudoku.JPG" type="thumb">
<caption>

"Star Burst Leo" Sudoku
</caption>
</image>

<image location="none" width="300px" src="Star_Burst_Leo_Chart.JPG" type="thumb">
<caption>

Chart of cell position for solution to "Star Burst Leo" when solved by a brute force algorithm
</caption>
</image>
</p>

</sec>
<sec>
<st>
 Solving sudokus via stochastic search / optimization methods </st>

<p>

Some researchers have also shown how sudoku can be solved using stochastic -- i.e. random-based -- search.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

Such a method could work as follows: first, start by randomly assigning numbers to the blank cells in the grid, and calculate the number of errors. Now start to "shuffle" these inserted numbers around the grid until the number of mistakes has been reduced to zero. A solution to the puzzle will then have been found. Approaches for shuffling the numbers include <link xlink:type="simple" xlink:href="../244/172244.xml">
simulated annealing</link>, and tabu search.</p>
<p>

The advantage of this type of method is that the puzzle does not have to be "logic-solvable" in order for the algorithm to be able to solve it. In other words, unlike other methods, the puzzles that are given to this algorithm do not have to be specially constructed so that they provide sufficient clues for filling the grid using forward chaining logic only. In fact, the only prerequisite for the stochastic search algorithm to work is that puzzle has at least one solution.  </p>
<p>

Stochastic-based optimisation algorithms are known to be quite fast, though they are perhaps not as fast as some logic-based techniques with logic solvable puzzles. Depending on the type of instance given to the algorithm, generally 9x9 puzzles will be solved in less than 1 second on a typical year-2000 lap top; 16x16 puzzles will take around 10-15 seconds.</p>
<p>

Finally, note that it is also possible to express a Sudoku as an integer linear programming problem. Such approaches seem to gets close to a solution quite quickly, and can then use branching towards the end. The Simplex Algorithm seems able to handle situations with no solutions or multiple solutions quite well.</p>

</sec>
<sec>
<st>
 Algorithmic Search for Symmetrical Sudokus with Few Givens </st>

<p>

Computer algorithms work through increasingly more cycles when searching for sudokus with 20 clues or fewer.  Indeed puzzles with 17 clues are notoriously difficult to find.  When the constraint of symmetry is applied, the expected search time will dramatically increases yet further.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> When working with 19 clues or fewer, there are some classes of symmetry for which no sudoku has been found, and none may exist.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> The table below shows the seven classes of symmetry and whether one or more sudokus has been discovered for the range of 20 clues and fewer.</p>
<p>

<table align="center" cellpadding="2" border="1" cellspacing="0">
<caption>
<b>Discovery of Sudokus with 20 Clues or Fewer for each Class of Symmetry</b></caption>
<header style="background:#efefef">
givens</header>
<header style="background:#efefef">
Vertical or Horizontal</header>
<header style="background:#efefef">
Vertical and Horizontal</header>
<header style="background:#efefef">
180° Rotational</header>
<header style="background:#efefef">
Full 90° Rotational</header>
<header style="background:#efefef">
Diagonal One Axis</header>
<header style="background:#efefef">
Diagonal Both Axes</header>
<header style="background:#efefef">
Full Dihedral (Vertical and Horizontal and Full Rotational)</header>
<row>
<col>
20</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
</row>
<row>
<col>
19</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#efefef;">
*</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#efefef;">
*</col>
</row>
<row>
<col>
18</col>
<col>
No</col>
<col>
No</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#efefef;">
*</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#C3FDB8;">
Yes</col>
<col style="background:#efefef;">
*</col>
</row>
<row>
<col>
17</col>
<col>
No</col>
<col>
No</col>
<col>
No</col>
<col>
No</col>
<col style="background:#C3FDB8;">
Yes</col>
<col>
No</col>
<col>
No</col>
</row>
</table>

(asterisk indicates this number of givens does not have a pattern with this class of symmetry)</p>
<p>

Two examples of symmetrical sudokus with a small number of givens are shown here:</p>
<p>

<image location="left" width="180px" src="Symmetrical_H_and_V_19_clue.JPG" type="thumb">
<caption>

A 19-Clue Sudoku with Horizontal and Vertical Symmetry.
</caption>
</image>

<image location="none" width="180px" src="Symmetrical_18_clue_sudoku_01.JPG" type="thumb">
<caption>

An 18-Clue Sudoku with Symmetry on Both Diagonal Axes.
</caption>
</image>
</p>


</sec>
<sec>
<st>
Solving a blank sudoku grid</st>

<p>

Although sudoku grids that come with some of their cells pre-filled can often be quite challenging to solve, blank sudoku grids can actually be solved very quickly. Perhaps the easiest way of doing this is to produce the <it>root solution</it>, which can be achieved using the following very simple, polynomial time algorithm<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref></p>
<p>

For the standard n2 x n2 grid this algorithm (java-implementation) is as follows:</p>

<p>

final int n = 3;
final int field = new int[n*n][n*n];
int x = 0;
for(int i = 0; i  n; i++, x++)
for(int j = 0; j  n; j++, x+=n)
for(int k = 0; k  n*n; k++, x++)
field[n*i+j][k] = (x % (n*n)) + 1;</p>

<p>

The above procedure produces the following 9x9 sudoku:</p>
<p>


+-----------------------+
| 1 2 3 | 4 5 6 | 7 8 9 |
| 4 5 6 | 7 8 9 | 1 2 3 |
| 7 8 9 | 1 2 3 | 4 5 6 |
|-------+-------+-------|
| 2 3 4 | 5 6 7 | 8 9 1 |
| 5 6 7 | 8 9 1 | 2 3 4 |
| 8 9 1 | 2 3 4 | 5 6 7 |
|-------+-------+-------|
| 3 4 5 | 6 7 8 | 9 1 2 |
| 6 7 8 | 9 1 2 | 3 4 5 |
| 9 1 2 | 3 4 5 | 6 7 8 |
+-----------------------+</p>

</sec>
<sec>
<st>
 Standard Sudoku solver and enumerator </st>

<p>

This section contains a discussion of a modified backtracking algorithm that can be used to create and solve Sudokus even with modest computing resources. A standard Sudoku is an <math>N x N</math> Sudoku where <math>N = k^2</math> whose zones consist of the rows, columns and <math>k x k</math> subsquares as in the classic <math>9 x 9</math> Sudoku.</p>

<ss1>
<st>
 Key modifications to the algorithm </st>

<p>

Conceptually there is one modification only: the backtracking algorithm sorts the vertices by the number of colors already assigned among its neighbors before selecting the next vertex to try. The vertex with the largest number of assigned colors, and hence, the smallest number of choices, is tried first. (There may be more than one such vertex).</p>
<p>

The data structures used during the backtracking search are chosen to make this easy and fast, although further optimization is possible. The search state is stored in three data structures: a hash table whose keys are the vertices and whose values are the colors that have been assigned to them. There is an array that contains the vertices that have not yet been assigned a color. Finally, there is a hash table whose keys are again the vertices and whose values are hash tables containing the colors present among the neighbors of the respective vertex, as well as a hint as to who assigned them.</p>

</ss1>
<ss1>
<st>
 Discussion of the modified algorithm  </st>

<p>

The algorithm follows this sequence of steps:</p>
<p>

<list>
<entry level="1" type="bullet">

 Create the row and column zones, then create the subsquare zones.</entry>
<entry level="1" type="bullet">

 Construct the adjacency matrix of the graph.</entry>
<entry level="1" type="bullet">

 The search routine:</entry>
<entry level="2" type="bullet">

 Print the solution if there are no more vertices to be assigned a color, and return.</entry>
<entry level="2" type="bullet">

 Sort the remaining vertices in descending order of colors present among their neighbors.</entry>
<entry level="2" type="bullet">

 Pick the/a vertex with the largest number of assigned colors.</entry>
<entry level="2" type="bullet">

 Try each of the remaining possible colors recursively.</entry>
<entry level="3" type="bullet">

 Update the hash table of vertex neighboring colors to reflect the assignment.</entry>
<entry level="3" type="bullet">

 Update the partial solution to reflect the assignment.</entry>
<entry level="3" type="bullet">

 Recurse.</entry>
<entry level="3" type="bullet">

 Remove the color from the partial solution.</entry>
<entry level="3" type="bullet">

 Undo the color assignments from the neighboring colors hash table.</entry>
<entry level="1" type="bullet">

 Before the search begins, read the initial color assignment.</entry>
<entry level="1" type="bullet">

 Compute the set of vertices to be assigned a color, i.e. not present in the initial assignment.</entry>
<entry level="1" type="bullet">

 Compute the initial state of the hash table of neighbor colors.</entry>
<entry level="1" type="bullet">

 Start the search.</entry>
</list>
</p>
<p>

The above algorithm can enter into loops. To detect this, add a hash table that stores seen configurations. When this happens, terminate the computation and indicate FAIL (e.g. by throwing an exception). Repeat with a different seed of the random number generator if desired.</p>

</ss1>
<ss1>
<st>
 Example of a back-tracking Sudoku solver (in <physical_entity wordnetid="100001930" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby programming language</link></causal_agent>
</physical_entity>
) </st>

<p>

def read_matrix
matrix = </p>
<p>

(0..8).each { |i|
l = readline
matrix[i] = 
(0..8).each { |j|
matrix[i][j] = l[j..j].to_i
}
}
matrix
end</p>
<p>

def permissible(matrix, i, j)
ok = [true,true,true,true,true,true,true,true,true]
<list>
<entry level="1" type="number">

 Same as another in the column isn't permissible...</entry>
</list>

(0..8).each { |i2|
next if matrix[i2][j] == 0
ok[matrix[i2][j] - 1] = false
}
<list>
<entry level="1" type="number">

 Same as another in the row isn't permissible...</entry>
</list>

(0..8).each { |j2|
next if matrix[i][j2] == 0
ok[matrix[i][j2] - 1] = false
}
<list>
<entry level="1" type="number">

 Same as another in the 3x3 block isn't permissible...</entry>
</list>

igroup = (i / 3) * 3
jgroup = (j / 3) * 3
(igroup..(igroup + 2)).each { |i2|
(jgroup..(jgroup + 2)).each { |j2|
next if matrix[i2][j2] == 0
ok[matrix[i2][j2] - 1] = false
}
}
<list>
<entry level="1" type="number">

 Convert to the array format...</entry>
</list>

ret = 
(0..8).each { |i2| ret.push(i2 + 1) if ok[i2] }
ret
end</p>
<p>

def deep_copy_sudoku(matrix)
newmat = 
(0..8).each { |i|
newmat[i] = 
(0..8).each { |j|
newmat[i][j] = matrix[i][j]
}
}
newmat
end</p>
<p>

def solve_sudoku(matrix)
while true
options = 
(0..8).each { |i|
(0..8).each { |j|
next if matrix[i][j] != 0
p = permissible(matrix, i, j)
<list>
<entry level="1" type="number">

 If nothing is permissible, there is no solution at this level.</entry>
</list>

return false if (p.length == 0)
options.push({:i =&amp;gt; i, :j =&amp;gt; j, :permissible =&amp;gt; p})
}
}
<list>
<entry level="1" type="number">

 If the matrix is complete, we have a solution...</entry>
</list>

return matrix if options.length == 0</p>
<p>

omin = options.min { | a, b |
a[:permissible].length =&amp;gt; b[:permissible].length
}</p>
<p>

<list>
<entry level="1" type="number">

 If there is an option with only one solution, set it and re-check permissibility</entry>
</list>

if omin[:permissible].length == 1
matrix[omin[:i]][omin[:j]] = omin[:permissible][0]
next
end</p>
<p>

<list>
<entry level="1" type="number">

 We have two or more choices. We need to search both...</entry>
</list>

omin[:permissible].each { |v|
mtmp = deep_copy_sudoku(matrix)
mtmp[omin[:i]][omin[:j]] = v
ret = solve_sudoku(mtmp)
if ret != false
return ret
end
}</p>
<p>

<list>
<entry level="1" type="number">

 We did an exhaustive search on this branch and nothing worked out.</entry>
</list>

return false
end
end</p>
<p>

def print_matrix(matrix)
if (matrix == false)
print "Impossible\n"
return
end</p>
<p>

(0..8).each { |i|
(0..8).each { |j|
print matrix[i][j]
}
print "\n"
}
end</p>
<p>

print_matrix(solve_sudoku(read_matrix()))</p>



</ss1>
</sec>
<sec>
<st>
Exceptionally difficult Sudokus (Hardest Sudokus)</st>

<p>

Some of the sudoku puzzles can  only be solved using logic that is too complex for human solvers. Most would describe them as <it>unsolvable</it> after exhausting their arsenal of sudoku solving techniques and would proceed to a  <it><link xlink:type="simple" xlink:href="../733/245733.xml">
trial and error</link></it> path to reach a solution.</p>
<p>

It was no surprise that computer programmers were interested in this subject, trying to generate even more difficult puzzles or even trying to find new ways to logically solve and rate them.</p>
<p>

Rating puzzles that are beyond human capabilities proved to be difficult as different points of view regarding what could be considered  a <it><link xlink:type="simple" xlink:href="../322/1298322.xml">
yardstick</link></it> for measuring difficulty resulted in heterogeneous opinions on which puzzle is the <it>hardest of them all</it>. </p>
<p>

Several active discussions on this issue took place on a number of popular sudoku forums since 2005.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> Several openly accessible solver programs became popular between users for the purpose of rating and generating such puzzles. </p>
<p>

The following is a compilation of the latest hardest sudoku puzzles according to a number of openly accessible solver Programs:</p>
<p>

Rating Program: gsf's sudoku q1 (rating) 
Rating: 99408 
Poster: JPF 
Label: Easter Monster 
1.......2.9.4...5...6...7...5.9.3.......7.......85..4.7.....6...3...9.8...2.....1 
1 . . | . . . | . . 2  
. 9 . | 4 . . | . 5 .  
. . 6 | . . . | 7 . .  
------+-------+------ 
. 5 . | 9 . 3 | . . .  
. . . | . 7 . | . . .  
. . . | 8 5 . | . 4 .  
------+-------+------ 
7 . . | . . . | 6 . .  
. 3 . | . . 9 | . 8 .  
. . 2 | . . . | . . 1  </p>
<p>

Rating Program: gsf's sudoku q1 (Processing time) 
Rating: 4m19s@2&nbsp;GHz 
Poster: tarek 
Label: tarek071223170000-052 
..1..4.......6.3.5...9.....8.....7.3.......285...7.6..3...8...6..92......4...1... 
. . 1 | . . 4 | . . .  
. . . | . 6 . | 3 . 5  
. . . | 9 . . | . . .  
------+-------+------ 
8 . . | . . . | 7 . 3  
. . . | . . . | . 2 8  
5 . . | . 7 . | 6 . .  
------+-------+------ 
3 . . | . 8 . | . . 6  
. . 9 | 2 . . | . . .  
. 4 . | . . 1 | . . .  </p>
<p>

Rating Program: Nicolas Juillerat's Sudoku explainer 1.2.1 
Rating: 11.9 
Poster: tarek 
Label: golden nugget 
.......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7..... 
. . . | . . . | . 3 9  
. . . | . . 1 | . . 5  
. . 3 | . 5 . | 8 . .  
------+-------+------ 
. . 8 | . 9 . | . . 6  
. 7 . | . . 2 | . . .  
1 . . | 4 . . | . . .  
------+-------+------ 
. . 9 | . 8 . | . 5 .  
. 2 . | . . . | 6 . .  
4 . . | 7 . . | . . .  </p>
<p>

Rating Program: dukuso's suexrat9 
Rating: 4483 
Poster: coloin 
Label: col-02-08-071 
.2.4.37.........32........4.4.2...7.8...5.........1...5.....9...3.9....7..1..86.. 
. 2 . | 4 . 3 | 7 . .  
. . . | . . . | . 3 2  
. . . | . . . | . . 4  
------+-------+------ 
. 4 . | 2 . . | . 7 .  
8 . . | . 5 . | . . .  
. . . | . . 1 | . . .  
------+-------+------ 
5 . . | . . . | 9 . .  
. 3 . | 9 . . | . . 7  
. . 1 | . . 8 | 6 . .  </p>
<p>

Rating Program: dukuso's suexratt (10000 2 option) 
Rating: 2141 
Poster: tarek 
Label: golden nugget 
.......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7..... 
. . . | . . . | . 3 9  
. . . | . . 1 | . . 5  
. . 3 | . 5 . | 8 . .  
------+-------+------ 
. . 8 | . 9 . | . . 6  
. 7 . | . . 2 | . . .  
1 . . | 4 . . | . . .  
------+-------+------ 
. . 9 | . 8 . | . 5 .  
. 2 . | . . . | 6 . .  
4 . . | 7 . . | . . .</p>

</sec>
<sec>
<st>
 References </st>


<p>

<reflist>
<entry id="1">
<weblink xlink:type="simple" xlink:href="http://www.flickr.com/photos/npcomplete/">
"flickr.com/photos/npcomplete/"</weblink></entry>
<entry id="2">
<weblink xlink:type="simple" xlink:href="http://www.flickr.com/photos/npcomplete/2384354604/">
http://www.flickr.com/photos/npcomplete/2384354604/"flickr.com/photos/npcomplete/2384354604/"</weblink><it> (Star Burst Leo sudoku)''</it></entry>
<entry id="3">
Lewis, R (2007) <it>Metaheuristics Can Solve Sudoku Puzzles</it> Journal of Heuristics, vol. 13 (4), pp 387-401.</entry>
<entry id="4">
<weblink xlink:type="simple" xlink:href="http://www.flickr.com/photos/npcomplete/2599486458/">
Clue Sudoku with Diagonal Symmetry"</weblink></entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://www.flickr.com/photos/npcomplete/2896377811/">
Clue Two-Way Symmetry"</weblink></entry>
<entry id="6">
Lewis, R (2007) <it>Metaheuristics Can Solve Sudoku Puzzles</it> Journal of Heuristics, vol. 13 (4), pp 387-401.</entry>
<entry id="7">
<weblink xlink:type="simple" xlink:href="http://www.sudoku.com/boards/viewtopic.php?t=4212&amp;start=0">
"The hardest sudokus"</weblink> <it>On the Sudoku Players' Forums''</it></entry>
<entry id="8">
<weblink xlink:type="simple" xlink:href="http://www.setbb.com/sudoku/viewtopic.php?t=103&amp;start=0&amp;mforum=sudoku">
"what is the hardest known suduko ?"</weblink> <it>On the Sudoku Programmers Forums''</it></entry>
<entry id="9">
<weblink xlink:type="simple" xlink:href="http://www.sudoku.com/boards/viewtopic.php?t=5336&amp;start=0">
"How regular is to generate sudoku with difficulty 9+ SE?"</weblink> <it>On the Sudoku Players' Forums''</it></entry>
</reflist>
</p>

</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 http://diuf.unifr.ch/people/juillera/Sudoku/Sudoku.html <it>Sudoku Explainer by Nicolas Juillerat</it>  (Popular for rating sudokus in general)</entry>
<entry level="1" type="bullet">

 http://www.research.att.com/~gsf/man/man1/sudoku.html <it>sudoku by gsf</it> (Popular for rating the hardest sudokus amongst other things)</entry>
<entry level="1" type="bullet">

 http://magictour.free.fr/sudoku.htm<it>suexrat9 by dukuso</it> (Popular for rating the hardest sudokus)</entry>
<entry level="1" type="bullet">

 http://magictour.free.fr/suexratt.exe <it>suexratt by dukuso</it> (Popular for rating the hardest sudokus)</entry>
</list>
</p>

</sec>
</bdy>
</article>
