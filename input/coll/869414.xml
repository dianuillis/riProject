<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:46:35[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Incremental encoding</title>
<id>869414</id>
<revision>
<id>243286666</id>
<timestamp>2008-10-05T22:37:37Z</timestamp>
<contributor>
<username>Dcoetzee</username>
<id>13476</id>
</contributor>
</revision>
<categories>
<category>Lossless compression algorithms</category>
</categories>
</header>
<bdy>

<b>Incremental encoding</b>, also known as <b>front compression</b>, <b>back compression</b>, or <b>front coding</b>, is a type of <link xlink:type="simple" xlink:href="../283/320283.xml">
delta encoding</link> <link xlink:type="simple" xlink:href="../013/8013.xml">
compression algorithm</link> whereby common <link xlink:type="simple" xlink:href="../835/1835.xml">
prefix</link>es or <link xlink:type="simple" xlink:href="../835/1835.xml">
suffixes</link> and their lengths are recorded so that they need not be duplicated. This algorithm is particularly well-suited for compressing <link xlink:type="simple" xlink:href="../656/144656.xml">
sorted</link> <link xlink:type="simple" xlink:href="../040/18985040.xml#xpointer(//*[./st=%22Uses+of+data+in+computing%22])">
data</link>, e.g., a list of <link xlink:type="simple" xlink:href="../866/1449866.xml">
word</link>s from a <link xlink:type="simple" xlink:href="../931/7931.xml">
dictionary</link>.<p>

For example:
<table align="center" cellpadding="3" border="1" cellspacing="0">
<row>
<header>
Input</header>
<header>
Common prefix</header>
<header>
Compressed output</header>
</row>
<row>
<col>

myxa
myxophyta
myxopod
nab
nabbed
nabbing
nabit
nabk
nabob
nacarat
nacelle
</col>
<col>

no preceding word
'myx'
'myxop'
no common prefix
'nab'
'nabb'
'nab'
'nab'
'nab'
'na'
'nac'
</col>
<col>

0 myxa
3 ophyta
5 od
0 nab
3 bed
4 ing
3 it
3 k
3 ob
2 carat
3 elle
</col>
</row>
<row>
<col align="right">
64 bytes</col>

<col align="left">
46 bytes</col>
</row>
</table>
</p>
<p>

The encoding used to store the common prefix length itself varies from application to application. Typical techniques are storing the value as a single byte; <link xlink:type="simple" xlink:href="../283/320283.xml">
delta encoding</link>, which store only the change in the common prefix length; and various <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../009/2522009.xml">
universal codes</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. It may be combined with other general <link xlink:type="simple" xlink:href="../209/18209.xml">
lossless data compression</link> techniques such as <link xlink:type="simple" xlink:href="../680/46680.xml">
entropy encoding</link> and <link xlink:type="simple" xlink:href="../812/894812.xml">
dictionary coder</link>s to compress the remaining suffixes.</p>

<sec>
<st>
 Applications </st>

<p>

Incremental encoding is widely used in information retrieval to compress the lexicons used in <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../386/7602386.xml">
search indexes</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
; these list all the words found in all the documents and a pointer for each one to a list of locations. Typically, it compresses these indexes by about 40%.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>
<p>

As one example, incremental encoding is used as a starting point by the  <link xlink:type="simple" xlink:href="../125/3522125.xml">
GNU locate</link> utility, in an index of filenames and directories. The <link xlink:type="simple" xlink:href="../125/3522125.xml">
GNU locate</link> utility further uses <link xlink:type="simple" xlink:href="../587/1064587.xml">
bigram</link> encoding to further shorten popular filepath prefixes.</p>

</sec>
<sec>
<st>
 References </st>

<p>

<reflist>
<entry id="1">
Ian H. Witten, Alistair Moffat, Timothy C. Bell. Managing Gigabytes. Second edition. Academic Press. ISBN 1-55860-5703. Section 4.1: Accessing the lexicon, subsection Front coding, pp.159&ndash;161.</entry>
</reflist>
</p>




</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
