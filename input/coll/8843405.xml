<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:40:00[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Producer-consumer problem</title>
<id>8843405</id>
<revision>
<id>242405652</id>
<timestamp>2008-10-02T02:47:23Z</timestamp>
<contributor>
<username>Keilana</username>
<id>4264700</id>
</contributor>
</revision>
<categories>
<category>Concurrency</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link>, the <b>producer-consumer problem</b> (also known as the <b>bounded-buffer problem</b>) is a classical example of a multi-<link xlink:type="simple" xlink:href="../178/45178.xml">
process</link> <link xlink:type="simple" xlink:href="../017/4726017.xml">
synchronization</link> problem. The problem describes two processes, the producer and the consumer, who share a common, fixed-size <link xlink:type="simple" xlink:href="../183/2406183.xml">
buffer</link>. The producer's job is to generate a piece of data, put it into the buffer and start again. At the same time the consumer is consuming the data (i.e. removing it from the buffer) one piece at a time. The problem is to make sure that the producer won't try to add data into the buffer if it's full and that the consumer won't try to remove data from an empty buffer.<p>

The solution for the producer is to go to sleep if the buffer is full. The next time the consumer removes an item from the buffer, it wakes up the producer who starts to fill the buffer again. In the same way the consumer goes to sleep if it finds the buffer to be empty. The next time the producer puts data into the buffer, it wakes up the sleeping consumer. The solution can be reached by means of <link xlink:type="simple" xlink:href="../106/152106.xml">
inter-process communication</link>, typically using <link xlink:type="simple" xlink:href="../557/164557.xml">
semaphores</link>. An inadequate solution could result in a <link xlink:type="simple" xlink:href="../181/105181.xml">
deadlock</link> where both processes are waiting to be awakened.</p>
<p>

The problem can also be generalized to have multiple producers and consumers.
</p>
<sec>
<st>
Implementations</st>

<ss1>
<st>
 Inadequate implementation </st>
<p>

This solution has a <link xlink:type="simple" xlink:href="../661/98661.xml">
race condition</link>. To solve the problem, a careless programmer might come up with a solution shown below. In the solution two library routines are used, sleep and wakeup. When sleep is called, the caller is blocked until another process wakes it up by using the wakeup routine. itemCount is the number of items in the buffer.</p>
<p>

<b>int</b> itemCount</p>
<p>

<b>procedure</b> producer() {
<b>while</b> (true) {
item = produceItem()</p>
<p>

<b>if</b> (itemCount == BUFFER_SIZE) {
sleep()
}</p>
<p>

putItemIntoBuffer(item)
itemCount = itemCount + 1</p>
<p>

<b>if</b> (itemCount == 1) {
wakeup(consumer)
}
}
}</p>
<p>

<b>procedure</b> consumer() {
<b>while</b> (true) {</p>
<p>

<b>if</b> (itemCount == 0) {
sleep()
}</p>
<p>

item = removeItemFromBuffer()
itemCount = itemCount - 1</p>
<p>

<b>if</b> (itemCount == BUFFER_SIZE - 1) {
wakeup(producer)
}</p>
<p>

consumeItem(item)
}
}</p>
<p>

The problem with this solution is that it contains a <link xlink:type="simple" xlink:href="../661/98661.xml">
race condition</link> that can lead into a deadlock. Consider the following scenario:
<list>
<entry level="1" type="number">

 The consumer has just read the variable itemCount, noticed it's zero and is just about to move inside the if-block.</entry>
<entry level="1" type="number">

 Just before calling sleep, the consumer is interrupted and the producer is resumed.</entry>
<entry level="1" type="number">

 The producer creates an item, puts it into the buffer, and increases itemCount.</entry>
<entry level="1" type="number">

 Because the buffer was empty prior to the last addition, the producer tries to wake up the consumer.</entry>
<entry level="1" type="number">

 Unfortunately the consumer wasn't yet sleeping, and the wakeup call is lost. The next time the consumer runs, it goes to sleep and will never be awakened.</entry>
<entry level="1" type="number">

 The producer will loop until the buffer is full, after which it will also go to sleep.</entry>
</list>

Since both processes will sleep forever, we have run into a deadlock. This solution therefore is unsatisfactory.</p>
<p>

An alternative analysis is that if the programming language does not define the semantics of concurrent accesses to shared 
variables (in this case itemCount) without use of synchronization, then the solution is unsatisfactory for that reason, without needing to explicitly demonstrate a race condition.</p>

</ss1>
<ss1>
<st>
 Using semaphores </st>
<p>

<link xlink:type="simple" xlink:href="../557/164557.xml">
Semaphores</link> solve the problem of lost wakeup calls. In the solution below we use two semaphores, fillCount and emptyCount, to solve the problem. fillCount is incremented and emptyCount decremented when a new item has been put into the buffer. If the producer tries to decrement emptyCount while its value is zero, the producer is put to sleep. The next time an item is consumed, emptyCount is incremented and the producer wakes up. The consumer works analogously.</p>
<p>

<b>semaphore</b> fillCount = 0
<b>semaphore</b> emptyCount = BUFFER_SIZE</p>
<p>

<b>procedure</b> producer() {
<b>while</b> (true) {
item = produceItem()
down(emptyCount)
putItemIntoBuffer(item)
up(fillCount)
}
}</p>
<p>

<b>procedure</b> consumer() {
<b>while</b> (true) {
down(fillCount)
item = removeItemFromBuffer()
up(emptyCount)
consumeItem(item)
}
}</p>
<p>

The solution above works fine when there is only one producer and consumer. Unfortunately, with multiple producers or consumers this solution contains a serious race condition that could result in two or more processes reading or writing into the same slot at the same time. To understand how this is possible, imagine how the procedure putItemIntoBuffer() can be implemented. It could contain two actions, one determining the next available slot and the other writing into it. If the procedure can be executed concurrently by multiple producers, then the following scenario is possible:
<list>
<entry level="1" type="number">

 Two producers decrement emptyCount</entry>
<entry level="1" type="number">

 One of the producers determines the next empty slot in the buffer</entry>
<entry level="1" type="number">

 Second producer determines the next empty slot and gets the same result as the first producer</entry>
<entry level="1" type="number">

 Both producers write into the same slot</entry>
</list>
</p>
<p>

To overcome this problem, we need a way to make sure that only one producer is executing putItemIntoBuffer() at a time. In other words we need a way to execute a <link xlink:type="simple" xlink:href="../312/638312.xml">
critical section</link> with <link xlink:type="simple" xlink:href="../827/36827.xml">
mutual exclusion</link>. To accomplish this we use a binary semaphore called mutex. Since the value of a binary semaphore can be only either one or zero, only one process can be executing between down(mutex) and up(mutex). The solution for multiple producers and consumers is shown below.</p>
<p>

<b>semaphore</b> mutex = 1
<b>semaphore</b> fillCount = 0
<b>semaphore</b> emptyCount = BUFFER_SIZE</p>
<p>

<b>procedure</b> producer() {
<b>while</b> (true) {
item = produceItem()
down(emptyCount)
down(mutex)
putItemIntoBuffer(item)
up(mutex)
up(fillCount)
}
}</p>
<p>

<b>procedure</b> consumer() {
<b>while</b> (true) {
down(fillCount)
down(mutex)
item = removeItemFromBuffer()
up(mutex)
up(emptyCount)
consumeItem(item)
}
}</p>
<p>

Notice that the order in which different semaphores are incremented or decremented is essential: changing the order might result in a deadlock.</p>

</ss1>
<ss1>
<st>
 Using monitors </st>
<p>

The following <link xlink:type="simple" xlink:href="../185/24185.xml">
pseudo code</link> shows a solution to the producer-consumer problem using <link xlink:type="simple" xlink:href="../789/1367789.xml">
monitors</link>. Since mutual exclusion is implicit with monitors, no extra effort is necessary to protect critical section. In other words, the solution shown below works with any number of producers and consumers without any modifications. It is also noteworthy that using monitors makes race conditions much less likely than when using semaphores.</p>
<p>

<b>monitor</b> ProducerConsumer {</p>
<p>

<b>int</b> itemCount
<b>condition</b> full
<b>condition</b> empty</p>
<p>

<b>procedure</b> add(item) {
<b>while</b> (itemCount == BUFFER_SIZE) {
wait(full)
}</p>
<p>

putItemIntoBuffer(item)
itemCount = itemCount + 1</p>
<p>

<b>if</b> (itemCount == 1) {
notify(empty)
}
}</p>
<p>

<b>procedure</b> remove() {
<b>while</b> (itemCount == 0) {
wait(empty)
}</p>
<p>

item = removeItemFromBuffer()
itemCount = itemCount - 1</p>
<p>

<b>if</b> (itemCount == BUFFER_SIZE - 1) {
notify(full)
}</p>
<p>

<b>return</b> item;
}
}</p>
<p>

<b>procedure</b> producer() {
<b>while</b> (true) {
item = produceItem()
ProducerConsumer.add(item)
}
}</p>
<p>

<b>procedure</b> consumer() {
<b>while</b> (true) {
item = ProducerConsumer.remove()
consumeItem(item)
}
}</p>

</ss1>
<ss1>
<st>
 Using Composable Memory Transactions </st>

<p>

Composable Memory Transactions is a special form of <link xlink:type="simple" xlink:href="../707/1478707.xml">
Software Transactional Memory</link> as proposed in 2005 by Tim Harris, Simon Marlow, <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../848/3617848.xml">
Simon Peyton Jones</link></associate>
</research_worker>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, and <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<honoree wordnetid="110183757" confidence="0.8">
<laureate wordnetid="110249011" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<acquirer wordnetid="109764201" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<recipient wordnetid="109627906" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../089/9169089.xml">
Maurice Herlihy</link></associate>
</recipient>
</scientist>
</acquirer>
</causal_agent>
</colleague>
</laureate>
</honoree>
</person>
</peer>
</physical_entity>
. Duilio Protti implemented the library libCMT in C, the following link is a source code example.  </p>
<p>

<weblink xlink:type="simple" xlink:href="http://sourceforge.krugle.com/kse/files/svn/svn.sourceforge.net/libcmt/libcmt/tests/classic/prod-cons.c#2">
Producers-Consumers example with libCMT</weblink></p>

</ss1>
</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <it>Modern Operating Systems (2nd Edition)</it> by <person wordnetid="100007846" confidence="0.9508927676800064">
<professor wordnetid="110480730" confidence="0.9173553029164789">
<link xlink:type="simple" xlink:href="../110/3110.xml">
Andrew S. Tanenbaum</link></professor>
</person>
 (ISBN 0-13-092641-8)</entry>
<entry level="1" type="bullet">

 <it>Foundations of Multithreaded, Parallel, and Distributed Programming</it> by Gregory R. Andrews (ISBN 0-201-35752-6)</entry>
</list>
</p>

</sec>
<sec>
<st>
 See also </st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../196/363196.xml">
Sleeping barber problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../344/285344.xml">
Dining philosophers problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../958/2991958.xml">
Cigarette smokers problem</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../100/4189100.xml">
Readers-writers problem</link></entry>
</list>
</p>


</sec>
</bdy>
</article>
