<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:54:39[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Greedy algorithm</title>
<id>89247</id>
<revision>
<id>243794151</id>
<timestamp>2008-10-08T01:38:29Z</timestamp>
<contributor>
<username>Clan-destine</username>
<id>1633057</id>
</contributor>
</revision>
<categories>
<category>Optimization_algorithms</category>
</categories>
</header>
<bdy>

<image location="right" width="280px" src="greedy_algorithm_change_diagram.jpg" type="thumb">
<caption>

The greedy algorithm determines the minimum number of US coins to give while making change.  These are the steps a human would take to emulate a greedy algorithm. The coin of the highest value, less than the remaining change owed, is the local optimum. (Note that in general the change-making problem requires <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> to find an optimal solution; US and other currencies are special cases where the greedy strategy works.)
</caption>
</image>
<p>

A <b>greedy algorithm</b> is any <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> that follows the <link xlink:type="simple" xlink:href="../948/1467948.xml">
problem solving</link> <link xlink:type="simple" xlink:href="../458/774458.xml">
metaheuristic</link> of making the locally optimum choice at each stage<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
with the hope of finding the global optimum.</p>
<p>

For example, applying the greedy strategy to the <link xlink:type="simple" xlink:href="../248/31248.xml">
traveling salesman problem</link> yields the following algorithm: "At each stage visit the unvisited city nearest to the current city".</p>

<sec>
<st>
Specifics</st>
<p>

In general, greedy algorithms have five pillars:
<list>
<entry level="1" type="number">

 A candidate set, from which a solution is created</entry>
<entry level="1" type="number">

 A selection function, which chooses the best candidate to be added to the solution</entry>
<entry level="1" type="number">

 A feasibility function, that is used to determine if a candidate can be used to contribute to a solution</entry>
<entry level="1" type="number">

 An objective function, which assigns a value to a solution, or a partial solution, and</entry>
<entry level="1" type="number">

 A solution function, which will indicate when we have discovered a complete solution</entry>
</list>
</p>
<p>

Greedy algorithms produce good solutions on some <link xlink:type="simple" xlink:href="../700/256700.xml">
mathematical problem</link>s, but not on others.  Most problems for which they work well  have two properties:</p>
<p>

<list>
<entry level="1" type="definition">

 <b>Greedy choice property</b> : We can make whatever choice seems best at the moment and then solve the subproblems that arise later. The choice made by a greedy algorithm may depend on choices made so far but not on future choices or all the solutions to the subproblem.  It iteratively makes one greedy choice after another, reducing each given problem into a smaller one. In other words, a greedy algorithm never reconsiders its choices. This is the main difference from <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>, which is exhaustive and is guaranteed to find the solution. After every stage, <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> makes decisions based on all the decisions made in the previous stage, and may reconsider the previous stage's algorithmic path to solution.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="definition">

 <b>Optimal substructure</b> : "A problem exhibits <link xlink:type="simple" xlink:href="../102/243102.xml">
optimal substructure</link> if an optimal solution to the problem contains optimal solutions to the sub-problems."<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></entry>
</list>
</p>

<ss1>
<st>
When greedy-type algorithms fail</st>
<p>

For many other problems, greedy algorithms fail to produce the optimal solution, and may even produce the <it>unique worst possible</it> solutions. One example is the nearest neighbor algorithm mentioned above: for each number of cities there is an assignment of distances between the cities for which the nearest neighbor heuristic produces the unique worst possible tour. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</ss1>
</sec>
<sec>
<st>
 Applications </st>

<p>

Greedy algorithms mostly (but not always) fail to find the globally optimal solution, because they usually do not operate exhaustively on all the data. They can make commitments to certain choices too early which prevent them from finding the best overall solution later. For example, all known greedy algorithms for the <link xlink:type="simple" xlink:href="../743/426743.xml">
graph coloring problem</link> and all other <class wordnetid="107997703" confidence="0.8">
<collection wordnetid="107951464" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../466/39466.xml">
NP-complete</link></group>
</collection>
</class>
 problems do not consistently find optimum solutions. Nevertheless, they are useful because they are quick to think up and often give good approximations to the optimum.</p>
<p>

If a greedy algorithm can be proven to yield the global optimum for a given problem class, it typically becomes the method of choice because it is faster than other optimisation methods like <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>. Examples of such greedy algorithms are <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 and <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for finding <link xlink:type="simple" xlink:href="../795/41795.xml">
minimum spanning tree</link>s, <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for finding single-source shortest paths, and the algorithm for finding optimum <link xlink:type="simple" xlink:href="../883/13883.xml">
Huffman tree</link>s. </p>
<p>

The theory of <link xlink:type="simple" xlink:href="../321/244321.xml">
matroid</link>s, and the more general theory of <link xlink:type="simple" xlink:href="../526/666526.xml">
greedoid</link>s, provide whole classes of such algorithms.</p>
<p>

Greedy algorithms appear in network <link xlink:type="simple" xlink:href="../750/25750.xml">
routing</link> as well.  Using greedy routing, a message is forwarded to the neighboring node which is "closest" to the destination. The notion of a node's location (and hence "closeness") may be determined by its physical location, as in <link xlink:type="simple" xlink:href="../648/8425648.xml">
geographic routing</link> used by <link xlink:type="simple" xlink:href="../928/6624928.xml">
ad-hoc network</link>s.  Location may also be an entirely artificial construct as in <link xlink:type="simple" xlink:href="../905/5429905.xml">
small world routing</link> and <link xlink:type="simple" xlink:href="../141/192141.xml">
distributed hash table</link>.</p>

</sec>
<sec>
<st>
 Examples </st>
<p>

<list>
<entry level="1" type="bullet">

 In the <link xlink:type="simple" xlink:href="../979/19006979.xml">
Macintosh computer</link> game <event wordnetid="100029378" confidence="0.8">
<social_event wordnetid="107288639" confidence="0.8">
<contest wordnetid="107456188" confidence="0.8">
<game wordnetid="100456199" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<link xlink:type="simple" xlink:href="../581/3992581.xml">
Crystal Quest</link></psychological_feature>
</game>
</contest>
</social_event>
</event>
 the objective is to collect crystals, in a fashion similar to the <link xlink:type="simple" xlink:href="../248/31248.xml">
travelling salesman problem</link>. The game has a demo mode, where the game uses a greedy algorithm to go to every crystal. Unfortunately, the <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link> does not account for obstacles, so the demo mode often ends quickly.</entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>
<p>

<reflist>
<entry id="1">
   Paul E. Black, "greedy algorithm" in
   <it>Dictionary of Algorithms and Data Structures</it> [online],
   <link xlink:type="simple" xlink:href="../750/3434750.xml">
U.S.</link> <link xlink:type="simple" xlink:href="../888/21888.xml">
National Institute of Standards and Technology</link>,
   February 2005, webpage:
   <weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/greedyalgo.html">
NIST-greedyalgo</weblink>.
</entry>
<entry id="2">
Introduction to Algorithms (Cormen, Leiserson, Rivest, and Stein) 2001, Chapter 16 "Greedy Algorithms".</entry>
<entry id="3">
(G. Gutin, A. Yeo and A. Zverovich, 2002)</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

<it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it> (Cormen, Leiserson, and Rivest) 1990, Chapter 17 "Greedy Algorithms" p. 329.</entry>
<entry level="1" type="bullet">

<it>Introduction to Algorithms</it> (Cormen, Leiserson, Rivest, and Stein) 2001, Chapter 16 "Greedy Algorithms" .</entry>
<entry level="1" type="bullet">

G. Gutin, A. Yeo and A. Zverovich, Traveling salesman should not be greedy: domination analysis of greedy-type heuristics for the TSP.  Discrete Applied Mathematics 117 (2002), 81-86. </entry>
<entry level="1" type="bullet">

J. Bang-Jensen, G. Gutin and A. Yeo, When the greedy algorithm fails. Discrete Optimization  1 (2004), 121-127. </entry>
<entry level="1" type="bullet">

G. Bendall and F. Margot,  Greedy Type Resistance of Combinatorial Problems, Discrete Optimization 3 (2006), 288-298.</entry>
</list>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
