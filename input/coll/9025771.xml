<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:34:35[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Anytime algorithm</title>
<id>9025771</id>
<revision>
<id>231605653</id>
<timestamp>2008-08-13T04:03:00Z</timestamp>
<contributor>
<username>SmackBot</username>
<id>433328</id>
</contributor>
</revision>
<categories>
<category>Artificial intelligence</category>
<category>Articles with invalid date parameter in template</category>
<category>Accuracy disputes from May 2008</category>
</categories>
</header>
<bdy>

<table class="metadata plainlinks ambox ">
<row>
<col>

ambox-content" style=""</col>
</row>
<row>
<col class="mbox-image"><p>

<image width="40x40px" src="Ambox_content.png">
</image>
</p>
</col>
<col style="" class="mbox-text">
 <b>The factual accuracy of this article is .</b></col>
</row>
</table>


<sec>
<st>
 Introduction </st>
<p>

Most <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s run to completion: they provide a single answer after performing some fixed amount of computation. In some cases, however, the user may wish to terminate the algorithm prior to completion. The amount of the computation required may be substantial, for example, and computational resources might need to be reallocated. Most algorithms either run to completion or they provide no useful solution information. Anytime algorithms, however, are able to return a partial answer, whose quality depends on the amount of computation they were able to perform. The answer generated by anytime algorithms is an approximation of the correct answer. This feature of anytime algorithms is modeled by such a theoretical construction as limit Turing machine (Burgin, 1992; 2005). A limit Turing machine provides a sequence of partial results that converge in a given topology to the final result.</p>

</sec>
<sec>
<st>
Names</st>
<p>

An anytime algorithm may be also called an "interruptible algorithm". They are different from contact algorithms, which must declare a time in advance; in an anytime algorithm, a process can just announce that it is terminating.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></p>

</sec>
<sec>
<st>
 Goals </st>
<p>

The goal of anytime algorithms are to give <link xlink:type="simple" xlink:href="../246/2932246.xml">
intelligent systems</link> the ability to make results of better quality in return for turn-around time <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. They are also supposed to be flexible in time and resources.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> They are important because <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link> or AI algorithms can take a long time to complete results. This algorithm is designed to complete in a shorter amount of time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Also, these are intended to have a better understanding that the system is dependent and restricted to its agents and how they work cooperatively.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> An example the is <link>
Newton-Raphson</link> iteration applied to finding the square root of a number.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> Another example that uses anytime algorithms is trajectory problems when you're aiming for a target.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>
<p>

What makes anytime algorithms unique is their ability to return many possible outcomes for any given output.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> An anytime algorithm uses many well defined quality measures to monitor progress in <link xlink:type="simple" xlink:href="../948/1467948.xml">
problem solving</link> and <link xlink:type="simple" xlink:href="../162/145162.xml">
distributing computing</link> resources.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> It keeps searching for the best possible answer with the amount of time that it is given.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> It may not run until completion and may improve the answer if it is allowed to run longer.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> This is often used for large decision set problems. This would generally not provide useful information unless it is allowed to finish.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> While this may sound similar to <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>, the difference is that it is fine-tuned through random adjustments, rather than sequential.</p>
<p>

Anytime algorithms are designed to be predictable.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Another goal is that someone can interrupt the process and the algorithm would give its most accurate result.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> This is why it is called an interruptible algorithm. Another goal of anytime algorithms are to maintain the last result so as they are given more time, they can continue calculating a more accurate result.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref></p>

</sec>
<sec>
<st>
 Construction </st>
<p>

Make an algorithm with a parameter that influences <link xlink:type="simple" xlink:href="../ury/23rd_century.xml">
running time</link>. For example, as time increases, this variable also increases. After for a period of time, the search is stopped without having the goal met. This is similar to Jeopardy when the time runs out.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref> The contestants have to represent what they believe is the closest answer, although they may not know it or come even close to figuring out what it could be. This is similar to an hour long test. Although the test questions are not in themselves limiting for time, the test must be completed within the hour. Likewise, the computer has to figure out how much time and resources to spend on each problem.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%227%22])">7</ref></p>

</sec>
<sec>
<st>
 Decision Trees </st>
<p>

When the decider has to act, there must be some ambiguity. Also, there must be some idea about how to solve this ambiguity. This idea must be translatable to a state to action diagram.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%228%22])">8</ref></p>

</sec>
<sec>
<st>
 Performance Profile </st>
<p>

The performance profile estimates the quality of the results based on the input and the amount of time that is allotted to the algorithm.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> The better the estimate, the sooner the result would be found.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> Some systems have a larger database that gives the probability that the output is the expected output.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> It is important to note that one algorithm can have several performance profiles.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref> Most of the time performance profiles are constructed using <link xlink:type="simple" xlink:href="../711/888711.xml">
mathematical statistics</link> using representative cases. For example in the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../248/31248.xml">
traveling salesman</link></difficulty>
</problem>
</state>
</condition>
 problem, the performance profile was generated using a user-defined special program to generate the necessary statistics.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> In this example, the performance profile is the mapping of time to the expected results.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> This quality can be measured in several ways:</p>
<p>

<list>
<entry level="1" type="bullet">

certainty: where probability of correctness determines quality<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
<entry level="1" type="bullet">

accuracy: where error bound determines quality<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
<entry level="1" type="bullet">

specificity: where the amount of particulars determine quality<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref></entry>
</list>
</p>

</sec>
<sec>
<st>
Algorithm Prerequisites</st>
<p>

Initial behavior: While some algorithms start with immediate guesses, others take a more calculated approach and have a start up period before making any guesses.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></p>
<p>

<list>
<entry level="1" type="bullet">

Growth direction: How the quality of the program's "output" or result, varies as a function of the amount of time ("run time")<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></entry>
<entry level="1" type="bullet">

Growth rate: Amount of increase with each step. Does it change constantly, such as in a <link xlink:type="simple" xlink:href="../255/4255.xml">
bubble sort</link> or does it change unpredictably?</entry>
<entry level="1" type="bullet">

End condition: The amount of runtime needed<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%229%22])">9</ref></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<reflist>
<entry id="1">
Hendler, James A., <it>Artificial Intelligence Planning Systems</it>, 1992</entry>
<entry id="2">
Zilberstein, Shlomo. "Using Anytime Algorithms in Intelligent Systems". http://anytime.cs.umass.edu/shlomo/papers/aimag96.pdf</entry>
<entry id="3">
Grass, Joshua.  "Reasoning about <link xlink:type="simple" xlink:href="../222/4628222.xml">
Computational Resource</link> Allocation." http://www.acm.org/crossroads/xrds3-1/racra.html</entry>
<entry id="4">
<weblink xlink:type="simple" xlink:href="http://foldoc.org/?anytime+algorithm">
anytime algorithm from FOLDOC</weblink></entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://ai.eecs.umich.edu/cogarch2/cap/anytime.plan">
Anytime algorithm</weblink></entry>
<entry id="6">
<weblink xlink:type="simple" xlink:href="http://www.elook.org/computing/anytime-algorithm.htm">
Anytime algorithm - Computing Reference - eLook.org</weblink></entry>
<entry id="7">
Bender, Edward A. <it>Mathematical Methods In Artificial Intelligence</it>, <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../246/12953246.xml">
IEEE Computer Society</link></organization>
 Pres, 1996</entry>
<entry id="8">
Horsch, Michael C., Poole, David "An Anytime Algorithm for Decision Making under Uncertainty" http://www.cs.ubc.ca/spider/poole/papers/randaccref.pdf</entry>
<entry id="9">
Teije, Annette ten, Harmelen, Frank. "Describing Problem Solving Methods using Anytime Performance Profiles".</entry>
</reflist>

<list>
<entry level="1" type="bullet">

Anytime Algorithm http://tarono.wordpress.com/2007/03/20/anytime-algorithm</entry>
<entry level="1" type="bullet">

http://www.acm.org/crossroads/xrds3-1/racra.html</entry>
</list>
</p>

</sec>
<sec>
<st>
 Further reading </st>

<p>

<list>
<entry level="1" type="bullet">

 Boddy, M, Dean, T.  1989.  <it>Solving Time-Dependent Planning Problems</it>. Technical Report: CS-89-03, Brown University</entry>
<entry level="1" type="bullet">

 Burgin, M. Multiple computations and Kolmogorov complexity for such processes, <it>Notices of the Academy of Sciences of the USSR</it>, 1983, v. 27, No. 2 , pp. 793-797</entry>
<entry level="1" type="bullet">

 Burgin M., Universal limit Turing machines, <it>Notices of the Russian Academy of Sciences</it>, 325, No. 4, (1992), 654-658</entry>
<entry level="1" type="bullet">

 Burgin, M. <it>Super-recursive algorithms</it>, Monographs in computer science, Springer, 2005</entry>
<entry level="1" type="bullet">

 Grass, J., and Zilberstein, S. 1996. Anytime Algorithm Development Tools. <it>SIGART Bulletin</it> (Special Issue on Anytime Algorithms and Deliberation Scheduling) 7(2)</entry>
<entry level="1" type="bullet">

 Michael C. Horsch and David Poole, An Anytime Algorithm for Decision Making under Uncertainty, In Proc. 14th Conference on Uncertainty in Artificial Intelligence (UAI-98), Madison, Wisconsin, USA, July 1998, pages 246-255. </entry>
<entry level="1" type="bullet">

 E.J. Horvitz. <it>Reasoning about inference tradeoffs in a world of bounded resources</it>. Technical Report KSL-86-55, Medical Computer Science Group, Section on Medical Informatics, Stanford University, Stanford, CA, March 1986</entry>
<entry level="1" type="bullet">

 Wallace, R., and Freuder, E. 1995. Anytime Algorithms for Constraint Satisfaction and SAT Problems. Paper presented at the IJCAI-95 Workshop on Anytime Algorithms and Deliberation Scheduling, 20 August, Montreal, Canada.</entry>
<entry level="1" type="bullet">

 Zilberstein, S. 1993. <it>Operational Rationality through Compilation of Anytime Algorithms</it>. Ph.D. diss., Computer Science Division, University of California at Berkeley.</entry>
<entry level="1" type="bullet">

 Shlomo Zilberstein, Using Anytime Algorithms in Intelligent Systems, <it>AI Magazine</it>, 17(3):73-83, 1996</entry>
</list>
</p>

</sec>
</bdy>
</article>
