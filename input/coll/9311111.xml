<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:49:23[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Closest pair of points problem</title>
<id>9311111</id>
<revision>
<id>227000975</id>
<timestamp>2008-07-21T14:38:52Z</timestamp>
<contributor>
<username>AgentNN</username>
<id>6041155</id>
</contributor>
</revision>
<categories>
<category>Articles with example pseudocode</category>
<category>Geometric algorithms</category>
</categories>
</header>
<bdy>

<image location="right" width="150px" src="ClosestPair.png" type="thumb">
<caption>

Closest pair of points shown in red.
</caption>
</image>
<p>

The <b>closest pair of points problem</b> or <b>closest pair problem</b> is a problem of <link xlink:type="simple" xlink:href="../927/176927.xml">
computational geometry</link>: given <it>n</it> points in the <it>d</it>-dimensional <link xlink:type="simple" xlink:href="../018/20018.xml">
metric space</link>, find a pair of points with the smallest distance between them. Its two-dimensional version, for points in the plane<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, was among the first geometric problems which were treated at the origins of the systematic study of the <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link> of geometric algorithms.</p>
<p>

A naive algorithm of finding distances between all pairs of points and selecting the minimum requires O(<it>dn</it>2) time. It turns out that the problem may be solved in O(<it>n</it> log <it>n</it>) time (assuming the dimension d of the space to be constant). In the rest of the text, we assume that <it>d</it> is a constant, unless otherwise specified. In the <link>
algebraic decision tree</link> <link xlink:type="simple" xlink:href="../278/1773278.xml">
model of computation</link>, the O(<it>n</it> log <it>n</it>) algorithm is optimal. The optimality follows from the observation that the <link xlink:type="simple" xlink:href="../350/9312350.xml">
element uniqueness problem</link> (with the lower bound of Ω(<it>n</it> log <it>n</it>) for time complexity) is reducible to the closest pair problem: checking whether the minimal distance is 0 after the solving of the closest pair problem answers the question whether there are two coinciding points.</p>
<p>

In the computational model which assumes that the <link xlink:type="simple" xlink:href="../267/54267.xml">
floor function</link> is computable in constant time the problem can be solved in O(<it>n</it> log log <it>n</it>) time<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. If we allow randomization to be used together with the floor function, the problem can be solved in O(<it>n</it>) time<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref>.</p>

<sec>
<st>
<link xlink:type="simple" xlink:href="../127/103127.xml">
Brute-force</link> algorithm</st>

<p>

The closest pair of points can easily be computed in <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(<it>n²</it>) <link xlink:type="simple" xlink:href="../543/7543.xml">
time</link>. To do that, one could compute the distances between all the <it>n(n-1)/2</it> pairs of points, then pick the pair with the smallest distance, as illustrated below.</p>
<p>

minDist = infinity
for each p in P:
for each q in P:
if p ≠ q and dist(p,q)  minDist:
minDist = dist(p,q)
closestPair = (p,q)
return closestPair</p>

</sec>
<sec>
<st>
Planar case</st>
<p>

The problem can be solved in O(<it>n</it> log <it>n</it>) time using the <link xlink:type="simple" xlink:href="../407/25407.xml">
recursive</link> <link xlink:type="simple" xlink:href="../154/201154.xml">
divide and conquer</link> approach, e.g., as follows<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>:</p>
<p>

<list>
<entry level="1" type="number">

Sort points along the x-coordinate</entry>
<entry level="1" type="number">

Split the set of points into two equal-sized subsets by a vertical line <math>x=x_{mid}</math></entry>
<entry level="1" type="number">

Solve the problem recursively in the left and right subsets. This will give the left-side and right-side minimal distances <math>d_{Lmin}</math> and <math>d_{Rmin}</math> respectively.</entry>
<entry level="1" type="number">

Find the minimal distance <math>d_{LRmin}</math> among the pair of points in which one point lies on the left of the dividing vertical and the second point lies to the right.</entry>
<entry level="1" type="number">

The final answer is the minimum among <math>d_{Lmin}</math>, <math>d_{Rmin}</math>, and <math>d_{LRmin}</math>.</entry>
</list>
</p>
<p>

<image location="right" width="150px" src="Closest_pair.jpg" type="thumb">
<caption>

Divide-and-conquer: sparse box observation
</caption>
</image>

It turns out that step 4 may be accomplished in linear time. Again, a naive approach would require the calculation of distances for all left-right pairs, i.e., in quadratic time. The key observation is based on the following sparsity property of the point set. We already know that the closest pair of points is no further apart than <math>dist=\min(d_{Lmin}, d_{Rmin})</math>. Therefore for each point <math>p</math> of the left of the dividing line we have to compare the distances to the points that lie in the rectangle of dimensions (<it>dist</it>, 2 * <it>dist</it>) to the right of the dividing line, as shown in the figure. And what is more, this rectangle can contain at most 6 points with pairwise distances at least <math>d_{Rmin}</math>. Therefore it is sufficient to compute at most 6<it>n</it> left-right distances in step 4.</p>
<p>

As the closest pair of points define an edge in the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../864/8864.xml">
Delaunay triangulation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, and correspond to two adjacent cells in the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/177668.xml">
Voronoi diagram</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, the closest pair of points can be determined in linear time when we are given one of these two structures. Computing either the Delaunay triangulation or the Voronoi diagram takes O(<it>n</it> log <it>n</it>) time. These approaches are not efficient for dimension <it>d</it>&amp;gt;2, while the divide and conquer algorithm can be generalized to take O(<it>n</it> log <it>n</it>) time for any constant value of <it>d</it>.</p>

</sec>
<sec>
<st>
Dynamic closest-pair problem</st>
<p>

The <link xlink:type="simple" xlink:href="../644/9314644.xml">
dynamic version</link> for the closest-pair problem is stated as follows:
<list>
<entry level="1" type="bullet">

Given a <link xlink:type="simple" xlink:href="../127/2271127.xml">
dynamic set</link> of objects, find algorithms and <link xlink:type="simple" xlink:href="../519/8519.xml">
data structure</link>s for efficient recalculation of the closest pair of objects each time the objects are inserted or deleted.</entry>
</list>
</p>
<p>

If the <link xlink:type="simple" xlink:href="../300/12087300.xml">
bounding box</link> for all points is known in advance and the constant-time floor function is available, then the expected O(<it>n</it>) space data structure was suggested that supports expected-time O(log <it>n</it>) insertions and deletions and constant query time. When modified for the algebraic decision tree model, insertions and deletions would require O(log² <it>n</it>) expected time. <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref> It is worth noting, though, that the complexity of the dynamic closest pair algorithm cited above is exponential in the dimension <it>d</it>, and therefore such an algorithm is not suitable for high-dimensional problems.
</p>
</sec>
<sec>
<st>
References</st>
<p>

<reflist>
<entry id="1">
M. I. Shamos and D. Hoey. "Closest-point problems." In <it>Proc. 16th <link>
Annual IEEE Symposium on Foundations of Computer Science</link></it> (FOCS), pp. 151&mdash;162, 1975</entry>
<entry id="2">
S. Fortune and J.E. Hopcroft. "A note on Rabin's nearest-neighbor algorithm." Information Processing Letters, 8(1), pp. 20&mdash;23, 1979</entry>
<entry id="3">
S. Khuller and Y. Matias. A simple randomized sieve algorithm for the closest-pair problem. Inf. Comput., 118(1):34&mdash;37,1995</entry>
<entry id="4">
Mordecai Golin, Rajeev Raman, Christian Schwarz, Michiel Smid, "Randomized Data Structures For The Dynamic Closest-Pair Problem", <link>
SIAM J. Comput.</link>, vo. 26, no. 4, 1998, preliminary version reported at the 4th Annu. ACM-SIAM Symp. on Discrete Algorithms, pp. 301-310 (1993)</entry>
</reflist>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Pages 957&ndash;961 of section 33.4: Finding the closest pair of points.</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book">Jon Kleinberg; Éva Tardos&#32;(2006). Algorithm Design.&#32;Addison Wesley.</cite>&nbsp;</entry>
</list>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
