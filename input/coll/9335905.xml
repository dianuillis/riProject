<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:49:55[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Multidelay block frequency domain adaptive filter</title>
<id>9335905</id>
<revision>
<id>202243182</id>
<timestamp>2008-03-31T06:50:30Z</timestamp>
<contributor>
<username>Gdickins</username>
<id>6783739</id>
</contributor>
</revision>
<categories>
<category>Filter theory</category>
<category>Digital signal processing</category>
</categories>
</header>
<bdy>

The <b>Multidelay block frequency domain adaptive filter</b> (MDF) algorithm is a block-based frequency domain implementation of the (normalised) <link>
Least mean squares filter (LMS)</link> algorithm. 
<sec>
<st>
 Introduction </st>
<p>

The MDF algorithm is based on the fact that convolutions may be efficiently computed in the frequency domain (thanks to the <link xlink:type="simple" xlink:href="../512/11512.xml">
Fast Fourier Transform</link>). However, the algorithm differs from the <link>
Fast LMS algorithm</link> in that block size it uses may be smaller than the filter length. If both are equal, then MDF reduces to the FLMS algorithm. </p>
<p>

The advantages of MDF over the (N)LMS algorithm are:
<list>
<entry level="1" type="bullet">

 Lower algorithmic complexity</entry>
<entry level="1" type="bullet">

 Partial de-correlation of the input (which 'may' lead to faster convergence)</entry>
</list>
</p>


</sec>
<sec>
<st>
 Variable definitions </st>

<p>

<image width="150px" src="Lms_filter.png">
<caption>

LMS filter
</caption>
</image>
</p>
<p>

Let <math>N</math> be the length of the processing blocks, <math>K</math> be the number of blocks and <math>\mathbf{F}</math> denote the 2Nx2N Fourier transform matrix. The variables are defined as:</p>
<p>

<indent level="1">

 <math>\underline{\mathbf{e}}(\ell) = \mathbf{F}\left[ \mathbf{0}_{1xN}, e(\ell N),\dots,e(\ell N-N-1) \right]^T</math>
</indent>
: <math>\underline{\mathbf{x}}_k(\ell) = \mathrm{diag} \left\{ \mathbf{F}\left[ x((\ell -k+1) N),\dots,x((\ell -k-1) N-1) \right]^T \right\}</math>
<indent level="1">

 <math>\underline{\mathbf{X}}(\ell) = \left[ \underline{\mathbf{x}}_0(\ell), \underline{\mathbf{x}}_1(\ell), \dots, \underline{\mathbf{x}}_{K-1}(\ell) \right]</math>
</indent>
: <math>\underline{\mathbf{d}}(\ell) = \mathbf{F}\left[ \mathbf{0}_{1xN}, d(\ell N),\dots,d(\ell N-N-1) \right]^T</math>
With normalisation matrices <math>\mathbf{G}_1</math> and <math>\mathbf{G}_2</math>:</p>
<p>

<indent level="1">

 <math>\mathbf{G}_1 = \mathbf{F}\begin{bmatrix}
\mathbf{0}_{NxN} &amp; \mathbf{0}_{NxN} \\
\mathbf{0}_{NxN} &amp; \mathbf{I}_{NxN} \\
\end{bmatrix}\mathbf{F}^{-1}</math>
</indent>
: <math>\tilde{\mathbf{G}}_2 = \mathbf{F}\begin{bmatrix}
\mathbf{I}_{NxN} &amp; \mathbf{0}_{NxN} \\
\mathbf{0}_{NxN} &amp; \mathbf{0}_{NxN} \\
\end{bmatrix}\mathbf{F}^{-1}</math>
<indent level="1">

 <math>\mathbf{G}_2 = \mathrm{diag} \left\{ \tilde{\mathbf{G}}_2, \tilde{\mathbf{G}}_2, \dots, \tilde{\mathbf{G}}_2 \right\} </math>
</indent>

In practice, when multiplying a column vector <math>\mathbf{x}</math> by <math>\mathbf{G}_1</math>, we take the inverse FFT of <math>\mathbf{x}</math>, set the first <math>N</math> values in the result to zero and then take the FFT. This is meant to remove the effects of the circular convolution.</p>

</sec>
<sec>
<st>
 Algorithm description </st>

<p>

For each block, the MDF algorithm is computed as: 
<indent level="1">

 <math> \underline{\hat{\mathbf{y}}}(\ell) = \mathbf{G}_1 \underline{\mathbf{X}}(\ell) \underline{\hat{\mathbf{h}}}(\ell-1)  </math>
</indent>
: <math> \underline{\mathbf{e}}(\ell) = \underline{\mathbf{d}}(\ell) - \underline{\hat{\mathbf{y}}}(\ell) </math>
<indent level="1">

 <math>\mathbf{\Phi}_\mathbf{xx} = \underline{\mathbf{X}}(\ell)\underline{\mathbf{X}}(\ell)^H</math>
</indent>
: <math> \underline{\hat{\mathbf{h}}}(\ell) = \underline{\hat{\mathbf{h}}}(\ell-1) + \mu\mathbf{G}_2\mathbf{\Phi}_\mathbf{xx}^{-1}(\ell) \underline{\mathbf{X}}^H(\ell) \underline{\mathbf{e}}(\ell)  </math></p>
<p>

It is worth noting that, while the algorithm is more easily expressed in matrix form, the actual implementation requires no matrix multiplications. For instance the normalisation matrix computation <math>\mathbf{\Phi}_\mathbf{xx} = \underline{\mathbf{X}}(\ell)\underline{\mathbf{X}}(\ell)^H</math> reduces to an element-wise vector multiplication because <math>\underline{\mathbf{X}}(\ell)</math> is block-diagonal. The same goes for other multiplications.</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 J.-S. Soo and K. Pang, “Multidelay block frequency domain adaptive filter,” <it>IEEE Transactions on Acoustics, Speech and Signal Processing</it>, vol. 38, no. 2, pp. 373–376, 1990.</entry>
<entry level="1" type="bullet">

 H. Buchner, J. Benesty, W. Kellermann, "An Extended Multidelay Filter: Fast Low-Delay Algorithms for Very High-Order Adaptive Systems". <it>Proc. IEEE International Conference on Acoustics, Speech, and Signal Processing (ICASSP)</it>, 2003.</entry>
<entry level="1" type="bullet">

 A free implementation of the MDF algorithm is available in <weblink xlink:type="simple" xlink:href="http://www.speex.org">
Speex</weblink> (<weblink xlink:type="simple" xlink:href="http://svn.xiph.org/trunk/speex/libspeex/mdf.c">
main source file</weblink>)</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<filter wordnetid="103339643" confidence="0.8">
<link xlink:type="simple" xlink:href="../071/172071.xml">
Adaptive filter</link></filter>
</device>
</instrumentality>
</artifact>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../338/2017338.xml">
Recursive least squares</link></entry>
<entry level="1" type="bullet">

For statistical techniques relevant to LMS filter see <link xlink:type="simple" xlink:href="../359/82359.xml">
Least squares</link>.</entry>
</list>
</p>

</sec>
</bdy>
</article>
