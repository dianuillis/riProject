<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:50:12[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Weighted matroid</title>
<id>9401560</id>
<revision>
<id>162050300</id>
<timestamp>2007-10-03T17:14:45Z</timestamp>
<contributor>
<username>Giftlite</username>
<id>37986</id>
</contributor>
</revision>
<categories>
<category>Matroid theory</category>
</categories>
</header>
<bdy>
<p>

In <link xlink:type="simple" xlink:href="../170/5170.xml">
combinatorics</link>, a branch of <link xlink:type="simple" xlink:href="../831/18831.xml">
mathematics</link>, a <b>weighted matroid</b> is a <link xlink:type="simple" xlink:href="../321/244321.xml">
matroid</link> endowed with function with respect to which one can perform a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link>.</p>
<p>

There is a simple algorithm for finding a basis:</p>
<p>

<list>
<entry level="1" type="bullet">

 Let A be the empty set.</entry>
<entry level="1" type="bullet">

 For each <it>x</it> in <it>E''</it></entry>
<entry level="2" type="bullet">

 if A U {x} is independent, then set A to A U {x}.</entry>
</list>
</p>
<p>

The result is clearly an independent set. It is a maximal independent set because if B U {x} is not independent for some subset B of A, then A U {x} is not independent either (the contrapositive follows from the <link>
hereditary property</link>). Thus if we pass up an element, we'll never have an opportunity to use it later. We will generalize this algorithm to solve a harder problem.</p>
<p>

A <it>weight function</it> <it>w</it> : <it>E</it> &amp;rarr; <b>R</b>+ for a matroid <it>M</it>=(<it>E</it>, <it>I</it>) assigns a strictly positive weight to each element of <it>E</it>. We extend the function to subsets of <it>E</it> by summation; <it>w</it>(<it>A</it>) is the sum of <it>w</it>(<it>x</it>) over <it>x</it> in <it>A</it>. A matroid with an associated weight function is called a weighted matroid.</p>
<p>

As a simple example, say we wish to find the <link xlink:type="simple" xlink:href="../770/455770.xml">
maximum spanning forest</link> of a graph. That is, given a graph and a weight for each edge, find a forest containing every vertex and maximizing the total weight of the edges in the tree. This problem arises in some clustering applications. If we look at the definition of the forest matroid above, we see that the maximum spanning forest is simply the independent set with largest total weight &mdash; such a set must span the graph, for otherwise we can add edges without creating cycles. But how do we find it?</p>
<p>

An independent set of largest total weight is called an <it>optimal</it> set. Optimal sets are always bases, because if an edge can be added, it should be; this only increases the total weight. As it turns out, there is a trivial <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link> for computing an optimal set of a weighted matroid. It works as follows:</p>
<p>

<list>
<entry level="1" type="bullet">

 Let A be the empty set.</entry>
<entry level="1" type="bullet">

 For each <it>x</it> in <it>E</it>, taken in (monotonically) decreasing order by weight</entry>
<entry level="2" type="bullet">

 if A U {x} is independent, then set A to A U {x}.</entry>
</list>
</p>
<p>

This algorithm finds a basis, since it is a special case of the above algorithm. It always chooses the element of largest weight that it can while preserving independence (thus the term "greedy"). This always produces an optimal set: suppose that it produces <math>A=\{e_1,e_2,\ldots,e_r\}</math> and that <math>B=\{f_1,f_2,\ldots,f_r\}</math>. Now for any <math>k</math> with <math>1\le k\le r</math>, consider open sets <math>O_1=\{e_1,\ldots,e_{k-1}\}</math> and <math>O_2=\{f_1,\ldots,f_k\}</math>. Since <math>O_1</math> is smaller than <math>O_2</math>, there is some element of <math>O_2</math> which can be put into <math>O_1</math> with the result still being independent. However <math>e_k</math> is an element of maximal weight that can be added to <math>O_1</math> to maintain independence. Thus <math>e_k</math> is of no smaller weight than some element of <math>O_2</math>, and hence <math>e_k</math> is of at least a large a weight as <math>f_k</math>. As this is true for all <math>k</math>, <math>A</math> is weightier than <math>B</math>.</p>
<p>

The easiest way to traverse the members of <it>E</it> in the desired order is to sort them. This requires O(|E|log|E|) time using a comparison <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>. We also need to test for each <it>x</it> whether A U {x} is independent; assuming independence tests require O(f(|E|)) time, the total time for the algorithm is O(|E|log|E| + |E|f(|E|)).</p>
<p>

If we want to find a minimum spanning tree instead, we simply "invert" the weight function by subtracting it from a large constant. More specifically, let <it>w</it>min(<it>x</it>) = <it>W</it> - <it>w</it>(<it>x</it>), where <it>W</it> exceeds the total weight over all graph edges. Many more optimization problems about all sorts of matroids and weight functions can be solved in this trivial way, although in many cases more efficient algorithms can be found that exploit more specialized properties.</p>
<p>

Note also that if we take a set <math>I</math> of "independent" sets which is a down-set but not a matroid, then the greedy algorithm will not always work. For then there are independent sets <math>I_1</math> and <math>I_2</math> with <math>|I_1|&amp;lt;|I_2|</math>, but such that for no <math>e\in I_2\setminus I_1</math> is <math>I_1\cup e</math> independent.</p>
<p>

Pick an <math>\epsilon&amp;gt;0</math> and <math>\tau&amp;gt;0</math> such that <math>(1+2\epsilon)|I_1|+\tau|E|&amp;lt;|I_2|</math>. Weight the elements of <math>I_1\cup I_2</math> in the range <math>2</math> to <math>2+2\epsilon</math>, the elements of <math>I_1\setminus I_2</math> in the range <math>1+\epsilon</math> to <math>1+2\epsilon</math>, the elements of <math>I_2\setminus I_1</math> in the range <math>1</math> to <math>1+\epsilon</math>, and the rest in the range <math>0</math> to <math>\tau</math>. The greedy algorithm will select the elements of <math>I_1</math>, and then cannot pick any elements of <math>I_2\setminus I_1</math>. Therefore the independent set it constructs will be of weight at most <math>(1+2\epsilon)|I_1|+\tau|E|+|I_1\cup I_2|</math>, which is smaller than the weight of <math>I_2</math>.</p>

<sec>
<st>
History</st>

<p>

It was not until 1971 that <link xlink:type="simple" xlink:href="../459/3625459.xml">
Jack Edmonds</link> connected weighted matroids to greedy algorithms in his paper  "Matroids and the greedy algorithm". Korte and Lov√°sz would generalize these ideas to objects called <it><link xlink:type="simple" xlink:href="../526/666526.xml">
greedoid</link>s</it>, which allow even larger classes of problems to be solved by greedy algorithms.</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Jack Edmonds. Matroids and the Greedy Algorithm. Mathematical Programming, volume 1, p.125&ndash;136. 1971.</entry>
</list>

</p>
</sec>
</bdy>
</article>
