<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:56:17[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<subject  confidence="0.9511911446218017" wordnetid="106599788">
<header>
<title>Sapir–Whorf and programming languages</title>
<id>949412</id>
<revision>
<id>195549903</id>
<timestamp>2008-03-03T14:03:17Z</timestamp>
<contributor>
<username>BOTijo</username>
<id>3729068</id>
</contributor>
</revision>
<categories>
<category>Psycholinguistics</category>
<category>Programming language topics</category>
</categories>
</header>
<bdy>

The <link>
Sapir–Whorf hypothesis</link> is sometimes applied in <link xlink:type="simple" xlink:href="../323/5323.xml">
computer science</link> to postulate that <link xlink:type="simple" xlink:href="../716/23716.xml">
programmer</link>s skilled in a certain <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> may not have a (deep) understanding of some concepts of other languages. Though it may equally apply to any area where languages are "synthesized" for specific purposes, computer science is especially fertile when it comes to creating languages.<p>

<link xlink:type="simple" xlink:href="../716/23716.xml">
Computer programmer</link>s who are fluent in different <link xlink:type="simple" xlink:href="../015/23015.xml">
programming languages</link> (e.g. <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
, <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link>, <link xlink:type="simple" xlink:href="../768/25768.xml">
Ruby</link>), and/or <link xlink:type="simple" xlink:href="../897/189897.xml">
programming paradigms</link> (e.g. <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logical programming</link>, <link xlink:type="simple" xlink:href="../648/210648.xml">
declarative programming</link>, <link xlink:type="simple" xlink:href="../847/197847.xml">
imperative programming</link>, <link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming</link>, <link xlink:type="simple" xlink:href="../757/22757.xml">
object oriented programming</link>), often see the same problem in completely different ways.</p>
<p>

One way of stating the <link>
Church–Turing thesis</link> is that any language that can simulate a <invention wordnetid="105633385" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../403/30403.xml">
Turing machine</link></method>
</know-how>
</invention>
 can be used to implement any effective <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> &mdash; in this sense, it is irrelevant what language is used to implement a particular algorithm, as that exact algorithm can also be implemented in every other language. However, when <it>designing</it> an algorithm to solve a particular problem, programmers are sometimes heavily influenced by the language constructs available. Though a large part of this is undoubtedly the way of least resistance (implement whatever is easiest to implement), there is also an element of "appropriateness" or "naturalness" that seems to compel the programmer to a design that "befits" the language.</p>
<p>

This is a similar situation to <link xlink:type="simple" xlink:href="../177/350177.xml">
Feynman</link>'s view of physical theories: it is possible for two theories to use completely different concepts and rules but still give identical predictions. However the 'parameterization' of each theory will suggest different possible modifications and experiments to the human physicist who uses it.</p>
<p>

Most programmers consider this to be beneficial, and the bewildering multitude of programming languages can be defended with the remark that a new programming language, while not extending the set of all <it>possible</it> algorithms, does extend the set of all algorithms we can efficiently think about. A well-known saying by <person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../462/300462.xml">
Alan Perlis</link></scientist>
</person>
 states that <it>"a language that doesn't affect the way you think about programming is not worth knowing"</it>.</p>
<p>

This is not universal, however. Programmers familiar with only one paradigm often find the task of algorithm design largely the same, regardless of the programming language used. And, due to the current overwhelming dominance of imperative languages in commercial applications <link xlink:type="simple" xlink:href="../164/36164.xml">
as of 2006</link>, the supposed diversity of programming languages is often a case of slightly different syntax for essentially the same set of programming language constructs. Another famous <link xlink:type="simple" xlink:href="../075/10075.xml">
epigram</link> states that <it>"a good <link xlink:type="simple" xlink:href="../168/11168.xml">
FORTRAN</link> programmer can write FORTRAN code in any language"</it>.</p>

<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cerezo.name/archives/000005.html">
On the Sapir-Whorf hypothesis and its relation to programming languages</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.paulgraham.com/avg.html">
The Blub Paradox - the inability of programmers skilled in one programming language to recognize a different language as superior</weblink></entry>
</list>
</p>


</sec>
<sec>
<st>
 Bibliography </st>
<p>

Wexelblat RL (1980), "The consequences of one's first programming language". URL:<it>http://portal.acm.org/citation.cfm?id=802823''</it></p>
</sec>
</bdy>
</subject>
</article>
