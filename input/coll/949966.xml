<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:54:02[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Constraint satisfaction</title>
<id>949966</id>
<revision>
<id>242058503</id>
<timestamp>2008-09-30T19:12:38Z</timestamp>
<contributor>
<username>Antonielly</username>
<id>812167</id>
</contributor>
</revision>
<categories>
<category>Constraint satisfaction</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link> and <link xlink:type="simple" xlink:href="../476/43476.xml">
operations research</link>, <b>constraint satisfaction</b> is the process of finding a solution to a set of <link xlink:type="simple" xlink:href="../360/206360.xml">
constraints</link> that impose conditions that the <link xlink:type="simple" xlink:href="../818/32818.xml">
variable</link>s must satisfy.  A solution is therefore a vector of variables that satisfies all constraints.<p>

The techniques used in constraint satisfaction depend on the kind of constraints being considered. Often used are constraints on a finite domain, to the point that <link xlink:type="simple" xlink:href="../652/211652.xml">
constraint satisfaction problem</link>s are typically identified with problems based on constraints on a finite domain. Such problems are usually solved via <link xlink:type="simple" xlink:href="../149/19386149.xml">
search</link>, in particular a form of <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link> or <link xlink:type="simple" xlink:href="../194/4149194.xml">
local search</link>. <link xlink:type="simple" xlink:href="../747/3923747.xml">
Constraint propagation</link> are other methods used on such problems; most of them are incomplete in general, that is, they may solve the problem or prove it unsatisfiable, but not always. Constraint propagation methods are also used in conjunction with search to make a given problem simpler to solve. Other considered kinds of constraints are on real or rational numbers; solving problems on these constraints is done via <link>
variable elimination</link> or the <link xlink:type="simple" xlink:href="../458/349458.xml">
simplex algorithm</link>.</p>
<p>

Constraint satisfaction originated in the field of <link xlink:type="simple" xlink:href="../164/1164.xml">
artificial intelligence</link> in the 1970s. During the 1980s and 1990s, embedding of constraints into a <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link> were developed. Languages often used for constraint programming are <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link> and <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
.</p>

<sec>
<st>
Constraint satisfaction problem</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../652/211652.xml">
Constraint satisfaction problem</link></it>
</indent>

As originally defined in artificial intelligence, constraints enumerate the possible values a set of variables may take. Informally, a finite domain is a finite set of arbitrary elements. A constraint satisfaction problem on such domain contains a set of variables whose values can only be taken from the domain, and a set of constraints, each constraint specifying the allowed values for a group of variables. A solution to this problem is an evaluation of the variables that satisfies all constraints. In other words, a solution is a way for assigning a value to each variable in such a way all constraints are satisfied by these values.</p>
<p>

Formally, a constraint satisfaction problem is defined a triple <math>\langle X,D,C \rangle</math>, where <math>X</math> is a set of variables, <math>D</math> is a domain of values, and <math>C</math> is a set of constraints. Every constraint is in turn a pair <math>\langle t,R \rangle</math>, where <math>t</math> is a <link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link> of variables and <math>R</math> is a set of tuples of values; all these tuples having the same number of elements; as a result <math>R</math> is a <link xlink:type="simple" xlink:href="../227/38227.xml">
relation</link>. An evaluation of the variables is a function from variables to <math>v:X \rightarrow D</math>. Such an evaluation satisfies a constraint <math>\langle (x_1,\ldots,x_n),R \rangle</math> if <math>(v(x_1),\ldots,v(x_n)) \in R</math>. A solution is an evaluation that satisfies all constraints.</p>
<p>

In practice, constraints are often expressed in compact form, rather than enumerating all  values of the variables that would satisfy the constraint. The constraint expressing that the values of some variables are all different is one of the most used such constraints.</p>
<p>

Problems that can be expressed as constraint satisfaction problems are the <condition wordnetid="113920835" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../474/10474.xml">
Eight queens puzzle</link></difficulty>
</problem>
</state>
</condition>
, the <link xlink:type="simple" xlink:href="../807/1365807.xml">
Sudoku</link> solving problem, the <condition wordnetid="113920835" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<link xlink:type="simple" xlink:href="../715/4715.xml">
Boolean satisfiability problem</link></difficulty>
</method>
</problem>
</state>
</know-how>
</condition>
, <link xlink:type="simple" xlink:href="../851/4941851.xml">
scheduling</link> problems and various problems on graphs such as the <link xlink:type="simple" xlink:href="../743/426743.xml">
graph coloring</link> problem.</p>
<p>

While usually not included in the above definition of a constraint satisfaction problem, arithmetic equations and inequalities bound the values of the variables they contain and can therefore be considered a form of constraints. Their domain is the set of numbers (either integer, rational, or real), which is infinite: therefore, the relations of these constraints may be infinite as well; for example, <math>X=Y+1</math> has an infinite number of pairs of satisfying values. Arithmetic equations and inequalities are often not considered within the definition of a "constraint satisfaction problem", which is limited to finite domains. They are however used often in <link xlink:type="simple" xlink:href="../899/189899.xml">
constraint programming</link>.</p>

</sec>
<sec>
<st>
Solving</st>

<p>

Constraint satisfaction problems (on finite domains) are typically solved using a form of <link xlink:type="simple" xlink:href="../149/19386149.xml">
search</link>. The most used techniques are variants of backtracking, constraint propagation, and local search.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../867/238867.xml">
Backtracking</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is a recursive algorithm. It maintains a partial assignment of the variables. Initially, all variables are unassigned. At each step, a variable is chosen, and all possible values are assigned to it in turn. For each value, the consistency of the partial assignment with the constraints is checked; in case of consistency, a <link xlink:type="simple" xlink:href="../407/25407.xml">
recursive</link> call is performed. When all values have been tried, the algorithm backtracks. In this basic backtracking algorithm, consistency is defined as the satisfaction of all constraints whose variables are all assigned. Several variants of backtracking exists. <link xlink:type="simple" xlink:href="../047/3956047.xml">
Backmarking</link> improves the efficiency of checking consistency. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../690/4001690.xml">
Backjumping</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 allows saving part of the search by backtracking "more than one variable" in some cases. <link xlink:type="simple" xlink:href="../640/4016640.xml">
Constraint learning</link> infers and saves new constraints that can be later used to avoid part of the search. <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../464/3978464.xml">
Look-ahead</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 is also often used in backtracking to attempt to foresee the effects of choosing a variable or a value, thus sometimes determining in advance when a subproblem is satisfiable or unsatisfiable.</p>
<p>

<link xlink:type="simple" xlink:href="../747/3923747.xml">
Constraint propagation</link> techniques are methods used to modify a constraint satisfaction problem. More precisely, they are methods that enforce a form of <link xlink:type="simple" xlink:href="../747/3923747.xml">
local consistency</link>, which are conditions related to the consistency of a group of variables and/or constraints. Constraints propagation has various uses. First, they turn a problem into one that is equivalent but is usually simpler to solve. Second, they may prove satisfiability or unsatisfiability of problems. This is not guaranteed to happen in general; however, it always happens for some forms of constraint propagation and/or for some certain kinds of problems. The most known and used form of local consistency are <link xlink:type="simple" xlink:href="../747/3923747.xml">
arc consistency</link>, <link xlink:type="simple" xlink:href="../747/3923747.xml">
hyper-arc consistency</link>, and <link xlink:type="simple" xlink:href="../747/3923747.xml">
path consistency</link>. The most popular constraint propagation method is the <link xlink:type="simple" xlink:href="../424/1709424.xml">
AC-3 algorithm</link>, which enforces arc consistency.</p>
<p>

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../942/313942.xml">
Local search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 methods are incomplete satisfiability algorithms. They may find a solution of a problem, but they may fail even if the problem is satisfiable. They work by iteratively improving a complete assignment over the variables. At each step, a small number of variables are changed value, with the overall aim of increasing the number of constraints satisfied by this assignment. In practice, local search appears to work well when these changes are also affected by random choices. Integration of search with local search have been developed, leading to <link xlink:type="simple" xlink:href="../205/4194205.xml">
hybrid algorithms</link>.</p>
<p>

<link>
Variable elimination</link> and the <link xlink:type="simple" xlink:href="../458/349458.xml">
simplex algorithm</link> are used for solving <link xlink:type="simple" xlink:href="../591/91591.xml">
linear</link> and <link xlink:type="simple" xlink:href="../000/23000.xml">
polynomial</link> equations and inequalities.</p>

</sec>
<sec>
<st>
Complexity</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../942/4489942.xml">
Complexity of constraint satisfaction</link></it>
</indent>

Solving a constraint satisfaction problem on a finite domain is an <link xlink:type="simple" xlink:href="../466/39466.xml">
NP complete</link> problem. Research has shown a number of <link>
tractable</link> subcases, some limiting the allowed constraint relations, some requiring the scopes of constraints to form a tree, possibly in a reformulated version of the problem. Research has also established relationship of the constraint satisfaction problem with problems in other areas such as <link xlink:type="simple" xlink:href="../596/1773596.xml">
finite model theory</link>.</p>

</sec>
<sec>
<st>
Constraint programming</st>

<p>

<indent level="1">

<it>Main article: <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../899/189899.xml">
Constraint programming</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
</it>
</indent>

Constraint programming is the use of constraints as a programming language to encode and solve problems. This is often done by embedding constraints into a <link xlink:type="simple" xlink:href="../015/23015.xml">
programming language</link>, which is called the host language. Constraint programming originated from a formalization of equalities of terms in <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog II</link>, leading to a general framework for embedding constraints into a <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic programming</link> language. The most common host languages are <link xlink:type="simple" xlink:href="../485/23485.xml">
Prolog</link>, <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, and <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
, but other languages have been used as well.</p>

<ss1>
<st>
Constraint logic programming</st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../442/4249442.xml">
Constraint logic programming</link></it>
</indent>

A constraint logic program is a <link xlink:type="simple" xlink:href="../de)/17927_(Z$I$P$_code).xml">
logic program</link> that contains constraints in the bodies of clauses. As an example, the clause A(X):-X&amp;gt;0,B(X) is a clause containing the constraint X&amp;gt;0 in the body. Constraints can also be present in the goal. The constraints in the goal and in the clauses used to prove the goal are accumulated into a set called <link xlink:type="simple" xlink:href="../442/4249442.xml">
constraint store</link>. This set contains the constraints the interpreter has assumed satisfiable in order to proceed in the evaluation. As a result, if this set is detected unsatisfiable, the interpreter backtracks. Equations of terms, as used in logic programming, are considered a particular form of constraints which can be simplified using <link xlink:type="simple" xlink:href="../432/54432.xml">
unification</link>. As a result, the constraint store can be considered an extension of the concept of <link xlink:type="simple" xlink:href="../668/239668.xml">
substitution</link> that is used in regular logic programming. The most common kinds of constraints used in constraint logic programming are constraints over integers/rational/real numbers and constraints over finite domains.</p>
<p>

<link xlink:type="simple" xlink:href="../477/4467477.xml">
Concurrent constraint logic programming</link> languages have also been developed. They significantly differ from non-concurrent constraint logic programming in that they are aimed at programming <link xlink:type="simple" xlink:href="../162/145162.xml">
concurrent process</link>es that may not terminate. <link xlink:type="simple" xlink:href="../362/1753362.xml">
Constraint handling rules</link> can be seen as a form of concurrent constraint logic programming, but are also sometimes used within a non-concurrent constraint logic programming language. They allow for rewriting constraints or to infer new ones based on the truth of conditions.</p>

</ss1>
<ss1>
<st>
Constraint satisfaction toolkits</st>

<p>

Constraint satisfaction toolkits are <link xlink:type="simple" xlink:href="../421/106421.xml">
software libraries</link> for <link xlink:type="simple" xlink:href="../847/197847.xml">
imperative programming language</link>s that are used to encode and solve a constraint satisfaction problem. The most common host language for these toolkits is <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../038/72038.xml">
C++</link></programming_language>
, but implementations exist for <message wordnetid="106598915" confidence="0.8">
<request wordnetid="106513366" confidence="0.8">
<link xlink:type="simple" xlink:href="../881/15881.xml">
Java</link></request>
</message>
 and other programming languages.
<weblink xlink:type="simple" xlink:href="http://www.bracil.net/CSP/cacp/cacpdemo.html">
ZDC</weblink> is an open source <link xlink:type="simple" xlink:href="../592/11592.xml">
freeware</link> developed in the <weblink xlink:type="simple" xlink:href="http://www.bracil.net/CSP/cacp/">
Computer-Aided Constraint Satisfaction Project</weblink> for modelling and solving constraint satisfaction problems.</p>

</ss1>
<ss1>
<st>
Other constraint programming languages</st>

<p>

Constraint toolkits are a way for embedding constraints into an <link xlink:type="simple" xlink:href="../847/197847.xml">
imperative programming language</link>. However, they are only used as external libraries for encoding and solving problems. An approach in which constraints are integrated into an imperative programming language is taken in the <link xlink:type="simple" xlink:href="../159/4400159.xml">
Kaleidoscope programming language</link>.</p>
<p>

Constraints have also been embedded into <paradigm wordnetid="113804375" confidence="0.8">
<linguistic_relation wordnetid="113797142" confidence="0.8">
<inflection wordnetid="113803782" confidence="0.8">
<grammatical_relation wordnetid="113796779" confidence="0.8">
<link xlink:type="simple" xlink:href="../933/10933.xml">
functional programming languages</link></grammatical_relation>
</inflection>
</linguistic_relation>
</paradigm>
.</p>


</ss1>
</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../540/7418540.xml">
Constraint (mathematics)</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../808/1556808.xml">
Candidate solution</link></entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>

<p>

<list>
<entry level="1" type="bullet">

 <cite id="Reference-Rossi-2006" style="font-style:normal" class="book">Rossi, Francesca;&#32;Peter van Beek, Toby Walsh (ed.)&#32;(2006). <weblink xlink:type="simple" xlink:href="http://www.elsevier.com/wps/find/bookdescription.cws_home/708863/description#description">
Handbook of Constraint Programming,</weblink>.&#32;Elsevier.</cite>&nbsp; ISBN-13 978-0-444-52726-4 ISBN-10 0-444-52726-5</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Dechter-2003" style="font-style:normal" class="book">Dechter, Rina&#32;(2003). <weblink xlink:type="simple" xlink:href="http://www.ics.uci.edu/~dechter/books/index.html">
Constraint processing</weblink>.&#32;Morgan Kaufmann.</cite>&nbsp; ISBN 1-55860-890-7</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Apt-2003" style="font-style:normal" class="book">Apt, Krzysztof&#32;(2003). Principles of constraint programming.&#32;Cambridge University Press.</cite>&nbsp; ISBN 0-521-82583-0</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Fr&amp;uuml;hwirth-2003" style="font-style:normal" class="book">Fr&amp;uuml;hwirth, Thom;&#32;Slim Abdennadher&#32;(2003). Essentials of constraint programming.&#32;Springer.</cite>&nbsp; ISBN 3-540-67623-6</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Marriot-1998" style="font-style:normal" class="book">Marriot, Kim;&#32;Peter J. Stuckey&#32;(1998). Programming with constraints: An introduction.&#32;MIT Press.</cite>&nbsp; ISBN 0-262-13341-5</entry>
<entry level="1" type="bullet">

 <cite style="font-style:normal">Jaffar, Joxan; Michael J. Maher&#32;(1994).&#32;"Constraint logic programming: a survey". <it>Journal of logic programming</it>&#32;<b>19/20</b>: 503–581. <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1016%2F0743-1066%2894%2990033-7">
10.1016/0743-1066(94)90033-7</weblink>.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Freuder-1994" style="font-style:normal" class="book">Freuder, Eugene;&#32;Alan Mackworth (ed.)&#32;(1994). Constraint-based reasoning.&#32;MIT Press.</cite>&nbsp; ISBN </entry>
<entry level="1" type="bullet">

 <cite id="Reference-Tsang-1993" style="font-style:normal" class="book">Tsang, Edward&#32;(1993). <weblink xlink:type="simple" xlink:href="http://www.bracil.net/edward/FCS.html">
Foundations of Constraint Satisfaction</weblink>.&#32;Academic Press.</cite>&nbsp; ISBN 0-12-701610-4</entry>
<entry level="1" type="bullet">

 <cite id="Reference-Van Hentenryck-1989" style="font-style:normal" class="book">Van Hentenryck, Pascal&#32;(1989). Constraint Satisfaction in Logic Programming.&#32;MIT Press.</cite>&nbsp; ISBN 0-262-08181-4</entry>
</list>
</p>

</sec>
</bdy>
</article>
