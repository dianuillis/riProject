<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:47:27[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Reverse-delete algorithm</title>
<id>9516059</id>
<revision>
<id>189701404</id>
<timestamp>2008-02-07T09:59:26Z</timestamp>
<contributor>
<username>Terencehonles</username>
<id>1522713</id>
</contributor>
</revision>
<categories>
<category>Graph algorithms</category>
<category>Spanning tree</category>
</categories>
</header>
<bdy>

The <b>reverse-delete algorithm</b> is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> in <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link> used to obtain a <link xlink:type="simple" xlink:href="../795/41795.xml">
minimum spanning tree</link> from a given connected, edge-weighed graph.  If the graph is disconnected, this algorithm will find a minimum spanning tree for each disconnected part of the graph.  The set of these minimum spanning trees is called a minimum spanning forest, which consists of every vertex in the graph.<p>

This algorithm is a <link xlink:type="simple" xlink:href="../247/89247.xml">
greedy algorithm</link>, choosing the best choice given any situation.  It is the reverse of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, which is another greedy algorithm to find a minimum spanning tree.  Kruskal’s algorithm starts with an empty graph and adds edges while the Reverse-Delete algorithm starts with the original graph and deletes edges from it.  The algorithm works as follows:
<list>
<entry level="1" type="bullet">

 Start with graph G, which contains a list of edges E.</entry>
<entry level="1" type="bullet">

 Go through E in decreasing order of edge weights.</entry>
<entry level="1" type="bullet">

 Check if deleting current edge will further disconnect graph.</entry>
<entry level="1" type="bullet">

 If G is not further disconnected, delete the edge.</entry>
</list>
</p>

<sec>
<st>
 Proof of correctness </st>
<p>

The Reverse-Delete algorithm ensures connectivity in the graph or graph parts before deletion.  Since the algorithm only deletes edges when it does not disconnect the graph, any edge removed by the algorithm at the time of deletion was in a cycle.  Since the algorithm starts from the heaviest weighted edge and continues in decreasing order, the edge removed from any cycle is the maximum edge in that cycle.  Therefore, according to the definition of a minimum spanning tree, the edges removed by the algorithm are not in any minimum spanning tree.</p>

</sec>
<sec>
<st>
 Pseudocode </st>
<p>

1  <b>function</b> ReverseDelete(edges <it>E</it>)
2    <b>sort</b> <it>E</it> in decreasing order
3    Define an index <it>i</it> ← 0
4    <b>while</b> <it>i</it>  <b>size</b>(<it>E</it>)
5       Define edge <it>temp</it> ← <it>E</it>[''i'']
6	<b>delete</b> <it>E</it>[''i'']
7	<b>if</b> <it>temp.v1</it> is not connected to <it>temp.v2</it>
8          <it>E</it>[''i''] ← <it>temp</it>
9	<it>i</it> ← <it>i</it> + 1
10   <b>return</b> edges <it>E</it>
In the above the graph is the set of edges <it>E</it> with each edge containing a weight and connected vertices <it>v1</it> and <it>v2</it>.</p>

</sec>
<sec>
<st>
 Example </st>
<p>

In the following example green edges are those being evaluated by the algorithm and red edges are those which have been deleted.
<table cellpadding="5" border="1" cellspacing="0">
<row>
<col>
<image width="200px" src="Reverse_Delete_0.svg">
</image>
</col>
<col>
This is our original graph. The numbers near the edge indicate their edge weight.</col>
</row>
<row>
<col>
<image width="200px" src="Reverse_Delete_1.svg">
</image>
</col>
<col>
The algorithm will start with the maximum weighted edge, which in this case is <b>DE</b> with an edge weight of 15. Since deleting edge DE does not further disconnect the graph it is deleted.</col>
</row>
<row>
<col>
<image width="200px" src="Reverse_Delete_2.svg">
</image>
</col>
<col>
The next largest edge is <b>FG</b> so the algorithm will check if deleting this edge will further disconnect the graph.  Since deleting the edge will not further disconnect the graph, the edge is then deleted.</col>
</row>
<row>
<col>
<image width="200px" src="Reverse_Delete_3.svg">
</image>
</col>
<col>
The next largest edge is edge <b>BD</b> so the algorithm will check this edge and delete the edge.</col>
</row>
<row>
<col>
<image width="200px" src="Reverse_Delete_4.svg">
</image>
</col>
<col>
The next edge to check is edge <b>EG</b>, which will not be deleted since it would disconnect node <b>G</b> from the graph.  Therefore, the next edge to delete is edge <b>BC</b>.</col>
</row>
<row>
<col>
<image width="200px" src="Reverse_Delete_5.svg">
</image>
</col>
<col>
The next largest edge is edge <b>EF</b> so the algorithm will check this edge and delete the edge.</col>
</row>
<row>
<col>
<image width="200px" src="Reverse_Delete_6.svg">
</image>
</col>
<col>
The algorithm will then search the remaining edges and will not find another edge to delete; therefore this is the final graph returned by the algorithm.</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Running time </st>
<p>

The algorithm can be shown to run in <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link></it>(<it>E</it> log <it>E</it> (log log <it>E</it>)3) time, where <it>E</it> is the number of edges and <it>V</it> is the number of vertices.  This bound is achieved as follows: 
<list>
<entry level="1" type="bullet">

	sorting the edges by weight using a comparison sort in <it>O</it>(<it>E</it> log <it>E</it>) time</entry>
<entry level="1" type="bullet">

	<it>E</it> iterations of loop</entry>
<entry level="1" type="bullet">

	deleting in <it>O</it>(1) time</entry>
<entry level="1" type="bullet">

	connectivity checked in <it>O</it>(log<it>V</it> (log log <it>V</it>)3) time  <cite class="inline">(<link xlink:type="simple" xlink:href="#xpointer(//cite[@id=%22CITEREFThorup2000%22])">
Thorup 2000</link>)</cite>.</entry>
</list>
</p>
<p>

Equally, the running time can be considered <it><link xlink:type="simple" xlink:href="../578/44578.xml">
O</link></it>(<it>E</it> log <it>V</it> (log log <it>V</it>)3) because the largest <it>E</it> can be is <it>V</it>2.  Remember that log<it>V</it>2 = 2 * log<it>V</it>, so <it>2</it> is a multiplicative constant that will be ignored in <link xlink:type="simple" xlink:href="../578/44578.xml">
big-O notation</link>.</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../776/53776.xml">
Kruskal's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../783/53783.xml">
Prim's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <link>
Borůvka's algorithm</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 <cite id="CITEREFKleinbergTardos2006" style="font-style:normal">Kleinberg, Jo&#32;&amp;&#32;<link>
Tardos, Éva</link>&#32;(2006),&#32;<it>Algorithm Design</it>, New York: Pearson Education, Inc.</cite>&nbsp;.</entry>
<entry level="1" type="bullet">

 <cite id="CITEREFThorup2000" style="font-style:normal">Thorup, Mikkel&#32;(2000),&#32;"Near-optimal fully-dynamic graph connectivity", pp. 343–350, <document wordnetid="106470073" confidence="0.8">
<written_communication wordnetid="106349220" confidence="0.8">
<writing wordnetid="106362953" confidence="0.8">
<link xlink:type="simple" xlink:href="../994/422994.xml">
doi</link></writing>
</written_communication>
</document>
:<weblink xlink:type="simple" xlink:href="http://dx.doi.org/10.1145%2F335305.335345">
10.1145/335305.335345</weblink></cite>&nbsp;.</entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
