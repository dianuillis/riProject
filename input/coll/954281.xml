<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:54:21[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Cache algorithms</title>
<id>954281</id>
<revision>
<id>235368007</id>
<timestamp>2008-08-31T12:48:32Z</timestamp>
<contributor>
<username>Fvasconcellos</username>
<id>1051513</id>
</contributor>
</revision>
<categories>
<category>Memory management algorithms</category>
<category>Cache</category>
</categories>
</header>
<bdy>

This article is about general cache algorithms.&#32;&#32;For detailed algorithms specific to paging, see <link xlink:type="simple" xlink:href="../476/727476.xml">
page replacement algorithm</link>.&#32;&#32;
<indent level="1">

 <it>For detailed algorithms specific to the cache between a CPU and RAM, see <link xlink:type="simple" xlink:href="../181/849181.xml">
CPU cache</link>.</it>
</indent>

In <link xlink:type="simple" xlink:href="../213/5213.xml">
computing</link>, <b>cache algorithms</b> (also frequently called <it>replacement algorithms</it> or <it>replacement policies</it>) are <link>
optimizing</link> instructions&nbsp;&ndash; <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s&nbsp;&ndash; that a <link xlink:type="simple" xlink:href="../783/5783.xml">
computer program</link> or a hardware-maintained structure can follow to manage a <link xlink:type="simple" xlink:href="../829/6829.xml">
cache</link> of information stored on the computer. When the cache is full, the algorithm must choose which items to discard to make room for the new ones.<p>

The "hit rate" of a cache describes how often a searched-for item is actually found in the cache.
More efficient replacement policies keep track of more usage information in order to improve the hit rate (for a given cache size).</p>
<p>

The "latency" of a cache describes how long after requesting a desired item the cache can return that item (when there is a hit).
Faster replacement strategies typically keep track of less usage information -- or, in the case of direct-mapped cache, no information -- to reduce the amount of time required to update that information.</p>
<p>

Each replacement strategy is a compromise between hit rate and latency.</p>
<p>

Examples of caching algorithms are: 
<list>
<entry level="1" type="bullet">

 The <it>most</it> efficient caching algorithm would be to always discard the information that will not be needed for the longest time in the future. This optimal result is referred to as <physical_entity wordnetid="100001930" confidence="0.8">
<executive wordnetid="110069645" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<leader wordnetid="109623038" confidence="0.8">
<administrator wordnetid="109770949" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<head wordnetid="110162991" confidence="0.8">
<employee wordnetid="110053808" confidence="0.8">
<research_worker wordnetid="110523076" confidence="0.8">
<link xlink:type="simple" xlink:href="../489/2120489.xml">
Belady's</link></research_worker>
</employee>
</head>
</scientist>
</causal_agent>
</worker>
</administrator>
</leader>
</person>
</executive>
</physical_entity>
 optimal algorithm or <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link>
 the clairvoyant algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
. Since it is generally impossible to predict how far in the future information will be needed, this is generally not implementable in practice. The practical minimum can be calculated only after experimentation, and one can compare the effectiveness of the actually chosen cache algorithm with the optimal minimum.</entry>
<entry level="1" type="bullet">

<b>Least Recently Used</b> (LRU): discards the least recently used items first. This algorithm requires keeping track of what was used when, which is expensive if one wants to make sure the algorithm always discards <it>the</it> least recently used item. General implementations of this technique require to keep "age bits" for cache-lines and track the "Least Recently Used" cache-line based on age-bits. In such implementation, every time a cache-line is used, the age of all other cache-lines changes. </entry>
<entry level="1" type="bullet">

<b>Most Recently Used</b> (MRU): discards, in contrast to LRU, the most recently used items first. This caching mechanism is used when access is unpredictable, and determining the least most recently used section of the cache system is a high time complexity operation.  A common example of this is database memory caches.</entry>
<entry level="1" type="bullet">

<b><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../628/1911628.xml">
Pseudo-LRU</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</b> (PLRU): For caches with large <link xlink:type="simple" xlink:href="../181/849181.xml#xpointer(//*[./st=%22Associativity%22])">
associativity</link> (generally &amp;gt;4 ways), the implementation cost of LRU becomes prohibitive.  If a probabilistic scheme that almost always discards one of the least recently used items is sufficient, the PLRU algorithm can be used which only needs one bit per cache item to work.</entry>
</list>

<image width="450px" src="Cache,associative-fill-both.png" type="thumb">
<caption>

Which memory locations can be cached by which cache locations
</caption>
</image>

<list>
<entry level="1" type="bullet">

 <b>2-way</b> <link xlink:type="simple" xlink:href="../181/849181.xml#xpointer(//*[./st=%22Associativity+%22])">
 set associative</link>: for high-speed <link xlink:type="simple" xlink:href="../181/849181.xml">
CPU cache</link>s where even PLRU is too slow. The address of a new item is used to calculate one of two possible locations in the cache where it is allowed to go. The LRU of the two is discarded. This requires one bit per pair of cache lines, to indicate which of the two was the least recently used.</entry>
<entry level="1" type="bullet">

 <b>Direct-mapped cache</b>: for the highest-speed CPU caches where even 2-way set associative caches are too slow. The address of the new item is used to calculate the one location in the cache where it is allowed to go. Whatever was there before is discarded.</entry>
<entry level="1" type="bullet">

<b><link>
Least Frequently Used</link></b> (LFU): LFU counts how often an item is needed. Those that are used least often are discarded first.</entry>
<entry level="1" type="bullet">

<b><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../427/8910427.xml">
Adaptive Replacement Cache</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</b> (ARC): constantly balances between LRU and LFU, to improve combined result.</entry>
</list>
</p>
<p>

Other things to consider:</p>
<p>

<list>
<entry level="1" type="bullet">

 Items with different cost: keep items that are expensive to obtain, e.g. those that take a long time to get.</entry>
<entry level="1" type="bullet">

 Items taking up more cache: If items have different sizes, the cache may want to discard a large item to store several smaller ones.</entry>
<entry level="1" type="bullet">

 Items that expire with time: Some caches keep information that expires (e.g. a news cache, a DNS cache, or a web browser cache). The computer may discard items because they are expired. Depending on the size of the cache no further caching algorithm to discard items may be necessary.</entry>
</list>
</p>
<p>

Various algorithms also exist to maintain <link xlink:type="simple" xlink:href="../865/176865.xml">
cache coherency</link>. This applies only to situation where <it>multiple</it> independent caches are used for the <it>same</it> data (for example multiple database servers updating the single shared data file).</p>

<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../829/6829.xml">
Cache</link></entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../181/849181.xml">
CPU cache</link></entry>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../476/727476.xml">
Page replacement algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/Memory/fully.html">
Fully associative cache</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/Memory/set.html">
Set associative cache</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/Memory/direct.html">
Direct mapped cache</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
