<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:57:58[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Robustification</title>
<id>9645719</id>
<revision>
<id>235955926</id>
<timestamp>2008-09-03T03:17:38Z</timestamp>
<contributor>
<username>Jayen466</username>
<id>1277430</id>
</contributor>
</revision>
<categories>
<category>Reliability engineering</category>
<category>Quality</category>
<category>Engineering stubs</category>
</categories>
</header>
<bdy>

<b>Robustification</b> is a form of optimisation whereby a system is made less sensitive to the effects of random variability, or noise, that is present in that system’s input variables and parameters. The process is typically associated with engineering systems, but the process can also be applied to a political policy, a business strategy or any other system that is subject to the effects of random variability.
<sec>
<st>
Clarification on definition</st>
<p>

Robustification as it is defined here is sometimes referred to as parameter design and is often associated with <link xlink:type="simple" xlink:href="../079/442079.xml">
Taguchi methods</link>. Within that context, robustification can include the process of finding the inputs that contribute most to the random variability in the output and controlling them, or tolerance design. At times the terms design for quality or <link xlink:type="simple" xlink:href="../273/718273.xml">
Design for Six Sigma</link> (DFSS) might also be used as synonyms.</p>

</sec>
<sec>
<st>
Principles</st>
<p>

Robustification works by taking advantage of two different principles.</p>

<ss1>
<st>
Non-linearities</st>

<p>

Consider the graph below of a relationship between an input variable <it>x</it> and the output <it>Y</it>, for which it is desired that a value of 7 is taken, of a system of interest. It can be seen that there are two possible values that <it>x</it> can take, 5 and 30. If the tolerance for <it>x</it> is independent of the nominal value, then it can also be seen that when <it>x</it> is set equal to 30, the expected variation of <it>Y</it> is less than if <it>x</it> were set equal to 5. The reason is that the gradient at <it>x</it> = 30 is less than at <it>x</it> = 5, and the random variability in <it>x</it> is suppressed as it flows to <it>Y</it>.</p>
<p>

<image width="150px" src="Robustification.JPG‎">
<caption>

Robustification.JPG‎
</caption>
</image>
</p>
<p>

This basic principle underlies all robustification, but in practice there are typically a number of inputs and it is the suitable point with the lowest gradient on a multi-dimensional surface that must be found.</p>

</ss1>
<ss1>
<st>
Non-constant variability</st>
<p>

Consider a case where an output <it>Z</it> is a function of two inputs <it>x</it> and <it>y</it> that are multiplied by each other. </p>
<p>

<it>Z</it> = <it>x y</it></p>
<p>

For any target value of <it>Z</it> there is an infinite number of combinations for the nominal values of <it>x</it> and <it>y</it> that will be suitable. However, if the standard deviation of <it>x</it> was proportional to the nominal value and the standard deviation of <it>y</it> was constant, then <it>x</it> would be reduced (to limit the random variability that will flow from the right hand side of the equation to the left hand side) and <it>y</it> would be increased (with no expected increase random variability because the standard deviation is constant) to bring the value of <it>Z</it> to the target value. By doing this, <it>Z</it> would have the desired nominal value and it would be expected that its standard deviation would be at a minimum: robustified. </p>
<p>

By taking advantage of the two principles covered above, one is able to optimise a system so that the nominal value of a systems output is kept at its desired level while also minimising the likelihood of any deviation from that nominal value. This is despite the presence of random variability within the input variables.</p>

</ss1>
</sec>
<sec>
<st>
Methods</st>
<p>

There are three distinct methods of robustification, but a practitioner might use a mix that provides the best in results, resources and time.</p>

<ss1>
<st>
Experimental</st>
<p>

The experimental approach is probably the most widely known. It involves the identification of those variables that can be adjusted and those variables that are treated as noises. An experiment is then designed to investigate how changes to the nominal value of the adjustable variables can limit the transfer of noise from the noise variables to the output. This approach is attributed to <physical_entity wordnetid="100001930" confidence="0.8">
<expert wordnetid="109617867" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<statistician wordnetid="110653238" confidence="0.8">
<theorist wordnetid="110706812" confidence="0.8">
<intellectual wordnetid="109621545" confidence="0.8">
<engineer wordnetid="109615807" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<link xlink:type="simple" xlink:href="../240/440240.xml">
Taguchi</link></mathematician>
</scientist>
</causal_agent>
</engineer>
</intellectual>
</theorist>
</statistician>
</person>
</expert>
</physical_entity>
 and is often associated with <link xlink:type="simple" xlink:href="../079/442079.xml">
Taguchi methods</link>. While many have found the approach to provide impressive results, the techniques have also been criticised for being statistically erroneous and inefficient. Also, the time and effort required can be significant.</p>
<p>

Another experimental method that was used for robustification is the Operating Window. It was developed in the US before the wave of quality methods from Japan came to the West, but still remains unknown to many.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> In this approach, the noise of the inputs is continually increased as the system is modified to reduce sensitivity to that noise. This increases robustness, but also provides a clearer measure of the variability that is flowing through the system. After optimisation, the random variability of the inputs is controlled and reduced, and the system exhibits improved quality.</p>

</ss1>
<ss1>
<st>
Analytical</st>
<p>

The analytical approach relies initially on the development of an analytical model of the system of interest. The expected variability of the output is then found by using a method like the <link xlink:type="simple" xlink:href="../908/593908.xml">
propagation of error</link> or functions of random variables.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref> These typically produce an algebraic expression that can be analysed for optimisation and robustification. This approach is only as accurate as the model developed and it can be very difficult if not impossible for complex systems. </p>
<p>

The analytical approach might also be used in conjunction with some kind of surrogate model that is based on the results of experiments or numerical simulations of the system.</p>

</ss1>
<ss1>
<st>
Numerical</st>
<p>

In the numerical approach a model is run a number of times as part of a <technique wordnetid="105665146" confidence="0.8">
<know-how wordnetid="105616786" confidence="0.8">
<method wordnetid="105660268" confidence="0.8">
<link xlink:type="simple" xlink:href="../098/56098.xml">
Monte Carlo simulation</link></method>
</know-how>
</technique>
 or a numerical propagation of errors to predict the variability of the outputs. Numerical optimisation methods such as hill climbing or evolutionary algorithms are then used to find the optimum nominal values for the inputs. This approach typically requires less human time and effort than the other two, but it can be very demanding on computational resources during simulation and optimisation.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../083/620083.xml">
Sensitivity analysis</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Footnotes</st>
<p>

<reflist>
<entry id="1">
See Clausing (2004) reference for more details</entry>
<entry id="2">
See the 'Probabilistic Design' link in the external links for more information.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 Clausing (1994) <it>Total Quality Development: A Step-By-Step Guide to World-Class Concurrent Engineering.</it> American Society of Mechanical Engineers. ISBN 0791800350</entry>
<entry level="1" type="bullet">

 Clausing, D. (2004)  <it>Operating Window: An Engineering Measure for Robustness</it> Technometrics. Vol. 46 [1] pp. 25-31. </entry>
<entry level="1" type="bullet">

 Siddall (1982) <it>Optimal Engineering Design.</it> CRC. ISBN 0824716337</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://grassmannalgebra.info/probabilisticdesign">
 Probabilistic design</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cjsteele.com/Robustification.pdf">
Robustification</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.synopsys.com/products/mixedsignal/saber/auto/comp_art-using_saber.pdf">
<it>Improving System Reliability Using the Saber® Simulator in a Robust Design Flow''</it></weblink></entry>
</list>
</p>


</sec>
</bdy>
</article>
