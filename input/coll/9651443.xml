<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 23:58:08[mciao0826] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Radial basis function network</title>
<id>9651443</id>
<revision>
<id>236209675</id>
<timestamp>2008-09-04T10:32:30Z</timestamp>
<contributor>
<username>Paolo.dL</username>
<id>4370711</id>
</contributor>
</revision>
<categories>
<category>Optimization algorithms</category>
<category>Neural networks</category>
<category>Computational statistics</category>
<category>Machine learning</category>
<category>Classification algorithms</category>
<category>Interpolation</category>
</categories>
</header>
<bdy>

A <b>radial basis function network</b> is an <link xlink:type="simple" xlink:href="../523/21523.xml">
artificial neural network</link> that uses <link xlink:type="simple" xlink:href="../753/2310753.xml">
radial basis function</link>s as activation functions. They are used in <link xlink:type="simple" xlink:href="../897/336897.xml">
function approximation</link>, <link xlink:type="simple" xlink:href="../624/406624.xml">
time series prediction</link>, and <link xlink:type="simple" xlink:href="../039/7039.xml">
control</link>.
<sec>
<st>
Network architecture</st>

<p>

<image location="right" width="350px" src="Radial_funktion_network.svg" type="thumb">
<caption>

Figure 1: Architecture of a radial basis function network. An input vector <b>x</b> is used as input to all radial basis functions, each with different parameters. The output of the network is a linear combination of the outputs from radial basis functions.
</caption>
</image>
</p>
<p>

Radial basis function (RBF) networks typically have three layers: an input layer, a hidden layer with a non-linear RBF activation function and a linear output layer. The output, <math>  \varphi : \mathbb{R}^n \to \mathbb{R} </math>, of the network is thus</p>
<p>

<indent level="1">

<math>\varphi(\mathbf{x}) = \sum_{i=1}^N a_i \rho(||\mathbf{x}-\mathbf{c}_i||)</math>
</indent>

where <it>N</it> is the number of neurons in the hidden layer, <math>c_i</math> is the center vector for neuron <it>i</it>, and <math>a_i</math> are the weights of the linear output neuron. In the basic form all inputs are connected to each hidden neuron. The norm is typically taken to be the <link xlink:type="simple" xlink:href="../932/53932.xml">
Euclidean distance</link> and the basis function is taken to be <link xlink:type="simple" xlink:href="../462/21462.xml">
Gaussian</link></p>
<p>

<indent level="1">

<math> \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) = \exp \left[ -\beta \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert ^2 \right] </math>.
</indent>

The Gaussian basis functions are local in the sense that </p>
<p>

<indent level="1">

<math>\lim_{||x|| \to \infty}\rho(\left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert) = 0</math>
</indent>

i.e. changing parameters of one neuron has only a small effect for input values that are far away from the center of that neuron.</p>
<p>

RBF networks are <link xlink:type="simple" xlink:href="../448/18543448.xml">
universal approximator</link>s on a compact subset of <math>\mathbb{R}^n</math>. This means that a RBF network with enough hidden neurons can approximate any continuous function with arbitrary precision.</p>
<p>

The weights <math>  a_i </math>, <math>  \mathbf{c}_i </math>, and <math> \beta </math> are determined in a manner that optimizes the fit between <math> \varphi </math> and the data.</p>
<p>

<image location="right" width="350px" src="Unnormalized_radial_basis_functions.svg" type="thumb">
<caption>

Figure 2: Two unnormalized radial basis functions in one input dimension. The basis function centers are located at <math>  c_1=0.75 </math> and <math>  c_2=3.25 </math>.

</caption>
</image>

</p>
<ss1>
<st>
Normalized</st>

<ss2>
<st>
Normalized architecture</st>
<p>

In addition to the above <it>unnormalized</it> architecture, RBF networks can be <it>normalized</it>. In this case the mapping is</p>
<p>

<indent level="1">

<math>  \varphi ( \mathbf{x} ) \ \stackrel{\mathrm{def}}{=}\   \frac { \sum_{i=1}^N  a_i \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) } { \sum_{i=1}^N  \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) }  = \sum_{i=1}^N  a_i u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>
where</p>
<p>

<indent level="1">

<math>  u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) \ \stackrel{\mathrm{def}}{=}\   \frac { \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) } { \sum_{i=1}^N  \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) }  </math>
</indent>

is known as a "normalized radial basis function".</p>
<p>

<image location="right" width="350px" src="060803_normalized_radial_basis_functions.png" type="thumb">
<caption>

Figure 3: Two normalized radial basis functions in one input dimension. The basis function centers are located at <math>  c_1=0.75 </math> and <math>  c_2=3.25 </math>.
</caption>
</image>
</p>


</ss2>
<ss2>
<st>
Theoretical motivation for normalization</st>
<p>

There is theoretical justification for this architecture in the case of stochastic data flow. Assume a <link xlink:type="simple" xlink:href="../425/1499425.xml">
stochastic kernel</link> approximation for the joint probability density</p>
<p>

<indent level="1">

<math>  P\left ( \mathbf{x} \land y \right ) = \sum_{i=1}^N \, \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) \, \sigma \big ( \left \vert y - e_i  \right \vert \big )</math>
</indent>

where the weights <math> \mathbf{c}_i </math>  and <math> e_i </math> are exemplars from the data and we require the kernels to be normalized
<indent level="1">

<math>  \int \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) \, d^n\mathbf{x} =1</math>
</indent>
and
<indent level="1">

<math>  \int \sigma \big ( \left \vert y - e_i  \right \vert \big ) \, dy =1</math>.
</indent>

<image location="right" width="350px" src="060804_3_normalized_basis_functions.png" type="thumb">
<caption>

Figure 4: Three normalized radial basis functions in one input dimension. The additional basis function has center at <math>  c_3=2.75 </math>
</caption>
</image>
</p>
<p>

The probability densities in the input and output spaces are</p>
<p>

<indent level="1">

<math>  P \left ( \mathbf{x} \right ) = \int P \left ( \mathbf{x} \land y \right )   \, dy = \sum_{i=1}^N \, \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big )</math>
</indent>

and</p>
<p>

<indent level="1">

<math>  P \left ( y \right ) = \int P \left ( \mathbf{x} \land y \right )  \, d^n \mathbf{x} = \sum_{i=1}^N \, \sigma \big ( \left \vert y - e_i  \right \vert \big ) </math>
</indent>

The expectation of y given an input <math>   \mathbf{x} </math> is</p>
<p>

<indent level="1">

<math>  \varphi \left ( \mathbf{x} \right ) \ \stackrel{\mathrm{def}}{=}\   E\left ( y \mid \mathbf{x} \right ) = \int y \, P\left ( y \mid \mathbf{x} \right ) dy </math>
</indent>
where
<indent level="1">

<math> P\left ( y \mid \mathbf{x} \right )  </math>
</indent>
is the conditional probability of y given <math>  \mathbf{x}   </math>.
The conditional probability is related to the joint probability through <link xlink:type="simple" xlink:href="../569/49569.xml">
Bayes theorem</link></p>
<p>

<indent level="1">

<math> P\left ( y \mid \mathbf{x} \right ) = \frac {P \left ( \mathbf{x} \land y \right )} {P \left ( \mathbf{x}  \right )}  </math>
</indent>

which yields</p>
<p>

<indent level="1">

<math>  \varphi \left ( \mathbf{x} \right ) =  \int y \, \frac {P \left ( \mathbf{x} \land y \right )} {P \left ( \mathbf{x}  \right )}  \,  dy </math>.
</indent>

This becomes</p>
<p>

<indent level="1">

<math>  \varphi \left ( \mathbf{x} \right ) =  \frac { \sum_{i=1}^N  a_i \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) } { \sum_{i=1}^N  \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) } = \sum_{i=1}^N  a_i u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>

when the integrations are performed.
<image location="right" width="350px" src="060804_4_normalized_basis_functions.png" type="thumb">
<caption>

Figure 5: Four normalized radial basis functions in one input dimension. The fourth basis function has center at <math>  c_4=0 </math>. Note that the first basis function (dark blue) has become localized.
</caption>
</image>
</p>

</ss2>
</ss1>
<ss1>
<st>
Local linear models</st>
<p>

It is sometimes convenient to expand the architecture to include <mathematical_relation wordnetid="113783581" confidence="0.8">
<function wordnetid="113783816" confidence="0.8">
<link xlink:type="simple" xlink:href="../520/2194520.xml">
local linear</link></function>
</mathematical_relation>
 models. In that case the architectures become, to first order,</p>
<p>

<indent level="1">

<math>  \varphi \left ( \mathbf{x} \right ) =  \sum_{i=1}^N  \left ( a_i + \mathbf{b}_i \cdot \left ( \mathbf{x} - \mathbf{c}_i \right )   \right )\rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>

and </p>
<p>

<indent level="1">

<math>  \varphi \left ( \mathbf{x} \right ) =  \sum_{i=1}^N  \left ( a_i + \mathbf{b}_i \cdot \left ( \mathbf{x} - \mathbf{c}_i \right )  \right )u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>

in the unnormalized and normalized cases, respectively. Here <math> \mathbf{b}_i </math> are weights to be determined. Higher order linear terms are also possible.</p>
<p>

This result can be written</p>
<p>

<indent level="1">

<math>  \varphi \left ( \mathbf{x} \right ) =  \sum_{i=1}^{2N} \sum_{j=1}^n e_{ij} v_{ij} \big ( \mathbf{x} - \mathbf{c}_i   \big ) </math>
</indent>

where</p>
<p>

<indent level="1">

<math> e_{ij} = \begin{cases} a_i, &amp; \mbox{if } i \in [1,N] \\ b_{ij}, &amp; \mbox{if }i \in [N+1,2N] \end{cases} </math>
</indent>

and</p>
<p>

<indent level="1">

<math> v_{ij}\big ( \mathbf{x} - \mathbf{c}_i   \big ) \ \stackrel{\mathrm{def}}{=}\   \begin{cases} \delta_{ij} \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) , &amp; \mbox{if } i \in [1,N] \\ \left ( x_{ij} - c_{ij} \right ) \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big )  , &amp; \mbox{if }i \in [N+1,2N] \end{cases} </math>
</indent>

in the unnormalized case and</p>
<p>

<indent level="1">

<math> v_{ij}\big ( \mathbf{x} - \mathbf{c}_i   \big ) \ \stackrel{\mathrm{def}}{=}\   \begin{cases} \delta_{ij} u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) , &amp; \mbox{if } i \in [1,N] \\ \left ( x_{ij} - c_{ij} \right ) u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big )  , &amp; \mbox{if }i \in [N+1,2N] \end{cases} </math>
</indent>

in the normalized case.</p>
<p>

Here <math> \delta_{ij} </math> is a <link xlink:type="simple" xlink:href="../890/182890.xml">
Kronecker delta function</link> defined as</p>
<p>

<indent level="1">

<math> \delta_{ij} = \begin{cases} 1, &amp; \mbox{if }i = j \\ 0, &amp; \mbox{if }i \ne j \end{cases} </math>.
</indent>

</p>
</ss1>
</sec>
<sec>
<st>
Training</st>

<p>

In a RBF network there are three types of parameters that need to be chosen to adapt the network for a particular task: the center vectors <math>c_i</math>, the output weights <math>w_i</math>, and the RBF width parameters <math>\beta_i</math>. In the sequential training of the weights are updated at each time step as data streams in.</p>
<p>

For some tasks it makes sense to define an objective function and select the parameter values that minimize its value. The most common objective function is the least squares function</p>
<p>

<indent level="1">

<math>  K( \mathbf{w} ) \ \stackrel{\mathrm{def}}{=}\    \sum_{t=1}^\infty K_t( \mathbf{w} ) </math>
</indent>
where
<indent level="1">

<math>  K_t( \mathbf{w} ) \ \stackrel{\mathrm{def}}{=}\   \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ]^2 </math>.
</indent>
We have explicitly included the dependence on the weights. Minimization of the least squares objective function by optimal choice of weights optimizes accuracy of fit.</p>
<p>

There are occasions in which multiple objectives, such as smoothness as well as accuracy, must be optimized. In that case it is useful to optimize a regularized objective function such as </p>
<p>

<indent level="1">

<math>  H( \mathbf{w} ) \ \stackrel{\mathrm{def}}{=}\    K( \mathbf{w} ) + \lambda S( \mathbf{w} ) \ \stackrel{\mathrm{def}}{=}\    \sum_{t=1}^\infty H_t( \mathbf{w} ) </math>
</indent>

where</p>
<p>

<indent level="1">

<math>  S( \mathbf{w} ) \ \stackrel{\mathrm{def}}{=}\    \sum_{t=1}^\infty S_t( \mathbf{w} ) </math>
</indent>

and</p>
<p>

<indent level="1">

<math>  H_t( \mathbf{w} ) \ \stackrel{\mathrm{def}}{=}\    K_t ( \mathbf{w} ) + \lambda S_t ( \mathbf{w} ) </math>
</indent>

where optimization of S maximizes smoothness and <math>   \lambda  </math> is known as a <link xlink:type="simple" xlink:href="../061/2009061.xml">
regularization</link> parameter.</p>

<ss1>
<st>
Interpolation</st>

<p>

RBF networks can be used to interpolate a function <math>y: \mathbb{R}^n \to \mathbb{R}</math> when the values of that function are known on finite number of points: <math>y(x_i) = b_i, i=1, \ldots, N</math>. Taking the known points <math>x_i</math> to be the centers of the radial basis functions and evaluating the values of the basis functions at the same points <math>g_{ij} = \rho(|| x_j - x_i ||)</math> the weights can be solved from the equation
<indent level="1">

<math>\left[ \begin{matrix}
g_{11} &amp; g_{12} &amp; \cdots &amp; g_{1N} \\
g_{21} &amp; g_{22} &amp; \cdots &amp; g_{2N} \\
\vdots &amp; &amp; \ddots &amp; \vdots \\
g_{N1} &amp; g_{N2} &amp; \cdots &amp; g_{NN}
\end{matrix}\right] \left[ \begin{matrix}
w_1 \\
w_2 \\
\vdots \\
w_N
\end{matrix} \right] = \left[ \begin{matrix}
b_1 \\
b_2 \\
\vdots \\
b_N
\end{matrix} \right]</math>
</indent>

It can be shown that the interpolation matrix in the above equation is non-singular, if the points <it>x_i</it> are distinct, and thus the weights <it>w</it> can be solved by simple linear algebra:
<indent level="1">

<math>\mathbf{w} = \mathbf{G}^{-1} \mathbf{b}</math>
</indent>

</p>
</ss1>
<ss1>
<st>
Function approximation</st>

<p>

If the purpose is not to perform strict interpolation but instead more general <link xlink:type="simple" xlink:href="../897/336897.xml">
function approximation</link> or <link xlink:type="simple" xlink:href="../244/1579244.xml">
classification</link> the optimization is somewhat more complex because there is no obvious choice for the centers.  The training is typically done in two phases first fixing the width and centers and then the weights. This can be justified by considering the different nature of the non-linear hidden neurons versus the linear output neuron.</p>

<ss2>
<st>
Training the basis function centers</st>

<p>

Basis function centers can be randomly sampled among the input instances or obtained by Orthogonal Least Square Learning Algorithm or found by <link xlink:type="simple" xlink:href="../675/669675.xml">
clustering</link> the samples and choosing the cluster means as the centers.</p>
<p>

The RBF widths are usually all fixed to same value which is proportional to the maximum distance between the chosen centers.</p>

</ss2>
<ss2>
<st>
Pseudoinverse solution for the linear weights</st>

<p>

After the centers <math>c_i</math> have been fixed, the weights that minimize the error at the output are computed with a linear <link xlink:type="simple" xlink:href="../631/7043631.xml">
pseudoinverse</link> solution:
<indent level="1">

<math>\mathbf{w} = \mathbf{G}^+ \mathbf{b}</math>,
</indent>
where the entries of <it>G</it> are the values of the radial basis functions evaluated at the points <math>x_i</math>: <math>g_{ji} = \rho(||x_j-c_i||)</math>.</p>
<p>

The existence of this linear solution means that unlike <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../523/21523.xml#xpointer(//*[./st=%22Multi-layer+perceptron%22])">
Multi-Layer Perceptron (MLP) networks</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 the RBF networks have a unique local minimum (when the centers are fixed).</p>

</ss2>
<ss2>
<st>
Gradient descent training of the linear weights</st>

<p>

Another possible training algorithm is <link xlink:type="simple" xlink:href="../489/201489.xml">
gradient descent</link>. In gradient descent training, the weights are adjusted at each time step by moving them in a direction opposite from the gradient of the objective function</p>
<p>

<indent level="1">

<math>  \mathbf{w}(t+1) = \mathbf{w}(t) - \nu \frac {d} {d\mathbf{w}} H_t(\mathbf{w}) </math>
</indent>

where <math>  \nu </math> is a "learning parameter."</p>
<p>

For the case of training the linear weights, <math> a_i </math>, the algorithm becomes</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] \rho \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>

in the unnormalized case and</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] u \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>

in the normalized case.</p>
<p>

For local-linear-architectures gradient-descent training is</p>
<p>

<indent level="1">

<math>  e_{ij} (t+1) = e_{ij}(t) + \nu \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] v_{ij} \big (  \mathbf{x}(t) - \mathbf{c}_i  \big ) </math>
</indent>

</p>
</ss2>
<ss2>
<st>
Projection operator training of the linear weights</st>

<p>

For the case of training the linear weights, <math> a_i </math> and <math> e_{ij} </math>, the algorithm becomes</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] \frac {\rho \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} {\sum_{i=1}^N \rho^2 \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} </math>
</indent>

in the unnormalized case and</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] \frac {u \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} {\sum_{i=1}^N u^2 \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} </math>
</indent>

in the normalized case and</p>
<p>

<indent level="1">

<math>  e_{ij} (t+1) = e_{ij}(t) + \nu \big [ y(t) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] \frac { v_{ij} \big (  \mathbf{x}(t) - \mathbf{c}_i  \big ) } {\sum_{i=1}^N \sum_{j=1}^n  v_{ij}^2 \big (  \mathbf{x}(t) - \mathbf{c}_i  \big ) } </math>
</indent>

in the local-linear case.</p>
<p>

For one basis function, projection operator training reduces to <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../145/22145.xml">
Newton's method</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
.</p>
<p>

<image location="right" width="350px" src="060731_logistic_map_time_series_2.png" type="thumb">
<caption>

Figure 6: Logistic map time series. Repeated iteration of the logistic map generates a chaotic time series. The values lie between zero and one. Displayed here are the 100 training points used to train the examples in this section. The weights c are the first five points from this time series.
</caption>
</image>
</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
Examples</st>

<ss1>
<st>
Logistic map</st>

<p>

The basic properties of radial basis functions can be illustrated with a simple mathematical map, the <link xlink:type="simple" xlink:href="../137/18137.xml">
logistic map</link>, which maps the unit interval onto itself. It can be used to generate a convenient prototype data stream. The logistic map can be used to explore <link xlink:type="simple" xlink:href="../897/336897.xml">
function approximation</link>, <link xlink:type="simple" xlink:href="../624/406624.xml">
time series prediction</link>, and <link xlink:type="simple" xlink:href="../039/7039.xml">
control theory</link>. The map originated from the field of <link xlink:type="simple" xlink:href="../466/501466.xml">
population dynamics</link> and became the prototype <link xlink:type="simple" xlink:href="../295/6295.xml">
chaotic</link> time series. The map, in the fully chaotic regime, is given by</p>
<p>

<indent level="1">

<math>  x(t+1)\ \stackrel{\mathrm{def}}{=}\   f\left [ x(t)\right ] = 4 x(t) \left [ 1-x(t) \right ]  </math>
</indent>

where t is a time index. The value of x at time t+1 is a parabolic function of x at time t. This equation represents the underlying geometry of the chaotic time series generated by the logistic map.</p>
<p>

Generation of the time series from this equation is the <link>
forward problem</link>. The examples here illustrate the <link xlink:type="simple" xlink:href="../956/203956.xml">
inverse problem</link>; identification of the underlying dynamics, or fundamental equation, of the logistic map from exemplars of the time series. The goal is to find an estimate </p>
<p>

<indent level="1">

<math>  x(t+1) = f \left [ x(t) \right ]  \approx  \varphi(t) = \varphi  \left [ x(t)\right ]  </math>
</indent>

for f.</p>

</ss1>
<ss1>
<st>
Function approximation</st>

<ss2>
<st>
Unnormalized radial basis functions</st>

<p>

The architecture is</p>
<p>

<image location="right" width="350px" src="060728b_unnormalized_basis_function_phi.png" type="thumb">
<caption>

Figure 7: Unnormalized basis functions. The Logistic map (blue) and the approximation to the logistic map (red) after one pass through the training set.
</caption>
</image>

<indent level="1">

<math>  \varphi ( \mathbf{x} ) \ \stackrel{\mathrm{def}}{=}\   \sum_{i=1}^N  a_i \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>

where </p>
<p>

<indent level="1">

<math> \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) = \exp \left[ -\beta \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert ^2 \right] = \exp \left[ -\beta \left ( x(t) - c_i  \right ) ^2 \right] </math>.
</indent>

Since the input is a <link xlink:type="simple" xlink:href="../331/3588331.xml">
scalar</link> rather than a <link xlink:type="simple" xlink:href="../533/32533.xml">
vector</link>, the input dimension is one. We choose the number of basis functions as N=5 and the size of the training set to be 100 exemplars generated by the chaotic time series. The weight <math> \beta </math> is taken to be a constant equal to 5. The weights <math>  c_i </math> are five exemplars from the time series. The weights <math>  a_i </math> are trained with projection operator training:</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \big [ x(t+1) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] \frac {\rho \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} {\sum_{i=1}^N \rho^2 \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} </math>
</indent>

where the learning rate <math> \nu </math> is taken to be 0.3. The training is performed with one pass through the 100 training points. The <link xlink:type="simple" xlink:href="../816/201816.xml">
rms error</link> is 0.15.</p>
<p>

<image location="right" width="350px" src="Normalized_basis_functions.png" type="thumb">
<caption>

Figure 8: Normalized basis functions. The Logistic map (blue) and the approximation to the logistic map (red) after one pass through the training set. Note the improvement over the unnormalized case.
</caption>
</image>
</p>

</ss2>
<ss2>
<st>
Normalized radial basis functions</st>

<p>

The normalized RBF architecture is</p>
<p>

<indent level="1">

<math>  \varphi ( \mathbf{x} ) \ \stackrel{\mathrm{def}}{=}\   \frac { \sum_{i=1}^N  a_i \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) } { \sum_{i=1}^N  \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) }  = \sum_{i=1}^N  a_i u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) </math>
</indent>
where</p>
<p>

<indent level="1">

<math>  u \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) \ \stackrel{\mathrm{def}}{=}\   \frac { \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) } { \sum_{i=1}^N  \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) }  </math>.
</indent>

Again:</p>
<p>

<indent level="1">

<math> \rho \big ( \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert \big ) = \exp \left[ -\beta \left \Vert \mathbf{x} - \mathbf{c}_i  \right \Vert ^2 \right] = \exp \left[ -\beta \left ( x(t) - c_i  \right ) ^2 \right] </math>.
</indent>

Again, we choose the number of basis functions as five and the size of the training set to be 100 exemplars generated by the chaotic time series. The weight <math> \beta </math> is taken to be a constant equal to 6. The weights <math>  c_i </math> are five exemplars from the time series. The weights <math>  a_i </math> are trained with projection operator training:</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \big [ x(t+1) - \varphi \big (  \mathbf{x}(t), \mathbf{w} \big ) \big ] \frac {u \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} {\sum_{i=1}^N u^2 \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} </math>
</indent>

where the learning rate <math> \nu </math> is again taken to be 0.3. The training is performed with one pass through the 100 training points. The <link xlink:type="simple" xlink:href="../816/201816.xml">
rms error</link> on a test set of 100 exemplars is 0.084, smaller than the unnormalized error. Normalization yields accuracy improvement. Typically accuracy with normalized basis functions increases even more over unnormalized functions as input dimensionality increases.</p>
<p>

<image location="right" width="350px" src="060803b_chaotic_time_series_prediction.png" type="thumb">
<caption>

Figure 9: Normalized basis functions. The Logistic map (blue) and the approximation to the logistic map (red) as a function of time. Note that the approximation is good for only a few time steps. This is a general characterisitc of chaotic time series.
</caption>
</image>
</p>

</ss2>
</ss1>
<ss1>
<st>
Time series prediction</st>

<p>

Once the underlying geometry of the time series is estimated as in the previous examples, a prediction for the time series can be made by iteration:</p>
<p>

<indent level="1">

<math>  \varphi(0) = x(1)</math>
</indent>

<indent level="1">

<math>  {x}(t) \approx \varphi(t-1) </math>
</indent>

<indent level="1">

<math>  {x}(t+1) \approx \varphi(t)=\varphi [\varphi(t-1)]</math>.
</indent>

A comparison of the actual and estimated time series is displayed in the figure. The estimated times series starts out at time zero with an exact knowledge of x(0). It then uses the estimate  of the dynamics to update the time series estimate for several time steps. </p>
<p>

Note that the estimate is accurate for only a few time steps. This is a general characteristic of chaotic time series. This is a property of the sensitive dependence on initial conditions common to chaotic time series. A small initial error is amplified with time. A measure of the divergence of time series with nearly identical initial conditions is known as the <link xlink:type="simple" xlink:href="../441/166441.xml">
Lyapunov exponent</link>.</p>

</ss1>
<ss1>
<st>
Control of a chaotic time series</st>

<p>

<image location="right" width="350px" src="060808_control_of_logistic_map.png" type="thumb">
<caption>

Figure 10: Control of the logistic map. The system is allowed to evolve naturally for 49 time steps. At time 50 control is turned on. The desired trajectory for the time series is red. The system under control learns the underlying dynamics and drives the time series to the desired output. The architecture is the same as for the time series prediction example.
</caption>
</image>

We assume the output of the logistic map can be manipulated through a control parameter <math>  c[ x(t),t]  </math> such that</p>
<p>

<indent level="1">

<math>  {x}^{ }_{ }(t+1) = 4 x(t) [1-x(t)] +c[x(t),t] </math>.
</indent>

The goal is to choose the control parameter in such a way as to drive the time series to a desired output <math>  d(t)  </math>. This can be done if we choose the control paramer to be </p>
<p>

<indent level="1">

<math>  c^{ }_{ }[x(t),t] \ \stackrel{\mathrm{def}}{=}\   -\varphi [x(t)] + d(t+1) </math>
</indent>

where </p>
<p>

<indent level="1">

<math>  y[x(t)] \approx f[x(t)] = x(t+1)- c[x(t),t] </math>
</indent>

is an approximation to the underlying natural dynamics of the system.</p>
<p>

The learning algorithm is given by</p>
<p>

<indent level="1">

<math>  a_i (t+1) = a_i(t) + \nu \varepsilon  \frac {u \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} {\sum_{i=1}^N u^2 \big ( \left \Vert \mathbf{x}(t) - \mathbf{c}_i  \right \Vert \big )} </math>
</indent>

where</p>
<p>

<indent level="1">

<math>  \varepsilon \ \stackrel{\mathrm{def}}{=}\   f[x(t)] - \varphi [x(t)] = x(t+1)- c[x(t),t] - \varphi [x(t)] = x(t+1) - d(t+1) </math>.
</indent>

</p>
</ss1>
</sec>
<sec>
<st>
See also</st>

<p>

<list>
<entry level="1" type="bullet">

 <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<model wordnetid="110324560" confidence="0.8">
<assistant wordnetid="109815790" confidence="0.8">
<worker wordnetid="109632518" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<link xlink:type="simple" xlink:href="../563/4141563.xml">
Predictive analytics</link></causal_agent>
</worker>
</assistant>
</model>
</person>
</physical_entity>
</entry>
<entry level="1" type="bullet">

 <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<link xlink:type="simple" xlink:href="../295/6295.xml">
Chaos theory</link></concept>
</idea>
</entry>
</list>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

 J. Moody and C. J. Darken, "Fast learning in networks of locally tuned processing units," Neural Computation, 1, 281-294 (1989). Also see <weblink xlink:type="simple" xlink:href="http://www.ki.inf.tu-dresden.de/~fritzke/FuzzyPaper/node5.html">
Radial basis function networks according to Moody and Darken</weblink></entry>
<entry level="1" type="bullet">

 T. Poggio and F. Girosi, "Networks for approximation and learning," Proc. IEEE 78(9), 1484-1487 (1990).</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../091/9390091.xml">
 Roger D. Jones</link>, Y. C. Lee, C. W. Barnes, G. W. Flake, K. Lee, P. S. Lewis, and S. Qian, ?<weblink xlink:type="simple" xlink:href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=137644">
Function approximation and time series prediction with neural networks</weblink>,? Proceedings of the International Joint Conference on Neural Networks, June 17-21, p. I-649 (1990).</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book">Martin D. Buhmann, M. J. Ablowitz&#32;(2003). Radial Basis Functions : Theory and Implementations.&#32;Cambridge University. ISBN 0-521-63338-9.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book">Yee, Paul V. and Haykin, Simon&#32;(2001). Regularized Radial Basis Function Networks: Theory and Applications.&#32;John Wiley. ISBN 0-471-35349-3.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 John R. Davies, Stephen V. Coggeshall, <link xlink:type="simple" xlink:href="../091/9390091.xml">
 Roger D. Jones</link>, and Daniel Schutzer, "Intelligent Security Systems," in  <cite style="font-style:normal" class="book">Freedman, Roy S., Flein, Robert A., and Lederman, Jess, Editors&#32;(1995). Artificial Intelligence in the Capital Markets.&#32;Chicago:&#32;Irwin. ISBN 1-55738-811-3.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

  <cite style="font-style:normal" class="book">Simon Haykin&#32;(1999). Neural Networks: A Comprehensive Foundation, 2nd edition,&#32;Upper Saddle River, NJ:&#32;Prentice Hall. ISBN 0-13-908385-5.</cite>&nbsp;</entry>
<entry level="1" type="bullet">

 S. Chen, C. F. N. Cowan, and P. M. Grant, "Orthogonal Least Squares Learning Algorithm for Radial Basis Function Networks", IEEE Transactions on Neural Networks, Vol 2, No 2 (Mar) 1991.</entry>
</list>
</p>

</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
