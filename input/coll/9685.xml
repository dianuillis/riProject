<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:25:14[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Earley parser</title>
<id>9685</id>
<revision>
<id>222966914</id>
<timestamp>2008-07-01T23:26:29Z</timestamp>
<contributor>
<username>Lightbot</username>
<id>7178666</id>
</contributor>
</revision>
<categories>
<category>Dynamic programming</category>
<category>Parsing algorithms</category>
</categories>
</header>
<bdy>

The <b>Earley parser</b> is a type of <link xlink:type="simple" xlink:href="../490/106490.xml">
chart parser</link> mainly used for parsing in <link xlink:type="simple" xlink:href="../561/5561.xml">
computational linguistics</link>, named after its inventor, <physical_entity wordnetid="100001930" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<psychologist wordnetid="110488865" confidence="0.8">
<link xlink:type="simple" xlink:href="../834/13893834.xml">
Jay Earley</link></psychologist>
</scientist>
</causal_agent>
</person>
</physical_entity>
. The algorithm uses <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link>.<p>

Earley parsers are appealing because they can parse all <link xlink:type="simple" xlink:href="../867/6867.xml">
context-free language</link>s.  The Earley parser executes in cubic time (<link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(n3), where <it>n</it> is the length of the parsed string) in the general case, quadratic time (<link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>(n2)) for unambiguous grammars, and linear time for almost all LR(k) grammars. It performs particularly well when the rules are written <link xlink:type="simple" xlink:href="../498/1418498.xml">
left-recursively</link>.</p>

<sec>
<st>
 The algorithm </st>

<p>

In the following descriptions, α, β, and γ represent any <link xlink:type="simple" xlink:href="../701/27701.xml">
string</link> of <link xlink:type="simple" xlink:href="../061/7689061.xml">
terminals/nonterminals</link> (including the <link xlink:type="simple" xlink:href="../827/835827.xml">
empty string</link>), X, Y, and Z represent single nonterminals, and <it>a</it> represents a terminal symbol.</p>
<p>

Earley's algorithm is a top-down <link xlink:type="simple" xlink:href="../297/125297.xml">
dynamic programming</link> algorithm. In the following, we use Earley's dot notation: given a production X → αβ, the notation X → α • β represents a condition in which α has already been parsed and β is expected.</p>
<p>

For every input position (which represents a position <it>between</it> <link xlink:type="simple" xlink:href="../251/81251.xml">
tokens</link>), the parser generates an ordered <it>state set</it>.  Each state is a <link xlink:type="simple" xlink:href="../729/132729.xml">
tuple</link> (X → α • β, <it>i</it>), consisting of</p>
<p>

<list>
<entry level="1" type="bullet">

 the production currently being matched (X → α β)</entry>
<entry level="1" type="bullet">

 our current position in that production (represented by the dot)</entry>
<entry level="1" type="bullet">

 the position <it>i</it> in the input at which the matching of this production began: the <it>origin position''</it></entry>
</list>
</p>
<p>

(Earley's original algorithm included a look-ahead in the state; later research showed this to have little practical effect on the parsing efficiency, and it has subsequently been dropped from most implementations.)</p>
<p>

The state set at input position <it>k</it> is called S(<it>k</it>).  The parser is seeded with S(0) consisting of only the top-level rule.  The parser then iteratively operates in three stages:  <it>prediction</it>, <it>scanning</it>, and <it>completion</it>.  </p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Prediction</b>:  For every state in S(<it>k</it>) of the form (X → α • Y β, <it>j</it>) (where <it>j</it> is the origin position as above), add (Y → • γ, <it>k</it>) to S(<it>k</it>) for every production with Y on the left-hand side.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Scanning</b>: If <it>a</it> is the next symbol in the input stream, for every state in S(<it>k</it>) of the form (X → α • <it>a</it> β, <it>j</it>), add (X → α <it>a</it> • β, <it>j</it>) to S(<it>k</it>+1).</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 <b>Completion</b>: For every state in S(<it>k</it>) of the form (X → γ •, <it>j</it>), find states in S(<it>j</it>) of the form (Y → α • X β, <it>i</it>) and add (Y → α X • β, <it>i</it>) to S(<it>k</it>).</entry>
</list>
</p>
<p>

These steps are repeated until no more states can be added to the set.  The set is generally implemented as a queue of states to process (though a given state must appear in one place only), and performing the corresponding operation depending on what kind of state it is.</p>

</sec>
<sec>
<st>
 Example </st>

<p>

Consider the following simple grammar for arithmetic expressions:</p>
<p>

P → S      # the start rule
S → S + M
| M
M → M * T
| T
T → number</p>
<p>

With the input:</p>
<p>

2 + 3 * 4</p>
<p>

This is the sequence of state sets:</p>
<p>

(state no.) Production          (Origin) # Comment
---------------------------------
</p>
</sec>
<sec>
<st>
 S(0): • 2 + 3 * 4 </st>
<p>

(1)  P → • S         (0)    # start rule
(2)  S → • S + M     (0)    # predict from (1)
(3)  S → • M         (0)    # predict from (1)
(4)  M → • M * T     (0)    # predict from (3)
(5)  M → • T         (0)    # predict from (3)
(6)  T → • number    (0)    # predict from (5)</p>

</sec>
<sec>
<st>
 S(1): 2 • + 3 * 4 </st>
<p>

(1)  T → number •    (0)    # scan from S(0)(6)
(2)  M → T •         (0)    # complete from S(0)(5)
(3)  M → M • * T     (0)    # complete from S(0)(4)
(4)  S → M •         (0)    # complete from S(0)(3)
(5)  S → S • + M     (0)    # complete from S(0)(2)
(6)  P → S •         (0)    # complete from S(0)(1)</p>

</sec>
<sec>
<st>
 S(2): 2 + • 3 * 4 </st>
<p>

(1)  S → S + • M     (0)    # scan from S(1)(5)
(2)  M → • M * T     (2)    # predict from (1)
(3)  M → • T         (2)    # predict from (1)
(4)  T → • number    (2)    # predict from (3)</p>

</sec>
<sec>
<st>
 S(3): 2 + 3 • * 4 </st>
<p>

(1)  T → number •    (2)    # scan from S(2)(4)
(2)  M → T •         (2)    # complete from S(2)(3)
(3)  M → M • * T     (2)    # complete from S(2)(2)
(4)  S → S + M •     (0)    # complete from S(2)(1)
(5)  S → S • + M     (0)    # complete from S(0)(2)
(6)  P → S •         (0)    # complete from S(0)(1)</p>

</sec>
<sec>
<st>
 S(4): 2 + 3 * • 4 </st>
<p>

(1)  M → M * • T     (2)    # scan from S(3)(3)
(2)  T → • number    (4)    # predict from (1)</p>

</sec>
<sec>
<st>
 S(5): 2 + 3 * 4 • </st>
<p>

(1)  T → number •    (4)    # scan from S(4)(2)
(2)  M → M * T •     (2)    # complete from S(4)(1)
(3)  M → M • * T     (2)    # complete from S(2)(2)
(4)  S → S + M •     (0)    # complete from S(2)(1)
(5)  S → S • + M     (0)    # complete from S(0)(2)
(6)  P → S •         (0)    # complete from S(0)(1)</p>
<p>

The state (P → S •, 0) represents a completed parse.  This state also appears in S(3) and S(1), which are complete sentences.</p>

</sec>
<sec>
<st>
 See also </st>

<p>

<list>
<entry level="1" type="bullet">

 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../929/53929.xml">
CYK algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

 <message wordnetid="106598915" confidence="0.8">
<subject wordnetid="106599788" confidence="0.8">
<language wordnetid="106282651" confidence="0.8">
<link xlink:type="simple" xlink:href="../759/6759.xml">
Context-free grammar</link></language>
</subject>
</message>
</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../568/18568.xml#xpointer(//*[./st=%22Parsing%22])">
Parsing Algorithms</link></entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

J. Earley, <weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=362007.362035">
"An efficient context-free parsing algorithm"</weblink>, <it>Communications of the Association for Computing Machinery</it>, <b>13</b>:2:94-102, 1970.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

J. Aycock and R.N. Horspool. <weblink xlink:type="simple" xlink:href="http://www.cs.uvic.ca/~nigelh/Publications/PracticalEarleyParsing.pdf">
Practical Earley Parsing</weblink>. <it>The Computer Journal</it>, <b>45</b>:6:620-630, 2002.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://search.cpan.org/~lpalmer/Parse-Earley-0.15/Earley.pm">
Parse::Earley</weblink> An Earley parser <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../939/23939.xml">
Perl</link></programming_language>
 module.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://cocom.sourceforge.net/ammunition-13.html">
'early'</weblink> An Earley parser <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
 -library.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://pages.cpsc.ucalgary.ca/~aycock/spark/">
Spark</weblink> an Object Oriented "little language framework" for <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 that implements an Earley parser.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://nltk.sourceforge.net/">
NLTK</weblink> a <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../862/23862.xml">
Python</link></programming_language>
 toolkit that has an Earley parser.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.ling.ohio-state.edu/~scott/#projects-pep">
Pep</weblink> A Java library that implements the Earley algorithm and provides charts and parse trees as parsing artifacts.</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://linguateca.dei.uc.pt/index.php?sep=recursos">
PEN</weblink> A Java library that implements the Earley.</entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
