<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:56:34[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9508927676800064" wordnetid="105847438">
<header>
<title>Breadth-first search</title>
<id>97026</id>
<revision>
<id>240263906</id>
<timestamp>2008-09-22T18:39:43Z</timestamp>
<contributor>
<username>Ohnoitsjamie</username>
<id>507787</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>
<template>
<name>Infobox Algorithm</name>
<parameters>

<image location="none" width="300px" src="Breadth-first-tree.svg">
<caption>

Order in which the nodes get expanded
</caption>
</image>
Order in which the nodes are expanded<time>
<math>O(|V|+|E|) = O(b^d)</math></time>
<complete>
yes</complete>
<data>
<link xlink:type="simple" xlink:href="../931/557931.xml">
Graph</link></data>
<class>
<link xlink:type="simple" xlink:href="../249/28249.xml">
Search Algorithm</link></class>
<optimal>
yes (for unweighted graphs)</optimal>
<space>
<math>O(|V|+|E|) = O(b^d)</math></space>
</parameters>
</template>

<p>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>
</p>
<p>

In <link xlink:type="simple" xlink:href="../401/12401.xml">
graph theory</link>, <b>breadth-first search</b> (<b>BFS</b>) is a <link xlink:type="simple" xlink:href="../731/6263731.xml">
graph search algorithm</link> that begins at the root <link xlink:type="simple" xlink:href="../074/998074.xml">
node</link> and explores all the neighboring nodes.  Then for each of those nearest nodes, it explores their unexplored neighbor nodes, and so on, until it finds the goal.</p>


<sec>
<st>
 How it works </st>

<p>

BFS is an <link>
uninformed search</link> method that aims to expand and examine all nodes of a <link xlink:type="simple" xlink:href="../931/557931.xml">
graph</link> systematically in search of a solution. In other words, it exhaustively searches the entire graph without considering the goal until it finds it. It does not use a <link xlink:type="simple" xlink:href="../509/846509.xml">
heuristic</link>.</p>
<p>

From the standpoint of the <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>, all child nodes obtained by expanding a node are added to a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../347/11347.xml">
FIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 <link xlink:type="simple" xlink:href="../265/25265.xml">
queue</link>. In typical implementations, nodes that have not yet been examined for their neighbors are placed in some container (such as a queue or <link xlink:type="simple" xlink:href="../167/18167.xml">
linked list</link>) called "open" and then once examined are placed in the container "closed".</p>
<p>

<table>
<row>
<col>
<image location="left" width="250px" src="MapGermanyGraph.svg" type="thumb">
<caption>

An example map of <country wordnetid="108544813" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../867/11867.xml">
Germany</link></country>
 with some connections between cities.
</caption>
</image>
</col>
<col>
<image location="center" width="250px" src="GermanyBFS.svg" type="thumb">
<caption>

The breadth-first tree one gets when running BFS on the given map and starting in <link xlink:type="simple" xlink:href="../992/10992.xml">
Frankfurt</link>.
</caption>
</image>
</col>
<col>
<image location="right" width="187px" src="Animated_BFS.gif" type="thumb">
<caption>

Animated example of a breadth-first search
</caption>
</image>
</col>
</row>
</table>
</p>

</sec>
<sec>
<st>
 Algorithm (informal) </st>


<p>

<list>
<entry level="1" type="number">

 Put the root node on the queue.</entry>
<entry level="1" type="number">

 Pull a node from the beginning of the queue and examine it.</entry>
<entry level="2" type="bullet">

 If the searched element is found in this node, quit the search and return a result.</entry>
<entry level="2" type="bullet">

 Otherwise push all the (so-far-unexamined) successors (the direct child nodes) of this node into the end of the queue, if there are any.</entry>
<entry level="1" type="number">

 If the queue is empty, every node on the graph has been examined -- quit the search and return "not found".</entry>
<entry level="1" type="number">

 Repeat from Step 2.</entry>
</list>
</p>
<p>

<b>Note</b>: Using a stack instead of a queue to store the nodes yet to be visited would turn this algorithm into a  <link xlink:type="simple" xlink:href="../034/97034.xml">
depth-first search</link>.</p>

<ss1>
<st>
 Python implementation </st>
<p>

Assume we have a graph made up of Node objects, each containing a value and a list of child Node objects:</p>
<p>

class Node:
"""Simple structure for nodes in a graph."""
def __init__(self, value, children=):
self.value = value
self.children = children</p>

<p>

Then this function performs a breadth-first search on that graph when passed the graph's root node (a Node instance) and any function to be applied to each node in the graph:</p>
<p>

from collections import deque
def bfs(top_node, visit):
"""Breadth-first search on a graph, starting at top_node."""
visited = set()
queue = deque([top_node])
while queue:
curr_node = queue.popleft()         # Dequeue
if curr_node in visited: continue   # Skip visited nodes
visit(curr_node)                    # Visit the node
visited.add(curr_node)
<list>
<entry level="1" type="number">

 Enqueue the children</entry>
</list>

queue.extend(curr_node.children)</p>

<p>

For example, this script finds the sum of the integer values of each node in the graph:</p>

<p>

<list>
<entry level="1" type="number">

 Build an example graph</entry>
</list>

the_graph = Node(1, [Node(1, [Node(2), Node(3)]),
Node(5, [Node(8, [Node(13)]),
Node(21, [Node(34), Node(55)])])])</p>
<p>

<list>
<entry level="1" type="number">

 Define a "visit" function</entry>
</list>

total = 0
def sum_graph(node):
global total
total += node.value</p>
<p>

<list>
<entry level="1" type="number">

 Visit the whole graph</entry>
</list>

bfs(the_graph, sum_graph)
print total</p>


</ss1>
<ss1>
<st>
C implementation</st>
<p>

Algorithm of Breadth-first search：</p>
<p>

void BFS(VLink G, int v) { 
int w;
VISIT(v);                    /*visit vertex v*/
visited[v] = 1;              /*mark v as visited : 1 */
ADDQ(Q,v);
while(!EMPTYQ(Q)) { 
v = DELQ(Q);               /*Dequeue v*/
w = FIRSTADJ(G,v);         /*Find first neighbor, return -1 if no neighbor*/
while(w != -1) { 
if(visited[w] == 0) { 
VISIT(w);              /*visit vertex w*/
ADDQ(Q,w);             /*Enqueue current visited vertex w*/
visited[w] = 1;        /*mark w as visited*/
}
w = NEXTADJ(G,v);        /*Find next neighbor, return -1 if no neighbor*/
}
}  
}</p>

<p>

Main Algorithm of apply Breadth-first search to graph G=(V,E)：</p>
<p>

void TRAVEL_BFS(VLink G, int visited, int n) { 
int i;
for(i = 0; i  n; i ++) {
visited[i] = 0;            /* Mark initial value as 0 */
}
for(i = 0; i  n; i ++)
if(visited[i] == 0)
BFS(G,i);
}</p>


</ss1>
<ss1>
<st>
C++ implementation</st>
<p>

This is the implementation of the above informal algorithm, where the "so-far-unexamined" is handled by the parent array. For actual C++ applications, see the <link xlink:type="simple" xlink:href="../324/711324.xml">
Boost Graph Library</link>.
<indent level="1">

Suppose we have a struct:
</indent>

struct Vertex {
...
std::vector out;
...
};</p>
<p>

<indent level="1">

and an array of vertices: (the algorithm will use the indices of this array, to handle the vertices)
</indent>

std::vector graph(vertices);</p>
<p>

<indent level="1">

the algorithm starts from <b>start</b> and returns true if there is a directed path from <b>start</b> to <b>end</b>:
</indent>

bool BFS(const std::vector&amp; graph, int start, int end) {
std::queue next;
std::vector parent(graph.size(), -1) ;
next.push(start);
parent[start] = start;
while (!next.empty()) {
int u = next.front();
next.pop();
// Here is the point where you can examine the u th vertex of graph
// For example:
if (u == end) return true;
for (std::vector::const_iterator j = graph[u].out.begin(); j != graph[u].out.end(); ++j) {
// Look through neighbors.
int v = *j;
if (parent[v] == -1) {
// If v is unvisited.
parent[v] = u;
next.push(v);
}
}
}
return false;
}</p>
<p>

<indent level="1">

it also stores the parents of each node, from which you can get the path.
</indent>
</p>

</ss1>
</sec>
<sec>
<st>
 Features </st>

<p>

<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>

</p>
<ss1>
<st>
 Space Complexity </st>

<p>

Since all of the nodes of a level must be saved until their child nodes in the next level have been generated, the space complexity is proportional to the number of nodes at the deepest level. Given a <link xlink:type="simple" xlink:href="../471/438471.xml">
branching factor</link> <math>b</math> and graph depth <math>d</math> the asymptotic space complexity is the number of nodes at the deepest level, <math>O(b^d)</math>. When the number of vertices and edges in the graph are known ahead of time, the space complexity can also be expressed as <math>O(|E|+|V|)</math> where <math>|E|</math> is the <link xlink:type="simple" xlink:href="../er)/6174_(number).xml">
cardinality</link> of the set of edges (the number of edges), and <math>|V|</math> is the cardinality of the set of vertices. In the worst case the graph has a depth of 1 and all vertices must be stored. Since it is exponential in the depth of the graph, breadth-first search is often impractical for large problems on systems with bounded space.</p>

</ss1>
<ss1>
<st>
 Time Complexity </st>

<p>

Since in the worst case breadth-first search has to consider all paths to all possible nodes the time complexity of breadth-first search is <math>b+b^2+b^3+...+b^d</math> which asymptotically approaches <math>O(b^d)</math>. The time complexity can also be expressed as <math>O(|E|+|V|)</math> since every vertex and every edge will be explored in the worst case.</p>

</ss1>
<ss1>
<st>
 Completeness </st>

<p>

Breadth-first search is complete. This means that if there is a solution breadth-first search will find it regardless of the kind of graph. However, if the graph is infinite and there is no solution breadth-first search will diverge.</p>

</ss1>
<ss1>
<st>
 Optimality </st>

<p>

For unit-step cost, breadth-first search is optimal.  In general breadth-first search is not optimal since it always returns the result with the fewest edges between the start node and the goal node. If the graph is a weighted graph, and therefore has costs associated with each step, a goal next to the start does not have to be the cheapest goal available. This problem is solved by improving breadth-first search to <link xlink:type="simple" xlink:href="../989/2801989.xml">
uniform-cost search</link> which considers the path costs. Nevertheless, if the graph is not weighted, and therefore all step costs are equal, breadth-first search will find the nearest and the best solution.</p>

</ss1>
</sec>
<sec>
<st>
 Applications of BFS </st>

<p>

Breadth-first search can be used to solve many problems in graph theory, for example:</p>
<p>

<list>
<entry level="1" type="bullet">

 Finding all <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../223/246223.xml">
connected components</link></part>
</component>
</concept>
</idea>
 in a <link xlink:type="simple" xlink:href="../931/557931.xml">
graph</link>.</entry>
<entry level="1" type="bullet">

 Finding all nodes within one connected component</entry>
<entry level="1" type="bullet">

 Copying Collection, <link xlink:type="simple" xlink:href="../941/4422941.xml">
Cheney's algorithm</link></entry>
<entry level="1" type="bullet">

 Finding the <link xlink:type="simple" xlink:href="../985/41985.xml">
shortest path</link> between two nodes <it>u</it> and <it>v</it> (in an <link>
unweighted graph</link>)</entry>
<entry level="1" type="bullet">

 Finding the <link xlink:type="simple" xlink:href="../985/41985.xml">
shortest path</link> between two nodes <it>u</it> and <it>v</it> (in a <link xlink:type="simple" xlink:href="../908/638908.xml">
weighted graph</link>: see talk page)</entry>
<entry level="1" type="bullet">

 Testing a graph for <graph wordnetid="107000195" confidence="0.8">
<family wordnetid="108078020" confidence="0.8">
<visual_communication wordnetid="106873252" confidence="0.8">
<link xlink:type="simple" xlink:href="../431/244431.xml">
bipartite</link></visual_communication>
</family>
</graph>
ness</entry>
<entry level="1" type="bullet">

 <link>
(Reverse) Cuthill–McKee</link> mesh numbering</entry>
</list>
</p>

<ss1>
<st>
 Finding connected Components </st>

<p>

The set of nodes reached by a BFS (breadth-first search) are the largest connected component containing the start node.</p>

</ss1>
<ss1>
<st>
 Testing bipartiteness </st>

<p>

BFS can be used to test bipartiteness, by starting the search at any vertex and giving alternating labels to the vertices visited during the search. That is, give label 0 to the starting vertex, 1 to all its neighbours, 0 to those neighbours' neighbours, and so on. If at any step a vertex has (visited) neighbours with the same label as itself, then the graph is not bipartite. If the search ends without such a situation occurring, then the graph is bipartite.</p>

</ss1>
</sec>
<sec>
<st>
Literature</st>
<p>

<cite id="CITEREFKnuth1997" style="font-style:normal">Knuth, Donald E.&#32;(1997),&#32;<it><weblink xlink:type="simple" xlink:href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html">
The Art Of Computer Programming Vol 1.  3rd ed.</weblink></it>, Boston: Addison-Wesley, ISBN 0-201-89683-4, </cite>&nbsp;</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.martienus.com/code/t-sql-breadth-first-shortest-route-search.html">
Breadth-First shortest-route search implemented in T-SQL by Martin Withaar</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</article>
