<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:57:55[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<algorithm  confidence="0.9508927676800064" wordnetid="105847438">
<header>
<title>Depth-first search</title>
<id>97034</id>
<revision>
<id>238665589</id>
<timestamp>2008-09-15T21:09:05Z</timestamp>
<contributor>
<username>Escarbot</username>
<id>1554195</id>
</contributor>
</revision>
<categories>
<category>Search algorithms</category>
<category>Articles with example pseudocode</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>
<template>
<name>Infobox Algorithm</name>
<parameters>

<image location="none" width="300px" src="Depth-first-tree.svg">
<caption>

Order in which the nodes get expanded
</caption>
</image>
Order in which the nodes are expanded<time>
<math>O (|V| + |E|) = O (b^d)</math></time>
<complete>
yes (unless infinite paths are possible)</complete>
<data>
<link xlink:type="simple" xlink:href="../931/557931.xml">
Graph</link></data>
<class>
<link xlink:type="simple" xlink:href="../249/28249.xml">
Search algorithm</link></class>
<optimal>
no</optimal>
<space>
<math>O (h)</math> where <math>h</math> is the length of the longest <link xlink:type="simple" xlink:href="../889/638889.xml">
simple path</link> in the graph.</space>
</parameters>
</template>


<table style="padding: 0px; width: 170px; margin: 0 0 1em 1em;" align="right" class="toccolours">
<header style="background: #ccf;">
 <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../731/6263731.xml">
Graph search algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
s</header>
<row>
<col>
<b>Search</b>
<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/100558.xml">
A*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../828/14993828.xml">
B*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<condition wordnetid="113920835" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<state wordnetid="100024720" confidence="0.8">
<problem wordnetid="114410605" confidence="0.8">
<difficulty wordnetid="114408086" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../244/221244.xml">
Bellman-Ford algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</difficulty>
</problem>
</state>
</rule>
</event>
</condition>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../271/148271.xml">
Best-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../516/3157516.xml">
Bidirectional search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../026/97026.xml">
Breadth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/17247558.xml">
D*</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../034/97034.xml">
Depth-first search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../285/890285.xml">
Depth-limited search</link></algorithm>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../809/45809.xml">
Dijkstra's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../401/230401.xml">
Floyd-Warshall algorithm</link></entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../002/364002.xml">
Hill climbing</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../326/433326.xml">
Iterative deepening depth-first search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../311/1284311.xml">
Johnson's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../989/2801989.xml">
Uniform-cost search</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
</list>
</col>
</row>
</table>

<b>Depth-first search</b> (<b>DFS</b>) is an <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> for traversing or searching a <link xlink:type="simple" xlink:href="../806/30806.xml">
tree</link>, <link xlink:type="simple" xlink:href="../821/41821.xml">
tree structure</link>, or <link xlink:type="simple" xlink:href="../931/557931.xml">
graph</link>. One starts at the root (selecting some node as the root in the graph case) and explores as far as possible along each branch before <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracking</link>.
<sec>
<st>
Formal definition</st>

<p>

Formally, DFS is an <link>
uninformed search</link> that progresses by expanding the first child node of the search <link xlink:type="simple" xlink:href="../806/30806.xml">
tree</link> that appears and thus going deeper and deeper until a goal node is found, or until it hits a node that has no children. Then the search <link xlink:type="simple" xlink:href="../867/238867.xml">
backtracks</link>, returning to the most recent node it hadn't finished exploring. In a non-recursive implementation, all freshly expanded nodes are added to a <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../937/4690937.xml">
LIFO</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 <link xlink:type="simple" xlink:href="../993/273993.xml">
stack</link> for exploration.</p>
<p>

Space <link xlink:type="simple" xlink:href="../363/7363.xml">
complexity</link> of DFS is much lower than BFS (<link xlink:type="simple" xlink:href="../026/97026.xml">
breadth-first search</link>). It also lends itself much better to <link xlink:type="simple" xlink:href="../452/63452.xml">
heuristic</link> methods of choosing a likely-looking branch.  Time <link xlink:type="simple" xlink:href="../363/7363.xml">
complexity</link> of both algorithms are proportional to the number of vertices plus the number of edges in the graphs they traverse (O(|V| + |E|)). </p>
<p>

When searching large graphs that cannot be fully contained in memory, DFS suffers from non-termination when the length of a path in the search tree is infinite. The simple solution of "remember which nodes I have already seen" doesn't always work because there can be insufficient memory. This can be solved by maintaining an increasing limit on the depth of the tree, which is called <link xlink:type="simple" xlink:href="../326/433326.xml">
iterative deepening depth-first search</link>.</p>
<p>

For the following graph:</p>
<p>

<image width="200px" src="graph.traversal.example.svg">
</image>
</p>
<p>

a depth-first search starting at A, assuming that the left edges in the shown graph are chosen before right edges, and assuming the search remembers previously-visited nodes and will not repeat them (since this is a small graph), will visit the nodes in the following order: A, B, D, F, E, C, G.</p>
<p>

Performing the same search without remembering previously visited nodes results in visiting nodes in the order A, B, D, F, E, A, B, D, F, E, etc. forever, caught in the A, B, D, F, E cycle and never reaching C or G.</p>
<p>

Iterative deepening prevents this loop and will reach the following nodes on the following depths, assuming it proceeds left-to-right as above:</p>
<p>

<list>
<entry level="1" type="bullet">

0: A</entry>
<entry level="1" type="bullet">

1: A (repeated), B, C, E</entry>
</list>

(Note that iterative deepening has now seen C, when a conventional depth-first search did not.)
<list>
<entry level="1" type="bullet">

2: A, B, D, F, C, G, E, F</entry>
</list>

(Note that it still sees C, but that it came later. Also note that it sees E via a different path, and loops back to F twice.)
<list>
<entry level="1" type="bullet">

3: A, B, D, F, E, C, G, E, F, B</entry>
</list>
</p>
<p>

For this graph, as more depth is added, the two cycles "ABFE" and "AEFB" will simply get longer before the algorithm gives up and tries another branch.</p>

</sec>
<sec>
<st>
Output of a depth-first search</st>

<p>

<image width="270px" src="Tree_edges.svg" type="thumb">
<caption>

The four types of edges defined by a spanning tree
</caption>
</image>

The most natural result of a depth first search of a graph (if it is considered as a <link xlink:type="simple" xlink:href="../427/185427.xml">
function</link> rather than a <link xlink:type="simple" xlink:href="../988/40988.xml">
procedure</link>) is a <link xlink:type="simple" xlink:href="../770/455770.xml">
spanning tree</link> of the vertices reached during the search. Based on this spanning tree, the edges of the original graph can be divided into three classes: <b>forward edges</b>, which point from a node of the tree to one of its descendants, <b>back edges</b>, which point from a node to one of its ancestors, and <b>cross edges</b>, which do neither. Sometimes <b>tree edges</b>, edges which belong to the spanning tree itself, are classified separately from forward edges. It can be shown that if the graph is undirected then all of its edges are tree edges or back edges.</p>

<ss1>
<st>
Vertex orderings</st>

<p>

It is also possible to use the depth-first search to linearly order the vertices (or nodes) of the original graph (or tree). There are three common ways of doing this:</p>
<p>

<list>
<entry level="1" type="bullet">

 A <b>preordering</b> is a list of the vertices in the order that they were first visited by the depth-first search algorithm. This is a compact and natural way of describing the progress of the search, as was done earlier in this article. A preordering of an expression tree is the expression in <notation wordnetid="106808493" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../056/25056.xml">
Polish notation</link></notation>
. </entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 A <b>postordering</b> is a list of the vertices in the order that they were <it>last</it> visited by the algorithm. A postordering of an <link xlink:type="simple" xlink:href="../404/118404.xml">
expression tree</link> is the expression in <link xlink:type="simple" xlink:href="../513/26513.xml">
reverse Polish notation</link>.</entry>
</list>
</p>
<p>

<list>
<entry level="1" type="bullet">

 A <b>reverse postordering</b> is the reverse of a postordering, i.e. a list of the vertices in the opposite order of their last visit. When searching a tree, reverse postordering is the same as preordering, but in general they are different when searching a graph. For example, when searching the graph</entry>
</list>
</p>
<p>

<indent level="1">

 <image width="150px" src="If-then-else-control-flow-graph.svg">
<caption>

If-then-else-control-flow-graph.svg
</caption>
</image>

</indent>

<indent level="1">

 beginning at node A, the possible preorderings are A B D C and A C D B (depending upon whether the algorithm chooses to visit B or C first), while the possible reverse postorderings are A B C D and A C B D. Reverse postordering produces a <link xlink:type="simple" xlink:href="../064/897064.xml">
topological sorting</link> of any <link xlink:type="simple" xlink:href="../002/204002.xml">
directed acyclic graph</link>. This ordering is also useful in <link xlink:type="simple" xlink:href="../653/43653.xml">
control flow analysis</link> as it often represents a natural linearization of the control flow. The graph above might represent the flow of control in a code fragment like
</indent>

if (<b>A</b>) then {
<b>B</b>
} else {
<b>C</b>
}
<b>D</b></p>
<p>

<indent level="1">

 and it is natural to consider this code in the order A B C D or A C B D, but not natural to use the order A B D C or A C D B.
</indent>

</p>
</ss1>
</sec>
<sec>
<st>
Pseudocode</st>

<p>

A recursive version of the algorithm:</p>
<p>

def dfs(<b>v</b>):
mark <b>v</b> as visited
preorder-process(<b>v</b>)
for all vertices <b>i</b> adjacent to <b>v</b> such that <b>i</b> not visited
dfs(<b>i</b>)
postorder-process(<b>v</b>)</p>
<p>

Another version, without the <link xlink:type="simple" xlink:href="../407/25407.xml">
recursion</link>:</p>
<p>

dfs(<b>graph</b> G)
{
<b>list</b> L = <b>empty</b>
<b>tree</b> T = <b>empty</b>
<it>choose a starting vertex x</it>
search(x)
<b>while</b>(L <b>is not empty</b>)
{
<it>remove edge (v, w) from beginning of L</it>
<b>if</b> <it>w not yet visited</it>
{
<it>add (v, w) to T</it>
search(w)
}
}
}</p>
<p>

search(<b>vertex</b> v)
{
<it>visit v</it>
<it>for each edge (v, w)</it>
<it>add edge (v, w) to the beginning of L</it>
}</p>

</sec>
<sec>
<st>
Applications</st>

<p>

Here are some algorithms where DFS is used:
<list>
<entry level="1" type="bullet">

 Finding <idea wordnetid="105833840" confidence="0.8">
<concept wordnetid="105835747" confidence="0.8">
<component wordnetid="105868954" confidence="0.8">
<part wordnetid="105867413" confidence="0.8">
<link xlink:type="simple" xlink:href="../223/246223.xml">
connected components</link></part>
</component>
</concept>
</idea>
.</entry>
<entry level="1" type="bullet">

 <information wordnetid="106634376" confidence="0.8">
<electronic_database wordnetid="106588511" confidence="0.8">
<lexical_database wordnetid="106638868" confidence="0.8">
<database wordnetid="106637824" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<wordnet wordnetid="106639428" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<link xlink:type="simple" xlink:href="../064/897064.xml">
Topological sorting</link></procedure>
</activity>
</psychological_feature>
</wordnet>
</act>
</rule>
</event>
</message>
</algorithm>
</database>
</lexical_database>
</electronic_database>
</information>
.</entry>
<entry level="1" type="bullet">

 Finding 2-(edge or vertex)-connected components.</entry>
<entry level="1" type="bullet">

 Finding <link xlink:type="simple" xlink:href="../680/684680.xml">
strongly connected components</link>.</entry>
<entry level="1" type="bullet">

 Solving puzzles with only one solution, such as <link xlink:type="simple" xlink:href="../161/20161.xml">
mazes</link>.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 22.3: Depth-first search, pp.540&ndash;549.</entry>
<entry level="1" type="bullet">

  <cite id="CITEREFKnuth1997" style="font-style:normal"><link>
Knuth, Donald E.</link>&#32;(1997),&#32;<it><weblink xlink:type="simple" xlink:href="http://www-cs-faculty.stanford.edu/~knuth/taocp.html">
The Art Of Computer Programming Vol 1.  3rd ed.</weblink></it>, Boston: Addison-Wesley, ISBN 0-201-89683-4, </cite>&nbsp;</entry>
</list>
</p>


</sec>
<sec>
<st>
 External links </st>
<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch14.html">
Depth-First Explanation and Example</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.boost.org/libs/graph/doc/depth_first_search.html">
C++ Boost Graph Library: Depth-First Search</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.duke.edu/csed/jawaa/DFSanim.html">
Depth-First Search Animation (for a directed graph)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.kirupa.com/developer/actionscript/depth_breadth_search.htm">
Depth First and Breadth First Search: Explanation and Code</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.usask.ca/resources/tutorials/csconcepts/1999_8/tutorial/beginner/trees/breadth.html">
dfs applet</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</article>
