<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 00:03:55[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Reduction (recursion theory)</title>
<id>9719800</id>
<revision>
<id>210017680</id>
<timestamp>2008-05-04T01:36:59Z</timestamp>
<contributor>
<username>MoodyGroove</username>
<id>2942138</id>
</contributor>
</revision>
<categories>
<category>Recursion theory</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../084/3244084.xml">
computability theory</link>, many <b>reducibility relations</b> (also called <b>reductions</b>, <b>reducibilities</b>, and <b>notions of reducibility</b>) are studied. They are motivated by the question: given sets <it>A</it> and <it>B</it> of natural numbers, is it possible to effectively convert a method for deciding membership in <it>B</it> into a method for deciding membership in <it>A</it>?  If the answer to this question is affirmative then <it>A</it> is said to be <b>reducible to</b> <it>B</it>. <p>

The study of reducibility notions is motivated by the study of <link xlink:type="simple" xlink:href="../336/8336.xml">
decision problems</link>. For many notions of reducibility, if any <link xlink:type="simple" xlink:href="../264/332264.xml">
noncomputable</link> set is reducible to a set <it>A</it> then <it>A</it> must also be noncomputable.  This gives a powerful technique for proving that many sets are noncomputable.</p>

<sec>
<st>
 Reducibility relations</st>
<p>

A <b>reducibility relation</b> is a binary relation on sets of natural numbers that is 
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../458/200458.xml">
Reflexive</link>:  Every set is reducible to itself.</entry>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../463/200463.xml">
Transitive</link>:  If a set <it>A</it> is reducible to a set <it>B</it> and <it>B</it> is reducible to a set <it>C</it> then <it>A</it> is reducible to <it>C</it>.</entry>
</list>

These two properties imply that a reducibility is a <link xlink:type="simple" xlink:href="../582/23582.xml">
preorder</link> on the powerset of the natural numbers.  Not all preorders are studied as reducibility notions, however.  The notions studied in computability theory have the informal property that <it>A</it> is reducible to <it>B</it> if and only if any (possibly noneffective) decision procedure for <it>B</it> can be effectively converted to a decision procedure for <it>A</it>. The different reducibility relations vary in the methods they permit such a conversion process to use. </p>

<ss1>
<st>
 Degrees of a reducibility relation </st>

<p>

Every reducibility relation (in fact, every preorder) induces an equivalence relation on the powerset of the natural numbers in which two sets are equivalent if and only if each one is reducible to the other.  In recursion theory, these equivalence classes are called the <b>degrees</b> of the reducibility relation.  For example, the Turing degrees are the equivalence classes of sets of naturals induced by Turing reducibility. </p>
<p>

The degrees of any reducibility relation are <link xlink:type="simple" xlink:href="../572/23572.xml">
partially ordered</link> by the relation in the following manner.  Let &amp;le; be a reducibility relation and let <b>A</b> and <b>B</b> be two of its degrees.  Then <b>A</b> &amp;le; <b>B</b> if and only if there is a set <it>A</it> in <b>A</b> and a set <it>B</it> in <b>B</b> such that <it>A</it> &amp;le; <it>B</it>.  This is equivalent to the property that for every set <it>A</it> in <b>A</b> and every set <it>B</it> in <b>B</b>, <it>A</it> &amp;le; <it>B</it>, because any two sets in <it>A</it> are equivalent and any two sets in <it>B</it> are equivalent.  It is common, as shown here, to use boldface notation to denote degrees.</p>

</ss1>
</sec>
<sec>
<st>
 Turing reducibility </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../375/1188375.xml">
Turing reduction</link></it>
</indent>

The most fundamental reducibility notion is <link xlink:type="simple" xlink:href="../375/1188375.xml">
Turing reducibility</link>.  A set <it>A</it> of natural numbers is <b>Turing reducible</b> to a set <it>B</it> if and only if there is an <link xlink:type="simple" xlink:href="../431/22431.xml">
oracle Turing machine</link> that, when run with <it>B</it> as its oracle set, will compute the <link xlink:type="simple" xlink:href="../790/240790.xml">
indicator function</link> (characteristic function) of <it>A</it>.  Equivalently, <it>A</it> is Turing reducible to <it>B</it> if and only if there is an algorithm for computing the indicator function for <it>A</it> provided that the algorithm is provided with a means to correctly answer questions of the form "Is <it>n</it> in <it>B</it>?". </p>
<p>

Turing reducibility serves as a dividing line for other reducibility notions because, according to the <link xlink:type="simple" xlink:href="../854/6854.xml">
Church-Turing thesis</link>, it is the most general reducibility relation that is effective.  Reducibility relations that imply Turing reducibility have come to be known as <b>strong reducibilities</b>, while those that are implied by Turing reducibility are <b>weak reducibilities.</b>   Equivalently, a strong reducibility relation is one whose degrees form a finer equivalence relation than the Turing degrees, while a weak reducibility relation is one whose degrees form a coarser equivalence relation than Turing equivalence.</p>

</sec>
<sec>
<st>
 Reductions stronger than Turing reducibility </st>
<p>

The strong reducibilities include
<list>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../983/362983.xml">
One-one reducibility</link>: <it>A</it> is one-one reducible to <it>B</it> if there is a computable one-one function <it>f</it> with <it>A</it>(<it>x</it>) = <it>B</it>(<it>f</it>(<it>x</it>)) for all <it>x</it>.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../983/362983.xml">
Many-one reducibility</link>: <it>A</it> is many-one reducible to <it>B</it> if there is a computable function <it>f</it> with <it>A</it>(<it>x</it>) = <it>B</it>(<it>f</it>(<it>x</it>)) for all <it>x</it>.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../407/2695407.xml">
Truth-table reducible</link>: <it>A</it> is truth-table reducible to <it>B</it> if <it>A</it> is Turing reducible to <it>B</it> via a single (oracle) Turing machine which produces a total function relative to every oracle.</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../407/2695407.xml">
Weak truth-table reducible</link>: <it>A</it> is weak truth-table reducible to <it>B</it> if there is a Turing reduction from <it>B</it> to <it>A</it> and a recursive function <it>f</it> which bounds the <link>
use</link>. Whenever <it>A</it> is truth-table reducible to <it>B</it>, <it>A</it> is also weak truth-table reducible to <it>B</it>, since one can construct a recursive bound on the use by considering the maximum use on any oracle, which is computable if the reduction is total on all oracles.</entry>
<entry level="1" type="bullet">

Positive reducible: <it>A</it> is positive reducible to <it>B</it> if and only if <it>A</it> is truth-table reducible to <it>B</it> in a way that one can compute for every <it>x</it> a formula consisting of atoms of the form <it>B</it>(0), <it>B</it>(1), ... such that these atoms are combined by and's and or's, where the and of <it>a</it> and <it>b</it> is 1 if <it>a</it> = 1 and <it>b</it> = 1 and so on.</entry>
<entry level="1" type="bullet">

Disjunctive reducible: Similar to positive reducible with the additional constraint that only or's are permitted.</entry>
<entry level="1" type="bullet">

Conjunctive reducibility: Similar to positive reducibility with the additional constraint that only and's are permitted.</entry>
<entry level="1" type="bullet">

Linear reducibility: Similar to positive reducibility but with the constraint that all atoms of the form <it>B</it>(<it>n</it>) are combined by exclusive or's. In other words, <it>A</it> is linear reducible to <it>B</it> if and only if a computable function computes for each <it>x</it> a finite set <it>F</it>(<it>x</it>) given as an explicit list of numbers such that <it>x</it> &amp;isin; <it>A</it> if and only if <it>F</it>(<it>x</it>) contains an odd number of elements of <it>B</it>.</entry>
</list>

Many of these were introduced by Post (1944). Post was searching for a non-<link xlink:type="simple" xlink:href="../798/54798.xml">
recursive set</link> <link xlink:type="simple" xlink:href="../090/332090.xml">
recursively enumerable</link> set which the <link xlink:type="simple" xlink:href="../668/13668.xml">
halting problem</link> could not be Turing reduced to. As he could not construct such a set in 1944, he instead worked on the analogous problems for the various reducibilities that he introducted. These reducibilities have since been the subject of much research, and many relationships between them are known.  </p>

<ss1>
<st>
 Bounded reducibilities </st>
<p>

A <b>bounded</b> form of each of the above strong reducibilities can be defined. The most famous of these is bounded truth-table reduction, but there are also bounded Turing, bounded weak truth-table and others. These first three are the most common ones and they are based on the number of queries. For example, a set <it>A</it> is bounded truth-table reducible to <it>B</it> if and only if the Turing machine <it>M</it> computing <it>A</it> relative to <it>B</it> computes a list of up to <it>n</it> numbers, queries <it>B</it> on these numbers and then terminates for all possible oracle answers; the value <it>n</it> is a constant independent of <it>x</it>. The difference between bounded weak truth-table and bounded Turing reduction is that in the first case, the up to <it>n</it> queries have to be made at the same time while in the second case, the queries can be made one after the other. For that reason, there are cases where <it>A</it> is bounded Turing reducible to <it>B</it> but not weak truth-table reducible to <it>B</it>.</p>

</ss1>
<ss1>
<st>
 Strong reductions in computational complexity </st>

<p>

<indent level="1">

<it>Main article: <link xlink:type="simple" xlink:href="../067/848067.xml">
Reduction (complexity)</link></it>
</indent>

The strong reductions listed above restrict the manner in which oracle information can be accessed by a decision procedure but do not otherwise limit the computational resources available.  Thus if a set <it>A</it> is <link xlink:type="simple" xlink:href="../264/332264.xml">
decidable</link> then <it>A</it> is reducible to any set <it>B</it> under any of the strong reducibility relations listed above, even if <it>A</it> is not polynomial-time or exponential-time decidable.   This is acceptable in the study of recursion theory, which is interested in theoretical computability, but it is not reasonable for <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity theory</link>, which studies which sets can be decided under certain asymptotical resource bounds.  </p>
<p>

The most common reducibility in computational complexity theory is <link xlink:type="simple" xlink:href="../695/159695.xml">
polynomial-time reducibility</link>; a set <it>A</it> is polynomial-time reducible to a set <it>B</it> if there is a polynomial-time function <it>f</it> such that for every <it>n</it>, <it>n</it> is in <it>A</it> if and only if <it>f</it>(<it>n</it>) is in <it>B</it>.  This reducibility is, essentially, a resource-bounded version of many-one reducibility.  Other resource-bounded reducibilites are used in other contexts of computational complexity theory where other resource bounds are of interest.</p>

</ss1>
</sec>
<sec>
<st>
 Reductions weaker than Turing reducibility </st>
<p>

Although Turing reducibility is the most general reducibility that is effective, weaker reducibility relations are commonly studied.  These reducibilities are related to relative definability of sets over arithmetic or set theory. They include:
<list>
<entry level="1" type="bullet">

 <link xlink:type="simple" xlink:href="../475/186475.xml">
Arithmetical reducibility</link>: A set <it>A</it> is arithmetical in a set <it>B</it> if <it>A</it> is definable over the standard model of Peano arithmetic with an extra predicate for <it>B</it>.   Equivalently, according to <statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<series wordnetid="108457976" confidence="0.8">
<arrangement wordnetid="107938773" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<ordering wordnetid="108456993" confidence="0.8">
<hierarchy wordnetid="108377806" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<group wordnetid="100031264" confidence="0.8">
<link xlink:type="simple" xlink:href="../468/764468.xml">
Post's theorem</link></group>
</proposition>
</hierarchy>
</ordering>
</theorem>
</arrangement>
</series>
</message>
</statement>
, <it>A</it> is arithmetical in <it>B</it> if and only if <it>A</it> is Turing reducible to <math>B^{(n)}</math>, the <it>n</it>th <link xlink:type="simple" xlink:href="../091/1681091.xml">
Turing jump</link> of <it>B</it>, for some natural number <it>n</it>. The <link xlink:type="simple" xlink:href="../475/186475.xml">
arithmetical hierarchy</link> gives a finer classification of arithmetical reducibility. </entry>
<entry level="1" type="bullet">

 <link>
Hyperarithmetical reducibility</link>:  A set <it>A</it> is hyperarithmetical in a set <it>B</it> if <it>A</it> is <math>\Delta^1_1</math> definable (see <link xlink:type="simple" xlink:href="../233/634233.xml">
analytical hierarchy</link>) over the standard model of Peano arithmetic with a predicate for <it>B</it>.  Equivalently, <it>A</it> is hyperarithmetical in <it>B</it> if and only if <it>A</it> is Turing reducible to <math>B^{(\alpha)}</math>, the <it>α</it>th <link xlink:type="simple" xlink:href="../091/1681091.xml">
Turing jump</link> of <it>B</it>, for some <it>B</it>-<link xlink:type="simple" xlink:href="../979/5173979.xml">
recursive ordinal</link> α. </entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../335/343335.xml#xpointer(//*[./st=%22Relative+constructibility%22])">
Relative constructibility</link>: A set <it>A</it> is relatively constructible from a set <it>B</it> if <it>A</it> is in <it>L</it>(<it>B</it>), the smallest transitive model of <link xlink:type="simple" xlink:href="../214/152214.xml">
ZFC set theory</link> containing <it>B</it> and all the ordinals.</entry>
</list>
</p>

</sec>
<sec>
<st>
 References </st>
<p>

<list>
<entry level="1" type="bullet">

 K. Ambos-Spies and P. Fejer, 2006. "<weblink xlink:type="simple" xlink:href="http://www.cs.umb.edu/~fejer/articles/History_of_Degrees.pdf">
Degrees of Unsolvability</weblink>." Unpublished preprint.</entry>
<entry level="1" type="bullet">

 P. Odifreddi, 1989. <it>Classical Recursion Theory</it>, North-Holland. ISBN 0-444-87295-7</entry>
<entry level="1" type="bullet">

 P. Odifreddi, 1999. <it>Classical Recursion Theory, Volume II</it>, Elsevier. ISBN 0-444-50205-X</entry>
<entry level="1" type="bullet">

E. Post, 1944, "Recursively enumerable sets of positive integers and their decision problems", <it>Bulletin of the American Mathematical Society</it>, volume 50, pages 284&ndash;316.</entry>
<entry level="1" type="bullet">

 H. Rogers, Jr., 1967. <it>The Theory of Recursive Functions and Effective Computability</it>, second edition 1987, MIT Press. ISBN 0-262-68052-1 (paperback), ISBN 0-07-053522-1</entry>
<entry level="1" type="bullet">

 G Sacks, 1990.  <it>Higher Recursion Theory</it>, Springer-Verlag. ISBN 3-540-19305-7</entry>
</list>
</p>

</sec>
</bdy>
</article>
