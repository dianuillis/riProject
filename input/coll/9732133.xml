<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 17.04.2009 00:04:11[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Midpoint circle algorithm</title>
<id>9732133</id>
<revision>
<id>239817137</id>
<timestamp>2008-09-20T17:20:36Z</timestamp>
<contributor>
<username>TaBOT-zerem</username>
<id>7359933</id>
</contributor>
</revision>
<categories>
<category>Digital geometry</category>
<category>Geometric algorithms</category>
</categories>
</header>
<bdy>

In <link xlink:type="simple" xlink:href="../210/18567210.xml">
computer graphics</link>, the <b>midpoint circle algorithm</b> is an algorithm used to determine the points needed for drawing a circle. The algorithm is a variant of <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../005/64005.xml">
Bresenham's line algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
, and is thus sometimes known as <b>Bresenham's circle algorithm</b>, although not actually invented by <link xlink:type="simple" xlink:href="../326/938326.xml">
Bresenham</link>.<p>

<image location="right" width="320px" src="Bresenham_circle3.png" type="thumb">
<caption>

Rasterisation of a circle by the Bresenham algorithm
</caption>
</image>

The algorithm is related to work by <it>Pitteway</it> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref> and <it>van Aken</it> <ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref>. </p>

<sec>
<st>
The algorithm</st>

<p>

The algorithm starts accordingly with the <link xlink:type="simple" xlink:href="../220/6220.xml">
circle</link> equation <it>x</it>2&nbsp;+&nbsp;<it>y</it>2&nbsp;=&nbsp;<it>r</it>2. We consider first only the first octant  and draw a curve which starts at point (r,0) and proceeds to the top right, reaching the angle of 45°.</p>
<p>

The "fast" direction here is the y direction. The algorithm always does a step in the positive y direction (upwards), and every now and then also has to do a step in the "slow" direction, the negative x direction.</p>
<p>

The frequent computations of <link xlink:type="simple" xlink:href="../942/659942.xml">
square</link>s in the circle equation, <link xlink:type="simple" xlink:href="../261/18717261.xml">
trigonometric</link> expressions or <link xlink:type="simple" xlink:href="../208/29208.xml">
square root</link>s can again be avoided by dissolving everything into single steps and recursive computation of the quadratic terms from the preceding ones.</p>
<p>

From the circle equation we obtain the transformed equation 0=x²+y²-r², with r² to be computed only a single time during initialization, <it>x</it>2&nbsp;=&nbsp;(xpreceding&nbsp;&amp;minus;&nbsp;1)2&nbsp;=&nbsp;xpreceding2&nbsp;&amp;minus;&nbsp;2&nbsp;&amp;times;&nbsp;xpreceding&nbsp;+&nbsp;1 (according for <it>y</it>), where <it>x</it>2 (or xpreceding2) is kept as an own variable. Additionally we need to add the mid point coordinates when setting a pixel. These frequent integer additions do not limit the <link xlink:type="simple" xlink:href="../801/225801.xml">
performance</link> much, as we can spare those square (root) computations in the inner loop in turn. Again the zero in the transformed circle equation is replaced by the error term.</p>
<p>

The initialization of the error term is derived from an offset of ½ pixel at the start. Until the intersection with the perpendicular line, this leads to an accumulated value of r in the error term, so that this value is used for initialization.</p>
<p>

A possible implementation of the Bresenham Algorithm for a full circle in C. Here another variable for recursive computation of the quadratic terms is used, which corresponds with the term 2<it>n</it>&nbsp;+&nbsp;1 above. It just has to be increased by 2 from one step to the next:</p>

<p>

void rasterCircle(int x0, int y0, int radius)
{
int f = 1 - radius;
int ddF_x = 1;
int ddF_y = -2 * radius;
int x = 0;
int y = radius;</p>
<p>

setPixel(x0, y0 + radius);
setPixel(x0, y0 - radius);
setPixel(x0 + radius, y0);
setPixel(x0 - radius, y0);</p>
<p>

while(x  y) 
{
if(f &amp;gt;= 0) 
{
y--;
ddF_y += 2;
f += ddF_y;
}
x++;
ddF_x += 2;
f += ddF_x;    
setPixel(x0 + x, y0 + y);
setPixel(x0 - x, y0 + y);
setPixel(x0 + x, y0 - y);
setPixel(x0 - x, y0 - y);
setPixel(x0 + y, y0 + x);
setPixel(x0 - y, y0 + x);
setPixel(x0 + y, y0 - x);
setPixel(x0 - y, y0 - x);
}
}</p>

<p>

Note: There is correlation between this algorithm and the sum of first <it>N</it> odd numbers, which this one basically does.  Sum of <it>N</it> odd numbers, from 1 inclusive, is equal to the <link>
 square</link> of <it>N</it> ( <it>N</it> squared). </p>
<p>

So.
When we compare sum of N odd numbers to this algorithm we have.
ddF_y = -2 * radius       is connected to last member of sum of N odd numbers.
This member has index equal to value of radius (integral). 
Since odd number is 2*n + 1 there is 1 handled elsewhere
or it should be -2*radius - 1
ddF_x = 0                 should be 1. Because difference between two consecutive odd numbers is 2.
If so f += ddF_y + 1 is f+= ddF_y. Saving one operation.
f = - radius + 1          Initial error equal to half of "bigger" step. 
In case of saving one addition it should be either -radius or -radius + 2.
In any case there should be addition of 1 driven out of outer loop.
So.
f += ddF_y                Adding odd numbers from Nth to 1st. 
f += ddF_x                Adding odd numbers from 1st to Nth. 1 is missing because it can be moved outside of loop.</p>

<ss1>
<st>
 Drawing incomplete octants </st>

<p>

The implementations above always only draw complete octants or circles. To draw only a certain <link xlink:type="simple" xlink:href="../731/3082731.xml">
arc</link> from an angle α to an angle β, the algorithm needs first to calculate the x and y coordinates of these end points, where it is necessary to resort to trigonometric or square root computations (see <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/2698660.xml">
Methods of computing square roots</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
). Then the Bresenham algorithm is run over the complete octant or circle and sets the pixels only if they fall into the wanted interval. After finishing this arc, the algorithm can be ended prematurely.</p>
<p>

Note that if the angles are given as <link xlink:type="simple" xlink:href="../368/29368.xml">
slope</link>s, then no trigonometry or square roots are required: one simply checks that <it>y</it>/<it>x</it> is between the desired slopes.</p>

</ss1>
<ss1>
<st>
 Ellipses </st>

<p>

By <link xlink:type="simple" xlink:href="../962/584962.xml">
scaling</link> the drawn x and y values (and horizontal or vertical line expansion, respectively) the algorithm can produce <link xlink:type="simple" xlink:href="../277/9277.xml">
ellipse</link>s parallel to the x or y axis. For this, we use the circle algorithm with the smaller ellipse axis as radius and add a value in the other direction, which again is computed through another Bresenham line algorithm increasing from the pole to the equator. As the ellipse has to be elongated into the longer axis direction, the algorithm cannot set single pixels any more, but has to draw lines (though simple ones, only horizontal or vertical) from the previous to the next point.</p>
<p>

A general ellipse can be derived from such an axis-parallel one by application of a <link xlink:type="simple" xlink:href="../405/799405.xml">
shear mapping</link> on it. Again an additional Bresenham line algorithm is used to compute the offset increasing in one of the axis directions and to let it contribute to every drawn coordinate.</p>

</ss1>
</sec>
<sec>
<st>
References</st>


<p>

<reflist>
<entry id="1">
Pitteway, M.L.V., "Algorithm for Drawing Ellipses or Hyperbolae with a Digital Plotter", Computer J., 10(3) November 1967, pp 282-289</entry>
<entry id="2">
Van Aken, J.R., "An Efficient Ellipse Drawing Algorithm", CG&amp;A, 4(9), September 1984, pp 24-35</entry>
</reflist>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
