<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:56:30[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Binary GCD algorithm</title>
<id>985410</id>
<revision>
<id>244580742</id>
<timestamp>2008-10-11T15:20:08Z</timestamp>
<contributor>
<username>Regregex</username>
<id>3987750</id>
</contributor>
</revision>
<categories>
<category>Number theoretic algorithms</category>
<category>Articles with example C code</category>
</categories>
</header>
<bdy>

The <b>binary GCD algorithm</b> is an algorithm which computes the <link xlink:type="simple" xlink:href="../354/12354.xml">
greatest common divisor</link> of two nonnegative integers. It gains a measure of efficiency over the ancient <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 by replacing divisions and multiplications with shifts, which are cheaper when operating on the binary representation used by modern computers. This is particularly critical on embedded platforms that have no direct processor support for division. While the algorithm was first published by the German <link>
Josef Stein</link> in <link xlink:type="simple" xlink:href="../659/34659.xml">
1961</link>, it may have been known in first-century China.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>
<sec>
<st>
Algorithm</st>
<p>

This algorithm is also known as <b>Stein's Algorithm</b>.</p>
<p>

The algorithm reduces the problem of finding the GCD by repeatedly applying these identities:</p>
<p>

<list>
<entry level="1" type="number">

 gcd(0, <it>v</it>) = <it>v</it>, because everything divides zero, and <it>v</it> is the largest number that divides <it>v</it>. Similarly, gcd(<it>u</it>, 0) = <it>u</it>. gcd(0, 0) is not defined.</entry>
<entry level="1" type="number">

 If <it>u</it> and <it>v</it> are both even, then gcd(<it>u</it>, <it>v</it>) = 2·gcd(<it>u</it>/2, <it>v</it>/2), because 2 is a common divisor.</entry>
<entry level="1" type="number">

 If <it>u</it> is even and <it>v</it> is odd, then gcd(<it>u</it>, <it>v</it>) = gcd(<it>u</it>/2, <it>v</it>), because 2 is not a common divisor. Similarly, if <it>u</it> is odd and <it>v</it> is even, then gcd(<it>u</it>, <it>v</it>) = gcd(<it>u</it>, <it>v</it>/2).</entry>
<entry level="1" type="number">

 If <it>u</it> and <it>v</it> are both odd, and <it>u</it> ≥ <it>v</it>, then gcd(<it>u</it>, <it>v</it>) = gcd((<it>u</it>&amp;minus;<it>v</it>)/2, <it>v</it>). If both are odd and <it>u</it>  <it>v</it>, then gcd(<it>u</it>, <it>v</it>) = gcd((<it>v</it>-<it>u</it>)/2, <it>u</it>). These are combinations of one step of the simple Euclidean algorithm, which uses subtraction at each step, and an application of step 3 above. The division by 2 results in an integer because the difference of two odd numbers is even.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%222%22])">2</ref></entry>
<entry level="1" type="number">

 Repeat steps 3&ndash;4 until <it>u</it> = <it>v</it>, or (one more step) until <it>u</it> = 0. In either case, the result is 2<it>kv</it>, where <it>k</it> is the number of common factors of 2 found in step 2.</entry>
</list>
</p>
<p>

Since this definition is <link xlink:type="simple" xlink:href="../742/30742.xml">
tail-recursive</link>, a loop can be used to replace the recursion.</p>
<p>

The algorithm requires <link xlink:type="simple" xlink:href="../578/44578.xml">
O</link>((log2 <it>uv</it>)2) worst-case time, or in other words time proportional to the square of the number of bits in <it>u</it> and <it>v</it> together. Although each step reduces at least one of the operands by at least a factor of 2, the subtract and shift operations do not take constant time for very large integers (although they're still quite fast in practice, requiring about one operation per word of the representation).</p>
<p>

An extended version of binary GCD, analogous to the <link xlink:type="simple" xlink:href="../438/99438.xml">
extended Euclidean algorithm</link>, is given in <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>,<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%223%22])">3</ref> along with pointers to other versions.</p>

</sec>
<sec>
<st>
Implementation</st>

<ss1>
<st>
Implementation in C</st>
<p>

Following is an implementation of the algorithm in <programming_language wordnetid="106898352" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../021/6021.xml">
C</link></programming_language>
, taking two non-negative arguments <it>u</it> and <it>v</it>. It first removes all common factors of 2 using identity&nbsp;2, then computes the GCD of the remaining numbers using identities 3 and&nbsp;4, and combines these to form the final answer.</p>


<p>

unsigned int gcd(unsigned int u, unsigned int v)
{
int shift;</p>
<p>

/* GCD(0,x) := x */
if (u == 0 || v == 0)
return u | v;</p>
<p>

/* Let shift := lg K, where K is the greatest power of 2
dividing both u and v. */
for (shift = 0; ((u | v) &amp; 1) == 0; ++shift) {
u &amp;gt;&amp;gt;= 1;
v &amp;gt;&amp;gt;= 1;
}</p>
<p>

while ((u &amp; 1) == 0)
u &amp;gt;&amp;gt;= 1;</p>
<p>

/* From here on, u is always odd. */
do {
while ((v &amp; 1) == 0)  /* Loop X */
v &amp;gt;&amp;gt;= 1;</p>
<p>

/* Now u and v are both odd, so diff(u, v) is even.
Let u = min(u, v), v = diff(u, v)/2. */
if (u  v) {
v -= u;
} else {
unsigned int diff = u - v;
u = v;
v = diff;
}
v &amp;gt;&amp;gt;= 1;
} while (v != 0);</p>
<p>

return u  shift;
}</p>


</ss1>
<ss1>
<st>
Implementation in assembly</st>
<p>

This version of binary GCD in <chip wordnetid="103020034" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<instrumentality wordnetid="103575240" confidence="0.8">
<microprocessor wordnetid="103760310" confidence="0.8">
<conductor wordnetid="103088707" confidence="0.8">
<device wordnetid="103183080" confidence="0.8">
<semiconductor_device wordnetid="104171831" confidence="0.8">
<link xlink:type="simple" xlink:href="../558/60558.xml">
ARM</link></semiconductor_device>
</device>
</conductor>
</microprocessor>
</instrumentality>
</artifact>
</chip>
 <link xlink:type="simple" xlink:href="../368/1368.xml">
assembly</link> (using <physical_entity wordnetid="100001930" confidence="0.8">
<communicator wordnetid="109610660" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<compiler wordnetid="109946957" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<writer wordnetid="110794014" confidence="0.8">
<link xlink:type="simple" xlink:href="../402/863402.xml">
GNU Assembler</link></writer>
</causal_agent>
</compiler>
</person>
</communicator>
</physical_entity>
 syntax) highlights the benefit of <link xlink:type="simple" xlink:href="../439/199439.xml">
branch predication</link>, showing that the advantage of binary GCD over the Euclidean algorithm lies in its optimizability for real-world machines.  The loop to implement step 2 consists of three instructions, all predicated.  Step 3 consists of two loops, each 2 instructions long (one of the instructions being predicated); however, after the first iteration r0 is kept odd and need not be tested, and only one of the loops is executed.  (On cores that implement the clz instruction, steps 2 and 3 can be completed without looping.)  Finally, step 4 takes four instructions of which 2 are predicated.</p>
<p>

Since u and v are guaranteed even or odd at certain points, their least significant bits (LSBs) need not be stored in the registers but considered part of the program state.  The evenness tests then become a side effect of the bit shifts, since the LSB can be placed in the <link xlink:type="simple" xlink:href="../176/5503176.xml">
carry flag</link>.  Thus the code works with u/2 and v/2, which are known at the start of each loop to be even or odd.</p>
<p>

@ Arguments arrive in registers r0 and r1
<b>gcd:</b>
subs    r3, r0, r0         @ Power-of-two counter = 0, carry flag = 1
orrs    r2, r0, r1         @ Logical-OR r0 and r1, set flags on result
@ Carry flag remains set. If r0 and r1 are
@ both zero, this loop does nothing and the
@ code exits with r0 = 0.
<b>remove_twos_loop:</b>
movnes  r2, r2, lsr #1     @ Shift r2 right if &amp;gt;0, carry flag = LSB
addcc   r3, r3, #1         @ If the LSB was 0 then add 1 to the counter
bcc     remove_twos_loop   @ and loop to try the next bit (terminates)
movs    r0, r0, lsr r3     @ else divide r0 by 2^r3 and test result
movnes  r1, r1, lsr r3     @ if r0 &amp;gt; 0 divide r1 by 2^r3 and test result
beq     finish             @ if either is zero return sum (OR) of inputs</p>
<p>

@ Now the LSB of either r0 or r1 is 1,
@ and u and v are considered to be even.
@ But starting when we reach the subs below, 
@ u &amp;gt; 0; v &amp;gt; 0; r0 = u / 2; r1 = v / 2.
@ The LSBs of u and v are tested in the carry
@ flag, then memorized by the program state.
<b>check_two_r0:</b>
movs    r0, r0, lsr #1     @ divide u by 2 by shifting r0 right
bcc     check_two_r0       @ repeat until u is odd (loop terminates)
<b>check_two_r1:</b>                 @ Loop X:
movs    r1, r1, lsr #1     @ divide v by 2 by shifting r2 right
bcc     check_two_r1       @ repeat until v is odd (loop terminates)</p>
<p>

subs    r1, r1, r0         @ v := v0 - u0 (even, possibly zero)
rsbcc   r1, r1, #0         @ v := |v0 - u0| (if v0  u0 then v := 0 - v)
subcc   r0, r0, r1         @ u := min(u0, v0) (if v0  u0, u := u - v)
bne     check_two_r1       @ u remains odd. if v &amp;gt; 0 then loop.
@ This loop can be shown to terminate.</p>
<p>

@ if v = 0, the carry flag is set (from subs)
adc     r0, r0, r0         @ Restore u; u = 2(r0) + 1
<b>finish:</b>
orr     r0, r1, r0, lsl r3 @ multiply u by 2^r3 by shifting left
bx      lr                 @ return to caller with result in r0.</p>

</ss1>
<ss1>
<st>
Efficiency</st>
<p>
  	 
<link>
Brigitte Vallée</link> proved that binary GCD can be about 60% more efficient (in terms of the number of bit operations) on average than the Euclidean algorithm.<weblink xlink:type="simple" xlink:href="http://users.info.unicaen.fr/~brigitte/Publications/icalp8-2000.ps">
http://users.info.unicaen.fr/~brigitte/Publications/icalp8-2000.ps</weblink><weblink xlink:type="simple" xlink:href="http://web.comlab.ox.ac.uk/oucl/work/richard.brent/ftp/rpb183pr.ps.gz">
http://web.comlab.ox.ac.uk/oucl/work/richard.brent/ftp/rpb183pr.ps.gz</weblink><ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%224%22])">4</ref>.  However, although this algorithm outperforms the traditional Euclidean algorithm, its <link xlink:type="simple" xlink:href="../578/44578.xml">
asymptotic performance</link> is the same, and it is considerably more complex thanks to the availability of division instruction in all modern microprocessors.</p>
<p>

In addition, real computers, however, operate on more than one bit at a time, and even assembly language binary GCD implementations have to compete against carefully designed hardware circuits for integer division.  Overall, Knuth (1998) reports a 15% gain over Euclidean GCD<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%221%22])">1</ref>, and according to one comparison, the greatest gain was about 60%, while on some popular architectures even good implementations of binary GCD were marginally slower than the Euclidean algorithm.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> </p>
<p>

In general, with implementations of binary GCD similar to the above C code, the gain in speed over the Euclidean algorithm is always less in practice than in theory. The reason is that the code features a plethora of data-dependent branches.  Most may be removed either using conditional instructions along the model of the ARM code, or by computing <it>min(a,b)</it> and <it>|a-b|</it> using <work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../055/7560055.xml">
mixtures of Boolean algebra and arithmetic</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
.</p>
<p>

The only one that these techniques do not remove is the loop condition marked <it>Loop X</it>, which can be <link xlink:type="simple" xlink:href="../647/1052647.xml">
unrolled</link> with the aid of a <link xlink:type="simple" xlink:href="../457/356457.xml">
lookup table</link>.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%225%22])">5</ref> With a 256-byte lookup table (8 bits), the implementation turned to be between 82.5% and 163% faster than the Euclidean algorithm, depending on CPU and compiler. Even with a small 16-byte lookup table (4 bits), the gains are in the range of 54% to 116%.  The lookup-table approach finds its logical conclusion in the use of the special "CTZ" <link xlink:type="simple" xlink:href="../801/3149801.xml">
instruction</link>, that count leading or trailing binary zeros in a number, allowing all trailing zero bits to be removed in a single step instead of one at a time.<ref xlink:type="simple" xlink:href="#xpointer(//reflist/entry[@id=%226%22])">6</ref> Of course, this optimization is possible only on platforms where such instructions are available.</p>

</ss1>
</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/99438.xml">
Extended Euclidean algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</entry>
<entry level="1" type="bullet">

<link xlink:type="simple" xlink:href="../961/17961.xml">
Least common multiple</link></entry>
</list>
</p>

</sec>
<sec>
<st>
Notes</st>
<p>

<reflist>
<entry id="1">
<person wordnetid="100007846" confidence="0.9508927676800064">
<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../095/8095.xml">
Donald Knuth</link></scientist>
</person>
, <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../358/31358.xml">
The Art of Computer Programming</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
, Volume 2: Seminumerical Algorithms</it> (3rd Edition). Addison-Wesley.</entry>
<entry id="2">
In fact, the algorithm might be improved by the observation that if both <it>u</it> and <it>v</it> are odd, then exactly one of <it>u</it>+<it>v</it> or <it>u</it>&amp;minus;<it>v</it> must be divisible by four. Specifically, assuming <it>u</it> ≥ <it>v</it>, if ((<it>u</it>&nbsp;<link xlink:type="simple" xlink:href="../979/105979.xml">
xor</link>&nbsp;<it>v</it>)&nbsp;<link xlink:type="simple" xlink:href="../399/264399.xml">
and</link>&nbsp;2)&nbsp;=&nbsp;2, then gcd(<it>u</it>, <it>v</it>) = gcd((<it>u</it>+<it>v</it>)/4, <it>v</it>), and otherwise gcd(<it>u</it>, <it>v</it>) = gcd((<it>u</it>&amp;minus;<it>v</it>)/4, <it>v</it>).</entry>
<entry id="3">
Knuth (1998), answer to exercise 39 of section 4.5.2, p. 646</entry>
<entry id="4">
<weblink xlink:type="simple" xlink:href="http://www.stepanovpapers.com/notes.pdf">
Notes on Programming</weblink> by <person wordnetid="100007846" confidence="0.9638700866880419">
<link xlink:type="simple" xlink:href="../374/1874374.xml">
Alexander Stepanov</link></person>
</entry>
<entry id="5">
<weblink xlink:type="simple" xlink:href="http://boost-consulting.com/vault/index.php?filename=GCD.zip&amp;directory=Math%20-%20Numerics&amp;">
Faster implementations of binary GCD algorithm</weblink> (<weblink xlink:type="simple" xlink:href="http://boost-consulting.com/vault/index.php?action=downloadfile&amp;filename=GCD.zip&amp;directory=Math%20-%20Numerics&amp;">
download GCD.zip</weblink>)</entry>
<entry id="6">
<weblink xlink:type="simple" xlink:href="http://wall.riscom.net/books/proc/ppc/cwg/examples.html#334387">
PowerPC Compiler Writer's Guide</weblink>, section 5.10: Count Trailing Zeros. Gives an instruction sequence for counting the trailing zeros in a word, on a platform providing only the complementary "Count Leading Zeros" instruction.</entry>
</reflist>
</p>

</sec>
<sec>
<st>
References</st>
<p>

<list>
<entry level="1" type="bullet">

<scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Problem 31-1, pg.902.</entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.nist.gov/dads/HTML/binaryGCD.html">
NIST Dictionary of Algorithms and Data Structures: binary GCD algorithm</weblink></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://www.cut-the-knot.org/blue/binary.shtml">
Cut-the-Knot: Binary Euclid's Algorithm</weblink> at <link xlink:type="simple" xlink:href="../167/3259167.xml">
cut-the-knot</link></entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://web.comlab.ox.ac.uk/oucl/work/richard.brent/pd/rpb037i.pdf">
<it>Analysis of the Binary Euclidean Algorithm''</it></weblink> (1976), a paper by <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<mathematician wordnetid="110301261" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../484/872484.xml">
Richard P. Brent</link></associate>
</mathematician>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, including a variant using left shifts</entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://gcd.awardspace.com">
Online gcd calculator(4 methods)</weblink></entry>
</list>
</p>

<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible uncollapsed " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../527/21527.xml">
Number-theoretic</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../751/183751.xml">
Primality test</link>s</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<b><process wordnetid="105701363" confidence="0.8">
<institute wordnetid="108407330" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<association wordnetid="108049401" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../847/405847.xml">
AKS</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</association>
</thinking>
</inquiry>
</institute>
</process>
</b> · <b><link>
APR</link></b> · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../890/3609890.xml">
Ballie-PSW</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <b><process wordnetid="105701363" confidence="0.8">
<curve wordnetid="113867641" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<line wordnetid="113863771" confidence="0.8">
<shape wordnetid="100027807" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/4049015.xml">
ECPP</link></higher_cognitive_process>
</trial>
</shape>
</line>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</curve>
</process>
</b> · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../755/157755.xml">
Fermat</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <b><link>
Lucas–Lehmer</link></b> · <b><it><link>
Lucas–Lehmer (Mersenne numbers)</link></it></b> · <b><it><process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../861/15371861.xml">
Lucas–Lehmer–Riesel</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
</it></b> · <b><it><statement wordnetid="106722453" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/3225985.xml">
Proth's theorem</link></higher_cognitive_process>
</trial>
</proposition>
</experiment>
</problem_solving>
</theorem>
</thinking>
</inquiry>
</message>
</process>
</statement>
</it></b> · <b><it><link>
Pépin's</link></it></b> · <link>
Solovay–Strassen</link> · <link>
Miller–Rabin</link> · <b><problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
</b></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Sieving algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/2150920.xml">
Sieve of Atkin</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/73415.xml">
Sieve of Eratosthenes</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../330/14517330.xml">
Sieve of Sundaram</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../216/4621216.xml">
Wheel factorization</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<premise wordnetid="106753800" confidence="0.8">
<postulate wordnetid="106753299" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/15491.xml">
Integer factorization</link></proposition>
</postulate>
</premise>
</message>
</statement>
algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../392/1335392.xml">
CFRAC</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../877/1033877.xml">
Dixon's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
ECM</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
 · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../069/15822069.xml">
Euler's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../753/578753.xml">
P − 1</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../573/1916573.xml">
P + 1</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <link xlink:type="simple" xlink:href="../340/582340.xml">
QS</link> · <link xlink:type="simple" xlink:href="../734/152734.xml">
GNFS</link> · <it><link xlink:type="simple" xlink:href="../132/589132.xml">
SNFS</link></it> · <link xlink:type="simple" xlink:href="../510/2608510.xml">
rational sieve</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../433/2132433.xml">
Fermat's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../328/3387328.xml">
Shanks' square forms</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../674/42674.xml">
Shor's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Other algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../814/3975814.xml">
Ancient Egyptian multiplication</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../197/4039197.xml">
Aryabhata</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <link xlink:type="simple" xlink:href="../410/985410.xml">
Binary GCD</link> · <link xlink:type="simple" xlink:href="../658/4050658.xml">
Chakravala</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/99438.xml">
Extended Euclidean</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <link xlink:type="simple" xlink:href="../054/13644054.xml">
integer relation algorithm</link> · <link xlink:type="simple" xlink:href="../655/981655.xml">
integer square root</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/903032.xml">
Modular exponentiation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../375/3667375.xml">
Shanks-Tonelli</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
<it>Italics</it> indicate that algorithm is for numbers of special forms; <b>bold</b> indicates <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic algorithm</link>for primality tests.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
