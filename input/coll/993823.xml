<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:57:24[mciao0827] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<header>
<title>Computationally expensive</title>
<id>993823</id>
<revision>
<id>203960932</id>
<timestamp>2008-04-07T11:24:02Z</timestamp>
<contributor>
<username>Quadell</username>
<id>57108</id>
</contributor>
</revision>
<categories>
<category>Computational complexity theory</category>
</categories>
</header>
<bdy>

A <b>computationally expensive</b> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link> is one that, for a given input size, requires a relatively large number of steps to complete; in other words, one with high <link xlink:type="simple" xlink:href="../543/7543.xml">
computational complexity</link>.  The "cost" of an algorithm relative to the size of its input is often represented using <link xlink:type="simple" xlink:href="../578/44578.xml">
Big O notation</link>.<p>

For some expensive algorithms, there are less expensive counterparts.  A traditional example in which multiple algorithms exist to achieve the same end is the class of <link xlink:type="simple" xlink:href="../442/28442.xml">
sorting algorithm</link>s used to order a one-dimensional <link xlink:type="simple" xlink:href="../382/208382.xml">
list</link>.  From the point of view of implementation, the so-called <link xlink:type="simple" xlink:href="../255/4255.xml">
bubble sort</link> is one of the simplest of these algorithms. It is, however, relatively computationally expensive, requiring more computation steps for a list of given size than almost any other standard algorithm. As such, bubble sort is virtually never used in practice.  For real-life sorting problems, much more efficient algorithms are used, such as <algorithm wordnetid="105847438" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../249/3268249.xml">
Quicksort</link></algorithm>
; these, however, are somewhat more complicated in their implementation.</p>
<p>

Often, the more general an algorithm, the more computationally expensive it is.  For example, algorithms used for manipulating a generic <link xlink:type="simple" xlink:href="../728/19008728.xml">
matrix</link> will work on a <link xlink:type="simple" xlink:href="../015/341015.xml">
sparse matrix</link>, but algorithms designed specifically for sparse matrices will be less expensive.</p>
<p>

Additionally, the cost of a given action can apply to what kind of I/O is involved; fetching data from memory is usually considered inexpensive, whereas having to fetch memory from disk -- a far slower medium -- is considered expensive.</p>

</bdy>
</article>
