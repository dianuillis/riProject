<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 15:56:52[mciao0828] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Extended Euclidean algorithm</title>
<id>99438</id>
<revision>
<id>235747664</id>
<timestamp>2008-09-02T05:00:25Z</timestamp>
<contributor>
<username>Gogo Dodo</username>
<id>1257855</id>
</contributor>
</revision>
<categories>
<category>Number theoretic algorithms</category>
<category>Articles with example pseudocode</category>
</categories>
</header>
<bdy>

The <b>extended Euclidean algorithm</b> is an extension to the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for finding the <link xlink:type="simple" xlink:href="../354/12354.xml">
greatest common divisor</link> (GCD) of integers <it>a</it> and <it>b</it>: it also finds the integers <it>x</it> and <it>y</it> in <link>
Bézout's identity</link>
<indent level="1">

 <math>ax + by = \gcd(a, b). \,</math>
</indent>

(Typically either x or y is negative).<p>

The extended Euclidean algorithm is particularly useful when <it>a</it> and <it>b</it> are <link xlink:type="simple" xlink:href="../556/6556.xml">
coprime</link>, since <it>x</it> is the <link xlink:type="simple" xlink:href="../338/9815338.xml">
modular multiplicative inverse</link> of <it>a</it> <link xlink:type="simple" xlink:href="../087/20087.xml">
modulo</link> <it>b</it>.</p>

<sec>
<st>
Informal formulation of the algorithm</st>

<p>

<table align="left" class="wikitable">
<header>
Dividend</header>
<header>
Divisor</header>
<header>
Quotient</header>
<header>
Remainder</header>
<row>
<col>
120</col>
<col>
23</col>
<col>
5</col>
<col>
5</col>
</row>
<row>
<col>
23</col>
<col>
5</col>
<col>
4</col>
<col>
3</col>
</row>
<row>
<col>
5</col>
<col>
3</col>
<col>
1</col>
<col>
2</col>
</row>
<row>
<col>
3</col>
<col>
2</col>
<col>
1</col>
<col>
1</col>
</row>
<row>
<col>
2</col>
<col>
1</col>
<col>
2</col>
<col>
0</col>
</row>
</table>
</p>
<p>

It is assumed that the reader is already familiar with <link xlink:type="simple" xlink:href="../377/10377.xml">
Euclid's algorithm</link>.</p>
<p>

To illustrate the extension of the Euclid's algorithm, consider the computation of gcd(120,&nbsp;23), which is shown on the table on the left. Notice that the quotient in each division is recorded as well alongside the remainder.</p>
<p>

In this case, the remainder in the fourth line (which is equal to 1) indicates that the gcd is 1; that is, 120 and 23 are <link xlink:type="simple" xlink:href="../556/6556.xml">
coprime</link> (also called relatively prime). For the sake of simplicity, the example chosen is a coprime pair; but the more general case of gcd other than 1 also works similarly.</p>
<p>

There are two methods to proceed, both using the <link xlink:type="simple" xlink:href="../987/679987.xml">
division algorithm</link>, which will be discussed separately.</p>

<ss1>
<st>
The iterative method</st>
<p>

This method computes expressions of the form <math>r_i = ax_i+by_i</math> for the remainder in each step <math>i</math> of the Euclidean algorithm.  Each <link>
modulus</link> can be written in terms of the previous two remainders and their whole quotient as follows:
<indent level="1">

<math>r_i = r_{i-2} - \left \lfloor \frac{r_{i-2}}{r_{i-1}} \right \rfloor \cdot r_{i-1}</math>
</indent>

By substitution, this gives:
<indent level="1">

<math>r_i = (ax_{i-2} + by_{i-2}) - \left \lfloor \frac{r_{i-2}}{r_{i-1}} \right \rfloor \cdot (ax_{i-1} + by_{i-1})</math>
</indent>
:<math>r_i = a(x_{i-2} - \left \lfloor \frac{r_{i-2}}{r_{i-1}} \right \rfloor \cdot x_{i-1}) + b(y_{i-2} - \left \lfloor \frac{r_{i-2}}{r_{i-1}} \right \rfloor \cdot y_{i-1})</math></p>
<p>

The first two values are the initial arguments to the algorithm:
<indent level="1">

<math>r_1 = a = a(1) + b(0)</math>
</indent>
:<math>r_2 = b = a(0) + b(1)</math></p>
<p>

The expression for the last non-zero remainder gives the desired results since this method computes every remainder in terms of <it>a</it> and <it>b</it>, as desired.</p>
<p>

<b>Example:</b> Compute the GCD of 120 and 23.  </p>
<p>

The computation proceeds as follows:</p>
<p>

<table class="wikitable">
<header>
Step</header>
<header>
Quotient</header>
<header>
Remainder</header>
<header>
Substitute</header>
<header>
Combine terms</header>
<row>
<col>
1</col>

<col>
120</col>

<col>
120 = 120 * 1 + 23 * 0</col>
</row>
<row>
<col>
2</col>

<col>
23</col>

<col>
23 = 120 * 0 + 23 * 1</col>
</row>
<row>
<col>
3</col>
<col>
5</col>
<col>
5 = 120 - 23 * 5</col>
<col>
5 = (120 * 1 + 23 * 0) - (120 * 0 + 23 * 1) * 5</col>
<col>
5 = 120 * 1 + 23 * -5</col>
</row>
<row>
<col>
4</col>
<col>
4</col>
<col>
3 = 23 - 5 * 4</col>
<col>
3 = (120 * 0 + 23 * 1) - (120 * 1 + 23 * -5) * 4</col>
<col>
3 = 120 * -4 + 23 * 21</col>
</row>
<row>
<col>
5</col>
<col>
1</col>
<col>
2 = 5 - 3 * 1</col>
<col>
2 = (120 * 1 + 23 * -5) - (120 * -4 + 23 * 21) * 1</col>
<col>
2 = 120 * 5 + 23 * -26</col>
</row>
<row>
<col>
6</col>
<col>
1</col>
<col>
1 = 3 - 2 * 1</col>
<col>
1 = (120 * -4 + 23 * 21) - (120 * 5 + 23 * -26) * 1</col>
<col>
1 = 120 * -9 + 23 * 47</col>
</row>
<row>
<col>
7</col>
<col>
2</col>
<col>
0</col>
<col colspan="3" align="center">
<it>End of algorithm''</it></col>
</row>
</table>
</p>
<p>

The last line reads 1&nbsp;=&nbsp;&amp;minus;9&amp;times;120&nbsp;+&nbsp;47&amp;times;23, which is the required solution: <it>x</it>&nbsp;=&nbsp;&amp;minus;9 and <it>y</it>&nbsp;=&nbsp;47.</p>
<p>

This also means that &amp;minus;9 is the <link xlink:type="simple" xlink:href="../940/229940.xml">
multiplicative inverse</link> of 120 modulo 23, and that 47 is the multiplicative inverse of 23 modulo 120.
<indent level="1">

&amp;minus;9 &amp;times; 120 ≡ 1 <b>mod</b> 23 and also 47 &amp;times; 23 ≡ 1 <b>mod</b> 120.
</indent>

</p>
</ss1>
<ss1>
<st>
The recursive method</st>
<p>

This method attempts to solve the original equation directly, by reducing the dividend and divisor gradually, from the first line to the last line, which can then be substituted with trivial value and work backward to obtain the solution.</p>
<p>

Consider the original equation:</p>
<p>

<table class="wikitable">
<row>
<col>
120</col>
<col>
x</col>
<col>
+</col>
<col>
23</col>
<col>
y</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
(5×23+5)</col>
<col>
x</col>
<col>
+</col>
<col>
23</col>
<col>
y</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
23</col>
<col>
(5x+y)</col>
<col>
+</col>
<col>
5</col>
<col>
x</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col colspan="7" align="center">
...</col>
</row>
<row>
<col>
1</col>
<col>
a</col>
<col>
+</col>
<col>
0</col>
<col>
b</col>
<col>
=</col>
<col>
1</col>
</row>
</table>
</p>
<p>

Notice that the equation remains unchanged after decomposing the original dividend in terms of the divisor plus a remainder, and then regrouping terms. If we have a solution to the equation in the second line, then we can work backward to find x and y as required. Although we don't have the solution yet to the second line, notice how the magnitude of the terms decreased (120 and 23 to 23 and 5). Hence, if we keep applying this, eventually we'll reach the last line, which obviously has (1,0) as a trivial solution. Then we can work backward and gradually find out x and y.</p>
<p>

<table class="wikitable">
<header>
Dividend</header>
<header>
=</header>
<header>
Quotient</header>
<header>
x</header>
<header>
Divisor</header>
<header>
+</header>
<header>
Remainder</header>
<row>
<col>
120</col>
<col>
=</col>
<col>
5</col>
<col>
x</col>
<col>
23</col>
<col>
+</col>
<col>
5</col>
</row>
<row>
<col>
23</col>
<col>
=</col>
<col>
4</col>
<col>
x</col>
<col>
5</col>
<col>
+</col>
<col>
3</col>
</row>
<row>
<col colspan="7" align="center">
...</col>
</row>
</table>
</p>
<p>

For the purpose of explaining this method, the full working will not be shown. Instead some of the repeating steps will be described to demonstrate the principle behind this method.</p>
<p>

Start by rewriting each line from the first table with division algorithm, focusing on the dividend this time (because we'll be substituting the dividend).</p>
<p>

<table align="left" class="wikitable">
<row>
<col>
120</col>
<col>
x0</col>
<col>
+</col>
<col>
23</col>
<col>
y0</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
(5×23+5)</col>
<col>
x0</col>
<col>
+</col>
<col>
23</col>
<col>
y0</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
23</col>
<col>
(5x0+y0)</col>
<col>
+</col>
<col>
5</col>
<col>
x0</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
23</col>
<col>
x1</col>
<col>
+</col>
<col>
5</col>
<col>
y1</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
(4×5+3)</col>
<col>
x1</col>
<col>
+</col>
<col>
5</col>
<col>
y1</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
5</col>
<col>
(4x1+y1)</col>
<col>
+</col>
<col>
3</col>
<col>
x1</col>
<col>
=</col>
<col>
1</col>
</row>
<row>
<col>
5</col>
<col>
x2</col>
<col>
+</col>
<col>
3</col>
<col>
y2</col>
<col>
=</col>
<col>
1</col>
</row>
</table>

<table align="left">
<row>
<col>
<list>
<entry level="1" type="number">

 Assume that we were given x2=2 and y2=-3 already, which is indeed a valid solution.</entry>
<entry level="1" type="number">

 x1=y2=-3</entry>
<entry level="1" type="number">

 Solve 4x1+y1=x2 by substituting x1=-3, which gives y1=2-4(-3)=14</entry>
<entry level="1" type="number">

 x0=y1=14</entry>
<entry level="1" type="number">

 Solve 5x0+y0=x1 by substituting x0=14, so y0=-3-5(14)=-73</entry>
</list>
</col>
</row>
</table>
</p>


</ss1>
<ss1>
<st>
The table method</st>

<p>

The table method is probably the simplest method to carry out with a pencil and paper. It is similar to the recursive method, although it does not directly require algebra to use and only requires working in one direction. The main idea is to think of the equation chain <math>\gcd(x, y), \gcd(y, x\mod y), \dots, \gcd(z, 1)</math> as a sequence of divisors <math>x, y, x\mod y, \dots, 1</math>. In the running example we have the sequence 120, 23, 5, 3, 2, 1. Any element in this chain can be written as a linear combination of the original <math>x</math> and <math>y</math>, most notably, the last element, <math>\gcd(x, y)</math>, can be written in this way. The table method involves keeping a table of each divisor, written as a linear combination. The algorithm starts with the table as follows:</p>
<p>

<table align="center" class="wikitable">
<row>
<col>
a</col>
<col>
b</col>
<col>
d</col>
</row>
<row>
<col>
1</col>
<col>
0</col>
<col>
120</col>
</row>
<row>
<col>
0</col>
<col>
1</col>
<col>
23</col>
</row>
</table>
</p>
<p>

The elements in the <math>d</math> column of the table will be the divisors in the sequence. Each  <math>d_i</math> can be represented as the linear combination <math>d_i = a_i \cdot x + b_i \cdot y</math>. The <math>a</math> and <math>b</math> values are obvious for the first two rows of the table, which represent <math>x</math> and <math>y</math> themselves. To compute <math>d_i</math> for any <math>i &amp;gt; 2</math>, notice that <math>d_i = d_{i-2} \mod d_{i-1}</math>. Suppose <math>d_i = d_{i-2} - k \cdot d_{i-1}</math>. Then it must be that <math>a_i = a_{i-2} - k \cdot a_{i-1}</math> and <math>b_i = b_{i-2} - k \cdot b_{i-1}</math>. This is easy to verify algebraically with a simple substitution.</p>
<p>

Actually carrying out the table method though is simpler than the above equations would indicate. To find the third row of the table in the example, just notice that 120 divided by 23 goes 5 times plus a remainder. This gives us k, the multiplying factor for this row. Now, each value in the table is the value two rows above it, minus k times the value immediately above it. This correctly leads to <math>a_3 = 1 - 5 \cdot 0 = 1</math>, <math>b_3 = 0 - 5 \cdot 1 = -5</math>,  and <math>d_3 = 1 \cdot 120 - 5 \cdot 23 = 5</math>. After repeating this method to find each line of the table (note that the remainder written in the table and the multiplying factor are two different numbers!), the final values for <math>a</math> and <math>b</math> will solve <math>ax + by = \gcd(x, y)\,</math>:</p>
<p>

<table align="center" class="wikitable">
<row>
<col>
a</col>
<col>
b</col>
<col>
d</col>
</row>
<row>
<col>
1</col>
<col>
0</col>
<col>
120</col>
</row>
<row>
<col>
0</col>
<col>
1</col>
<col>
23</col>
</row>
<row>
<col>
1</col>
<col>
-5</col>
<col>
5</col>
</row>
<row>
<col>
-4</col>
<col>
21</col>
<col>
3</col>
</row>
<row>
<col>
5</col>
<col>
-26</col>
<col>
2</col>
</row>
<row>
<col>
-9</col>
<col>
47</col>
<col>
1</col>
</row>
</table>
</p>
<p>

This method is simple, requiring only the repeated application of one rule, and leaves the answer in the final row of the table with no backtracking.
Note also that if you end up with a negative number as the answer for the factor of, in this case <it>b</it>, you will then need to add the modulus in order to make it work as a modular inverse (instead of just taking the absolute value of <it>b</it>).  I.e. if it returns a negative number, don't just flip the sign, but add in the other number to make it work.  Otherwise it will give you the modular inverse yielding negative one.</p>

</ss1>
</sec>
<sec>
<st>
Formal description of the algorithm</st>

<ss1>
<st>
Iterative method</st>
<p>

By routine algebra of expanding and grouping like terms (refer to last section), the following algorithm for iterative method is obtained:
<list>
<entry level="1" type="number">

 Apply Euclidean algorithm, and let qn(n starts from 1) be a finite list of quotients in the division.</entry>
<entry level="1" type="number">

 Initialize x0, x1 as 1, 0, and y0, y1 as 0,1 respectively.</entry>
<entry level="2" type="number">

 Then for each i so long as qi is defined,</entry>
<entry level="2" type="number">

 Compute xi+1= xi-1- qixi</entry>
<entry level="2" type="number">

 Compute yi+1= yi-1- qiyi</entry>
<entry level="2" type="number">

 Repeat the above after incrementing i by 1.</entry>
<entry level="1" type="number">

 The answers are the second-to-last of xn and yn.</entry>
</list>
</p>
<p>

Pseudocode for this method is shown below:</p>
<p>

<b>function</b> extended_gcd(a, b)
x := 0    lastx := 1
y := 1    lasty := 0
<b>while</b> b ≠ 0
temp := b
quotient := a <b>div</b> b
b := a <b>mod</b> b
a := temp</p>
<p>

temp := x
x := lastx-quotient*x
lastx := temp</p>
<p>

temp := y
y := lasty-quotient*y
lasty := temp
<b>return</b> {lastx, lasty, a}</p>

</ss1>
<ss1>
<st>
Recursive method</st>
<p>

Solving the general case of the equation in the last corresponding section, the following algorithm results:
<list>
<entry level="1" type="number">

 If a is divisible by b, the algorithm ends and return the trivial solution x = 0, y = 1.</entry>
<entry level="1" type="number">

 Otherwise, repeat the algorithm with b and a modulus b, storing the solution as x' and y'.</entry>
<entry level="1" type="number">

 Then, the solution to the current equation is x = y', and y = x' minus y' times quotient of a divided by b</entry>
</list>
</p>
<p>

Which can be directly translated to this pseudocode:
<b>function</b> extended_gcd(a, b)
<b>if</b> a <b>mod</b> b = 0
<b>return</b> {0, 1}
<b>else</b>
{x, y} := extended_gcd(b, a <b>mod</b> b)
<b>return</b> {y, x-y*(a <b>div</b> b)}</p>

<ss2>
<st>
Proof of correctness</st>
<p>

Let <it>d</it> be the gcd of <it>a</it> and <it>b</it>.  We wish to prove that <it>a</it>*<it>x</it> + <it>b</it>*<it>y</it> = <it>d</it>.</p>
<p>

<list>
<entry level="1" type="bullet">

 If <it>b</it> evenly divides <it>a</it> (i.e. a <b>mod</b> b = 0),</entry>
<entry level="2" type="bullet">

 then <it>d</it> is <it>b</it> and <it>a</it>*0 + <it>b</it>*1 = <it>d</it>.</entry>
<entry level="2" type="bullet">

 So <it>x</it> and <it>y</it> are 0 and 1.</entry>
<entry level="1" type="bullet">

 Otherwise given the recursive call we know that <it>b</it>*<it>x</it> + (<it>a</it> <b>mod</b> <it>b</it>) * <it>y</it> = <it>d</it>,</entry>
<entry level="2" type="bullet">

 then <it>b</it>*<it>x</it> - <it>b</it>*(<it>a</it> <b>div</b> <it>b</it>)*<it>y</it> + (<it>a</it> <b>mod</b> <it>b</it>) * <it>y</it> + <it>b</it>*(<it>a</it> <b>div</b> <it>b</it>)*<it>y</it>= <it>d</it>,</entry>
<entry level="2" type="bullet">

 and <it>b</it>*(<it>x</it> - (<it>a</it> <b>div</b> <it>b</it>)*<it>y</it>) + <it>a</it>*<it>y</it>=<it>d</it>.</entry>
<entry level="2" type="bullet">

 So the new <it>x</it> and <it>y</it> are <it>y</it> and <it>x</it> - (<it>a</it> <b>div</b> <it>b</it>)*<it>y</it>.</entry>
</list>
</p>
<p>

See the <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 for the proof that the gcd(<it>a</it>,<it>b</it>) = gcd(<it>b</it>,a <b>mod</b> <it>b</it>) which this proof depends on in the recursive call step.</p>

</ss2>
</ss1>
</sec>
<sec>
<st>
Computing a multiplicative inverse in a finite field</st>

<p>

The extended Euclidean algorithm can also be used to calculate the <link xlink:type="simple" xlink:href="../940/229940.xml">
multiplicative inverse</link> in a <link xlink:type="simple" xlink:href="../615/11615.xml">
finite field</link>.</p>

<ss1>
<st>
Pseudocode</st>

<p>

Given the irreducible polynomial <it>f</it>(<it>x</it>) used to define the finite field, and the element <it>a</it>(<it>x</it>) whose inverse is desired, then a form of the algorithm suitable for determining the inverse is given by the following.
NOTE: <it>remainder()</it> and <it>quotient()</it> are functions different from the arrays remainder[ ] and quotient[ ]. <it>remainder()</it> refers to the remainder when two numbers are divided, and <it>quotient()</it> refers to the integer quotient when two numbers are divided.
For example, <it>remainder</it>(5/3) = 2 and <it>quotient</it>(5/3) = 1. Equivalent operators in the C language are % and / respectively.</p>
<p>

<link xlink:type="simple" xlink:href="../185/24185.xml">
pseudocode</link>:</p>
<p>

remainder[1] := <it>f</it>(x)
remainder[2] := <it>a</it>(x)
auxiliary[1] := 0
auxiliary[2] := 1
i := 2
<b>while</b> remainder[i] &amp;gt; 1
i := i + 1
remainder[i] := <it>remainder</it>(remainder[i-2] / remainder[i-1])
quotient[i] := <it>quotient</it>(remainder[i-2] / remainder[i-1])
auxiliary[i] := -quotient[i] * auxiliary[i-1] + auxiliary[i-2]
inverse := auxiliary[i]</p>

</ss1>
<ss1>
<st>
Note</st>

<p>

The minus sign is not necessary for some finite fields in the step.</p>
<p>

auxiliary[i] := -quotient[i] * auxiliary[i-1] + auxiliary[i-2]</p>
<p>

This is true since in the finite field GF(28), for instance, addition and subtraction are the same.  In other words, 1 is its own additive inverse in <link xlink:type="simple" xlink:href="../615/11615.xml">
GF</link>(28). This occurs in any finite field GF(2n), where n is an integer.</p>

</ss1>
<ss1>
<st>
Example</st>

<p>

For example, if the polynomial used to define the finite field GF(28) is <it>f</it>(<it>x</it>)&nbsp;=&nbsp;<it>x</it>8&nbsp;+&nbsp;<it>x</it>4&nbsp;+&nbsp;<it>x</it>3&nbsp;+&nbsp;<it>x</it>&nbsp;+&nbsp;1, and <it>x</it>6&nbsp;+&nbsp;<it>x</it>4&nbsp;+&nbsp;<it>x</it>&nbsp;+&nbsp;1&nbsp;=&nbsp;{53} in <link xlink:type="simple" xlink:href="../026/43026.xml">
big-endian</link> <link xlink:type="simple" xlink:href="../263/13263.xml">
hexadecimal</link> notation, is the element whose inverse is desired, then performing the algorithm results in the following:</p>

<p>

<table align="center" class="wikitable" border="1">
<row>
<header>
i</header>
<header>
remainder[i]</header>
<header>
&nbsp;quotient[i]&nbsp;</header>
<header>
auxiliary[i]</header>
</row>
<row>
<col>
&nbsp;1&nbsp;</col>
<col>
&nbsp;<it>x</it>
8 + <it>x</it>4 + <it>x</it>3 + <it>x</it> + 1&nbsp;</col>
<col>
&nbsp;</col>
<col>
&nbsp;0</col>
</row>
<row>
<col align="center">
2</col>
<col>
&nbsp;<it>x</it>
6 + <it>x</it>4 + <it>x</it> + 1</col>
<col>
&nbsp;</col>
<col>
&nbsp;1</col>
</row>
<row>
<col align="center">
3</col>
<col>
&nbsp;<it>x</it>
2</col>
<col>
&nbsp;<it>x</it>
2 + 1</col>
<col>
&nbsp;<it>x</it>
2 + 1</col>
</row>
<row>
<col align="center">
4</col>
<col>
&nbsp;<it>x</it> + 1</col>
<col>
&nbsp;<it>x</it>
4 + <it>x</it>2</col>
<col>
&nbsp;<it>x</it>
6 + <it>x</it>4 + <it>x</it>4 + <it>x</it>2 + 1</col>
</row>
<row>
<col align="center">
5</col>
<col>
&nbsp;1</col>
<col>
&nbsp;<it>x</it> + 1</col>
<col>
&nbsp;<it>x</it>
7 + <it>x</it>6 + <it>x</it>3 + <it>x</it>2 + <it>x</it>2 + <it>x</it> + 1 + 1&nbsp;</col>
</row>
</table>
</p>
<p>

<indent level="1">

<it>Note: Addition in a binary finite field is <link xlink:type="simple" xlink:href="../979/105979.xml">
XOR</link>.</it>
</indent>

Thus, the inverse is <it>x</it>7&nbsp;+&nbsp;<it>x</it>6&nbsp;+&nbsp;<it>x</it>3&nbsp;+&nbsp;<it>x</it>&nbsp;=&nbsp;{CA}, as can be confirmed by <link xlink:type="simple" xlink:href="../387/576387.xml">
multiplying the two elements together</link>.</p>

</ss1>
</sec>
<sec>
<st>
 References </st>

<p>

<list>
<entry level="1" type="bullet">

 <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../475/4108475.xml">
Thomas H. Cormen</link></scientist>
, <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../884/1400884.xml">
Charles E. Leiserson</link></scientist>
, <link xlink:type="simple" xlink:href="../057/68057.xml">
Ronald L. Rivest</link>, and <scientist wordnetid="110560637" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../993/3489993.xml">
Clifford Stein</link></scientist>
. <it><work wordnetid="104599396" confidence="0.8">
<product wordnetid="104007894" confidence="0.8">
<creation wordnetid="103129123" confidence="0.8">
<artifact wordnetid="100021939" confidence="0.8">
<book wordnetid="106410904" confidence="0.8">
<publication wordnetid="106589574" confidence="0.8">
<link xlink:type="simple" xlink:href="../226/3499226.xml">
Introduction to Algorithms</link></publication>
</book>
</artifact>
</creation>
</product>
</work>
</it>, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Pages 859&ndash;861 of section 31.2: Greatest common divisor.</entry>
</list>
</p>

</sec>
<sec>
<st>
See also</st>
<p>

<list>
<entry level="1" type="bullet">

 <link>
Bézout's identity</link></entry>
</list>
</p>

</sec>
<sec>
<st>
External links</st>

<p>

<list>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://marauder.millersville.edu/~bikenaga/absalg/exteuc/exteucex.html">
How to use the algorithm by hand</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://marauder.millersville.edu/~bikenaga/absalg/euc/euclidex.html">
How to use the algorithm by hand</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://banach.millersville.edu/~bob/math478/ExtendedEuclideanAlgorithmApplet.html">
Extended Euclidean Algorithm Applet</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://mathforum.org/library/drmath/view/51675.html">
Source for the form of the algorithm used to determine the multiplicative inverse in GF(2^8)</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.cs.utoronto.ca/~trebla/ExtendedEuclid.txt">
A simple explanation of the Extended Euclidean Algorithm</weblink></entry>
<entry level="1" type="bullet">

 <weblink xlink:type="simple" xlink:href="http://www.informationsuebertragung.ch/indexAlgorithmen.html">
Extended Euclidean Algorithm Applet</weblink>(Deutsch)</entry>
</list>
</p>





<p>

<table style=";" class="navbox" cellspacing="0">
<row>
<col style="padding:2px;">
<table style="width:100%;background:transparent;color:inherit;;" class="nowraplinks collapsible uncollapsed " cellspacing="0">
<row>
<header colspan="2" style=";" class="navbox-title">
<link xlink:type="simple" xlink:href="../527/21527.xml">
Number-theoretic</link> <link xlink:type="simple" xlink:href="../775/775.xml">
algorithm</link>s</header>
</row>
<row style="height:2px;">

</row>
<row>
<col style=";;" class="navbox-group">
<link xlink:type="simple" xlink:href="../751/183751.xml">
Primality test</link>s</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<b><process wordnetid="105701363" confidence="0.8">
<institute wordnetid="108407330" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<association wordnetid="108049401" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../847/405847.xml">
AKS</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</association>
</thinking>
</inquiry>
</institute>
</process>
</b> · <b><link>
APR</link></b> · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../890/3609890.xml">
Ballie-PSW</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <b><process wordnetid="105701363" confidence="0.8">
<curve wordnetid="113867641" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<line wordnetid="113863771" confidence="0.8">
<shape wordnetid="100027807" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../015/4049015.xml">
ECPP</link></higher_cognitive_process>
</trial>
</shape>
</line>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</curve>
</process>
</b> · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../755/157755.xml">
Fermat</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <b><link>
Lucas–Lehmer</link></b> · <b><it><link>
Lucas–Lehmer (Mersenne numbers)</link></it></b> · <b><it><process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../861/15371861.xml">
Lucas–Lehmer–Riesel</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
</it></b> · <b><it><statement wordnetid="106722453" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<theorem wordnetid="106752293" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../985/3225985.xml">
Proth's theorem</link></higher_cognitive_process>
</trial>
</proposition>
</experiment>
</problem_solving>
</theorem>
</thinking>
</inquiry>
</message>
</process>
</statement>
</it></b> · <b><it><link>
Pépin's</link></it></b> · <link>
Solovay–Strassen</link> · <link>
Miller–Rabin</link> · <b><problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
</b></col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Sieving algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../920/2150920.xml">
Sieve of Atkin</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../415/73415.xml">
Sieve of Eratosthenes</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../330/14517330.xml">
Sieve of Sundaram</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
 · <process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<problem_solving wordnetid="105796750" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../216/4621216.xml">
Wheel factorization</link></higher_cognitive_process>
</trial>
</experiment>
</problem_solving>
</thinking>
</inquiry>
</process>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
<statement wordnetid="106722453" confidence="0.8">
<message wordnetid="106598915" confidence="0.8">
<premise wordnetid="106753800" confidence="0.8">
<postulate wordnetid="106753299" confidence="0.8">
<proposition wordnetid="106750804" confidence="0.8">
<link xlink:type="simple" xlink:href="../491/15491.xml">
Integer factorization</link></proposition>
</postulate>
</premise>
</message>
</statement>
algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-odd">
<link xlink:type="simple" xlink:href="../392/1335392.xml">
CFRAC</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../877/1033877.xml">
Dixon's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <region wordnetid="108630985" confidence="0.8">
<field wordnetid="108569998" confidence="0.8">
<location wordnetid="100027167" confidence="0.8">
<tract wordnetid="108673395" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<geographical_area wordnetid="108574314" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../212/154212.xml">
ECM</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</geographical_area>
</rule>
</event>
</tract>
</location>
</field>
</region>
 · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../069/15822069.xml">
Euler's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../668/580668.xml">
Pollard's rho</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../753/578753.xml">
P − 1</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <it><event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../573/1916573.xml">
P + 1</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</it> · <link xlink:type="simple" xlink:href="../340/582340.xml">
QS</link> · <link xlink:type="simple" xlink:href="../734/152734.xml">
GNFS</link> · <it><link xlink:type="simple" xlink:href="../132/589132.xml">
SNFS</link></it> · <link xlink:type="simple" xlink:href="../510/2608510.xml">
rational sieve</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../433/2132433.xml">
Fermat's</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../328/3387328.xml">
Shanks' square forms</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <problem_solving wordnetid="105796750" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<process wordnetid="105701363" confidence="0.8">
<inquiry wordnetid="105797597" confidence="0.8">
<thinking wordnetid="105770926" confidence="0.8">
<event wordnetid="100029378" confidence="0.8">
<experiment wordnetid="105798043" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<trial wordnetid="105799212" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<higher_cognitive_process wordnetid="105770664" confidence="0.8">
<link xlink:type="simple" xlink:href="../660/557660.xml">
Trial division</link></higher_cognitive_process>
</procedure>
</activity>
</psychological_feature>
</trial>
</act>
</rule>
</experiment>
</event>
</thinking>
</inquiry>
</process>
</algorithm>
</problem_solving>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../674/42674.xml">
Shor's algorithm</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</col>
</row>
<row style="height:2px">

</row>
<row>
<col style=";;" class="navbox-group">
Other algorithms</col>
<col style="text-align:left;border-left:2px solid #fdfdfd;width:100%;padding:0px;;;" class="navbox-list navbox-even">
<event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../814/3975814.xml">
Ancient Egyptian multiplication</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../197/4039197.xml">
Aryabhata</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <link xlink:type="simple" xlink:href="../410/985410.xml">
Binary GCD</link> · <link xlink:type="simple" xlink:href="../658/4050658.xml">
Chakravala</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../377/10377.xml">
Euclidean</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../438/99438.xml">
Extended Euclidean</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <link xlink:type="simple" xlink:href="../054/13644054.xml">
integer relation algorithm</link> · <link xlink:type="simple" xlink:href="../655/981655.xml">
integer square root</link> · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../032/903032.xml">
Modular exponentiation</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
 · <event wordnetid="100029378" confidence="0.8">
<rule wordnetid="105846932" confidence="0.8">
<act wordnetid="100030358" confidence="0.8">
<psychological_feature wordnetid="100023100" confidence="0.8">
<procedure wordnetid="101023820" confidence="0.8">
<activity wordnetid="100407535" confidence="0.8">
<algorithm wordnetid="105847438" confidence="0.8">
<link xlink:type="simple" xlink:href="../375/3667375.xml">
Shanks-Tonelli</link></algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</col>
</row>
<row style="height:2px;">

</row>
<row>
<col colspan="2" style=";" class="navbox-abovebelow">
<it>Italics</it> indicate that algorithm is for numbers of special forms; <b>bold</b> indicates <link xlink:type="simple" xlink:href="../951/665951.xml">
deterministic algorithm</link>for primality tests.</col>
</row>
</table>
</col>
</row>
</table>
</p>



</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
