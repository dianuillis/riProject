<?xml version="1.0" encoding="UTF-8"?>
<!-- generated by CLiX/Wiki2XML [MPI-Inf, MMCI@UdS] $LastChangedRevision: 92 $ on 16.04.2009 17:58:02[mciao0825] -->
<!DOCTYPE article SYSTEM "../article.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink">
<event  confidence="0.8" wordnetid="100029378">
<rule  confidence="0.8" wordnetid="105846932">
<act  confidence="0.8" wordnetid="100030358">
<psychological_feature  confidence="0.8" wordnetid="100023100">
<procedure  confidence="0.8" wordnetid="101023820">
<activity  confidence="0.8" wordnetid="100407535">
<algorithm  confidence="0.8" wordnetid="105847438">
<header>
<title>Sethi-Ullman algorithm</title>
<id>999491</id>
<revision>
<id>209838677</id>
<timestamp>2008-05-03T03:39:24Z</timestamp>
<contributor>
<username>Michael Hardy</username>
<id>4626</id>
</contributor>
</revision>
<categories>
<category>Compiler theory</category>
<category>Graph algorithms</category>
</categories>
</header>
<bdy>

When <link xlink:type="simple" xlink:href="../858/9806858.xml">
generating code</link> for arithmetic expressions, the <link xlink:type="simple" xlink:href="../739/5739.xml">
compiler</link> has to decide which is the best way to translate the expression in terms of number of instructions used as well as number of registers needed to evaluate a certain subtree (especially if free registers are scarce). The <b>Sethi-Ullman algorithm</b> (also known as <b>Sethi-Ullman numbering</b>) fulfills the property of producing code which needs the least number of instructions possible as well as the least number of storage references (under the assumption that at the most <link xlink:type="simple" xlink:href="../390/294390.xml">
commutativity</link> and <link xlink:type="simple" xlink:href="../335/1335.xml">
associativity</link> apply to the operators used, but distributive laws i.e. <math>a * b + a * c = a * (b + c)</math> do not hold). Please note that the algorithm succeeds as well if neither <link xlink:type="simple" xlink:href="../390/294390.xml">
commutativity</link> nor <link xlink:type="simple" xlink:href="../335/1335.xml">
associativity</link> hold for the expressions used, and therefore arithmetic transformations can not be applied.
<sec>
<st>
Simple Sethi-Ullman algorithm</st>
<p>

The <b>simple Sethi-Ullman algorithm</b> works as follows (for a <link xlink:type="simple" xlink:href="../672/3963672.xml">
load-store architecture</link>):</p>
<p>

<list>
<entry level="1" type="number">

 Traverse the <link xlink:type="simple" xlink:href="../629/75629.xml">
abstract syntax tree</link> in pre- or postorder</entry>
<entry level="2" type="number">

 For every non-constant leaf node, assign a 1 (i.e. 1 register is needed to hold the variable/field/etc.). For every constant leaf node (RHS of an operation - literals, values), assign a 0.</entry>
<entry level="2" type="number">

 For every non-leaf node <it>n</it>, assign the number of registers needed to evaluate the respective subtrees of <it>n</it>. If the number of registers needed in the left subtree (<it>l</it>) are not equal to the number of registers needed in the right subtree (<it>r</it>), the number of registers needed for the current node <it>n</it> is max(l,&nbsp;r). If <it>l == r</it>, then the number of registers needed for the current node is l&nbsp;+&nbsp;1.</entry>
<entry level="1" type="number">

 Code emission</entry>
<entry level="2" type="number">

 If the number of registers needed to compute the left subtree of node <it>n</it> is bigger than the number of registers for the right subtree, then the left subtree is evaluated first (since it may be possible that the one more register needed by the right subtree to save the result makes the left subtree <link xlink:type="simple" xlink:href="../122/485122.xml">
spill</link>). If the right subtree needs more registers than the left subtree, the right subtree is evaluated first accordingly. If both subtrees need equal as much registers, then the order of evaluation is irrelevant.</entry>
</list>
</p>

<ss1>
<st>
Example</st>
<p>

For an arithmetic expression <math>a = (b + c) * (d + 3)</math>, the <link xlink:type="simple" xlink:href="../629/75629.xml">
abstract syntax tree</link> looks like this:</p>
<p>

=
/ \
a   *
/ \
/   \
+     +
/ \   / \
b   c d   3</p>
<p>

To continue with the algorithm, we need only to examine the arithmetic expression <math>(b + c) * (d + 3)</math>, i.e. we only have to look at the right subtree of the assignment '=':</p>
<p>

<list>
<entry level="1" type="bullet">
</entry>
</list>

/ \
/   \
+     +
/ \   / \
b   c d   3</p>
<p>

Now we start traversing the tree (in preorder for now), assigning the number of registers needed to evaluate each subtree (note that the last summand in the expression <math>(b + c) * (d + 3)</math> is a constant):</p>
<p>

<list>
<entry level="1" type="bullet">

<b>2</b></entry>
</list>

/ \
/   \
+<b>2</b>    +<b>1</b>
/ \   / \
b<b>1</b>  c<b>1</b>d<b>1</b>  3<b>0</b></p>
<p>

From this tree it can be seen that we need 2 registers to compute the left subtree of the '*', but only 1 register to compute the right subtree. Therefore we shall start to emit code for the left subtree first, because we might run into the situation that we only have 2 registers left to compute the whole expression. If we now computed the right subtree first (which needs only 1 register), we would then need a register to hold the result of the right subtree while computing the left subtree (which would still need 2 registers), therefore needing 3 registers concurrently. Computing the left subtree first needs 2 registers, but the result can be stored in 1, and since the right subtree needs only 1 register to compute, the evaluation of the expression can do with only 2 registers left.</p>

</ss1>
</sec>
<sec>
<st>
Advanced Sethi-Ullman algorithm</st>
<p>

In an advanced version of the <b>Sethi-Ullman algorithm</b>, the arithmetic expressions are first transformed, exploiting the algebraic properties of the operators used.</p>

</sec>
<sec>
<st>
External links</st>
<p>

<list>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://portal.acm.org/citation.cfm?doid=321607.321620">
The Generation of Optimal Code for Arithmetic Expressions</weblink> <physical_entity wordnetid="100001930" confidence="0.8">
<peer wordnetid="109626238" confidence="0.8">
<person wordnetid="100007846" confidence="0.8">
<colleague wordnetid="109935990" confidence="0.8">
<causal_agent wordnetid="100007347" confidence="0.8">
<scientist wordnetid="110560637" confidence="0.8">
<associate wordnetid="109816771" confidence="0.8">
<link xlink:type="simple" xlink:href="../752/222752.xml">
Ravi Sethi</link></associate>
</scientist>
</causal_agent>
</colleague>
</person>
</peer>
</physical_entity>
, <link xlink:type="simple" xlink:href="../318/1702318.xml">
J. D. Ullman</link>, Journal of the <organization wordnetid="108008335" confidence="0.9508927676800064">
<link xlink:type="simple" xlink:href="../ury/30th_century.xml">
ACM</link></organization>
, Vol. 17, No. 4, October 1970, pp. 715-728</entry>
<entry level="1" type="bullet">

<weblink xlink:type="simple" xlink:href="http://lambda.uta.edu/cse5317/fall02/notes/node40.html">
Code Generation for Trees</weblink></entry>
</list>
</p>


</sec>
</bdy>
</algorithm>
</activity>
</procedure>
</psychological_feature>
</act>
</rule>
</event>
</article>
